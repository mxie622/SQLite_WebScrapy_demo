Comment_volume,Question_en,Difficulty,Description,No_thumb,Img_link,No_pass,Relevant_tag,Similar_q_link,No_handover
评论 (344),can-i-win,中等,"在 ""100 game"" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过  100 的玩家，即为胜者。
如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？
例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。
给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。
  示例 1：
输入：maxChoosableInteger = 10, desiredTotal = 11
输出：false
解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
示例 2:
输入：maxChoosableInteger = 10, desiredTotal = 0
输出：true
示例 3:
输入：maxChoosableInteger = 10, desiredTotal = 1
输出：true
  提示:
1 <= maxChoosableInteger <= 20
0 <= desiredTotal <= 300",433,,32020,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/', 'https://leetcode.cn/tag/game-theory/']","['https://leetcode.cn/problems/flip-game-ii/', 'https://leetcode.cn/problems/guess-number-higher-or-lower-ii/', 'https://leetcode.cn/problems/predict-the-winner/']",75953
评论 (11.1k),two-sum,简单,"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
  示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
  提示：
2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
只会存在一个有效答案
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？",14475,,3426067,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']","['https://leetcode.cn/problems/3sum/', 'https://leetcode.cn/problems/4sum/', 'https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/', 'https://leetcode.cn/problems/two-sum-iii-data-structure-design/', 'https://leetcode.cn/problems/subarray-sum-equals-k/', 'https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/', 'https://leetcode.cn/problems/two-sum-less-than-k/']",6521632
评论 (7.7k),add-two-numbers,中等,"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
  示例 1：
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：
输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
  提示：
每个链表中的节点数在范围 [1, 100] 内
0 <= Node.val <= 9
题目数据保证列表表示的数字不含前导零",8110,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg,1343780,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/math/']","['https://leetcode.cn/problems/multiply-strings/', 'https://leetcode.cn/problems/add-binary/', 'https://leetcode.cn/problems/sum-of-two-integers/', 'https://leetcode.cn/problems/add-strings/', 'https://leetcode.cn/problems/add-two-numbers-ii/', 'https://leetcode.cn/problems/add-to-array-form-of-integer/']",3233791
评论 (6.9k),longest-substring-without-repeating-characters,中等,"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
  示例 1:
输入: s = ""abcabcbb""
输出: 3 
解释: 因为无重复字符的最长子串是 ""abc""，所以其长度为 3。
示例 2:
输入: s = ""bbbbb""
输出: 1
解释: 因为无重复字符的最长子串是 ""b""，所以其长度为 1。
示例 3:
输入: s = ""pwwkew""
输出: 3
解释: 因为无重复字符的最长子串是 ""wke""，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，""pwke"" 是一个子序列，不是子串。
  提示：
0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成",7623,,1748042,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/', 'https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/', 'https://leetcode.cn/problems/subarrays-with-k-different-integers/']",4508314
评论 (4.1k),median-of-two-sorted-arrays,困难,"给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
算法的时间复杂度应该为 O(log (m+n)) 。
  示例 1：
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
    提示：
nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106",5458,,714771,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/']",[],1726845
评论 (4.4k),longest-palindromic-substring,中等,"给你一个字符串 s，找到 s 中最长的回文子串。
  示例 1：
输入：s = ""babad""
输出：""bab""
解释：""aba"" 同样是符合题意的答案。
示例 2：
输入：s = ""cbbd""
输出：""bb""
  提示：
1 <= s.length <= 1000
s 仅由数字和英文字母组成",5246,,1041189,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/shortest-palindrome/', 'https://leetcode.cn/problems/palindrome-permutation/', 'https://leetcode.cn/problems/palindrome-pairs/', 'https://leetcode.cn/problems/longest-palindromic-subsequence/', 'https://leetcode.cn/problems/palindromic-substrings/']",2838604
评论 (2.9k),zigzag-conversion,中等,"将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 ""PAYPALISHIRING"" 行数为 3 时，排列如下：
P   A   H   N
A P L S I I G
Y   I   R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：""PAHNAPLSIIGYIR""。
请你实现这个将字符串进行指定行数变换的函数：
string convert(string s, int numRows);
  示例 1：
输入：s = ""PAYPALISHIRING"", numRows = 3
输出：""PAHNAPLSIIGYIR""
示例 2：
输入：s = ""PAYPALISHIRING"", numRows = 4
输出：""PINALSIGYAHRPI""
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
示例 3：
输入：s = ""A"", numRows = 1
输出：""A""
  提示：
1 <= s.length <= 1000
s 由英文字母（小写和大写）、',' 和 '.' 组成
1 <= numRows <= 1000",1679,,436217,['https://leetcode.cn/tag/string/'],[],840078
评论 (4.7k),reverse-integer,中等,"给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。
  示例 1：
输入：x = 123
输出：321
示例 2：
输入：x = -123
输出：-321
示例 3：
输入：x = 120
输出：21
示例 4：
输入：x = 0
输出：0
  提示：
-231 <= x <= 231 - 1",3517,,1018450,['https://leetcode.cn/tag/math/'],"['https://leetcode.cn/problems/string-to-integer-atoi/', 'https://leetcode.cn/problems/reverse-bits/']",2887031
评论 (3.3k),string-to-integer-atoi,中等,"请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。
函数 myAtoi(string s) 的算法如下：
读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，""123"" -> 123， ""0032"" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：
本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
  示例 1：
输入：s = ""42""
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步：""42""（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：""42""（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步：""42""（读入 ""42""）
           ^
解析得到整数 42 。
由于 ""42"" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
示例 2：
输入：s = ""   -42""
输出：-42
解释：
第 1 步：""   -42""（读入前导空格，但忽视掉）
            ^
第 2 步：""   -42""（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步：""   -42""（读入 ""42""）
               ^
解析得到整数 -42 。
由于 ""-42"" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
示例 3：
输入：s = ""4193 with words""
输出：4193
解释：
第 1 步：""4193 with words""（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：""4193 with words""（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步：""4193 with words""（读入 ""4193""；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 ""4193"" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。
  提示：
0 <= s.length <= 200
s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成",1436,,456415,['https://leetcode.cn/tag/string/'],"['https://leetcode.cn/problems/reverse-integer/', 'https://leetcode.cn/problems/valid-number/']",2110448
评论 (4.1k),palindrome-number,简单,"给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
例如，121 是回文，而 123 不是。
  示例 1：
输入：x = 121
输出：true
示例 2：
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3：
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
  提示：
-231 <= x <= 231 - 1
  进阶：你能不将整数转为字符串来解决这个问题吗？",2022,,1038625,['https://leetcode.cn/tag/math/'],['https://leetcode.cn/problems/palindrome-linked-list/'],1813785
评论 (2.4k),regular-expression-matching,困难,"给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
  示例 1：
输入：s = ""aa"", p = ""a""
输出：false
解释：""a"" 无法匹配 ""aa"" 整个字符串。
示例 2:
输入：s = ""aa"", p = ""a*""
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 ""aa"" 可被视为 'a' 重复了一次。
示例 3：
输入：s = ""ab"", p = "".*""
输出：true
解释："".*"" 表示可匹配零个或多个（'*'）任意字符（'.'）。
  提示：
1 <= s.length <= 20
1 <= p.length <= 30
s 只包含从 a-z 的小写字母。
p 只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符",3002,,279380,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/wildcard-matching/'],883642
评论 (2.2k),container-with-most-water,中等,"给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明：你不能倾斜容器。
  示例 1：
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例 2：
输入：height = [1,1]
输出：1
  提示：
n == height.length
2 <= n <= 105
0 <= height[i] <= 104",3510,,733247,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/']",['https://leetcode.cn/problems/trapping-rain-water/'],1194918
评论 (2.2k),integer-to-roman,中等,"罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字。
  示例 1:
输入: num = 3
输出: ""III""
示例 2:
输入: num = 4
输出: ""IV""
示例 3:
输入: num = 9
输出: ""IX""
示例 4:
输入: num = 58
输出: ""LVIII""
解释: L = 50, V = 5, III = 3.
示例 5:
输入: num = 1994
输出: ""MCMXCIV""
解释: M = 1000, CM = 900, XC = 90, IV = 4.
  提示：
1 <= num <= 3999",880,,296532,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/roman-to-integer/', 'https://leetcode.cn/problems/integer-to-english-words/']",447733
评论 (4.1k),roman-to-integer,简单,"罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。
  示例 1:
输入: s = ""III""
输出: 3
示例 2:
输入: s = ""IV""
输出: 4
示例 3:
输入: s = ""IX""
输出: 9
示例 4:
输入: s = ""LVIII""
输出: 58
解释: L = 50, V= 5, III = 3.
示例 5:
输入: s = ""MCMXCIV""
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
  提示：
1 <= s.length <= 15
s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。",1886,,635623,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/integer-to-roman/'],1017133
评论 (3.6k),longest-common-prefix,简单,"编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 """"。
  示例 1：
输入：strs = [""flower"",""flow"",""flight""]
输出：""fl""
示例 2：
输入：strs = [""dog"",""racecar"",""car""]
输出：""""
解释：输入不存在公共前缀。
  提示：
1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] 仅由小写英文字母组成",2248,,840847,['https://leetcode.cn/tag/string/'],[],1982579
评论 (3.7k),3sum,中等,"给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
  示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：
输入：nums = []
输出：[]
示例 3：
输入：nums = [0]
输出：[]
  提示：
0 <= nums.length <= 3000
-105 <= nums[i] <= 105",4803,,976899,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/two-sum/', 'https://leetcode.cn/problems/3sum-closest/', 'https://leetcode.cn/problems/4sum/', 'https://leetcode.cn/problems/3sum-smaller/']",2751538
评论 (1.1k),3sum-closest,中等,"给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。
返回这三个数的和。
假定每组输入只存在恰好一个解。
  示例 1：
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
示例 2：
输入：nums = [0,0,0], target = 1
输出：0
  提示：
3 <= nums.length <= 1000
-1000 <= nums[i] <= 1000
-104 <= target <= 104",1149,,353741,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/3sum/', 'https://leetcode.cn/problems/3sum-smaller/']",775405
评论 (2.8k),letter-combinations-of-a-phone-number,中等,"给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
  示例 1：
输入：digits = ""23""
输出：[""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
示例 2：
输入：digits = """"
输出：[]
示例 3：
输入：digits = ""2""
输出：[""a"",""b"",""c""]
  提示：
0 <= digits.length <= 4
digits[i] 是范围 ['2', '9'] 的一个数字。",1910,,489880,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/generate-parentheses/', 'https://leetcode.cn/problems/combination-sum/', 'https://leetcode.cn/problems/binary-watch/']",847424
评论 (1.7k),4sum,中等,"给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。
  示例 1：
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
示例 2：
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
  提示：
1 <= nums.length <= 200
-109 <= nums[i] <= 109
-109 <= target <= 109",1248,,319856,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/two-sum/', 'https://leetcode.cn/problems/3sum/', 'https://leetcode.cn/problems/4sum-ii/']",813378
评论 (3.1k),remove-nth-node-from-end-of-list,中等,"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
  示例 1：
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
示例 2：
输入：head = [1], n = 1
输出：[]
示例 3：
输入：head = [1,2], n = 1
输出：[1]
  提示：
链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz
  进阶：你能尝试使用一趟扫描实现吗？",2048,https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg,792402,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],1797956
评论 (4.4k),valid-parentheses,简单,"给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
  示例 1：
输入：s = ""()""
输出：true
示例 2：
输入：s = ""()[]{}""
输出：true
示例 3：
输入：s = ""(]""
输出：false
示例 4：
输入：s = ""([)]""
输出：false
示例 5：
输入：s = ""{[]}""
输出：true
  提示：
1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成",3266,,1093247,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/generate-parentheses/', 'https://leetcode.cn/problems/longest-valid-parentheses/', 'https://leetcode.cn/problems/remove-invalid-parentheses/', 'https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/']",2451759
评论 (2.6k),merge-two-sorted-lists,简单,"将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
  示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：
输入：l1 = [], l2 = []
输出：[]
示例 3：
输入：l1 = [], l2 = [0]
输出：[0]
  提示：
两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列",2446,https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg,1017170,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/']","['https://leetcode.cn/problems/merge-k-sorted-lists/', 'https://leetcode.cn/problems/merge-sorted-array/', 'https://leetcode.cn/problems/sort-list/', 'https://leetcode.cn/problems/shortest-word-distance-ii/']",1525979
评论 (2.6k),generate-parentheses,中等,"数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
  示例 1：
输入：n = 3
输出：[""((()))"",""(()())"",""(())()"",""()(())"",""()()()""]
示例 2：
输入：n = 1
输出：[""()""]
  提示：
1 <= n <= 8",2650,,510524,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/letter-combinations-of-a-phone-number/', 'https://leetcode.cn/problems/valid-parentheses/']",659075
评论 (2.0k),merge-k-sorted-lists,困难,"给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。
  示例 1：
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
示例 2：
输入：lists = []
输出：[]
示例 3：
输入：lists = [[]]
输出：[]
  提示：
k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4",1963,,470250,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/heap-priority-queue/', 'https://leetcode.cn/tag/merge-sort/']","['https://leetcode.cn/problems/merge-two-sorted-lists/', 'https://leetcode.cn/problems/ugly-number-ii/']",825838
评论 (2.2k),swap-nodes-in-pairs,中等,"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
  示例 1：
输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：
输入：head = []
输出：[]
示例 3：
输入：head = [1]
输出：[1]
  提示：
链表中节点的数目在范围 [0, 100] 内
0 <= Node.val <= 100",1395,https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg,446265,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/']",['https://leetcode.cn/problems/reverse-nodes-in-k-group/'],629652
评论 (1.8k),reverse-nodes-in-k-group,困难,"给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
  示例 1：
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
示例 2：
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
  提示：
链表中的节点数目为 n
1 <= k <= n <= 5000
0 <= Node.val <= 1000
  进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？",1640,https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg,342082,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/']",['https://leetcode.cn/problems/swap-nodes-in-pairs/'],508405
评论 (4.5k),remove-duplicates-from-sorted-array,简单,"给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
将最终结果插入 nums 的前 k 个位置后返回 k 。
不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
判题标准:
系统会用下面的代码来测试你的题解:
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
如果所有断言都通过，那么您的题解将被 通过。
  示例 1：
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
  提示：
0 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按 升序 排列",2651,,1114938,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/']","['https://leetcode.cn/problems/remove-element/', 'https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/']",2062896
评论 (3.5k),remove-element,简单,"给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
  说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
  示例 1：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
示例 2：
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  提示：
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100",1342,,706632,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/']","['https://leetcode.cn/problems/remove-duplicates-from-sorted-array/', 'https://leetcode.cn/problems/remove-linked-list-elements/', 'https://leetcode.cn/problems/move-zeroes/']",1188782
评论 (3.6k),implement-strstr,简单,"实现 strStr() 函数。
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
说明：
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
  示例 1：
输入：haystack = ""hello"", needle = ""ll""
输出：2
示例 2：
输入：haystack = ""aaaaa"", needle = ""bba""
输出：-1
  提示：
1 <= haystack.length, needle.length <= 104
haystack 和 needle 仅由小写英文字符组成",1431,,648769,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/']","['https://leetcode.cn/problems/shortest-palindrome/', 'https://leetcode.cn/problems/repeated-substring-pattern/']",1598055
评论 (1.2k),divide-two-integers,中等,"给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2
  示例 1:
输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = truncate(3.33333..) = truncate(3) = 3
示例 2:
输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = truncate(-2.33333..) = -2
  提示：
被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。",906,,165673,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/']",[],747163
评论 (728),substring-with-concatenation-of-all-words,困难,"给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。
  示例 1：
输入：s = ""barfoothefoobarman"", words = [""foo"",""bar""]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 ""barfoo"" 和 ""foobar"" 。
输出的顺序不重要, [9,0] 也是有效答案。
示例 2：
输入：s = ""wordgoodgoodgoodbestword"", words = [""word"",""good"",""best"",""word""]
输出：[]
示例 3：
输入：s = ""barfoofoobarthefoobarman"", words = [""bar"",""foo"",""the""]
输出：[6,9,12]
  提示：
1 <= s.length <= 104
s 由小写英文字母组成
1 <= words.length <= 5000
1 <= words[i].length <= 30
words[i] 由小写英文字母组成",658,,108172,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",['https://leetcode.cn/problems/minimum-window-substring/'],291307
评论 (2.1k),next-permutation,中等,"整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。
必须 原地 修改，只允许使用额外常数空间。
  示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
  提示：
1 <= nums.length <= 100
0 <= nums[i] <= 100",1715,,311753,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/']","['https://leetcode.cn/problems/permutations/', 'https://leetcode.cn/problems/permutations-ii/', 'https://leetcode.cn/problems/permutation-sequence/', 'https://leetcode.cn/problems/palindrome-permutation-ii/']",828938
评论 (1.2k),longest-valid-parentheses,困难,"给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
  示例 1：
输入：s = ""(()""
输出：2
解释：最长有效括号子串是 ""()""
示例 2：
输入：s = "")()())""
输出：4
解释：最长有效括号子串是 ""()()""
示例 3：
输入：s = """"
输出：0
  提示：
0 <= s.length <= 3 * 104
s[i] 为 '(' 或 ')'",1834,,270466,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/valid-parentheses/'],741514
评论 (2.5k),search-in-rotated-sorted-array,中等,"整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
  示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：
输入：nums = [1], target = 0
输出：-1
  提示：
1 <= nums.length <= 5000
-10^4 <= nums[i] <= 10^4
nums 中的每个值都 独一无二
题目数据保证 nums 在预先未知的某个下标上进行了旋转
-10^4 <= target <= 10^4
  进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？",2094,,539217,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']","['https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/', 'https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/']",1236513
评论 (2.8k),find-first-and-last-position-of-element-in-sorted-array,中等,"给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
  示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
示例 3：
输入：nums = [], target = 0
输出：[-1,-1]
  提示：
0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums 是一个非递减数组
-109 <= target <= 109",1707,,542713,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",['https://leetcode.cn/problems/first-bad-version/'],1284656
评论 (3.5k),search-insert-position,简单,"给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
  示例 1:
输入: nums = [1,3,5,6], target = 5
输出: 2
示例 2:
输入: nums = [1,3,5,6], target = 2
输出: 1
示例 3:
输入: nums = [1,3,5,6], target = 7
输出: 4
  提示:
1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 为 无重复元素 的 升序 排列数组
-104 <= target <= 104",1564,,805706,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",['https://leetcode.cn/problems/first-bad-version/'],1778694
评论 (1.5k),valid-sudoku,中等,"请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
  注意：
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。
  示例 1：
输入：board = 
[[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
输出：true
示例 2：
输入：board = 
[[""8"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
  提示：
board.length == 9
board[i].length == 9
board[i][j] 是一位数字（1-9）或者 '.'",877,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png,282596,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/sudoku-solver/'],445264
评论 (1.0k),sudoku-solver,困难,"编写一个程序，通过填充空格来解决数独问题。
数独的解法需 遵循如下规则：
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。
  示例 1：
输入：board = [[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
输出：[[""5"",""3"",""4"",""6"",""7"",""8"",""9"",""1"",""2""],[""6"",""7"",""2"",""1"",""9"",""5"",""3"",""4"",""8""],[""1"",""9"",""8"",""3"",""4"",""2"",""5"",""6"",""7""],[""8"",""5"",""9"",""7"",""6"",""1"",""4"",""2"",""3""],[""4"",""2"",""6"",""8"",""5"",""3"",""7"",""9"",""1""],[""7"",""1"",""3"",""9"",""2"",""4"",""8"",""5"",""6""],[""9"",""6"",""1"",""5"",""3"",""7"",""2"",""8"",""4""],[""2"",""8"",""7"",""4"",""1"",""9"",""6"",""3"",""5""],[""3"",""4"",""5"",""2"",""8"",""6"",""1"",""7"",""9""]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
  提示：
board.length == 9
board[i].length == 9
board[i][j] 是一位数字或者 '.'
题目数据 保证 输入数独仅有一个解",1275,,145271,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/valid-sudoku/', 'https://leetcode.cn/problems/unique-paths-iii/']",215276
评论 (3.0k),count-and-say,中等,"给定一个正整数 n ，输出外观数列的第 n 项。
「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。
你可以将其视作是由递归公式定义的数字字符串序列：
countAndSay(1) = ""1""
countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。
前五项如下：
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 ""11""
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 ""21""
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 ""1211""
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 ""111221""
要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。
例如，数字字符串 ""3322251"" 的描述如下图：
  示例 1：
输入：n = 1
输出：""1""
解释：这是一个基本样例。
示例 2：
输入：n = 4
输出：""1211""
解释：
countAndSay(1) = ""1""
countAndSay(2) = 读 ""1"" = 一 个 1 = ""11""
countAndSay(3) = 读 ""11"" = 二 个 1 = ""21""
countAndSay(4) = 读 ""21"" = 一 个 2 + 一 个 1 = ""12"" + ""11"" = ""1211""
  提示：
1 <= n <= 30",903,https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png,285765,['https://leetcode.cn/tag/string/'],"['https://leetcode.cn/problems/encode-and-decode-strings/', 'https://leetcode.cn/problems/string-compression/']",476075
评论 (1.7k),combination-sum,中等,"给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
对于给定的输入，保证和为 target 的不同组合数少于 150 个。
  示例 1：
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
示例 2：
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
示例 3：
输入: candidates = [2], target = 1
输出: []
  提示：
1 <= candidates.length <= 30
1 <= candidates[i] <= 200
candidate 中的每个元素都 互不相同
1 <= target <= 500",1968,,508424,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/letter-combinations-of-a-phone-number/', 'https://leetcode.cn/problems/combination-sum-ii/', 'https://leetcode.cn/problems/combinations/', 'https://leetcode.cn/problems/combination-sum-iii/', 'https://leetcode.cn/problems/factor-combinations/', 'https://leetcode.cn/problems/combination-sum-iv/']",698313
评论 (1.2k),combination-sum-ii,中等,"给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用 一次 。
注意：解集不能包含重复的组合。 
  示例 1:
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
示例 2:
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
  提示:
1 <= candidates.length <= 100
1 <= candidates[i] <= 50
1 <= target <= 30",973,,297908,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/combination-sum/'],490488
评论 (1.5k),first-missing-positive,困难,"给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
  示例 1：
输入：nums = [1,2,0]
输出：3
示例 2：
输入：nums = [3,4,-1,1]
输出：2
示例 3：
输入：nums = [7,8,9,11,12]
输出：1
  提示：
1 <= nums.length <= 5 * 105
-231 <= nums[i] <= 231 - 1",1477,,224946,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']","['https://leetcode.cn/problems/missing-number/', 'https://leetcode.cn/problems/find-the-duplicate-number/', 'https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/', 'https://leetcode.cn/problems/couples-holding-hands/']",527836
评论 (1.7k),trapping-rain-water,困难,"给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
  示例 1：
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
示例 2：
输入：height = [4,2,0,3,2,5]
输出：9
  提示：
n == height.length
1 <= n <= 2 * 104
0 <= height[i] <= 105",3468,,485698,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/monotonic-stack/']","['https://leetcode.cn/problems/container-with-most-water/', 'https://leetcode.cn/problems/product-of-array-except-self/', 'https://leetcode.cn/problems/trapping-rain-water-ii/', 'https://leetcode.cn/problems/pour-water/']",797016
评论 (1.3k),multiply-strings,中等,"给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。
  示例 1:
输入: num1 = ""2"", num2 = ""3""
输出: ""6""
示例 2:
输入: num1 = ""123"", num2 = ""456""
输出: ""56088""
  提示：
1 <= num1.length, num2.length <= 200
num1 和 num2 只能由数字组成。
num1 和 num2 都不包含任何前导零，除了数字0本身。",937,,226808,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']","['https://leetcode.cn/problems/add-two-numbers/', 'https://leetcode.cn/problems/plus-one/', 'https://leetcode.cn/problems/add-binary/', 'https://leetcode.cn/problems/add-strings/']",506008
评论 (601),wildcard-matching,困难,"给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。
说明:
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
示例 1:
输入:
s = ""aa""
p = ""a""
输出: false
解释: ""a"" 无法匹配 ""aa"" 整个字符串。
示例 2:
输入:
s = ""aa""
p = ""*""
输出: true
解释: '*' 可以匹配任意字符串。
示例 3:
输入:
s = ""cb""
p = ""?a""
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
示例 4:
输入:
s = ""adceb""
p = ""*a*b""
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 ""dce"".
示例 5:
输入:
s = ""acdcb""
p = ""a*c?b""
输出: false",884,,107127,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/regular-expression-matching/'],322018
评论 (1.7k),jump-game-ii,中等,"给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
假设你总是可以到达数组的最后一个位置。
  示例 1:
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:
输入: nums = [2,3,0,1,4]
输出: 2
  提示:
1 <= nums.length <= 104
0 <= nums[i] <= 1000",1630,,335130,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/jump-game/'],750961
评论 (1.9k),permutations,中等,"给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
  示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：
输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：
输入：nums = [1]
输出：[[1]]
  提示：
1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同",2031,,621737,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/next-permutation/', 'https://leetcode.cn/problems/permutations-ii/', 'https://leetcode.cn/problems/permutation-sequence/', 'https://leetcode.cn/problems/combinations/']",791492
评论 (1.3k),permutations-ii,中等,"给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
  示例 1：
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
示例 2：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
  提示：
1 <= nums.length <= 8
-10 <= nums[i] <= 10",1071,,320772,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/next-permutation/', 'https://leetcode.cn/problems/permutations/', 'https://leetcode.cn/problems/palindrome-permutation-ii/', 'https://leetcode.cn/problems/number-of-squareful-arrays/']",495605
评论 (1.9k),rotate-image,中等,"给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
  示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
示例 2：
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
  提示：
n == matrix.length == matrix[i].length
1 <= n <= 20
-1000 <= matrix[i][j] <= 1000
 ",1307,https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg,324731,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/matrix/']",[],437926
评论 (1.3k),group-anagrams,中等,"给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。
  示例 1:
输入: strs = [""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""]
输出: [[""bat""],[""nat"",""tan""],[""ate"",""eat"",""tea""]]
示例 2:
输入: strs = [""""]
输出: [[""""]]
示例 3:
输入: strs = [""a""]
输出: [[""a""]]
  提示：
1 <= strs.length <= 104
0 <= strs[i].length <= 100
strs[i] 仅包含小写字母",1146,,329132,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/valid-anagram/', 'https://leetcode.cn/problems/group-shifted-strings/']",489064
评论 (1.5k),n-queens,困难,"n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
  示例 1：
输入：n = 4
输出：[["".Q.."",""...Q"",""Q..."",""..Q.""],[""..Q."",""Q..."",""...Q"","".Q..""]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
示例 2：
输入：n = 1
输出：[[""Q""]]
  提示：
1 <= n <= 9",1352,,217328,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/n-queens-ii/', 'https://leetcode.cn/problems/grid-illumination/']",293711
评论 (635),n-queens-ii,困难,"n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。
  示例 1：
输入：n = 4
输出：2
解释：如上图所示，4 皇后问题存在两个不同的解法。
示例 2：
输入：n = 1
输出：1
  提示：
1 <= n <= 9",366,,93514,['https://leetcode.cn/tag/backtracking/'],['https://leetcode.cn/problems/n-queens/'],113700
评论 (3.4k),maximum-subarray,简单,"给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
  示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：
输入：nums = [1]
输出：1
示例 3：
输入：nums = [5,4,-1,7,8]
输出：23
  提示：
1 <= nums.length <= 105
-104 <= nums[i] <= 104
  进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。",4908,,1037719,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/', 'https://leetcode.cn/problems/maximum-product-subarray/', 'https://leetcode.cn/problems/degree-of-an-array/', 'https://leetcode.cn/problems/longest-turbulent-subarray/']",1890984
评论 (1.7k),spiral-matrix,中等,"给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
  示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
示例 2：
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 10
-100 <= matrix[i][j] <= 100",1103,https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg,264329,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",['https://leetcode.cn/problems/spiral-matrix-ii/'],541798
评论 (2.4k),jump-game,中等,"给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
  示例 1：
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
  提示：
1 <= nums.length <= 3 * 104
0 <= nums[i] <= 105",1850,,501325,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/jump-game-ii/'],1151713
评论 (2.1k),merge-intervals,中等,"以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
  示例 1：
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
  提示：
1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104",1495,,450086,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/insert-interval/', 'https://leetcode.cn/problems/meeting-rooms/', 'https://leetcode.cn/problems/meeting-rooms-ii/', 'https://leetcode.cn/problems/teemo-attacking/', 'https://leetcode.cn/problems/add-bold-tag-in-string/', 'https://leetcode.cn/problems/range-module/', 'https://leetcode.cn/problems/employee-free-time/', 'https://leetcode.cn/problems/partition-labels/', 'https://leetcode.cn/problems/interval-list-intersections/']",926089
评论 (698),insert-interval,中等,"给你一个 无重叠的 ，按照区间起始端点排序的区间列表。
在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
  示例 1：
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
示例 2：
输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
示例 3：
输入：intervals = [], newInterval = [5,7]
输出：[[5,7]]
示例 4：
输入：intervals = [[1,5]], newInterval = [2,3]
输出：[[1,5]]
示例 5：
输入：intervals = [[1,5]], newInterval = [2,7]
输出：[[1,7]]
  提示：
0 <= intervals.length <= 104
intervals[i].length == 2
0 <= intervals[i][0] <= intervals[i][1] <= 105
intervals 根据 intervals[i][0] 按 升序 排列
newInterval.length == 2
0 <= newInterval[0] <= newInterval[1] <= 105",593,,110733,['https://leetcode.cn/tag/array/'],"['https://leetcode.cn/problems/merge-intervals/', 'https://leetcode.cn/problems/range-module/']",266675
评论 (2.9k),length-of-last-word,简单,"给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
  示例 1：
输入：s = ""Hello World""
输出：5
解释：最后一个单词是“World”，长度为5。
示例 2：
输入：s = ""   fly me   to   the moon  ""
输出：4
解释：最后一个单词是“moon”，长度为4。
示例 3：
输入：s = ""luffy is still joyboy""
输出：6
解释：最后一个单词是长度为6的“joyboy”。
  提示：
1 <= s.length <= 104
s 仅有英文字母和空格 ' ' 组成
s 中至少存在一个单词",459,,323035,['https://leetcode.cn/tag/string/'],[],802609
评论 (1.6k),spiral-matrix-ii,中等,"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
  示例 1：
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
示例 2：
输入：n = 1
输出：[[1]]
  提示：
1 <= n <= 20",711,https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg,199311,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",['https://leetcode.cn/problems/spiral-matrix/'],261112
评论 (1.0k),permutation-sequence,困难,"给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。
按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
""123""
""132""
""213""
""231""
""312""
""321""
给定 n 和 k，返回第 k 个排列。
  示例 1：
输入：n = 3, k = 3
输出：""213""
示例 2：
输入：n = 4, k = 9
输出：""2314""
示例 3：
输入：n = 3, k = 1
输出：""123""
  提示：
1 <= n <= 9
1 <= k <= n!",672,,107247,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']","['https://leetcode.cn/problems/next-permutation/', 'https://leetcode.cn/problems/permutations/']",202204
评论 (1.5k),rotate-list,中等,"给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
  示例 1：
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
示例 2：
输入：head = [0,1,2], k = 4
输出：[2,0,1]
  提示：
链表中节点的数目在范围 [0, 500] 内
-100 <= Node.val <= 100
0 <= k <= 2 * 109",773,https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg,250649,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']","['https://leetcode.cn/problems/rotate-array/', 'https://leetcode.cn/problems/split-linked-list-in-parts/']",601211
评论 (1.9k),unique-paths,中等,"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
  示例 1：
输入：m = 3, n = 7
输出：28
示例 2：
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
示例 3：
输入：m = 7, n = 3
输出：28
示例 4：
输入：m = 3, n = 3
输出：6
  提示：
1 <= m, n <= 100
题目数据保证答案小于等于 2 * 109",1416,https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png,441904,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/combinatorics/']","['https://leetcode.cn/problems/unique-paths-ii/', 'https://leetcode.cn/problems/minimum-path-sum/', 'https://leetcode.cn/problems/dungeon-game/']",659048
评论 (1.6k),unique-paths-ii,中等,"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。
  示例 1：
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
示例 2：
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
  提示：
m == obstacleGrid.length
n == obstacleGrid[i].length
1 <= m, n <= 100
obstacleGrid[i][j] 为 0 或 1",792,https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg,261573,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/unique-paths/', 'https://leetcode.cn/problems/unique-paths-iii/']",649676
评论 (1.6k),minimum-path-sum,中等,"给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
  示例 1：
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
示例 2：
输入：grid = [[1,2,3],[4,5,6]]
输出：12
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 200
0 <= grid[i][j] <= 100",1255,https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg,367347,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/unique-paths/', 'https://leetcode.cn/problems/dungeon-game/', 'https://leetcode.cn/problems/cherry-pickup/']",530752
评论 (929),valid-number,困难,"有效数字（按顺序）可以分成以下几个部分：
一个 小数 或者 整数
（可选）一个 'e' 或 'E' ，后面跟着一个 整数
小数（按顺序）可以分成以下几个部分：
（可选）一个符号字符（'+' 或 '-'）
下述格式之一：
至少一位数字，后面跟着一个点 '.'
至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
一个点 '.' ，后面跟着至少一位数字
整数（按顺序）可以分成以下几个部分：
（可选）一个符号字符（'+' 或 '-'）
至少一位数字
部分有效数字列举如下：[""2"", ""0089"", ""-0.1"", ""+3.14"", ""4."", ""-.9"", ""2e10"", ""-90E3"", ""3e+7"", ""+6e-1"", ""53.5e93"", ""-123.456e789""]
部分无效数字列举如下：[""abc"", ""1a"", ""1e"", ""e3"", ""99e2.5"", ""--6"", ""-+3"", ""95a54e53""]
给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。
  示例 1：
输入：s = ""0""
输出：true
示例 2：
输入：s = ""e""
输出：false
示例 3：
输入：s = "".""
输出：false
  提示：
1 <= s.length <= 20
s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，或者点 '.' 。",312,,54790,['https://leetcode.cn/tag/string/'],['https://leetcode.cn/problems/string-to-integer-atoi/'],199883
评论 (3.0k),plus-one,简单,"给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
  示例 1：
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
示例 2：
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
示例 3：
输入：digits = [0]
输出：[1]
  提示：
1 <= digits.length <= 100
0 <= digits[i] <= 9",1018,,491717,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']","['https://leetcode.cn/problems/multiply-strings/', 'https://leetcode.cn/problems/add-binary/', 'https://leetcode.cn/problems/plus-one-linked-list/', 'https://leetcode.cn/problems/add-to-array-form-of-integer/']",1071448
评论 (2.0k),add-binary,简单,"给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。
  示例 1:
输入: a = ""11"", b = ""1""
输出: ""100""
示例 2:
输入: a = ""1010"", b = ""1011""
输出: ""10101""
  提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 ""0"" ，就都不含前导零。",817,,249037,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']","['https://leetcode.cn/problems/add-two-numbers/', 'https://leetcode.cn/problems/multiply-strings/', 'https://leetcode.cn/problems/plus-one/', 'https://leetcode.cn/problems/add-to-array-form-of-integer/']",462529
评论 (646),text-justification,困难,"给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。
你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。
要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。
文本的最后一行应为左对齐，且单词之间不插入额外的空格。
注意:
单词是指由非空格字符组成的字符序列。
每个单词的长度大于 0，小于等于 maxWidth。
输入单词数组 words 至少包含一个单词。
  示例 1:
输入: words = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""], maxWidth = 16
输出:
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]
示例 2:
输入:words = [""What"",""must"",""be"",""acknowledgment"",""shall"",""be""], maxWidth = 16
输出:
[
  ""What   must   be"",
  ""acknowledgment  "",
  ""shall be        ""
]
解释: 注意最后一行的格式应为 ""shall be    "" 而不是 ""shall     be"",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
示例 3:
输入:words = [""Science"",""is"",""what"",""we"",""understand"",""well"",""enough"",""to"",""explain"",""to"",""a"",""computer."",""Art"",""is"",""everything"",""else"",""we"",""do""]，maxWidth = 20
输出:
[
  ""Science  is  what we"",
  ""understand      well"",
  ""enough to explain to"",
  ""a  computer.  Art is"",
  ""everything  else  we"",
  ""do                  ""
]
  提示:
1 <= words.length <= 300
1 <= words[i].length <= 20
words[i] 由小写英文字母和符号组成
1 <= maxWidth <= 100
words[i].length <= maxWidth",281,,44555,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],85457
评论 (2.0k),sqrtx,简单,"给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
  示例 1：
输入：x = 4
输出：2
示例 2：
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
  提示：
0 <= x <= 231 - 1",1020,,541597,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']","['https://leetcode.cn/problems/powx-n/', 'https://leetcode.cn/problems/valid-perfect-square/']",1394412
评论 (3.3k),climbing-stairs,简单,"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
  示例 1：
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
  提示：
1 <= n <= 45",2435,,834502,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/min-cost-climbing-stairs/', 'https://leetcode.cn/problems/fibonacci-number/', 'https://leetcode.cn/problems/n-th-tribonacci-number/']",1554198
评论 (1.0k),simplify-path,中等,"给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。
在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。
请注意，返回的 规范路径 必须遵循下述格式：
始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/' 。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
返回简化后得到的 规范路径 。
  示例 1：
输入：path = ""/home/""
输出：""/home""
解释：注意，最后一个目录名后面没有斜杠。 
示例 2：
输入：path = ""/../""
输出：""/""
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
示例 3：
输入：path = ""/home//foo/""
输出：""/home/foo""
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
示例 4：
输入：path = ""/a/./b/../../c/""
输出：""/c""
  提示：
1 <= path.length <= 3000
path 由英文字母，数字，'.'，'/' 或 '_' 组成。
path 是一个有效的 Unix 风格绝对路径。",485,,148039,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],334710
评论 (1.0k),edit-distance,困难,"给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。
你可以对一个单词进行如下三种操作：
插入一个字符
删除一个字符
替换一个字符
  示例 1：
输入：word1 = ""horse"", word2 = ""ros""
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
示例 2：
输入：word1 = ""intention"", word2 = ""execution""
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
  提示：
0 <= word1.length, word2.length <= 500
word1 和 word2 由小写英文字母组成",2389,,257774,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/one-edit-distance/', 'https://leetcode.cn/problems/delete-operation-for-two-strings/', 'https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/', 'https://leetcode.cn/problems/uncrossed-lines/']",414021
评论 (906),set-matrix-zeroes,中等,"给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
  示例 1：
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
示例 2：
输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
  提示：
m == matrix.length
n == matrix[0].length
1 <= m, n <= 200
-231 <= matrix[i][j] <= 231 - 1
  进阶：
一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个仅使用常量空间的解决方案吗？",725,https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg,187106,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/game-of-life/'],302405
评论 (1.4k),search-a-2d-matrix,中等,"编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。
  示例 1：
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
示例 2：
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-104 <= matrix[i][j], target <= 104",654,https://assets.leetcode.com/uploads/2020/10/05/mat.jpg,235440,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/search-a-2d-matrix-ii/'],495515
评论 (1.9k),sort-colors,中等,"给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
必须在不使用库的sort函数的情况下解决这个问题。
  示例 1：
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
示例 2：
输入：nums = [2,0,1]
输出：[0,1,2]
  提示：
n == nums.length
1 <= n <= 300
nums[i] 为 0、1 或 2
  进阶：
你可以不使用代码库中的排序函数来解决这道题吗？
你能想出一个仅使用常数空间的一趟扫描算法吗？",1278,,385076,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/sort-list/', 'https://leetcode.cn/problems/wiggle-sort/', 'https://leetcode.cn/problems/wiggle-sort-ii/']",640972
评论 (1.3k),minimum-window-substring,困难,"给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 """" 。
  注意：
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
  示例 1：
输入：s = ""ADOBECODEBANC"", t = ""ABC""
输出：""BANC""
示例 2：
输入：s = ""a"", t = ""a""
输出：""a""
示例 3:
输入: s = ""a"", t = ""aa""
输出: """"
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
  提示：
1 <= s.length, t.length <= 105
s 和 t 由英文字母组成
  进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？",1890,,288151,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/substring-with-concatenation-of-all-words/', 'https://leetcode.cn/problems/minimum-size-subarray-sum/', 'https://leetcode.cn/problems/sliding-window-maximum/', 'https://leetcode.cn/problems/permutation-in-string/', 'https://leetcode.cn/problems/minimum-window-subsequence/']",652886
评论 (1.1k),combinations,中等,"给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。
  示例 1：
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
示例 2：
输入：n = 1, k = 1
输出：[[1]]
  提示：
1 <= n <= 20
1 <= k <= n",986,,354001,['https://leetcode.cn/tag/backtracking/'],"['https://leetcode.cn/problems/combination-sum/', 'https://leetcode.cn/problems/permutations/']",459134
评论 (1.9k),subsets,中等,"给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
  示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：
输入：nums = [0]
输出：[[],[0]]
  提示：
1 <= nums.length <= 10
-10 <= nums[i] <= 10
nums 中的所有元素 互不相同",1645,,449382,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/subsets-ii/', 'https://leetcode.cn/problems/generalized-abbreviation/', 'https://leetcode.cn/problems/letter-case-permutation/']",557954
评论 (1.5k),word-search,中等,"给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
  示例 1：
输入：board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCCED""
输出：true
示例 2：
输入：board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""SEE""
输出：true
示例 3：
输入：board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCB""
输出：false
  提示：
m == board.length
n = board[i].length
1 <= m, n <= 6
1 <= word.length <= 15
board 和 word 仅由大小写英文字母组成
  进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？",1311,https://assets.leetcode.com/uploads/2020/11/04/word2.jpg,317214,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/word-search-ii/'],685096
评论 (916),remove-duplicates-from-sorted-array-ii,中等,"给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
  说明：
为什么返回数值是整数，但输出的答案是数组呢？
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
  示例 1：
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
  提示：
1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按升序排列",688,,181902,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/']",['https://leetcode.cn/problems/remove-duplicates-from-sorted-array/'],293229
评论 (948),search-in-rotated-sorted-array-ii,中等,"已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
你必须尽可能减少整个操作步骤。
  示例 1：
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
示例 2：
输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
  提示：
1 <= nums.length <= 5000
-104 <= nums[i] <= 104
题目数据保证 nums 在预先未知的某个下标上进行了旋转
-104 <= target <= 104
  进阶：
这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。
这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？
 ",597,,158116,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",['https://leetcode.cn/problems/search-in-rotated-sorted-array/'],382597
评论 (1.4k),remove-duplicates-from-sorted-list-ii,中等,"给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。
  示例 1：
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
示例 2：
输入：head = [1,1,1,2,3]
输出：[2,3]
  提示：
链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序 排列",898,https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg,257666,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",['https://leetcode.cn/problems/remove-duplicates-from-sorted-list/'],483347
评论 (1.7k),remove-duplicates-from-sorted-list,简单,"给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。
  示例 1：
输入：head = [1,1,2]
输出：[1,2]
示例 2：
输入：head = [1,1,2,3,3]
输出：[1,2,3]
  提示：
链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序 排列",794,https://assets.leetcode.com/uploads/2021/01/04/list1.jpg,432200,['https://leetcode.cn/tag/linked-list/'],['https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/'],807101
评论 (905),largest-rectangle-in-histogram,困难,"给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
  示例 1:
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
示例 2：
输入： heights = [2,4]
输出： 4
  提示：
1 <= heights.length <=105
0 <= heights[i] <= 104",1950,,250522,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/monotonic-stack/']",['https://leetcode.cn/problems/maximal-rectangle/'],566319
评论 (544),maximal-rectangle,困难,"给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
  示例 1：
输入：matrix = [[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]
输出：6
解释：最大矩形如上图所示。
示例 2：
输入：matrix = []
输出：0
示例 3：
输入：matrix = [[""0""]]
输出：0
示例 4：
输入：matrix = [[""1""]]
输出：1
示例 5：
输入：matrix = [[""0"",""0""]]
输出：0
  提示：
rows == matrix.length
cols == matrix[0].length
1 <= row, cols <= 200
matrix[i][j] 为 '0' 或 '1'",1273,https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg,130197,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/monotonic-stack/']","['https://leetcode.cn/problems/largest-rectangle-in-histogram/', 'https://leetcode.cn/problems/maximal-square/']",245566
评论 (1.0k),partition-list,中等,"给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
你应当 保留 两个分区中每个节点的初始相对位置。
  示例 1：
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
示例 2：
输入：head = [2,1], x = 2
输出：[1,2]
  提示：
链表中节点的数目在范围 [0, 200] 内
-100 <= Node.val <= 100
-200 <= x <= 200",561,https://assets.leetcode.com/uploads/2021/01/04/partition.jpg,151933,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],240343
评论 (442),scramble-string,困难,"使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止
如果字符串的长度 > 1 ，执行下述步骤：
在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。
  示例 1：
输入：s1 = ""great"", s2 = ""rgeat""
输出：true
解释：s1 上可能发生的一种情形是：
""great"" --> ""gr/eat"" // 在一个随机下标处分割得到两个子字符串
""gr/eat"" --> ""gr/eat"" // 随机决定：「保持这两个子字符串的顺序不变」
""gr/eat"" --> ""g/r / e/at"" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割
""g/r / e/at"" --> ""r/g / e/at"" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」
""r/g / e/at"" --> ""r/g / e/ a/t"" // 继续递归执行此算法，将 ""at"" 分割得到 ""a/t""
""r/g / e/ a/t"" --> ""r/g / e/ a/t"" // 随机决定：「保持这两个子字符串的顺序不变」
算法终止，结果字符串和 s2 相同，都是 ""rgeat""
这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true
示例 2：
输入：s1 = ""abcde"", s2 = ""caebd""
输出：false
示例 3：
输入：s1 = ""a"", s2 = ""a""
输出：true
  提示：
s1.length == s2.length
1 <= s1.length <= 30
s1 和 s2 由小写英文字母组成",462,,48252,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],100524
评论 (3.0k),merge-sorted-array,简单,"给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
  示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
示例 2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
示例 3：
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
  提示：
nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
  进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？",1433,,664263,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/merge-two-sorted-lists/', 'https://leetcode.cn/problems/squares-of-a-sorted-array/', 'https://leetcode.cn/problems/interval-list-intersections/']",1270404
评论 (685),gray-code,中等,"n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：
每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
第一个整数是 0
一个整数在序列中出现 不超过一次
每对 相邻 整数的二进制表示 恰好一位不同 ，且
第一个 和 最后一个 整数的二进制表示 恰好一位不同
给你一个整数 n ，返回任一有效的 n 位格雷码序列 。
  示例 1：
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
示例 2：
输入：n = 1
输出：[0,1]
  提示：
1 <= n <= 16",501,,95689,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/1-bit-and-2-bit-characters/'],128141
评论 (1.0k),subsets-ii,中等,"给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
  示例 1：
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
示例 2：
输入：nums = [0]
输出：[[],[0]]
  提示：
1 <= nums.length <= 10
-10 <= nums[i] <= 10",833,,203983,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/subsets/'],321254
评论 (1.5k),decode-ways,中等,"一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
'A' -> ""1""
'B' -> ""2""
...
'Z' -> ""26""
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，""11106"" 可以映射为：
""AAJF"" ，将消息分组为 (1 1 10 6)
""KJF"" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 ""06"" 不能映射为 ""F"" ，这是由于 ""6"" 和 ""06"" 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
  示例 1：
输入：s = ""12""
输出：2
解释：它可以解码为 ""AB""（1 2）或者 ""L""（12）。
示例 2：
输入：s = ""226""
输出：3
解释：它可以解码为 ""BZ"" (2 26), ""VF"" (22 6), 或者 ""BBF"" (2 2 6) 。
示例 3：
输入：s = ""0""
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> ""10"" 和 'T'-> ""20"" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
  提示：
1 <= s.length <= 100
s 只包含数字，并且可能包含前导零。",1179,,215084,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/decode-ways-ii/'],668214
评论 (1.5k),reverse-linked-list-ii,中等,"给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
  示例 1：
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
示例 2：
输入：head = [5], left = 1, right = 1
输出：[5]
  提示：
链表中节点数目为 n
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n
  进阶： 你可以使用一趟扫描完成反转吗？",1287,https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg,296868,['https://leetcode.cn/tag/linked-list/'],['https://leetcode.cn/problems/reverse-linked-list/'],536501
评论 (1.4k),restore-ip-addresses,中等,"有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
例如：""0.1.2.201"" 和 ""192.168.1.1"" 是 有效 IP 地址，但是 ""0.011.255.245""、""192.168.1.312"" 和 ""192.168@1.1"" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
  示例 1：
输入：s = ""25525511135""
输出：[""255.255.11.135"",""255.255.111.35""]
示例 2：
输入：s = ""0000""
输出：[""0.0.0.0""]
示例 3：
输入：s = ""101023""
输出：[""1.0.10.23"",""1.0.102.3"",""10.1.0.23"",""10.10.2.3"",""101.0.2.3""]
  提示：
1 <= s.length <= 20
s 仅由数字组成",918,,227606,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/ip-to-cidr/'],403918
评论 (1.5k),binary-tree-inorder-traversal,简单,"给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
  示例 1：
输入：root = [1,null,2,3]
输出：[1,3,2]
示例 2：
输入：root = []
输出：[]
示例 3：
输入：root = [1]
输出：[1]
  提示：
树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100
  进阶: 递归算法很简单，你可以通过迭代算法完成吗？",1440,https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg,828970,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/validate-binary-search-tree/', 'https://leetcode.cn/problems/binary-tree-preorder-traversal/', 'https://leetcode.cn/problems/binary-tree-postorder-traversal/', 'https://leetcode.cn/problems/binary-search-tree-iterator/', 'https://leetcode.cn/problems/kth-smallest-element-in-a-bst/', 'https://leetcode.cn/problems/closest-binary-search-tree-value-ii/', 'https://leetcode.cn/problems/inorder-successor-in-bst/', 'https://leetcode.cn/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/', 'https://leetcode.cn/problems/minimum-distance-between-bst-nodes/']",1092642
评论 (709),unique-binary-search-trees-ii,中等,"给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。
  示例 1：
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
示例 2：
输入：n = 1
输出：[[1]]
  提示：
1 <= n <= 8",1217,,132314,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/unique-binary-search-trees/', 'https://leetcode.cn/problems/different-ways-to-add-parentheses/']",183594
评论 (1.2k),unique-binary-search-trees,中等,"给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
  示例 1：
输入：n = 3
输出：5
示例 2：
输入：n = 1
输出：1
  提示：
1 <= n <= 19",1767,https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg,249153,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/unique-binary-search-trees-ii/'],354442
评论 (589),interleaving-string,中等,"给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。
两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：
s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
注意：a + b 意味着字符串 a 和 b 连接。
  示例 1：
输入：s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbcbcac""
输出：true
示例 2：
输入：s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbbaccc""
输出：false
示例 3：
输入：s1 = """", s2 = """", s3 = """"
输出：true
  提示：
0 <= s1.length, s2.length <= 100
0 <= s3.length <= 200
s1、s2、和 s3 都由小写英文字母组成
  进阶：您能否仅使用 O(s2.length) 额外的内存空间来解决它?",699,https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg,85057,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],188611
评论 (1.8k),validate-binary-search-tree,中等,"给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
  示例 1：
输入：root = [2,1,3]
输出：true
示例 2：
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
  提示：
树中节点数目范围在[1, 104] 内
-231 <= Node.val <= 231 - 1",1593,https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg,512533,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/binary-tree-inorder-traversal/', 'https://leetcode.cn/problems/find-mode-in-binary-search-tree/']",1420391
评论 (508),recover-binary-search-tree,中等,"给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。
  示例 1：
输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。
示例 2：
输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
  提示：
树上节点的数目在范围 [2, 1000] 内
-231 <= Node.val <= 231 - 1
  进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用 O(1) 空间的解决方案吗？",722,https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg,102354,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",[],169309
评论 (1.7k),same-tree,简单,"给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
  示例 1：
输入：p = [1,2,3], q = [1,2,3]
输出：true
示例 2：
输入：p = [1,2], q = [1,null,2]
输出：false
示例 3：
输入：p = [1,2,1], q = [1,1,2]
输出：false
  提示：
两棵树上的节点数目都在范围 [0, 100] 内
-104 <= Node.val <= 104",840,https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg,341752,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],571853
评论 (342),bitwise-and-of-numbers-range,中等,"给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。
  示例 1：
输入：left = 5, right = 7
输出：4
示例 2：
输入：left = 0, right = 0
输出：0
示例 3：
输入：left = 1, right = 2147483647
输出：0
  提示：
0 <= left <= right <= 231 - 1",379,,61305,['https://leetcode.cn/tag/bit-manipulation/'],[],114777
评论 (1.5k),happy-number,简单,"编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」 定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。
  示例 1：
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：
输入：n = 2
输出：false
  提示：
1 <= n <= 231 - 1",936,,252529,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/']","['https://leetcode.cn/problems/linked-list-cycle/', 'https://leetcode.cn/problems/add-digits/', 'https://leetcode.cn/problems/ugly-number/']",401929
评论 (1.3k),remove-linked-list-elements,简单,"给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
  示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
示例 2：
输入：head = [], val = 1
输出：[]
示例 3：
输入：head = [7,7,7,7], val = 7
输出：[]
  提示：
列表中的节点数目在范围 [0, 104] 内
1 <= Node.val <= 50
0 <= val <= 50",916,https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg,360325,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/']","['https://leetcode.cn/problems/remove-element/', 'https://leetcode.cn/problems/delete-node-in-a-linked-list/']",672891
评论 (829),count-primes,中等,"给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
  示例 1：
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
示例 2：
输入：n = 0
输出：0
示例 3：
输入：n = 1
输出：0
  提示：
0 <= n <= 5 * 106",890,,203685,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/', 'https://leetcode.cn/tag/number-theory/']","['https://leetcode.cn/problems/ugly-number/', 'https://leetcode.cn/problems/ugly-number-ii/', 'https://leetcode.cn/problems/perfect-squares/']",542832
评论 (856),isomorphic-strings,简单,"给定两个字符串 s 和 t ，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
  示例 1:
输入：s = ""egg"", t = ""add""
输出：true
示例 2：
输入：s = ""foo"", t = ""bar""
输出：false
示例 3：
输入：s = ""paper"", t = ""title""
输出：true
  提示：
1 <= s.length <= 5 * 104
t.length == s.length
s 和 t 由任意有效的 ASCII 字符组成",460,,141793,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/word-pattern/'],284337
评论 (2.1k),reverse-linked-list,简单,"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
  示例 1：
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
示例 2：
输入：head = [1,2]
输出：[2,1]
示例 3：
输入：head = []
输出：[]
  提示：
链表中节点的数目范围是 [0, 5000]
-5000 <= Node.val <= 5000
  进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？",2540,,1049043,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/']","['https://leetcode.cn/problems/reverse-linked-list-ii/', 'https://leetcode.cn/problems/binary-tree-upside-down/', 'https://leetcode.cn/problems/palindrome-linked-list/']",1438049
评论 (894),course-schedule,中等,"你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
  示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
示例 2：
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
  提示：
1 <= numCourses <= 105
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
prerequisites[i] 中的所有课程对 互不相同",1269,,209372,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']","['https://leetcode.cn/problems/course-schedule-ii/', 'https://leetcode.cn/problems/graph-valid-tree/', 'https://leetcode.cn/problems/minimum-height-trees/', 'https://leetcode.cn/problems/course-schedule-iii/']",388632
评论 (739),implement-trie-prefix-tree,中等,"Trie（发音类似 ""try""）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
请你实现 Trie 类：
Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
  示例：
输入
[""Trie"", ""insert"", ""search"", ""search"", ""startsWith"", ""insert"", ""search""]
[[], [""apple""], [""apple""], [""app""], [""app""], [""app""], [""app""]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert(""apple"");
trie.search(""apple"");   // 返回 True
trie.search(""app"");     // 返回 False
trie.startsWith(""app""); // 返回 True
trie.insert(""app"");
trie.search(""app"");     // 返回 True
  提示：
1 <= word.length, prefix.length <= 2000
word 和 prefix 仅由小写英文字母组成
insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次",1183,,197989,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/design-add-and-search-words-data-structure/', 'https://leetcode.cn/problems/design-search-autocomplete-system/', 'https://leetcode.cn/problems/replace-words/', 'https://leetcode.cn/problems/implement-magic-dictionary/']",275477
评论 (1.2k),minimum-size-subarray-sum,中等,"给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
  示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：
输入：target = 4, nums = [1,4,4]
输出：1
示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
  提示：
1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 105
  进阶：
如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。",1169,,333812,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/minimum-window-substring/', 'https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/', 'https://leetcode.cn/problems/maximum-length-of-repeated-subarray/']",685338
评论 (553),course-schedule-ii,中等,"现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。
例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。
  示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2：
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
示例 3：
输入：numCourses = 1, prerequisites = []
输出：[0]
  提示：
1 <= numCourses <= 2000
0 <= prerequisites.length <= numCourses * (numCourses - 1)
prerequisites[i].length == 2
0 <= ai, bi < numCourses
ai != bi
所有[ai, bi] 互不相同",629,,127998,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']","['https://leetcode.cn/problems/course-schedule/', 'https://leetcode.cn/problems/alien-dictionary/', 'https://leetcode.cn/problems/minimum-height-trees/', 'https://leetcode.cn/problems/sequence-reconstruction/', 'https://leetcode.cn/problems/course-schedule-iii/']",230332
评论 (461),design-add-and-search-words-data-structure,中等,"请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。
实现词典类 WordDictionary ：
WordDictionary() 初始化词典对象
void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。
  示例：
输入：
[""WordDictionary"",""addWord"",""addWord"",""addWord"",""search"",""search"",""search"",""search""]
[[],[""bad""],[""dad""],[""mad""],[""pad""],[""bad""],["".ad""],[""b..""]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord(""bad"");
wordDictionary.addWord(""dad"");
wordDictionary.addWord(""mad"");
wordDictionary.search(""pad""); // 返回 False
wordDictionary.search(""bad""); // 返回 True
wordDictionary.search("".ad""); // 返回 True
wordDictionary.search(""b..""); // 返回 True
  提示：
1 <= word.length <= 25
addWord 中的 word 由小写英文字母组成
search 中的 word 由 '.' 或小写英文字母组成
最多调用 104 次 addWord 和 search",425,,59031,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/implement-trie-prefix-tree/', 'https://leetcode.cn/problems/prefix-and-suffix-search/']",116089
评论 (510),word-search-ii,困难,"给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。
单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。
  示例 1：
输入：board = [[""o"",""a"",""a"",""n""],[""e"",""t"",""a"",""e""],[""i"",""h"",""k"",""r""],[""i"",""f"",""l"",""v""]], words = [""oath"",""pea"",""eat"",""rain""]
输出：[""eat"",""oath""]
示例 2：
输入：board = [[""a"",""b""],[""c"",""d""]], words = [""abcb""]
输出：[]
  提示：
m == board.length
n == board[i].length
1 <= m, n <= 12
board[i][j] 是一个小写英文字母
1 <= words.length <= 3 * 104
1 <= words[i].length <= 10
words[i] 由小写英文字母组成
words 中的所有字符串互不相同",659,https://assets.leetcode.com/uploads/2020/11/07/search1.jpg,75399,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/word-search/', 'https://leetcode.cn/problems/unique-paths-iii/']",165256
评论 (1.3k),house-robber-ii,中等,"你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
  示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：
输入：nums = [1,2,3]
输出：3
  提示：
1 <= nums.length <= 100
0 <= nums[i] <= 1000",1050,,246203,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/house-robber/', 'https://leetcode.cn/problems/paint-house/', 'https://leetcode.cn/problems/paint-fence/', 'https://leetcode.cn/problems/house-robber-iii/', 'https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/', 'https://leetcode.cn/problems/coin-path/']",563267
评论 (421),shortest-palindrome,困难,"给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
  示例 1：
输入：s = ""aacecaaa""
输出：""aaacecaaa""
示例 2：
输入：s = ""abcd""
输出：""dcbabcd""
  提示：
0 <= s.length <= 5 * 104
s 仅由小写英文字母组成",449,,37003,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']","['https://leetcode.cn/problems/longest-palindromic-substring/', 'https://leetcode.cn/problems/implement-strstr/', 'https://leetcode.cn/problems/palindrome-pairs/']",96991
评论 (2.0k),kth-largest-element-in-an-array,中等,"给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
  示例 1:
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
  提示：
1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104",1681,,633143,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/quickselect/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/wiggle-sort-ii/', 'https://leetcode.cn/problems/top-k-frequent-elements/', 'https://leetcode.cn/problems/third-maximum-number/', 'https://leetcode.cn/problems/kth-largest-element-in-a-stream/', 'https://leetcode.cn/problems/k-closest-points-to-origin/']",978126
评论 (942),combination-sum-iii,中等,"找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
只使用数字1到9
每个数字 最多使用一次 
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
  示例 1:
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
示例 2:
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
示例 3:
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
  提示:
2 <= k <= 9
1 <= n <= 60",474,,160093,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/combination-sum/'],220012
评论 (1.9k),contains-duplicate,简单,"给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
  示例 1：
输入：nums = [1,2,3,1]
输出：true
示例 2：
输入：nums = [1,2,3,4]
输出：false
示例 3：
输入：nums = [1,1,1,3,3,4,3,2,4,2]
输出：true
  提示：
1 <= nums.length <= 105
-109 <= nums[i] <= 109",738,,573166,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/contains-duplicate-ii/', 'https://leetcode.cn/problems/contains-duplicate-iii/']",1030671
评论 (261),the-skyline-problem,困难,"城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。
每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：
lefti 是第 i 座建筑物左边缘的 x 坐标。
righti 是第 i 座建筑物右边缘的 x 坐标。
heighti 是第 i 座建筑物的高度。
你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。
天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],...] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。
注意：输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]
  示例 1：
输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
解释：
图 A 显示输入的所有建筑物的位置和高度，
图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。
示例 2：
输入：buildings = [[0,2,3],[2,5,3]]
输出：[[0,3],[5,0]]
  提示：
1 <= buildings.length <= 104
0 <= lefti < righti <= 231 - 1
1 <= heighti <= 231 - 1
buildings 按 lefti 非递减排序",669,https://assets.leetcode.com/uploads/2020/12/01/merged.jpg,39249,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/line-sweep/', 'https://leetcode.cn/tag/heap-priority-queue/']",['https://leetcode.cn/problems/falling-squares/'],71708
评论 (1.4k),contains-duplicate-ii,简单,"给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。
  示例 1：
输入：nums = [1,2,3,1], k = 3
输出：true
示例 2：
输入：nums = [1,0,1,1], k = 1
输出：true
示例 3：
输入：nums = [1,2,3,1,2,3], k = 2
输出：false
    提示：
1 <= nums.length <= 105
-109 <= nums[i] <= 109
0 <= k <= 105",481,,181776,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/contains-duplicate/', 'https://leetcode.cn/problems/contains-duplicate-iii/']",409343
评论 (581),contains-duplicate-iii,中等,"给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。
如果存在则返回 true，不存在返回 false。
  示例 1：
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
示例 2：
输入：nums = [1,0,1,1], k = 1, t = 2
输出：true
示例 3：
输入：nums = [1,5,9,1,5,9], k = 2, t = 3
输出：false
  提示：
0 <= nums.length <= 2 * 104
-231 <= nums[i] <= 231 - 1
0 <= k <= 104
0 <= t <= 231 - 1",606,,79081,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/bucket-sort/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/contains-duplicate/', 'https://leetcode.cn/problems/contains-duplicate-ii/']",273158
评论 (830),maximal-square,中等,"在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
  示例 1：
输入：matrix = [[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]
输出：4
示例 2：
输入：matrix = [[""0"",""1""],[""1"",""0""]]
输出：1
示例 3：
输入：matrix = [[""0""]]
输出：0
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] 为 '0' 或 '1'",1144,https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg,197154,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/maximal-rectangle/', 'https://leetcode.cn/problems/largest-plus-sign/']",403226
评论 (754),count-complete-tree-nodes,中等,"给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
  示例 1：
输入：root = [1,2,3,4,5,6]
输出：6
示例 2：
输入：root = []
输出：0
示例 3：
输入：root = [1]
输出：1
  提示：
树中节点的数目范围是[0, 5 * 104]
0 <= Node.val <= 5 * 104
题目数据保证输入的树是 完全二叉树
  进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？",693,https://assets.leetcode.com/uploads/2021/01/14/complete.jpg,184090,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/closest-binary-search-tree-value/'],230832
评论 (526),rectangle-area,中等,"给你 二维 平面上两个 由直线构成且边与坐标轴平行/垂直 的矩形，请你计算并返回两个矩形覆盖的总面积。
每个矩形由其 左下 顶点和 右上 顶点坐标表示：
第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。
第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。
  示例 1：
输入：ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
输出：45
示例 2：
输入：ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2
输出：16
  提示：
-104 <= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 <= 104",189,https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png,47903,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/rectangle-overlap/'],90377
评论 (722),basic-calculator,困难,"给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。
注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。
  示例 1：
输入：s = ""1 + 1""
输出：2
示例 2：
输入：s = "" 2-1 + 2 ""
输出：3
示例 3：
输入：s = ""(1+(4+5+2)-3)+(6+8)""
输出：23
  提示：
1 <= s.length <= 3 * 105
s 由数字、'+'、'-'、'('、')'、和 ' ' 组成
s 表示一个有效的表达式
'+' 不能用作一元运算(例如， ""+1"" 和 ""+(2 + 3)"" 无效)
'-' 可以用作一元运算(即 ""-1"" 和 ""-(2 + 3)"" 是有效的)
输入中不存在两个连续的操作符
每个数字和运行的计算将适合于一个有符号的 32位 整数",765,,89673,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/evaluate-reverse-polish-notation/', 'https://leetcode.cn/problems/basic-calculator-ii/', 'https://leetcode.cn/problems/different-ways-to-add-parentheses/', 'https://leetcode.cn/problems/expression-add-operators/', 'https://leetcode.cn/problems/basic-calculator-iii/']",213915
评论 (696),implement-stack-using-queues,简单,"请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
实现 MyStack 类：
void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
  注意：
你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
  示例：
输入：
[""MyStack"", ""push"", ""push"", ""top"", ""pop"", ""empty""]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
  提示：
1 <= x <= 9
最多调用100 次 push、pop、top 和 empty
每次调用 pop 和 top 都保证栈不为空
  进阶：你能否仅用一个队列来实现栈。",518,,194949,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/']",['https://leetcode.cn/problems/implement-queue-using-stacks/'],288568
评论 (1.6k),invert-binary-tree,简单,"给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
  示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
示例 2：
输入：root = [2,1,3]
输出：[2,3,1]
示例 3：
输入：root = []
输出：[]
  提示：
树中节点数目范围在 [0, 100] 内
-100 <= Node.val <= 100",1295,,460014,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],581218
评论 (623),basic-calculator-ii,中等,"给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。
整数除法仅保留整数部分。
你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。
注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。
  示例 1：
输入：s = ""3+2*2""
输出：7
示例 2：
输入：s = "" 3/2 ""
输出：1
示例 3：
输入：s = "" 3+5 / 2 ""
输出：5
  提示：
1 <= s.length <= 3 * 105
s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开
s 表示一个 有效表达式
表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
题目数据保证答案是一个 32-bit 整数",572,,113354,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/basic-calculator/', 'https://leetcode.cn/problems/expression-add-operators/', 'https://leetcode.cn/problems/basic-calculator-iii/']",257679
评论 (595),summary-ranges,简单,"给定一个  无重复元素 的 有序 整数数组 nums 。
返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。
列表中的每个区间范围 [a,b] 应该按如下格式输出：
""a->b"" ，如果 a != b
""a"" ，如果 a == b
  示例 1：
输入：nums = [0,1,2,4,5,7]
输出：[""0->2"",""4->5"",""7""]
解释：区间范围是：
[0,2] --> ""0->2""
[4,5] --> ""4->5""
[7,7] --> ""7""
示例 2：
输入：nums = [0,2,3,4,6,8,9]
输出：[""0"",""2->4"",""6"",""8->9""]
解释：区间范围是：
[0,0] --> ""0""
[2,4] --> ""2->4""
[6,6] --> ""6""
[8,9] --> ""8->9""
  提示：
0 <= nums.length <= 20
-231 <= nums[i] <= 231 - 1
nums 中的所有值都 互不相同
nums 按升序排列",214,,72059,['https://leetcode.cn/tag/array/'],"['https://leetcode.cn/problems/missing-ranges/', 'https://leetcode.cn/problems/data-stream-as-disjoint-intervals/']",127199
评论 (445),majority-element-ii,中等,"给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
  示例 1：
输入：nums = [3,2,3]
输出：[3]
示例 2：
输入：nums = [1]
输出：[1]
示例 3：
输入：nums = [1,2]
输出：[1,2]
  提示：
1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109
  进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。",589,,80418,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/majority-element/', 'https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/']",150144
评论 (893),kth-smallest-element-in-a-bst,中等,"给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
  示例 1：
输入：root = [3,1,4,null,2], k = 1
输出：1
示例 2：
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
    提示：
树中的节点数为 n 。
1 <= k <= n <= 104
0 <= Node.val <= 104
  进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",624,https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg,210161,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/binary-tree-inorder-traversal/', 'https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/']",278705
评论 (1.4k),power-of-two,简单,"给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。
如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。
  示例 1：
输入：n = 1
输出：true
解释：20 = 1
示例 2：
输入：n = 16
输出：true
解释：24 = 16
示例 3：
输入：n = 3
输出：false
示例 4：
输入：n = 4
输出：true
示例 5：
输入：n = 5
输出：false
  提示：
-231 <= n <= 231 - 1
  进阶：你能够不使用循环/递归解决此问题吗？",499,,227287,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']","['https://leetcode.cn/problems/number-of-1-bits/', 'https://leetcode.cn/problems/power-of-three/', 'https://leetcode.cn/problems/power-of-four/']",450547
评论 (862),implement-queue-using-stacks,简单,"请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：
你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
  示例 1：
输入：
[""MyQueue"", ""push"", ""push"", ""peek"", ""pop"", ""empty""]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
  提示：
1 <= x <= 9
最多调用 100 次 push、pop、peek 和 empty
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）
  进阶：
你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。",658,,241875,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/']",['https://leetcode.cn/problems/implement-stack-using-queues/'],351657
评论 (398),number-of-digit-one,困难,"给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。
  示例 1：
输入：n = 13
输出：6
示例 2：
输入：n = 0
输出：0
  提示：
0 <= n <= 109",421,,42135,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/factorial-trailing-zeroes/', 'https://leetcode.cn/problems/digit-count-in-range/']",87333
评论 (1.9k),palindrome-linked-list,简单,"给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
  示例 1：
输入：head = [1,2,2,1]
输出：true
示例 2：
输入：head = [1,2]
输出：false
  提示：
链表中节点数目在范围[1, 105] 内
0 <= Node.val <= 9
  进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？",1397,https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg,439815,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']","['https://leetcode.cn/problems/palindrome-number/', 'https://leetcode.cn/problems/valid-palindrome/', 'https://leetcode.cn/problems/reverse-linked-list/']",851674
评论 (877),lowest-common-ancestor-of-a-binary-search-tree,简单,"给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
  示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
  说明:
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。",840,,241472,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/', 'https://leetcode.cn/problems/smallest-common-region/']",358633
评论 (1.1k),lowest-common-ancestor-of-a-binary-tree,中等,"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
  示例 1：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：
输入：root = [1,2], p = 1, q = 2
输出：1
  提示：
树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。",1756,https://assets.leetcode.com/uploads/2018/12/14/binarytree.png,382588,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/', 'https://leetcode.cn/problems/smallest-common-region/']",554311
评论 (1.5k),delete-node-in-a-linked-list,简单,"请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。
题目数据保证需要删除的节点 不是末尾节点 。
  示例 1：
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9
示例 2：
输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9
  提示：
链表中节点的数目范围是 [2, 1000]
-1000 <= Node.val <= 1000
链表中每个节点的值都是 唯一 的
需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点",1149,https://assets.leetcode.com/uploads/2020/09/01/node1.jpg,291710,['https://leetcode.cn/tag/linked-list/'],['https://leetcode.cn/problems/remove-linked-list-elements/'],339693
评论 (750),product-of-array-except-self,中等,"给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
请不要使用除法，且在 O(n) 时间复杂度内完成此题。
  示例 1:
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
示例 2:
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
  提示：
2 <= nums.length <= 105
-30 <= nums[i] <= 30
保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内
  进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）",1160,,192569,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']","['https://leetcode.cn/problems/trapping-rain-water/', 'https://leetcode.cn/problems/maximum-product-subarray/', 'https://leetcode.cn/problems/paint-house-ii/']",261907
评论 (1.1k),sliding-window-maximum,困难,"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回 滑动窗口中的最大值 。
  示例 1：
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：
输入：nums = [1], k = 1
输出：[1]
  提示：
1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length",1638,,295961,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/monotonic-queue/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/minimum-window-substring/', 'https://leetcode.cn/problems/min-stack/', 'https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/', 'https://leetcode.cn/problems/paint-house-ii/']",592658
评论 (775),search-a-2d-matrix-ii,中等,"编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：
每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
  示例 1：
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
示例 2：
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
  提示：
m == matrix.length
n == matrix[i].length
1 <= n, m <= 300
-109 <= matrix[i][j] <= 109
每行的所有元素从左到右升序排列
每列的所有元素从上到下升序排列
-109 <= target <= 109",1030,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg,274592,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/search-a-2d-matrix/'],536108
评论 (243),different-ways-to-add-parentheses,中等,"给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。
  示例 1：
输入：expression = ""2-1-1""
输出：[0,2]
解释：
((2-1)-1) = 0 
(2-(1-1)) = 2
示例 2：
输入：expression = ""2*3-4*5""
输出：[-34,-14,-10,-10,10]
解释：
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
  提示：
1 <= expression.length <= 20
expression 由数字和算符 '+'、'-' 和 '*' 组成。
输入表达式中的所有整数值在范围 [0, 99] ",569,,43733,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/unique-binary-search-trees-ii/', 'https://leetcode.cn/problems/basic-calculator/', 'https://leetcode.cn/problems/expression-add-operators/']",59429
评论 (1.4k),valid-anagram,简单,"给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
  示例 1:
输入: s = ""anagram"", t = ""nagaram""
输出: true
示例 2:
输入: s = ""rat"", t = ""car""
输出: false
  提示:
1 <= s.length, t.length <= 5 * 104
s 和 t 仅包含小写字母
  进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？",589,,423315,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/group-anagrams/', 'https://leetcode.cn/problems/palindrome-permutation/', 'https://leetcode.cn/problems/find-all-anagrams-in-a-string/']",647789
评论 (94),shortest-word-distance,Unknown,,-1,,-1,[],[],-1
评论 (42),shortest-word-distance-ii,Unknown,,-1,,-1,[],[],-1
评论 (36),shortest-word-distance-iii,Unknown,,-1,,-1,[],[],-1
评论 (98),strobogrammatic-number,Unknown,,-1,,-1,[],[],-1
评论 (71),strobogrammatic-number-ii,Unknown,,-1,,-1,[],[],-1
评论 (26),strobogrammatic-number-iii,Unknown,,-1,,-1,[],[],-1
评论 (72),group-shifted-strings,Unknown,,-1,,-1,[],[],-1
评论 (80),count-univalue-subtrees,Unknown,,-1,,-1,[],[],-1
评论 (320),remove-invalid-parentheses,困难,"给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。
返回所有可能的结果。答案可以按 任意顺序 返回。
  示例 1：
输入：s = ""()())()""
输出：[""(())()"",""()()()""]
示例 2：
输入：s = ""(a)())()""
输出：[""(a())()"",""(a)()()""]
示例 3：
输入：s = "")(""
输出：[""""]
  提示：
1 <= s.length <= 25
s 由小写英文字母以及括号 '(' 和 ')' 组成
s 中至多含 20 个括号",726,,69572,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/valid-parentheses/'],126376
评论 (31),smallest-rectangle-enclosing-black-pixels,Unknown,,-1,,-1,[],[],-1
评论 (803),range-sum-query-immutable,简单,"给定一个整数数组  nums，处理以下类型的多个查询:
计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left <= right
实现 NumArray 类：
NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )
  示例 1：
输入：
[""NumArray"", ""sumRange"", ""sumRange"", ""sumRange""]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
  提示：
1 <= nums.length <= 104
-105 <= nums[i] <= 105
0 <= i <= j < nums.length
最多调用 104 次 sumRange 方法",460,,166992,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']","['https://leetcode.cn/problems/range-sum-query-2d-immutable/', 'https://leetcode.cn/problems/range-sum-query-mutable/', 'https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/']",223039
评论 (632),range-sum-query-2d-immutable,中等,"给定一个二维矩阵 matrix，以下类型的多个请求：
计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。
实现 NumMatrix 类：
NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。
  示例 1：
输入: 
[""NumMatrix"",""sumRegion"",""sumRegion"",""sumRegion""]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
输出: 
[null, 8, 11, 12]

解释:
NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
-105 <= matrix[i][j] <= 105
0 <= row1 <= row2 < m
0 <= col1 <= col2 < n
最多调用 104 次 sumRegion 方法",398,,92404,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/prefix-sum/']","['https://leetcode.cn/problems/range-sum-query-immutable/', 'https://leetcode.cn/problems/range-sum-query-2d-mutable/']",156895
评论 (65),number-of-islands-ii,Unknown,,-1,,-1,[],[],-1
评论 (599),additive-number,中等,"累加数 是一个字符串，组成它的数字可以形成累加序列。
一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。
给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。
说明：累加序列里的数，除数字 0 之外，不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。
  示例 1：
输入：""112358""
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
示例 2：
输入：""199100199""
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
  提示：
1 <= num.length <= 35
num 仅由数字（0 - 9）组成
  进阶：你计划如何处理由过大的整数输入导致的溢出?",359,,42124,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/split-array-into-fibonacci-sequence/'],110142
评论 (418),range-sum-query-mutable,中等,"给你一个数组 nums ，请你完成两类查询。
其中一类查询要求 更新 数组 nums 下标对应的值
另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left <= right
实现 NumArray 类：
NumArray(int[] nums) 用整数数组 nums 初始化对象
void update(int index, int val) 将 nums[index] 的值 更新 为 val
int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]）
  示例 1：
输入：
[""NumArray"", ""sumRange"", ""update"", ""sumRange""]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
输出：
[null, 9, null, 8]

解释：
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1,2,5]
numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
  提示：
1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
0 <= index < nums.length
-100 <= val <= 100
0 <= left <= right < nums.length
调用 update 和 sumRange 方法次数不大于 3 * 104 ",503,,52294,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/']","['https://leetcode.cn/problems/range-sum-query-immutable/', 'https://leetcode.cn/problems/range-sum-query-2d-mutable/']",103093
评论 (34),range-sum-query-2d-mutable,Unknown,,-1,,-1,[],[],-1
评论 (908),best-time-to-buy-and-sell-stock-with-cooldown,中等,"给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
  示例 1:
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
示例 2:
输入: prices = [1]
输出: 0
  提示：
1 <= prices.length <= 5000
0 <= prices[i] <= 1000",1215,,176260,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/', 'https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/']",279968
评论 (351),minimum-height-trees,中等,"树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。
给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。
可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。
请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。
树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。
  示例 1：
输入：n = 4, edges = [[1,0],[1,2],[1,3]]
输出：[1]
解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。
示例 2：
输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
输出：[3,4]
  提示：
1 <= n <= 2 * 104
edges.length == n - 1
0 <= ai, bi < n
ai != bi
所有 (ai, bi) 互不相同
给定的输入 保证 是一棵树，并且 不会有重复的边",648,https://assets.leetcode.com/uploads/2020/09/01/e1.jpg,48591,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']","['https://leetcode.cn/problems/course-schedule/', 'https://leetcode.cn/problems/course-schedule-ii/']",112468
评论 (47),sparse-matrix-multiplication,Unknown,,-1,,-1,[],[],-1
评论 (344),burst-balloons,困难,"有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。
求所能获得硬币的最大数量。
  示例 1：
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
示例 2：
输入：nums = [1,5]
输出：10
  提示：
n == nums.length
1 <= n <= 300
0 <= nums[i] <= 100",998,,75280,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/minimum-cost-to-merge-stones/'],108681
评论 (398),super-ugly-number,中等,"超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。
  示例 1：
输入：n = 12, primes = [2,7,13,19]
输出：32 
解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
示例 2：
输入：n = 1, primes = [2,3,5]
输出：1
解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
  提示：
1 <= n <= 106
1 <= primes.length <= 100
2 <= primes[i] <= 1000
题目数据 保证 primes[i] 是一个质数
primes 中的所有值都 互不相同 ，且按 递增顺序 排列",314,,48468,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/ugly-number-ii/'],81788
评论 (56),binary-tree-vertical-order-traversal,Unknown,,-1,,-1,[],[],-1
评论 (484),count-of-smaller-numbers-after-self,困难,"给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
  示例 1：
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
示例 2：
输入：nums = [-1]
输出：[0]
示例 3：
输入：nums = [-1,-1]
输出：[0,0]
  提示：
1 <= nums.length <= 105
-104 <= nums[i] <= 104",815,,62136,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/merge-sort/']","['https://leetcode.cn/problems/count-of-range-sum/', 'https://leetcode.cn/problems/queue-reconstruction-by-height/', 'https://leetcode.cn/problems/reverse-pairs/']",146646
评论 (410),remove-duplicate-letters,中等,"给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。
  示例 1：
输入：s = ""bcabc""
输出：""abc""
示例 2：
输入：s = ""cbacdcbc""
输出：""acdb""
  提示：
1 <= s.length <= 104
s 由小写英文字母组成
  注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同",741,,89067,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/monotonic-stack/']",[],185936
评论 (35),shortest-distance-from-all-buildings,Unknown,,-1,,-1,[],[],-1
评论 (415),maximum-product-of-word-lengths,中等,"给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。
  示例 1：
输入：words = [""abcw"",""baz"",""foo"",""bar"",""xtfn"",""abcdef""]
输出：16 
解释：这两个单词为 ""abcw"", ""xtfn""。
示例 2：
输入：words = [""a"",""ab"",""abc"",""d"",""cd"",""bcd"",""abcd""]
输出：4 
解释：这两个单词为 ""ab"", ""cd""。
示例 3：
输入：words = [""a"",""aa"",""aaa"",""aaaa""]
输出：0 
解释：不存在这样的两个单词。
  提示：
2 <= words.length <= 1000
1 <= words[i].length <= 1000
words[i] 仅包含小写字母",355,,56697,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],76811
评论 (431),bulb-switcher,中等,"初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
找出并返回 n 轮后有多少个亮着的灯泡。
  示例 1：
输入：n = 3
输出：1 
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。
示例 2：
输入：n = 0
输出：0
示例 3：
输入：n = 1
输出：1
  提示：
0 <= n <= 109",317,,52519,"['https://leetcode.cn/tag/brainteaser/', 'https://leetcode.cn/tag/math/']","['https://leetcode.cn/problems/bulb-switcher-ii/', 'https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/']",91578
评论 (28),generalized-abbreviation,Unknown,,-1,,-1,[],[],-1
评论 (313),create-maximum-number,困难,"给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。
求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。
说明: 请尽可能地优化你算法的时间和空间复杂度。
示例 1:
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
示例 2:
输入:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
输出:
[6, 7, 6, 0, 4]
示例 3:
输入:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
输出:
[9, 8, 9]",470,,30615,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/monotonic-stack/']","['https://leetcode.cn/problems/remove-k-digits/', 'https://leetcode.cn/problems/maximum-swap/']",72562
评论 (1.0k),coin-change,中等,"给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
  示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：
输入：coins = [2], amount = 3
输出：-1
示例 3：
输入：coins = [1], amount = 0
输出：0
  提示：
1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104",1947,,444404,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/minimum-cost-for-tickets/'],974267
评论 (93),number-of-connected-components-in-an-undirected-graph,Unknown,,-1,,-1,[],[],-1
评论 (177),wiggle-sort-ii,中等,"给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。
你可以假设所有输入数组都可以得到满足题目要求的结果。
  示例 1：
输入：nums = [1,5,1,1,6,4]
输出：[1,6,1,5,1,4]
解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。
示例 2：
输入：nums = [1,3,2,2,3,1]
输出：[2,3,1,3,1,2]
  提示：
1 <= nums.length <= 5 * 104
0 <= nums[i] <= 5000
题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果
  进阶：你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？",350,,33672,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/quickselect/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/sort-colors/', 'https://leetcode.cn/problems/kth-largest-element-in-an-array/', 'https://leetcode.cn/problems/wiggle-sort/']",87212
评论 (69),maximum-size-subarray-sum-equals-k,Unknown,,-1,,-1,[],[],-1
评论 (654),power-of-three,简单,"给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x
  示例 1：
输入：n = 27
输出：true
示例 2：
输入：n = 0
输出：false
示例 3：
输入：n = 9
输出：true
示例 4：
输入：n = 45
输出：false
  提示：
-231 <= n <= 231 - 1
  进阶：你能不使用循环或者递归来完成本题吗？",255,,166328,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']","['https://leetcode.cn/problems/power-of-two/', 'https://leetcode.cn/problems/power-of-four/']",328211
评论 (342),count-of-range-sum,困难,"给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。
区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。
  示例 1：
输入：nums = [-2,5,-1], lower = -2, upper = 2
输出：3
解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
示例 2：
输入：nums = [0], lower = 0, upper = 0
输出：1
  提示：
1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
-105 <= lower <= upper <= 105
题目数据保证答案是一个 32 位 的整数",439,,30080,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/merge-sort/']","['https://leetcode.cn/problems/count-of-smaller-numbers-after-self/', 'https://leetcode.cn/problems/reverse-pairs/']",72557
评论 (832),odd-even-linked-list,中等,"给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。
第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。
请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。
你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。
  示例 1:
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
示例 2:
输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
  提示:
n ==  链表中的节点数
0 <= n <= 104
-106 <= Node.val <= 106",584,,161145,['https://leetcode.cn/tag/linked-list/'],['https://leetcode.cn/problems/split-linked-list-in-parts/'],246556
评论 (464),longest-increasing-path-in-a-matrix,困难,"给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。
  示例 1：
输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
输出：4 
解释：最长递增路径为 [1, 2, 6, 9]。
示例 2：
输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]
输出：4 
解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
示例 3：
输入：matrix = [[1]]
输出：1
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
0 <= matrix[i][j] <= 231 - 1",648,https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg,74087,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/dynamic-programming/']",[],147354
评论 (219),patching-array,困难,"给定一个已排序的正整数数组 nums ，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。
请返回 满足上述要求的最少需要补充的数字个数 。
  示例 1:
输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
示例 2:
输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2,4]。
示例 3:
输入: nums = [1,2,2], n = 5
输出: 0
  提示：
1 <= nums.length <= 1000
1 <= nums[i] <= 104
nums 按 升序排列
1 <= n <= 231 - 1",315,,20574,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],38797
评论 (459),verify-preorder-serialization-of-a-binary-tree,中等,"序列化二叉树的一种方法是使用 前序遍历 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。
例如，上面的二叉树可以被序列化为字符串 ""9,3,4,#,#,1,#,#,2,#,6,#,#""，其中 # 代表一个空节点。
给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。
保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。
你可以认为输入格式总是有效的
例如它永远不会包含两个连续的逗号，比如 ""1,,3"" 。
注意：不允许重建树。
  示例 1:
输入: preorder = ""9,3,4,#,#,1,#,#,2,#,6,#,#""
输出: true
示例 2:
输入: preorder = ""1,#""
输出: false
示例 3:
输入: preorder = ""9,#,#,1""
输出: false
  提示:
1 <= preorder.length <= 104
preorder 由以逗号 “，” 分隔的 [0,100] 范围内的整数和 “#” 组成",379,,51877,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-tree/']",[],108074
评论 (431),reconstruct-itinerary,困难,"给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。
所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。
例如，行程 [""JFK"", ""LGA""] 与 [""JFK"", ""LGB""] 相比就更小，排序更靠前。
假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。
  示例 1：
输入：tickets = [[""MUC"",""LHR""],[""JFK"",""MUC""],[""SFO"",""SJC""],[""LHR"",""SFO""]]
输出：[""JFK"",""MUC"",""LHR"",""SFO"",""SJC""]
示例 2：
输入：tickets = [[""JFK"",""SFO""],[""JFK"",""ATL""],[""SFO"",""ATL""],[""ATL"",""JFK""],[""ATL"",""SFO""]]
输出：[""JFK"",""ATL"",""JFK"",""SFO"",""ATL"",""SFO""]
解释：另一种有效的行程是 [""JFK"",""SFO"",""ATL"",""JFK"",""ATL"",""SFO""] ，但是它字典排序更大更靠后。
  提示：
1 <= tickets.length <= 300
tickets[i].length == 2
fromi.length == 3
toi.length == 3
fromi 和 toi 由大写英文字母组成
fromi != toi",567,https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg,56449,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/eulerian-circuit/']",[],121736
评论 (49),largest-bst-subtree,Unknown,,-1,,-1,[],[],-1
评论 (489),increasing-triplet-subsequence,中等,"给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。
如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。
  示例 1：
输入：nums = [1,2,3,4,5]
输出：true
解释：任何 i < j < k 的三元组都满足题意
示例 2：
输入：nums = [5,4,3,2,1]
输出：false
解释：不存在满足题意的三元组
示例 3：
输入：nums = [2,1,5,0,4,6]
输出：true
解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 < nums[4] == 4 < nums[5] == 6
  提示：
1 <= nums.length <= 5 * 105
-231 <= nums[i] <= 231 - 1
  进阶：你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？",578,,95242,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",['https://leetcode.cn/problems/longest-increasing-subsequence/'],220046
评论 (188),self-crossing,困难,"给你一个整数数组 distance 。
从 X-Y 平面上的点 (0,0) 开始，先向北移动 distance[0] 米，然后向西移动 distance[1] 米，向南移动 distance[2] 米，向东移动 distance[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。
判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。
  示例 1：
输入：distance = [2,1,1,2]
输出：true
示例 2：
输入：distance = [1,2,3,4]
输出：false
示例 3：
输入：distance = [1,1,1,1]
输出：true
  提示：
1 <= distance.length <= 105
1 <= distance[i] <= 105",150,https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg,17152,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],40063
评论 (332),palindrome-pairs,困难,"给定一组 互不相同 的单词， 找出所有 不同 的索引对 (i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。
  示例 1：
输入：words = [""abcd"",""dcba"",""lls"",""s"",""sssll""]
输出：[[0,1],[1,0],[3,2],[2,4]] 
解释：可拼接成的回文串为 [""dcbaabcd"",""abcddcba"",""slls"",""llssssll""]
示例 2：
输入：words = [""bat"",""tab"",""cat""]
输出：[[0,1],[1,0]] 
解释：可拼接成的回文串为 [""battab"",""tabbat""]
示例 3：
输入：words = [""a"",""""]
输出：[[0,1],[1,0]]
  提示：
1 <= words.length <= 5000
0 <= words[i].length <= 300
words[i] 由小写英文字母组成",306,,24304,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/longest-palindromic-substring/', 'https://leetcode.cn/problems/shortest-palindrome/']",61762
评论 (1.1k),house-robber-iii,中等,"小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。
  示例 1:
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
示例 2:
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
  提示：
树的节点数在 [1, 104] 范围内
0 <= Node.val <= 104",1314,,186968,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/house-robber/', 'https://leetcode.cn/problems/house-robber-ii/']",308154
评论 (1.1k),counting-bits,简单,"给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。
  示例 1：
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
示例 2：
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
  提示：
0 <= n <= 105
  进阶：
很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？
你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）",1006,,216494,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/number-of-1-bits/'],275363
评论 (63),nested-list-weight-sum,Unknown,,-1,,-1,[],[],-1
评论 (104),longest-substring-with-at-most-k-distinct-characters,Unknown,,-1,,-1,[],[],-1
评论 (377),flatten-nested-list-iterator,中等,"给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
实现扁平迭代器类 NestedIterator ：
NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。
int next() 返回嵌套列表的下一个整数。
boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。
你的代码将会用下述伪代码检测：
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。
  示例 1：
输入：nestedList = [[1,1],2,[1,1]]
输出：[1,1,2,1,1]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
示例 2：
输入：nestedList = [1,[4,[6]]]
输出：[1,4,6]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。
  提示：
1 <= nestedList.length <= 500
嵌套列表中的整数值在范围 [-106, 106] 内",439,,61692,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/iterator/']","['https://leetcode.cn/problems/flatten-2d-vector/', 'https://leetcode.cn/problems/zigzag-iterator/', 'https://leetcode.cn/problems/mini-parser/', 'https://leetcode.cn/problems/array-nesting/']",84916
评论 (738),power-of-four,简单,"给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。
整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x
  示例 1：
输入：n = 16
输出：true
示例 2：
输入：n = 5
输出：false
示例 3：
输入：n = 1
输出：true
  提示：
-231 <= n <= 231 - 1
  进阶：你能不使用循环或者递归来完成本题吗？",301,,105121,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']","['https://leetcode.cn/problems/power-of-two/', 'https://leetcode.cn/problems/power-of-three/']",201659
评论 (1.1k),integer-break,中等,"给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积 。
  示例 1:
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
  提示:
2 <= n <= 58",827,,168084,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],272238
评论 (1.8k),reverse-string,简单,"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
  示例 1：
输入：s = [""h"",""e"",""l"",""l"",""o""]
输出：[""o"",""l"",""l"",""e"",""h""]
示例 2：
输入：s = [""H"",""a"",""n"",""n"",""a"",""h""]
输出：[""h"",""a"",""n"",""n"",""a"",""H""]
  提示：
1 <= s.length <= 105
s[i] 都是 ASCII 码表中的可打印字符",594,,539471,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/reverse-vowels-of-a-string/', 'https://leetcode.cn/problems/reverse-string-ii/']",686376
评论 (891),reverse-vowels-of-a-string,简单,"给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。
元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。
  示例 1：
输入：s = ""hello""
输出：""holle""
示例 2：
输入：s = ""leetcode""
输出：""leotcede""
  提示：
1 <= s.length <= 3 * 105
s 由 可打印的 ASCII 字符组成",252,,128034,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/reverse-string/', 'https://leetcode.cn/problems/remove-vowels-from-a-string/']",236185
评论 (82),moving-average-from-data-stream,Unknown,,-1,,-1,[],[],-1
评论 (1.3k),top-k-frequent-elements,中等,"给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
  示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:
输入: nums = [1], k = 1
输出: [1]
  提示：
1 <= nums.length <= 105
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的
  进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。",1192,,295343,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/bucket-sort/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/quickselect/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/word-frequency/', 'https://leetcode.cn/problems/kth-largest-element-in-an-array/', 'https://leetcode.cn/problems/sort-characters-by-frequency/', 'https://leetcode.cn/problems/split-array-into-consecutive-subsequences/', 'https://leetcode.cn/problems/top-k-frequent-words/', 'https://leetcode.cn/problems/k-closest-points-to-origin/']",468914
评论 (52),design-tic-tac-toe,Unknown,,-1,,-1,[],[],-1
评论 (1.4k),intersection-of-two-arrays,简单,"给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。
  示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
  提示：
1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000",547,,301258,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/intersection-of-two-arrays-ii/', 'https://leetcode.cn/problems/intersection-of-three-sorted-arrays/']",406196
评论 (1.2k),intersection-of-two-arrays-ii,简单,"给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
  示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
  提示：
1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000
  进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？",758,,355967,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/intersection-of-two-arrays/', 'https://leetcode.cn/problems/find-common-characters/']",633736
评论 (64),android-unlock-patterns,Unknown,,-1,,-1,[],[],-1
评论 (314),data-stream-as-disjoint-intervals,困难," 给你一个由非负整数 a1, a2, ..., an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。
实现 SummaryRanges 类：
SummaryRanges() 使用一个空数据流初始化对象。
void addNum(int val) 向数据流中加入整数 val 。
int[][] getIntervals() 以不相交区间 [starti, endi] 的列表形式返回对数据流中整数的总结。
  示例：
输入：
[""SummaryRanges"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals"", ""addNum"", ""getIntervals""]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
输出：
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]

解释：
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // 返回 [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // 返回 [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // 返回 [[1, 3], [6, 7]]
  提示：
0 <= val <= 104
最多调用 addNum 和 getIntervals 方法 3 * 104 次
  进阶：如果存在大量合并，并且与数据流的大小相比，不相交区间的数量很小，该怎么办?",163,,22742,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/ordered-set/']","['https://leetcode.cn/problems/summary-ranges/', 'https://leetcode.cn/problems/find-right-interval/', 'https://leetcode.cn/problems/range-module/']",33643
评论 (41),design-snake-game,Unknown,,-1,,-1,[],[],-1
评论 (560),russian-doll-envelopes,困难,"给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。
当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
注意：不允许旋转信封。
  示例 1：
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
示例 2：
输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1
  提示：
1 <= envelopes.length <= 105
envelopes[i].length == 2
1 <= wi, hi <= 105",727,,85037,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/longest-increasing-subsequence/'],201854
评论 (480),design-twitter,中等,"设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 10 条推文。
实现 Twitter 类：
Twitter() 初始化简易版推特对象
void postTweet(int userId, int tweetId) 根据给定的 tweetId 和 userId 创建一条新推文。每次调用此函数都会使用一个不同的 tweetId 。
List<Integer> getNewsFeed(int userId) 检索当前用户新闻推送中最近  10 条推文的 ID 。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须 按照时间顺序由最近到最远排序 。
void follow(int followerId, int followeeId) ID 为 followerId 的用户开始关注 ID 为 followeeId 的用户。
void unfollow(int followerId, int followeeId) ID 为 followerId 的用户不再关注 ID 为 followeeId 的用户。
  示例：
输入
[""Twitter"", ""postTweet"", ""getNewsFeed"", ""follow"", ""postTweet"", ""getNewsFeed"", ""unfollow"", ""getNewsFeed""]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
输出
[null, null, [5], null, null, [6, 5], null, [5]]

解释
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5)
twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文
twitter.follow(1, 2);    // 用户 1 关注了用户 2
twitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6)
twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -> [6, 5] 。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的
twitter.unfollow(1, 2);  // 用户 1 取消关注了用户 2
twitter.getNewsFeed(1);  // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2
  提示：
1 <= userId, followerId, followeeId <= 500
0 <= tweetId <= 104
所有推特的 ID 都互不相同
postTweet、getNewsFeed、follow 和 unfollow 方法最多调用 3 * 104 次",296,,33994,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],82988
评论 (22),line-reflection,Unknown,,-1,,-1,[],[],-1
评论 (662),count-numbers-with-unique-digits,中等,"给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 <= x < 10n 。
  示例 1：
输入：n = 2
输出：91
解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x < 100 范围内的所有数字。 
示例 2：
输入：n = 0
输出：1
  提示：
0 <= n <= 8",287,,60180,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/']",[],100525
评论 (48),rearrange-string-k-distance-apart,Unknown,,-1,,-1,[],[],-1
评论 (50),logger-rate-limiter,Unknown,,-1,,-1,[],[],-1
评论 (39),sort-transformed-array,Unknown,,-1,,-1,[],[],-1
评论 (61),bomb-enemy,Unknown,,-1,,-1,[],[],-1
评论 (49),design-hit-counter,Unknown,,-1,,-1,[],[],-1
评论 (293),max-sum-of-rectangle-no-larger-than-k,困难,"给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。
题目数据保证总会存在一个数值和不超过 k 的矩形区域。
  示例 1：
输入：matrix = [[1,0,1],[0,-2,3]], k = 2
输出：2
解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
示例 2：
输入：matrix = [[2,2,-1]], k = 3
输出：3
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-100 <= matrix[i][j] <= 100
-105 <= k <= 105
  进阶：如果行数远大于列数，该如何设计解决方案？",402,https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg,36636,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/ordered-set/']",[],75402
评论 (30),nested-list-weight-sum-ii,Unknown,,-1,,-1,[],[],-1
评论 (495),water-and-jug-problem,中等,"有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。
如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。
你可以：
装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空
  示例 1: 
输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4
输出: true
解释：来自著名的 ""Die Hard""
示例 2:
输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5
输出: false
示例 3:
输入: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3
输出: true
  提示:
1 <= jug1Capacity, jug2Capacity, targetCapacity <= 106",369,,39868,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/math/']",[],104567
评论 (82),find-leaves-of-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (908),valid-perfect-square,简单,"给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。
进阶：不要 使用任何内置的库函数，如  sqrt 。
  示例 1：
输入：num = 16
输出：true
示例 2：
输入：num = 14
输出：false
  提示：
1 <= num <= 2^31 - 1",392,,157867,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']","['https://leetcode.cn/problems/sqrtx/', 'https://leetcode.cn/problems/sum-of-square-numbers/']",351954
评论 (366),largest-divisible-subset,中等,"给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：
answer[i] % answer[j] == 0 ，或
answer[j] % answer[i] == 0
如果存在多个有效解子集，返回其中任何一个均可。
  示例 1：
输入：nums = [1,2,3]
输出：[1,2]
解释：[1,3] 也会被视为正确答案。
示例 2：
输入：nums = [1,2,4,8]
输出：[1,2,4,8]
  提示：
1 <= nums.length <= 1000
1 <= nums[i] <= 2 * 109
nums 中的所有整数 互不相同",445,,48293,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],105095
评论 (78),plus-one-linked-list,Unknown,,-1,,-1,[],[],-1
评论 (51),range-addition,Unknown,,-1,,-1,[],[],-1
评论 (597),sum-of-two-integers,中等,"给你两个整数 a 和 b ，不使用 运算符 + 和 - ，计算并返回两整数之和。
  示例 1：
输入：a = 1, b = 2
输出：3
示例 2：
输入：a = 2, b = 3
输出：5
  提示：
-1000 <= a, b <= 1000",611,,93220,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/add-two-numbers/'],151657
评论 (326),super-pow,中等,"你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。
  示例 1：
输入：a = 2, b = [3]
输出：8
示例 2：
输入：a = 2, b = [1,0]
输出：1024
示例 3：
输入：a = 1, b = [4,3,3,8,5,2]
输出：1
示例 4：
输入：a = 2147483647, b = [2,0,0]
输出：1198
  提示：
1 <= a <= 231 - 1
1 <= b.length <= 2000
0 <= b[i] <= 9
b 不含前导 0",271,,39307,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/divide-and-conquer/']",['https://leetcode.cn/problems/powx-n/'],68613
评论 (408),find-k-pairs-with-smallest-sums,中等,"给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。
定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。
请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。
  示例 1:
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
示例 2:
输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
示例 3:
输入: nums1 = [1,2], nums2 = [3], k = 3 
输出: [1,3],[2,3]
解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]
  提示:
1 <= nums1.length, nums2.length <= 105
-109 <= nums1[i], nums2[i] <= 109
nums1 和 nums2 均为升序排列
1 <= k <= 1000",400,,48881,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/', 'https://leetcode.cn/problems/find-k-th-smallest-pair-distance/']",117554
评论 (648),guess-number-higher-or-lower,简单,"猜数字游戏的规则如下：
每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：
-1：我选出的数字比你猜的数字小 pick < num
1：我选出的数字比你猜的数字大 pick > num
0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
返回我选出的数字。
  示例 1：
输入：n = 10, pick = 6
输出：6
示例 2：
输入：n = 1, pick = 1
输出：1
示例 3：
输入：n = 2, pick = 1
输出：1
示例 4：
输入：n = 2, pick = 2
输出：2
  提示：
1 <= n <= 231 - 1
1 <= pick <= n",219,,114179,"['https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/interactive/']","['https://leetcode.cn/problems/first-bad-version/', 'https://leetcode.cn/problems/guess-number-higher-or-lower-ii/', 'https://leetcode.cn/problems/find-k-closest-elements/']",219135
评论 (394),guess-number-higher-or-lower-ii,中等,"我们正在玩一个猜数游戏，游戏规则如下：
我从 1 到 n 之间选择一个数字。
你来猜我选了哪个数字。
如果你猜到正确的数字，就会 赢得游戏 。
如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。
  示例 1：
输入：n = 10
输出：16
解释：制胜策略如下：
- 数字范围是 [1,10] 。你先猜测数字为 7 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
    - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
        - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
        - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
    - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
        - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
            - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
            - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
        - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
            - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
示例 2：
输入：n = 1
输出：0
解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
示例 3：
输入：n = 2
输出：1
解释：有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
    - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1 。
  提示：
1 <= n <= 200",484,https://assets.leetcode.com/uploads/2020/09/10/graph.png,37997,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']","['https://leetcode.cn/problems/flip-game-ii/', 'https://leetcode.cn/problems/guess-number-higher-or-lower/', 'https://leetcode.cn/problems/can-i-win/', 'https://leetcode.cn/problems/find-k-closest-elements/']",62464
评论 (734),wiggle-subsequence,中等,"如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
  示例 1：
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
示例 2：
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
示例 3：
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
  提示：
1 <= nums.length <= 1000
0 <= nums[i] <= 1000
  进阶：你能否用 O(n) 时间复杂度完成此题?",685,,117845,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],250396
评论 (636),combination-sum-iv,中等,"给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。
  示例 1：
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
示例 2：
输入：nums = [9], target = 3
输出：0
  提示：
1 <= nums.length <= 200
1 <= nums[i] <= 1000
nums 中的所有元素 互不相同
1 <= target <= 1000
  进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？",641,,94679,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/combination-sum/'],181118
评论 (559),kth-smallest-element-in-a-sorted-matrix,中等,"给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。
你必须找到一个内存复杂度优于 O(n2) 的解决方案。
  示例 1：
输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
示例 2：
输入：matrix = [[-5]], k = 1
输出：-5
  提示：
n == matrix.length
n == matrix[i].length
1 <= n <= 300
-109 <= matrix[i][j] <= 109
题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列
1 <= k <= n2
  进阶：
你能否用一个恒定的内存(即 O(1) 内存复杂度)来解决这个问题?
你能在 O(n) 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ this paper ）很有趣。",809,,100736,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/', 'https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/', 'https://leetcode.cn/problems/find-k-th-smallest-pair-distance/', 'https://leetcode.cn/problems/k-th-smallest-prime-fraction/']",159071
评论 (38),design-phone-directory,Unknown,,-1,,-1,[],[],-1
评论 (360),insert-delete-getrandom-o1,中等,"实现RandomizedSet 类：
RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。
  示例：
输入
[""RandomizedSet"", ""insert"", ""remove"", ""insert"", ""getRandom"", ""remove"", ""insert"", ""getRandom""]
[[], [1], [2], [2], [], [1], [2], []]
输出
[null, true, false, true, 2, true, false, 2]

解释
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。
randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。
randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。
randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
  提示：
-231 <= val <= 231 - 1
最多调用 insert、remove 和 getRandom 函数 2 * 105 次
在调用 getRandom 方法时，数据结构中 至少存在一个 元素。",554,,80376,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/randomized/']",['https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/'],151898
评论 (233),insert-delete-getrandom-o1-duplicates-allowed,困难,"RandomizedCollection 是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。
实现 RandomizedCollection 类:
RandomizedCollection()初始化空的 RandomizedCollection 对象。
bool insert(int val) 将一个 val 项插入到集合中，即使该项已经存在。如果该项不存在，则返回 true ，否则返回 false 。
bool remove(int val) 如果存在，从集合中移除一个 val 项。如果该项存在，则返回 true ，否则返回 false 。注意，如果 val 在集合中出现多次，我们只删除其中一个。
int getRandom() 从当前的多个元素集合中返回一个随机元素。每个元素被返回的概率与集合中包含的相同值的数量 线性相关 。
您必须实现类的函数，使每个函数的 平均 时间复杂度为 O(1) 。
注意：生成测试用例时，只有在 RandomizedCollection 中 至少有一项 时，才会调用 getRandom 。
  示例 1:
输入
[""RandomizedCollection"", ""insert"", ""insert"", ""insert"", ""getRandom"", ""remove"", ""getRandom""]
[[], [1], [1], [2], [], [1], []]
输出
[null, true, false, true, 2, true, 1]

解释
RandomizedCollection collection = new RandomizedCollection();// 初始化一个空的集合。
collection.insert(1);// 向集合中插入 1 。返回 true 表示集合不包含 1 。
collection.insert(1);// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。
collection.insert(2);// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。
collection.getRandom();// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。
collection.remove(1);// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。
collection.getRandom();// getRandom 应有相同概率返回 1 和 2 。
  提示:
-231 <= val <= 231 - 1
insert, remove 和 getRandom 最多 总共 被调用 2 * 105 次
当调用 getRandom 时，数据结构中 至少有一个 元素",244,,23493,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/randomized/']",['https://leetcode.cn/problems/insert-delete-getrandom-o1/'],54387
评论 (246),linked-list-random-node,中等,"给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。
实现 Solution 类：
Solution(ListNode head) 使用整数数组初始化对象。
int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。
  示例：
输入
[""Solution"", ""getRandom"", ""getRandom"", ""getRandom"", ""getRandom"", ""getRandom""]
[[[1, 2, 3]], [], [], [], [], []]
输出
[null, 1, 3, 2, 2, 3]

解释
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // 返回 1
solution.getRandom(); // 返回 3
solution.getRandom(); // 返回 2
solution.getRandom(); // 返回 2
solution.getRandom(); // 返回 3
// getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。
  提示：
链表中的节点数在范围 [1, 104] 内
-104 <= Node.val <= 104
至多调用 getRandom 方法 104 次
  进阶：
如果链表非常大且长度未知，该怎么处理？
你能否在不使用额外空间的情况下解决此问题？",286,https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg,46523,"['https://leetcode.cn/tag/reservoir-sampling/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/randomized/']",['https://leetcode.cn/problems/random-pick-index/'],64528
评论 (1.2k),ransom-note,简单,"给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true ；否则返回 false 。
magazine 中的每个字符只能在 ransomNote 中使用一次。
  示例 1：
输入：ransomNote = ""a"", magazine = ""b""
输出：false
示例 2：
输入：ransomNote = ""aa"", magazine = ""ab""
输出：false
示例 3：
输入：ransomNote = ""aa"", magazine = ""aab""
输出：true
  提示：
1 <= ransomNote.length, magazine.length <= 105
ransomNote 和 magazine 由小写英文字母组成",325,,173593,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",['https://leetcode.cn/problems/stickers-to-spell-word/'],270091
评论 (421),shuffle-an-array,中等,"给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象
int[] reset() 重设数组到它的初始状态并返回
int[] shuffle() 返回数组随机打乱后的结果
  示例 1：
输入
[""Solution"", ""shuffle"", ""reset"", ""shuffle""]
[[[1, 2, 3]], [], [], []]
输出
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

解释
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]
  提示：
1 <= nums.length <= 50
-106 <= nums[i] <= 106
nums 中的所有元素都是 唯一的
最多可以调用 104 次 reset 和 shuffle",278,,99958,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/randomized/']",[],163513
评论 (361),mini-parser,中等,"给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。
列表中的每个元素只可能是整数或整数嵌套列表
  示例 1：
输入：s = ""324"",
输出：324
解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。
示例 2：
输入：s = ""[123,[456,[789]]]"",
输出：[123,[456,[789]]]
解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：
1. 一个 integer 包含值 123
2. 一个包含两个元素的嵌套列表：
    i.  一个 integer 包含值 456
    ii. 一个包含一个元素的嵌套列表
         a. 一个 integer 包含值 789
  提示：
1 <= s.length <= 5 * 104
s 由数字、方括号 ""[]""、负号 '-' 、逗号 ','组成
用例保证 s 是可解析的 NestedInteger
输入中的所有值的范围是 [-106, 106]",178,,28350,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/flatten-nested-list-iterator/', 'https://leetcode.cn/problems/ternary-expression-parser/', 'https://leetcode.cn/problems/remove-comments/']",51539
评论 (486),lexicographical-numbers,中等,"给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。
你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。
  示例 1：
输入：n = 13
输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]
示例 2：
输入：n = 2
输出：[1,2]
  提示：
1 <= n <= 5 * 104",392,,61534,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/trie/']",[],81897
评论 (1.1k),first-unique-character-in-a-string,简单,"给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。
  示例 1：
输入: s = ""leetcode""
输出: 0
示例 2:
输入: s = ""loveleetcode""
输出: 2
示例 3:
输入: s = ""aabb""
输出: -1
  提示:
1 <= s.length <= 105
s 只包含小写字母",552,,299611,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",['https://leetcode.cn/problems/sort-characters-by-frequency/'],545757
评论 (404),longest-absolute-file-path,中等,"假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：
这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。
在文本格式中，如下所示(⟶表示制表符)：
dir
⟶ subdir1
⟶ ⟶ file1.ext
⟶ ⟶ subsubdir1
⟶ subdir2
⟶ ⟶ subsubdir2
⟶ ⟶ ⟶ file2.ext
如果是代码表示，上面的文件系统可以写为 ""dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"" 。'\n' 和 '\t' 分别是换行符和制表符。
文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 '/' 连接。上面例子中，指向 file2.ext 的 绝对路径 是 ""dir/subdir2/subsubdir2/file2.ext"" 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和/或空格组成。
给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0。
  示例 1：
输入：input = ""dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext""
输出：20
解释：只有一个文件，绝对路径为 ""dir/subdir2/file.ext"" ，路径长度 20
示例 2：
输入：input = ""dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext""
输出：32
解释：存在两个文件：
""dir/subdir1/file1.ext"" ，路径长度 21
""dir/subdir2/subsubdir2/file2.ext"" ，路径长度 32
返回 32 ，因为这是最长的路径
示例 3：
输入：input = ""a""
输出：0
解释：不存在任何文件
示例 4：
输入：input = ""file1.txt\nfile2.txt\nlongfile.txt""
输出：12
解释：根目录下有 3 个文件。
因为根目录中任何东西的绝对路径只是名称本身，所以答案是 ""longfile.txt"" ，路径长度为 12
  提示：
1 <= input.length <= 104
input 可能包含小写或大写的英文字母，一个换行符 '\n'，一个制表符 '\t'，一个点 '.'，一个空格 ' '，和数字。",231,https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg,29978,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/string/']",[],46904
评论 (891),find-the-difference,简单,"给定两个字符串 s 和 t ，它们只包含小写字母。
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。
请找出在 t 中被添加的字母。
  示例 1：
输入：s = ""abcd"", t = ""abcde""
输出：""e""
解释：'e' 是那个被添加的字母。
示例 2：
输入：s = """", t = ""y""
输出：""y""
  提示：
0 <= s.length <= 1000
t.length == s.length + 1
s 和 t 只包含小写字母",326,,127150,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/single-number/'],185997
评论 (283),elimination-game,中等,"列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：
从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
给你整数 n ，返回 arr 最后剩下的数字。
  示例 1：
输入：n = 9
输出：6
解释：
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr = [2, 4, 6, 8]
arr = [2, 6]
arr = [6]
示例 2：
输入：n = 1
输出：1
  提示：
1 <= n <= 109",280,,32201,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']",[],52617
评论 (224),perfect-rectangle,困难,"给你一个数组 rectangles ，其中 rectangles[i] = [xi, yi, ai, bi] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (xi, yi) ，右上顶点是 (ai, bi) 。
如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。
  示例 1：
输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
输出：true
解释：5 个矩形一起可以精确地覆盖一个矩形区域。 
示例 2：
输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]
输出：false
解释：两个矩形之间有间隔，无法覆盖成一个矩形。
示例 3：
输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]
输出：false
解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。
  提示：
1 <= rectangles.length <= 2 * 104
rectangles[i].length == 4
-105 <= xi, yi, ai, bi <= 105",220,https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg,23185,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/line-sweep/']",[],50076
评论 (1.1k),is-subsequence,简单,"给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，""ace""是""abcde""的一个子序列，而""aec""不是）。
进阶：
如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
致谢：
特别感谢 @pbrother 添加此问题并且创建所有测试用例。
  示例 1：
输入：s = ""abc"", t = ""ahbgdc""
输出：true
示例 2：
输入：s = ""axc"", t = ""ahbgdc""
输出：false
  提示：
0 <= s.length <= 100
0 <= t.length <= 10^4
两个字符串都只由小写字符组成。",653,,199490,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/number-of-matching-subsequences/', 'https://leetcode.cn/problems/shortest-way-to-form-string/']",382161
评论 (489),utf-8-validation,中等,"给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。
UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：
对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。
对于 n 字节 的字符 (n > 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。
这是 UTF-8 编码的工作方式：
      Number of Bytes  |        UTF-8 octet sequence
                       |              (binary)
   --------------------+---------------------------------------------
            1          | 0xxxxxxx
            2          | 110xxxxx 10xxxxxx
            3          | 1110xxxx 10xxxxxx 10xxxxxx
            4          | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
x 表示二进制形式的一位，可以是 0 或 1。
注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。
  示例 1：
输入：data = [197,130,1]
输出：true
解释：数据表示字节序列:11000101 10000010 00000001。
这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。
示例 2：
输入：data = [235,140,4]
输出：false
解释：数据表示 8 位的序列: 11101011 10001100 00000100.
前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。
下一个字节是开头为 10 的延续字节，这是正确的。
但第二个延续字节不以 10 开头，所以是不符合规则的。
  提示:
1 <= data.length <= 2 * 104
0 <= data[i] <= 255",170,,34664,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/']",[],78925
评论 (1.0k),decode-string,中等,"给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
  示例 1：
输入：s = ""3[a]2[bc]""
输出：""aaabcbc""
示例 2：
输入：s = ""3[a2[c]]""
输出：""accaccacc""
示例 3：
输入：s = ""2[abc]3[cd]ef""
输出：""abcabccdcdcdef""
示例 4：
输入：s = ""abc3[cd]xyz""
输出：""abccdcdcdxyz""
  提示：
1 <= s.length <= 30
s 由小写英文字母、数字和方括号 '[]' 组成
s 保证是一个 有效 的输入。
s 中所有整数的取值范围为 [1, 300] ",1158,,169410,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/encode-string-with-shortest-length/', 'https://leetcode.cn/problems/number-of-atoms/', 'https://leetcode.cn/problems/brace-expansion/']",301823
评论 (347),longest-substring-with-at-least-k-repeating-characters,中等,"给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。
  示例 1：
输入：s = ""aaabb"", k = 3
输出：3
解释：最长子串为 ""aaa"" ，其中 'a' 重复了 3 次。
示例 2：
输入：s = ""ababbc"", k = 2
输出：5
解释：最长子串为 ""ababb"" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
  提示：
1 <= s.length <= 104
s 仅由小写英文字母组成
1 <= k <= 105",686,,65556,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/sliding-window/']",[],125083
评论 (463),rotate-function,中等,"给定一个长度为 n 的整数数组 nums 。
假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：
F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]
返回 F(0), F(1), ..., F(n-1)中的最大值 。
生成的测试用例让答案符合 32 位 整数。
  示例 1:
输入: nums = [4,3,2,6]
输出: 26
解释:
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。
示例 2:
输入: nums = [100]
输出: 0
  提示:
n == nums.length
1 <= n <= 105
-100 <= nums[i] <= 100",221,,41624,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],77742
评论 (487),integer-replacement,中等,"给定一个正整数 n ，你可以做如下操作：
如果 n 是偶数，则用 n / 2替换 n 。
如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。
返回 n 变为 1 所需的 最小替换次数 。
  示例 1：
输入：n = 8
输出：3
解释：8 -> 4 -> 2 -> 1
示例 2：
输入：n = 7
输出：4
解释：7 -> 8 -> 4 -> 2 -> 1
或 7 -> 6 -> 3 -> 2 -> 1
示例 3：
输入：n = 4
输出：2
  提示：
1 <= n <= 231 - 1",235,,55311,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/dynamic-programming/']",[],128889
评论 (285),random-pick-index,中等,"给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。
实现 Solution 类：
Solution(int[] nums) 用数组 nums 初始化对象。
int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。
  示例：
输入
[""Solution"", ""pick"", ""pick"", ""pick""]
[[[1, 2, 3, 3, 3]], [3], [1], [3]]
输出
[null, 4, 0, 2]

解释
Solution solution = new Solution([1, 2, 3, 3, 3]);
solution.pick(3); // 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。
solution.pick(1); // 返回 0 。因为只有 nums[0] 等于 1 。
solution.pick(3); // 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。
  提示：
1 <= nums.length <= 2 * 104
-231 <= nums[i] <= 231 - 1
target 是 nums 中的一个整数
最多调用 pick 函数 104 次
 ",241,,51609,"['https://leetcode.cn/tag/reservoir-sampling/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/randomized/']","['https://leetcode.cn/problems/linked-list-random-node/', 'https://leetcode.cn/problems/random-pick-with-blacklist/', 'https://leetcode.cn/problems/random-pick-with-weight/']",70338
评论 (622),evaluate-division,中等,"给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。
另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。
返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。
注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。
  示例 1：
输入：equations = [[""a"",""b""],[""b"",""c""]], values = [2.0,3.0], queries = [[""a"",""c""],[""b"",""a""],[""a"",""e""],[""a"",""a""],[""x"",""x""]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
示例 2：
输入：equations = [[""a"",""b""],[""b"",""c""],[""bc"",""cd""]], values = [1.5,2.5,5.0], queries = [[""a"",""c""],[""c"",""b""],[""bc"",""cd""],[""cd"",""bc""]]
输出：[3.75000,0.40000,5.00000,0.20000]
示例 3：
输入：equations = [[""a"",""b""]], values = [0.5], queries = [[""a"",""b""],[""b"",""a""],[""a"",""c""],[""x"",""y""]]
输出：[0.50000,2.00000,-1.00000,-1.00000]
  提示：
1 <= equations.length <= 20
equations[i].length == 2
1 <= Ai.length, Bi.length <= 5
values.length == equations.length
0.0 < values[i] <= 20.0
1 <= queries.length <= 20
queries[i].length == 2
1 <= Cj.length, Dj.length <= 5
Ai, Bi, Cj, Dj 由小写英文字母与数字组成",747,,55700,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/shortest-path/']",[],93963
评论 (603),nth-digit,中等,"给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第 n 位上的数字。
  示例 1：
输入：n = 3
输出：3
示例 2：
输入：n = 11
输出：0
解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。
  提示：
1 <= n <= 231 - 1",316,,48213,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],105871
评论 (722),binary-watch,简单,"二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。
例如，下面的二进制手表读取 ""3:25"" 。
（图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ）
给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。
小时不会以零开头：
例如，""01:00"" 是无效的时间，正确的写法应该是 ""1:00"" 。
分钟必须由两位数组成，可能会以零开头：
例如，""10:2"" 是无效的时间，正确的写法应该是 ""10:02"" 。
  示例 1：
输入：turnedOn = 1
输出：[""0:01"",""0:02"",""0:04"",""0:08"",""0:16"",""0:32"",""1:00"",""2:00"",""4:00"",""8:00""]
示例 2：
输入：turnedOn = 9
输出：[]
  提示：
0 <= turnedOn <= 10",363,,61262,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/letter-combinations-of-a-phone-number/', 'https://leetcode.cn/problems/number-of-1-bits/']",99019
评论 (550),remove-k-digits,中等,"给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。
  示例 1 ：
输入：num = ""1432219"", k = 3
输出：""1219""
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
示例 2 ：
输入：num = ""10200"", k = 1
输出：""200""
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
示例 3 ：
输入：num = ""10"", k = 2
输出：""0""
解释：从原数字移除所有的数字，剩余为空就是 0 。
  提示：
1 <= k <= num.length <= 105
num 仅由若干位数字（0 - 9）组成
除了 0 本身之外，num 不含任何前导零",804,,105916,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/monotonic-stack/']","['https://leetcode.cn/problems/create-maximum-number/', 'https://leetcode.cn/problems/monotone-increasing-digits/']",327157
评论 (491),frog-jump,困难,"一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。
给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。
如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。
  示例 1：
输入：stones = [0,1,3,5,6,8,12,17]
输出：true
解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。
示例 2：
输入：stones = [0,1,2,3,4,8,9,11]
输出：false
解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。
  提示：
2 <= stones.length <= 2000
0 <= stones[i] <= 231 - 1
stones[0] == 0
stones 按严格升序排列",426,,52370,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],114502
评论 (1.1k),sum-of-left-leaves,简单,"给定二叉树的根节点 root ，返回所有左叶子之和。
  示例 1：
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
示例 2:
输入: root = [1]
输出: 0
  提示:
节点数在 [1, 1000] 范围内
-1000 <= Node.val <= 1000
 ",456,,154032,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],253996
评论 (405),convert-a-number-to-hexadecimal,简单,"给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。
注意:
十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
示例 1：
输入:
26

输出:
""1a""
示例 2：
输入:
-1

输出:
""ffffffff""",246,,53671,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/']",[],96406
评论 (773),queue-reconstruction-by-height,中等,"假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
  示例 1：
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
示例 2：
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
  提示：
1 <= people.length <= 2000
0 <= hi <= 106
0 <= ki < people.length
题目数据确保队列可以被重建",1272,,168041,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/count-of-smaller-numbers-after-self/'],223816
评论 (409),trapping-rain-water-ii,困难,"给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。
  示例 1:
输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
输出: 4
解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。
示例 2:
输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
输出: 10
  提示:
m == heightMap.length
n == heightMap[i].length
1 <= m, n <= 200
0 <= heightMap[i][j] <= 2 * 104
 ",603,,28346,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/heap-priority-queue/']",['https://leetcode.cn/problems/trapping-rain-water/'],49044
评论 (84),valid-word-abbreviation,Unknown,,-1,,-1,[],[],-1
评论 (924),longest-palindrome,简单,"给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。
在构造过程中，请注意 区分大小写 。比如 ""Aa"" 不能当做一个回文字符串。
  示例 1:
输入:s = ""abccccdd""
输出:7
解释:
我们可以构造的最长的回文串是""dccaccd"", 它的长度是 7。
示例 2:
输入:s = ""a""
输入:1
示例 3:
输入:s = ""bb""
输入: 2
  提示:
1 <= s.length <= 2000
s 只能由小写和/或大写英文字母组成",418,,124516,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/palindrome-permutation/'],224062
评论 (360),split-array-largest-sum,困难,"给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组。
设计一个算法使得这 m 个子数组各自和的最大值最小。
  示例 1：
输入：nums = [7,2,5,10,8], m = 2
输出：18
解释：
一共有四种方法将 nums 分割为 2 个子数组。 
其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
示例 2：
输入：nums = [1,2,3,4,5], m = 2
输出：9
示例 3：
输入：nums = [1,4,4], m = 3
输出：4
  提示：
1 <= nums.length <= 1000
0 <= nums[i] <= 106
1 <= m <= min(50, nums.length)",692,,50457,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],87036
评论 (10),minimum-unique-word-abbreviation,Unknown,,-1,,-1,[],[],-1
评论 (512),fizz-buzz,简单,"给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：
answer[i] == ""FizzBuzz"" 如果 i 同时是 3 和 5 的倍数。
answer[i] == ""Fizz"" 如果 i 是 3 的倍数。
answer[i] == ""Buzz"" 如果 i 是 5 的倍数。
answer[i] == i （以字符串形式）如果上述条件全不满足。
  示例 1：
输入：n = 3
输出：[""1"",""2"",""Fizz""]
示例 2：
输入：n = 5
输出：[""1"",""2"",""Fizz"",""4"",""Buzz""]
示例 3：
输入：n = 15
输出：[""1"",""2"",""Fizz"",""4"",""Buzz"",""Fizz"",""7"",""8"",""Fizz"",""Buzz"",""11"",""Fizz"",""13"",""14"",""FizzBuzz""]
  提示：
1 <= n <= 104",180,,123682,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],173356
评论 (832),arithmetic-slices,中等,"如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。
例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。
给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。
子数组 是数组中的一个连续序列。
  示例 1：
输入：nums = [1,2,3,4]
输出：3
解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。
示例 2：
输入：nums = [1]
输出：0
  提示：
1 <= nums.length <= 5000
-1000 <= nums[i] <= 1000",452,,97320,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/arithmetic-slices-ii-subsequence/'],140281
评论 (1.0k),third-maximum-number,简单,"给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。
  示例 1：
输入：[3, 2, 1]
输出：1
解释：第三大的数是 1 。
示例 2：
输入：[1, 2]
输出：2
解释：第三大的数不存在, 所以返回最大的数 2 。
示例 3：
输入：[2, 2, 3, 1]
输出：1
解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
  提示：
1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1
  进阶：你能设计一个时间复杂度 O(n) 的解决方案吗？",361,,108746,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/kth-largest-element-in-an-array/'],275723
评论 (938),add-strings,简单,"给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。
你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。
  示例 1：
输入：num1 = ""11"", num2 = ""123""
输出：""134""
示例 2：
输入：num1 = ""456"", num2 = ""77""
输出：""533""
示例 3：
输入：num1 = ""0"", num2 = ""0""
输出：""0""
    提示：
1 <= num1.length, num2.length <= 104
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零",564,,205896,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']","['https://leetcode.cn/problems/add-two-numbers/', 'https://leetcode.cn/problems/multiply-strings/', 'https://leetcode.cn/problems/add-to-array-form-of-integer/']",375675
评论 (783),partition-equal-subset-sum,中等,"给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
  示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
示例 2：
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
  提示：
1 <= nums.length <= 200
1 <= nums[i] <= 100",1321,,271119,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/'],523390
评论 (600),pacific-atlantic-water-flow,中等,"有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。
这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。
岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。
返回网格坐标 result 的 2D 列表 ，其中 result[i] = [ri, ci] 表示雨水从单元格 (ri, ci) 流动 既可流向太平洋也可流向大西洋 。
  示例 1：
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
示例 2：
输入: heights = [[2,1],[1,2]]
输出: [[0,0],[0,1],[1,0],[1,1]]
  提示：
m == heights.length
n == heights[r].length
1 <= m, n <= 200
0 <= heights[r][c] <= 105",478,,62833,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],114329
评论 (24),sentence-screen-fitting,Unknown,,-1,,-1,[],[],-1
评论 (554),battleships-in-a-board,中等,"给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。
战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。
  示例 1：
输入：board = [[""X"",""."",""."",""X""],[""."",""."",""."",""X""],[""."",""."",""."",""X""]]
输出：2
示例 2：
输入：board = [["".""]]
输出：0
  提示：
m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] 是 '.' 或 'X'
  进阶：你可以实现一次扫描算法，并只使用 O(1) 额外空间，并且不修改 board 的值来解决这个问题吗？",207,https://assets.leetcode.com/uploads/2021/04/10/battelship-grid.jpg,36891,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],46791
评论 (306),strong-password-checker,困难,"  如果一个密码满足下述所有条件，则认为这个密码是强密码：
由至少 6 个，至多 20 个字符组成。
至少包含 一个小写 字母，一个大写 字母，和 一个数字 。
同一字符 不能 连续出现三次 (比如 ""...aaa..."" 是不允许的, 但是 ""...aa...a..."" 如果满足其他条件也可以算是强密码)。
给你一个字符串 password ，返回 将 password 修改到满足强密码条件需要的最少修改步数。如果 password 已经是强密码，则返回 0 。
在一步修改操作中，你可以：
插入一个字符到 password ，
从 password 中删除一个字符，或
用另一个字符来替换 password 中的某个字符。
  示例 1：
输入：password = ""a""
输出：5
示例 2：
输入：password = ""aA1""
输出：3
示例 3：
输入：password = ""1337C0d3""
输出：0
  提示：
1 <= password.length <= 50
password 由字母、数字、点 '.' 或者感叹号 '!'",188,,17365,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],43995
评论 (234),maximum-xor-of-two-numbers-in-an-array,中等,"给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。
进阶：你可以在 O(n) 的时间解决这个问题吗？
  示例 1：
输入：nums = [3,10,5,25,2,8]
输出：28
解释：最大运算结果是 5 XOR 25 = 28.
示例 2：
输入：nums = [0]
输出：0
示例 3：
输入：nums = [2,4]
输出：6
示例 4：
输入：nums = [8,10,2]
输出：10
示例 5：
输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]
输出：127
  提示：
1 <= nums.length <= 2 * 104
0 <= nums[i] <= 231 - 1",444,,37894,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],61126
评论 (43),valid-word-square,Unknown,,-1,,-1,[],[],-1
评论 (396),reconstruct-original-digits-from-english,中等,"给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。
  示例 1：
输入：s = ""owoztneoer""
输出：""012""
示例 2：
输入：s = ""fviefuro""
输出：""45""
  提示：
1 <= s.length <= 105
s[i] 为 [""e"",""g"",""f"",""i"",""h"",""o"",""n"",""s"",""r"",""u"",""t"",""w"",""v"",""x"",""z""] 这些字符之一
s 保证是一个符合题目要求的字符串",181,,35634,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],58293
评论 (353),longest-repeating-character-replacement,中等,"给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。
在执行上述操作后，返回包含相同字母的最长子字符串的长度。
  示例 1：
输入：s = ""ABAB"", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
示例 2：
输入：s = ""AABABBA"", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 ""AABBBBA""。
子串 ""BBBB"" 有最长重复字母, 答案为 4。
  提示：
1 <= s.length <= 105
s 仅由大写英文字母组成
0 <= k <= s.length",616,,66034,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/', 'https://leetcode.cn/problems/max-consecutive-ones-iii/']",122859
评论 (16),word-squares,Unknown,,-1,,-1,[],[],-1
评论 (73),convert-binary-search-tree-to-sorted-doubly-linked-list,Unknown,,-1,,-1,[],[],-1
评论 (331),construct-quad-tree,中等,"给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。
你需要返回能表示矩阵的 四叉树 的根结点。
注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。
四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：
val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False；
isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}
我们可以按以下步骤为二维区域构建四叉树：
如果当前网格的值相同（即，全为 0 或者全为 1），将 isLeaf 设为 True ，将 val 设为网格相应的值，并将四个子节点都设为 Null 然后停止。
如果当前网格的值不同，将 isLeaf 设为 False， 将 val 设为任意值，然后如下图所示，将当前网格划分为四个子网格。
使用适当的子网格递归每个子节点。
如果你想了解更多关于四叉树的内容，可以参考 wiki 。
四叉树格式：
输出为使用层序遍历后四叉树的序列化形式，其中 null 表示路径终止符，其下面不存在节点。
它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 [isLeaf, val] 。
如果 isLeaf 或者 val 的值为 True ，则表示它在列表 [isLeaf, val] 中的值为 1 ；如果 isLeaf 或者 val 的值为 False ，则表示值为 0 。
  示例 1：
输入：grid = [[0,1],[1,0]]
输出：[[0,1],[1,0],[1,1],[1,1],[1,0]]
解释：此示例的解释如下：
请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。
示例 2：
输入：grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]
输出：[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
解释：网格中的所有值都不相同。我们将网格划分为四个子网格。
topLeft，bottomLeft 和 bottomRight 均具有相同的值。
topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。
解释如下图所示：
示例 3：
输入：grid = [[1,1],[1,1]]
输出：[[1,1]]
示例 4：
输入：grid = [[0]]
输出：[[1,0]]
示例 5：
输入：grid = [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]
输出：[[0,1],[1,1],[1,0],[1,0],[1,1]]
  提示：
n == grid.length == grid[i].length
n == 2^x 其中 0 <= x <= 6",159,,23048,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/matrix/']",[],32295
评论 (33),serialize-and-deserialize-n-ary-tree,Unknown,,-1,,-1,[],[],-1
评论 (608),n-ary-tree-level-order-traversal,中等,"给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。
树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
  示例 1：
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
示例 2：
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
  提示：
树的高度不会超过 1000
树的节点总数在 [0, 10^4] 之间",285,,115415,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/breadth-first-search/']","['https://leetcode.cn/problems/binary-tree-level-order-traversal/', 'https://leetcode.cn/problems/n-ary-tree-preorder-traversal/', 'https://leetcode.cn/problems/n-ary-tree-postorder-traversal/']",160377
评论 (664),flatten-a-multilevel-doubly-linked-list,中等,"你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的 子指针 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 多层数据结构 。
给定链表的头节点 head ，将链表 扁平化 ，以便所有节点都出现在单层双链表中。让 curr 是一个带有子列表的节点。子列表中的节点应该出现在扁平化列表中的 curr 之后 和 curr.next 之前 。
返回 扁平列表的 head 。列表中的节点必须将其 所有 子指针设置为 null 。
  示例 1：
输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
输出：[1,2,3,7,8,11,12,9,10,4,5,6]
解释：输入的多级列表如上图所示。
扁平化后的链表如下图：
示例 2：
输入：head = [1,2,null,3]
输出：[1,3,2]
解释：输入的多级列表如上图所示。
扁平化后的链表如下图：
示例 3：
输入：head = []
输出：[]
说明：输入中可能存在空列表。
  提示：
节点数目不超过 1000
1 <= Node.val <= 105
  如何表示测试用例中的多级链表？
以 示例 1 为例：
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL
序列化其中的每一级之后：
[1,2,3,4,5,6,null]
[7,8,9,10,null]
[11,12,null]
为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。
[1,2,3,4,5,6,null]
[null,null,7,8,9,10,null]
[null,11,12,null]
合并所有序列化结果，并去除末尾的 null 。
[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]",351,,51590,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/doubly-linked-list/']",['https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/'],87232
评论 (26),encode-n-ary-tree-to-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (319),all-oone-data-structure,困难,"请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。
实现 AllOne 类：
AllOne() 初始化数据结构的对象。
inc(String key) 字符串 key 的计数增加 1 。如果数据结构中尚不存在 key ，那么插入计数为 1 的 key 。
dec(String key) 字符串 key 的计数减少 1 。如果 key 的计数在减少后为 0 ，那么需要将这个 key 从数据结构中删除。测试用例保证：在减少计数前，key 存在于数据结构中。
getMaxKey() 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 """" 。
getMinKey() 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 """" 。
注意：每个函数都应当满足 O(1) 平均时间复杂度。
  示例：
输入
[""AllOne"", ""inc"", ""inc"", ""getMaxKey"", ""getMinKey"", ""inc"", ""getMaxKey"", ""getMinKey""]
[[], [""hello""], [""hello""], [], [], [""leet""], [], []]
输出
[null, null, null, ""hello"", ""hello"", null, ""hello"", ""leet""]

解释
AllOne allOne = new AllOne();
allOne.inc(""hello"");
allOne.inc(""hello"");
allOne.getMaxKey(); // 返回 ""hello""
allOne.getMinKey(); // 返回 ""hello""
allOne.inc(""leet"");
allOne.getMaxKey(); // 返回 ""hello""
allOne.getMinKey(); // 返回 ""leet""
  提示：
1 <= key.length <= 10
key 由小写英文字母组成
测试用例保证：在每次调用 dec 时，数据结构中总存在 key
最多调用 inc、dec、getMaxKey 和 getMinKey 方法 5 * 104 次",268,,26139,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/doubly-linked-list/']",[],55334
评论 (416),minimum-genetic-mutation,中等,"基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。
假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。
例如，""AACCGGTT"" --> ""AACCGGTA"" 就是一次基因变化。
另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。
给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。
注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。
  示例 1：
输入：start = ""AACCGGTT"", end = ""AACCGGTA"", bank = [""AACCGGTA""]
输出：1
示例 2：
输入：start = ""AACCGGTT"", end = ""AAACGGTA"", bank = [""AACCGGTA"",""AACCGCTA"",""AAACGGTA""]
输出：2
示例 3：
输入：start = ""AAAAACCC"", end = ""AACCCCCC"", bank = [""AAAACCCC"",""AAACCCCC"",""AACCCCCC""]
输出：3
  提示：
start.length == 8
end.length == 8
0 <= bank.length <= 10
bank[i].length == 8
start、end 和 bank[i] 仅由字符 ['A', 'C', 'G', 'T'] 组成",210,,44286,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/word-ladder/'],80329
评论 (846),number-of-segments-in-a-string,简单,"统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。
请注意，你可以假定字符串里不包括任何不可打印的字符。
示例:
输入: ""Hello, my name is John""
输出: 5
解释: 这里的单词是指连续的不是空格的字符，所以 ""Hello,"" 算作 1 个单词。",173,,73921,['https://leetcode.cn/tag/string/'],[],186429
评论 (679),non-overlapping-intervals,中等,"给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。
  示例 1:
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
  提示:
1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104",701,,147283,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/'],289878
评论 (555),find-right-interval,中等,"给你一个区间数组 intervals ，其中 intervals[i] = [starti, endi] ，且每个 starti 都 不同 。
区间 i 的 右侧区间 可以记作区间 j ，并满足 startj >= endi ，且 startj 最小化 。
返回一个由每个区间 i 的 右侧区间 在 intervals 中对应下标组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。
  示例 1：
输入：intervals = [[1,2]]
输出：[-1]
解释：集合中只有一个区间，所以输出-1。
示例 2：
输入：intervals = [[3,4],[2,3],[1,2]]
输出：[-1,0,1]
解释：对于 [3,4] ，没有满足条件的“右侧”区间。
对于 [2,3] ，区间[3,4]具有最小的“右”起点;
对于 [1,2] ，区间[2,3]具有最小的“右”起点。
示例 3：
输入：intervals = [[1,4],[2,3],[3,4]]
输出：[-1,2,-1]
解释：对于区间 [1,4] 和 [3,4] ，没有满足条件的“右侧”区间。
对于 [2,3] ，区间 [3,4] 有最小的“右”起点。
  提示：
1 <= intervals.length <= 2 * 104
intervals[i].length == 2
-106 <= starti <= endi <= 106
每个间隔的起点都 不相同",188,,36197,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/data-stream-as-disjoint-intervals/'],63498
评论 (950),path-sum-iii,中等,"给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
  示例 1：
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
示例 2：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
  提示:
二叉树的节点个数的范围是 [0,1000]
-109 <= Node.val <= 109 
-1000 <= targetSum <= 1000 ",1339,,166718,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/path-sum/', 'https://leetcode.cn/problems/path-sum-ii/', 'https://leetcode.cn/problems/path-sum-iv/', 'https://leetcode.cn/problems/longest-univalue-path/']",293992
评论 (937),find-all-anagrams-in-a-string,中等,"给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。
  示例 1:
输入: s = ""cbaebabacd"", p = ""abc""
输出: [0,6]
解释:
起始索引等于 0 的子串是 ""cba"", 它是 ""abc"" 的异位词。
起始索引等于 6 的子串是 ""bac"", 它是 ""abc"" 的异位词。
 示例 2:
输入: s = ""abab"", p = ""ab""
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 ""ab"", 它是 ""ab"" 的异位词。
起始索引等于 1 的子串是 ""ba"", 它是 ""ab"" 的异位词。
起始索引等于 2 的子串是 ""ab"", 它是 ""ab"" 的异位词。
  提示:
1 <= s.length, p.length <= 3 * 104
s 和 p 仅包含小写字母",893,,185216,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/valid-anagram/', 'https://leetcode.cn/problems/permutation-in-string/']",339515
评论 (40),ternary-expression-parser,Unknown,,-1,,-1,[],[],-1
评论 (275),k-th-smallest-in-lexicographical-order,困难,"给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。
  示例 1:
输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
示例 2:
输入: n = 1, k = 1
输出: 1
  提示:
1 <= k <= n <= 109",502,,40648,['https://leetcode.cn/tag/trie/'],[],95363
评论 (742),arranging-coins,简单,"你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。
给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。
  示例 1：
输入：n = 5
输出：2
解释：因为第三行不完整，所以返回 2 。
示例 2：
输入：n = 8
输出：3
解释：因为第四行不完整，所以返回 3 。
  提示：
1 <= n <= 231 - 1",218,https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg,94084,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],205636
评论 (589),find-all-duplicates-in-an-array,中等,"给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。
你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。
  示例 1：
输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
示例 2：
输入：nums = [1,1,2]
输出：[1]
示例 3：
输入：nums = [1]
输出：[]
  提示：
n == nums.length
1 <= n <= 105
1 <= nums[i] <= n
nums 中的每个元素出现 一次 或 两次",620,,90389,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",['https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/'],120795
评论 (761),string-compression,中等,"给你一个字符数组 chars ，请使用下述算法压缩：
从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：
如果这一组长度为 1 ，则将字符追加到 s 中。
否则，需要向 s 追加字符，后跟这一组的长度。
压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。
请在 修改完输入数组后 ，返回该数组的新长度。
你必须设计并实现一个只使用常量额外空间的算法来解决此问题。
  示例 1：
输入：chars = [""a"",""a"",""b"",""b"",""c"",""c"",""c""]
输出：返回 6 ，输入数组的前 6 个字符应该是：[""a"",""2"",""b"",""2"",""c"",""3""]
解释：""aa"" 被 ""a2"" 替代。""bb"" 被 ""b2"" 替代。""ccc"" 被 ""c3"" 替代。
示例 2：
输入：chars = [""a""]
输出：返回 1 ，输入数组的前 1 个字符应该是：[""a""]
解释：唯一的组是“a”，它保持未压缩，因为它是一个字符。
示例 3：
输入：chars = [""a"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b"",""b""]
输出：返回 4 ，输入数组的前 4 个字符应该是：[""a"",""b"",""1"",""2""]。
解释：由于字符 ""a"" 不重复，所以不会被压缩。""bbbbbbbbbbbb"" 被 “b12” 替代。
  提示：
1 <= chars.length <= 2000
chars[i] 可以是小写英文字母、大写英文字母、数字或符号",298,,65464,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/count-and-say/', 'https://leetcode.cn/problems/encode-and-decode-strings/', 'https://leetcode.cn/problems/design-compressed-string-iterator/']",136941
评论 (55),sequence-reconstruction,Unknown,,-1,,-1,[],[],-1
评论 (789),add-two-numbers-ii,中等,"给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
你可以假设除了数字 0 之外，这两个数字都不会以零开头。
  示例1：
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
示例2：
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[8,0,7]
示例3：
输入：l1 = [0], l2 = [0]
输出：[0]
  提示：
链表的长度范围为 [1, 100]
0 <= node.val <= 9
输入数据保证链表代表的数字无前导 0
  进阶：如果输入链表不能翻转该如何解决？",516,,101782,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/add-two-numbers/'],170592
评论 (154),arithmetic-slices-ii-subsequence,困难,"给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。
如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。
例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。
再例如，[1, 1, 2, 5, 7] 不是等差序列。
数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。
例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。
题目数据保证答案是一个 32-bit 整数。
  示例 1：
输入：nums = [2,4,6,8,10]
输出：7
解释：所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
示例 2：
输入：nums = [7,7,7,7,7]
输出：16
解释：数组中的任意子序列都是等差子序列。
  提示：
1  <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1",253,,21008,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/arithmetic-slices/'],38227
评论 (427),number-of-boomerangs,中等,"给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。
返回平面上所有回旋镖的数量。
  示例 1：
输入：points = [[0,0],[1,0],[2,0]]
输出：2
解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
示例 2：
输入：points = [[1,1],[2,2],[3,3]]
输出：2
示例 3：
输入：points = [[1,1]]
输出：0
  提示：
n == points.length
1 <= n <= 500
points[i].length == 2
-104 <= xi, yi <= 104
所有点都 互不相同",236,,51952,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/line-reflection/'],78053
评论 (1.0k),find-all-numbers-disappeared-in-an-array,简单,"给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。
  示例 1：
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
示例 2：
输入：nums = [1,1]
输出：[2]
  提示：
n == nums.length
1 <= n <= 105
1 <= nums[i] <= n
进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。",986,,197524,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']","['https://leetcode.cn/problems/first-missing-positive/', 'https://leetcode.cn/problems/find-all-duplicates-in-an-array/']",300956
评论 (308),serialize-and-deserialize-bst,中等,"序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。
设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。
编码的字符串应尽可能紧凑。
  示例 1：
输入：root = [2,1,3]
输出：[2,1,3]
示例 2：
输入：root = []
输出：[]
  提示：
树中节点数范围是 [0, 104]
0 <= Node.val <= 104
题目数据 保证 输入的树是一棵二叉搜索树。",359,,42235,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/', 'https://leetcode.cn/problems/find-duplicate-subtrees/', 'https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/']",69708
评论 (617),delete-node-in-a-bst,中等,"给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
一般来说，删除节点可分为两个步骤：
首先找到需要删除的节点；
如果找到了，删除它。
  示例 1:
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
示例 2:
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
示例 3:
输入: root = [], key = 0
输出: []
  提示:
节点数的范围 [0, 104].
-105 <= Node.val <= 105
节点值唯一
root 是合法的二叉搜索树
-105 <= key <= 105
  进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。",762,,112193,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/split-bst/'],221102
评论 (822),sort-characters-by-frequency,中等,"给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。
返回 已排序的字符串 。如果有多个答案，返回其中任何一个。
  示例 1:
输入: s = ""tree""
输出: ""eert""
解释: 'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，""eetr""也是一个有效的答案。
示例 2:
输入: s = ""cccaaa""
输出: ""cccaaa""
解释: 'c'和'a'都出现三次。此外，""aaaccc""也是有效的答案。
注意""cacaca""是不正确的，因为相同的字母必须放在一起。
示例 3:
输入: s = ""Aabb""
输出: ""bbAa""
解释: 此外，""bbaA""也是一个有效的答案，但""Aabb""是不正确的。
注意'A'和'a'被认为是两种不同的字符。
  提示:
1 <= s.length <= 5 * 105
s 由大小写英文字母和数字组成",392,,101286,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/bucket-sort/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/top-k-frequent-elements/', 'https://leetcode.cn/problems/first-unique-character-in-a-string/']",141326
评论 (765),minimum-number-of-arrows-to-burst-balloons,中等,"有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。
一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。
给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。
  示例 1：
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
示例 2：
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。
示例 3：
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。
  提示:
1 <= points.length <= 105
points[i].length == 2
-231 <= xstart < xend <= 231 - 1",596,,139051,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/meeting-rooms-ii/', 'https://leetcode.cn/problems/non-overlapping-intervals/']",274688
评论 (570),minimum-moves-to-equal-array-elements,简单,"给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。
  示例 1：
输入：nums = [1,2,3]
输出：3
解释：
只需要3次操作（注意每次操作会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
示例 2：
输入：nums = [1,1,1]
输出：0
  提示：
n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109
答案保证符合 32-bit 整数",458,,64680,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/'],105348
评论 (475),4sum-ii,中等,"给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：
0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
  示例 1：
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
示例 2：
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
    提示：
n == nums1.length
n == nums2.length
n == nums3.length
n == nums4.length
1 <= n <= 200
-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228",576,,122174,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",['https://leetcode.cn/problems/4sum/'],194614
评论 (1.0k),assign-cookies,简单,"假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
  示例 1:
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
  提示：
1 <= g.length <= 3 * 104
0 <= s.length <= 3 * 104
1 <= g[i], s[j] <= 231 - 1",510,,219523,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],383466
评论 (460),132-pattern,中等,"给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。
如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。
  示例 1：
输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。
示例 2：
输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。
示例 3：
输入：nums = [-1,3,2,0]
输出：true
解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。
  提示：
n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109",659,,65847,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/monotonic-stack/']",[],181325
评论 (388),circular-array-loop,中等,"存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：
如果 nums[i] 是正数，向前（下标递增方向）移动 |nums[i]| 步
如果 nums[i] 是负数，向后（下标递减方向）移动 |nums[i]| 步
因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。
数组中的 循环 由长度为 k 的下标序列 seq 标识：
遵循上述移动规则将导致一组重复下标序列 seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...
所有 nums[seq[j]] 应当不是 全正 就是 全负
k > 1
如果 nums 中存在循环，返回 true ；否则，返回 false 。
  示例 1：
输入：nums = [2,-1,1,2,2]
输出：true
解释：存在循环，按下标 0 -> 2 -> 3 -> 0 。循环长度为 3 。
示例 2：
输入：nums = [-1,2]
输出：false
解释：按下标 1 -> 1 -> 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。
示例 3:
输入：nums = [-2,1,-1,-2,-2]
输出：false
解释：按下标 1 -> 2 -> 1 -> ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。
所有 nums[seq[j]] 应当不是全正就是全负。
  提示：
1 <= nums.length <= 5000
-1000 <= nums[i] <= 1000
nums[i] != 0
  进阶：你能设计一个时间复杂度为 O(n) 且额外空间复杂度为 O(1) 的算法吗？",181,,31827,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/']",[],73166
评论 (461),poor-pigs,困难,"有 buckets 桶液体，其中 正好有一桶 含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有 minutesToTest 分钟时间来确定哪桶液体是有毒的。
喂猪的规则如下：
选择若干活猪进行喂养
可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。
小猪喝完水后，必须有 minutesToDie 分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。
过了 minutesToDie 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。
重复这一过程，直到时间用完。
给你桶的数目 buckets ，minutesToDie 和 minutesToTest ，返回 在规定时间内判断哪个桶有毒所需的 最小 猪数 。
  示例 1：
输入：buckets = 1000, minutesToDie = 15, minutesToTest = 60
输出：5
示例 2：
输入：buckets = 4, minutesToDie = 15, minutesToTest = 15
输出：2
示例 3：
输入：buckets = 4, minutesToDie = 15, minutesToTest = 30
输出：2
  提示：
1 <= buckets <= 1000
1 <= minutesToDie <= minutesToTest <= 100",365,,24594,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/combinatorics/']",[],35218
评论 (722),repeated-substring-pattern,简单,"给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。
  示例 1:
输入: s = ""abab""
输出: true
解释: 可由子串 ""ab"" 重复两次构成。
示例 2:
输入: s = ""aba""
输出: false
示例 3:
输入: s = ""abcabcabcabc""
输出: true
解释: 可由子串 ""abc"" 重复四次构成。 (或子串 ""abcabc"" 重复两次构成。)
  提示：
1 <= s.length <= 104
s 由小写英文字母组成",695,,116299,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/']","['https://leetcode.cn/problems/implement-strstr/', 'https://leetcode.cn/problems/repeated-string-match/']",228775
评论 (587),lfu-cache,困难,"请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。
实现 LFUCache 类：
LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。
void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。
为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。
当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。
函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
  示例：
输入：
[""LFUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""get"", ""put"", ""get"", ""get"", ""get""]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
输出：
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

解释：
// cnt(x) = 键 x 的使用计数
// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // 返回 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // 返回 4
                 // cache=[3,4], cnt(4)=2, cnt(3)=3
  提示：
0 <= capacity <= 104
0 <= key <= 105
0 <= value <= 109
最多调用 2 * 105 次 get 和 put 方法",536,,48124,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/doubly-linked-list/']","['https://leetcode.cn/problems/lru-cache/', 'https://leetcode.cn/problems/design-in-memory-file-system/']",109257
评论 (1.2k),hamming-distance,简单,"两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
给你两个整数 x 和 y，计算并返回它们之间的汉明距离。
  示例 1：
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
示例 2：
输入：x = 3, y = 1
输出：1
  提示：
0 <= x, y <= 231 - 1",603,,214785,['https://leetcode.cn/tag/bit-manipulation/'],"['https://leetcode.cn/problems/number-of-1-bits/', 'https://leetcode.cn/problems/total-hamming-distance/']",263064
评论 (345),minimum-moves-to-equal-array-elements-ii,中等,"给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。
在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。
  示例 1：
输入：nums = [1,2,3]
输出：2
解释：
只需要两步操作（每步操作指南使一个元素加 1 或减 1）：
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
示例 2：
输入：nums = [1,10,2,9]
输出：16
  提示：
n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109",249,,45234,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/best-meeting-point/', 'https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/']",72726
评论 (767),island-perimeter,简单,"给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。
网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
  示例 1：
输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边
示例 2：
输入：grid = [[1]]
输出：4
示例 3：
输入：grid = [[1,0]]
输出：4
  提示：
row == grid.length
col == grid[i].length
1 <= row, col <= 100
grid[i][j] 为 0 或 1",552,,98793,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/max-area-of-island/', 'https://leetcode.cn/problems/flood-fill/', 'https://leetcode.cn/problems/coloring-a-border/']",140562
评论 (13),optimal-account-balancing,Unknown,,-1,,-1,[],[],-1
评论 (282),count-the-repetitions,困难,"定义 str = [s, n] 表示 str 由 n 个字符串 s 连接构成。
例如，str == [""abc"", 3] ==""abcabcabc"" 。
如果可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。
例如，根据定义，s1 = ""abc"" 可以从 s2 = ""abdbec"" 获得，仅需要删除加粗且用斜体标识的字符。
现在给你两个字符串 s1 和 s2 和两个整数 n1 和 n2 。由此构造得到两个字符串，其中 str1 = [s1, n1]、str2 = [s2, n2] 。
请你找出一个最大整数 m ，以满足 str = [str2, m] 可以从 str1 获得。
  示例 1：
输入：s1 = ""acb"", n1 = 4, s2 = ""ab"", n2 = 2
输出：2
示例 2：
输入：s1 = ""acb"", n1 = 1, s2 = ""acb"", n2 = 1
输出：1
  提示：
1 <= s1.length, s2.length <= 100
s1 和 s2 由小写英文字母组成
1 <= n1, n2 <= 106",160,,12443,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],33233
评论 (153),unique-substrings-in-wraparound-string,中等,"把字符串 s 看作是 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的：
""...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...."" . 
现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。 
  示例 1:
输入: p = ""a""
输出: 1
解释: 字符串 s 中只有一个""a""子字符。
示例 2:
输入: p = ""cac""
输出: 2
解释: 字符串 s 中的字符串“cac”只有两个子串“a”、“c”。.
示例 3:
输入: p = ""zab""
输出: 6
解释: 在字符串 s 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。
  提示:
1 <= p.length <= 105
p 由小写英文字母构成",197,,11340,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],25277
评论 (383),validate-ip-address,中等,"给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 ""IPv4"" ；如果是有效的 IPv6 地址，返回 ""IPv6"" ；如果不是上述类型的 IP 地址，返回 ""Neither"" 。
有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 <= xi <= 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。
一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:
1 <= xi.length <= 4
xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )。
在 xi 中允许前导零。
例如 ""2001:0db8:85a3:0000:0000:8a2e:0370:7334"" 和 ""2001:db8:85a3:0:0:8A2E:0370:7334"" 是有效的 IPv6 地址，而 ""2001:0db8:85a3::8A2E:037j:7334"" 和 ""02001:0db8:85a3:0000:0000:8a2e:0370:7334"" 是无效的 IPv6 地址。
  示例 1：
输入：queryIP = ""172.16.254.1""
输出：""IPv4""
解释：有效的 IPv4 地址，返回 ""IPv4""
示例 2：
输入：queryIP = ""2001:0db8:85a3:0:0:8A2E:0370:7334""
输出：""IPv6""
解释：有效的 IPv6 地址，返回 ""IPv6""
示例 3：
输入：queryIP = ""256.256.256.256""
输出：""Neither""
解释：既不是 IPv4 地址，又不是 IPv6 地址
  提示：
queryIP 仅由英文字母，数字，字符 '.' 和 ':' 组成。",138,,33914,['https://leetcode.cn/tag/string/'],['https://leetcode.cn/problems/ip-to-cidr/'],130909
评论 (12),convex-polygon,Unknown,,-1,,-1,[],[],-1
评论 (390),implement-rand10-using-rand7,中等,"给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。
你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。
每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。
  示例 1:
输入: 1
输出: [2]
示例 2:
输入: 2
输出: [2,8]
示例 3:
输入: 3
输出: [3,8,10]
  提示:
1 <= n <= 105
  进阶:
rand7()调用次数的 期望值 是多少 ?
你能否尽量少调用 rand7() ?",397,,82238,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/rejection-sampling/', 'https://leetcode.cn/tag/probability-and-statistics/', 'https://leetcode.cn/tag/randomized/']",[],149205
评论 (7),encode-string-with-shortest-length,Unknown,,-1,,-1,[],[],-1
评论 (280),concatenated-words,困难,"给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。
连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。
  示例 1：
输入：words = [""cat"",""cats"",""catsdogcats"",""dog"",""dogcatsdog"",""hippopotamuses"",""rat"",""ratcatdogcat""]
输出：[""catsdogcats"",""dogcatsdog"",""ratcatdogcat""]
解释：""catsdogcats"" 由 ""cats"", ""dog"" 和 ""cats"" 组成; 
     ""dogcatsdog"" 由 ""dog"", ""cats"" 和 ""dog"" 组成; 
     ""ratcatdogcat"" 由 ""rat"", ""cat"", ""dog"" 和 ""cat"" 组成。
示例 2：
输入：words = [""cat"",""dog"",""catdog""]
输出：[""catdog""]
  提示：
1 <= words.length <= 104
0 <= words[i].length <= 30
words[i] 仅由小写字母组成
0 <= sum(words[i].length) <= 105",253,,23251,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/word-break-ii/'],46359
评论 (218),matchsticks-to-square,中等,"你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。
如果你能使这个正方形，则返回 true ，否则返回 false 。
  示例 1:
输入: matchsticks = [1,1,2,2,2]
输出: true
解释: 能拼成一个边长为2的正方形，每边两根火柴。
示例 2:
输入: matchsticks = [3,3,3,3,4]
输出: false
解释: 不能用所有火柴拼成一个正方形。
  提示:
1 <= matchsticks.length <= 15
1 <= matchsticks[i] <= 108",265,,29130,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",[],68958
评论 (655),ones-and-zeroes,中等,"给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。
  示例 1：
输入：strs = [""10"", ""0001"", ""111001"", ""1"", ""0""], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {""10"",""0001"",""1"",""0""} ，因此答案是 4 。
其他满足题意但较小的子集包括 {""0001"",""1""} 和 {""10"",""1"",""0""} 。{""111001""} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
示例 2：
输入：strs = [""10"", ""0"", ""1""], m = 1, n = 1
输出：2
解释：最大的子集是 {""0"", ""1""} ，所以答案是 2 。
  提示：
1 <= strs.length <= 600
1 <= strs[i].length <= 100
strs[i] 仅由 '0' 和 '1' 组成
1 <= m, n <= 100",727,,106750,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/'],169075
评论 (509),heaters,中等,"冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
在加热器的加热半径范围内的每个房屋都可以获得供暖。
现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。
说明：所有供暖器都遵循你的半径标准，加热的半径也一样。
  示例 1:
输入: houses = [1,2,3], heaters = [2]
输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。
示例 2:
输入: houses = [1,2,3,4], heaters = [1,4]
输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。
示例 3：
输入：houses = [1,5], heaters = [2]
输出：3
  提示：
1 <= houses.length, heaters.length <= 3 * 104
1 <= houses[i], heaters[i] <= 109",397,,57981,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],142687
评论 (807),number-complement,简单,"对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。
例如，整数 5 的二进制表示是 ""101"" ，取反后得到 ""010"" ，再转回十进制表示得到补数 2 。
给你一个整数 num ，输出它的补数。
  示例 1：
输入：num = 5
输出：2
解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
示例 2：
输入：num = 1
输出：0
解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
  提示：
1 <= num < 231
  注意：本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同",300,,70655,['https://leetcode.cn/tag/bit-manipulation/'],[],99505
评论 (294),total-hamming-distance,中等,"两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。
给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间 汉明距离的总和 。
  示例 1：
输入：nums = [4,14,2]
输出：6
解释：在二进制表示中，4 表示为 0100 ，14 表示为 1110 ，2表示为 0010 。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6
示例 2：
输入：nums = [4,14,4]
输出：4
  提示：
1 <= nums.length <= 104
0 <= nums[i] <= 109
给定输入的对应答案符合 32-bit 整数范围",257,,41916,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/hamming-distance/'],69296
评论 (82),generate-random-point-in-a-circle,中等,"给定圆的半径和圆心的位置，实现函数 randPoint ，在圆中产生均匀随机点。
实现 Solution 类:
Solution(double radius, double x_center, double y_center) 用圆的半径 radius 和圆心的位置 (x_center, y_center) 初始化对象
randPoint() 返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 [x, y] 。
  示例 1：
输入: 
[""Solution"",""randPoint"",""randPoint"",""randPoint""]
[[1.0, 0.0, 0.0], [], [], []]
输出: [null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]
解释:
Solution solution = new Solution(1.0, 0.0, 0.0);
solution.randPoint ();//返回[-0.02493，-0.38077]
solution.randPoint ();//返回[0.82314,0.38945]
solution.randPoint ();//返回[0.36572,0.17248]
  提示：
0 < radius <= 108
-107 <= x_center, y_center <= 107
randPoint 最多被调用 3 * 104 次",78,,9010,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/rejection-sampling/', 'https://leetcode.cn/tag/randomized/']",['https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/'],20125
评论 (185),largest-palindrome-product,困难,"给定一个整数 n ，返回 可表示为两个 n 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 1337 取余 。
  示例 1:
输入：n = 2
输出：987
解释：99 x 91 = 9009, 9009 % 1337 = 987
示例 2:
输入： n = 1
输出： 9
  提示:
1 <= n <= 8",124,,21515,['https://leetcode.cn/tag/math/'],[],34334
评论 (459),sliding-window-median,困难,"中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。
例如：
[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。
  示例：
给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。
窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。
  提示：
你可以假设 k 始终有效，即：k 始终小于等于输入的非空数组的元素个数。
与真实值误差在 10 ^ -5 以内的答案将被视作正确答案。",363,,33962,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/heap-priority-queue/']",['https://leetcode.cn/problems/find-median-from-data-stream/'],76131
评论 (122),magical-string,中等,"神奇字符串 s 仅由 '1' 和 '2' 组成，并需要遵守下面的规则：
神奇字符串 s 的神奇之处在于，串联字符串中 '1' 和 '2' 的连续出现次数可以生成该字符串。
s 的前几个元素是 s = ""1221121221221121122……"" 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 ""1 22 11 2 1 22 1 22 11 2 11 22 ......"" 。每组中 1 或者 2 的出现次数分别是 ""1 2 2 1 1 2 1 2 2 1 2 2 ......"" 。上面的出现次数正是 s 自身。
给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。
  示例 1：
输入：n = 6
输出：3
解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。 
示例 2：
输入：n = 1
输出：1
  提示：
1 <= n <= 105",58,,7616,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],13437
评论 (446),license-key-formatting,简单,"给定一个许可密钥字符串 s，仅由字母、数字字符和破折号组成。字符串由 n 个破折号分成 n + 1 组。你也会得到一个整数 k 。
我们想要重新格式化字符串 s，使每一组包含 k 个字符，除了第一组，它可以比 k 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。
返回 重新格式化的许可密钥 。
  示例 1：
输入：S = ""5F3Z-2e-9-w"", k = 4
输出：""5F3Z-2E9W""
解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
示例 2：
输入：S = ""2-5g-3-J"", k = 2
输出：""2-5G-3J""
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
  提示:
1 <= s.length <= 105
s 只包含字母、数字和破折号 '-'.
1 <= k <= 104",140,,47043,['https://leetcode.cn/tag/string/'],[],100011
评论 (162),smallest-good-base,困难,"以字符串的形式给出 n , 以字符串的形式返回 n 的最小 好进制  。
如果 n 的  k(k>=2) 进制数的所有数位全为1，则称 k(k>=2) 是 n 的一个 好进制 。
  示例 1：
输入：n = ""13""
输出：""3""
解释：13 的 3 进制是 111。
示例 2：
输入：n = ""4681""
输出：""8""
解释：4681 的 8 进制是 11111。
示例 3：
输入：n = ""1000000000000000000""
输出：""999999999999999999""
解释：1000000000000000000 的 999999999999999999 进制是 11。
  提示：
n 的取值范围是 [3, 1018]
n 没有前导 0",150,,17497,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],29585
评论 (15),find-permutation,Unknown,,-1,,-1,[],[],-1
评论 (745),max-consecutive-ones,简单,"给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。
  示例 1：
输入：nums = [1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.
示例 2:
输入：nums = [1,0,1,1,0,1]
输出：2
  提示：
1 <= nums.length <= 105
nums[i] 不是 0 就是 1.",319,,154660,['https://leetcode.cn/tag/array/'],"['https://leetcode.cn/problems/max-consecutive-ones-ii/', 'https://leetcode.cn/problems/max-consecutive-ones-iii/']",253224
评论 (469),predict-the-winner,中等,"给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。
玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。
如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。
  示例 1：
输入：nums = [1,5,2]
输出：false
解释：一开始，玩家 1 可以从 1 和 2 中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 false 。
示例 2：
输入：nums = [1,5,233,7]
输出：true
解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。
  提示：
1 <= nums.length <= 20
0 <= nums[i] <= 107",550,,55170,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",['https://leetcode.cn/problems/can-i-win/'],93407
评论 (66),max-consecutive-ones-ii,Unknown,,-1,,-1,[],[],-1
评论 (398),zuma-game,困难,"你正在参与祖玛游戏的一个变种。
在这个祖玛游戏变体中，桌面上有 一排 彩球，每个球的颜色可能是：红色 'R'、黄色 'Y'、蓝色 'B'、绿色 'G' 或白色 'W' 。你的手中也有一些彩球。
你的目标是 清空 桌面上所有的球。每一回合：
从你手上的彩球中选出 任意一颗 ，然后将其插入桌面上那一排球中：两球之间或这一排球的任一端。
接着，如果有出现 三个或者三个以上 且 颜色相同 的球相连的话，就把它们移除掉。
如果这种移除操作同样导致出现三个或者三个以上且颜色相同的球相连，则可以继续移除这些球，直到不再满足移除条件。
如果桌面上所有球都被移除，则认为你赢得本场游戏。
重复这个过程，直到你赢了游戏或者手中没有更多的球。
给你一个字符串 board ，表示桌面上最开始的那排球。另给你一个字符串 hand ，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的 最少 球数。如果不能移除桌上所有的球，返回 -1 。
  示例 1：
输入：board = ""WRRBBW"", hand = ""RB""
输出：-1
解释：无法移除桌面上的所有球。可以得到的最好局面是：
- 插入一个 'R' ，使桌面变为 WRRRBBW 。WRRRBBW -> WBBW
- 插入一个 'B' ，使桌面变为 WBBBW 。WBBBW -> WW
桌面上还剩着球，没有其他球可以插入。
示例 2：
输入：board = ""WWRRBBWW"", hand = ""WRBRW""
输出：2
解释：要想清空桌面上的球，可以按下述步骤：
- 插入一个 'R' ，使桌面变为 WWRRRBBWW 。WWRRRBBWW -> WWBBWW
- 插入一个 'B' ，使桌面变为 WWBBBWW 。WWBBBWW -> WWWW -> empty
只需从手中出 2 个球就可以清空桌面。
示例 3：
输入：board = ""G"", hand = ""GGGGG""
输出：2
解释：要想清空桌面上的球，可以按下述步骤：
- 插入一个 'G' ，使桌面变为 GG 。
- 插入一个 'G' ，使桌面变为 GGG 。GGG -> empty
只需从手中出 2 个球就可以清空桌面。
示例 4：
输入：board = ""RBYYBBRRB"", hand = ""YRBGB""
输出：3
解释：要想清空桌面上的球，可以按下述步骤：
- 插入一个 'Y' ，使桌面变为 RBYYYBBRRB 。RBYYYBBRRB -> RBBBRRB -> RRRB -> B
- 插入一个 'B' ，使桌面变为 BB 。
- 插入一个 'B' ，使桌面变为 BBB 。BBB -> empty
只需从手中出 3 个球就可以清空桌面。
  提示：
1 <= board.length <= 16
1 <= hand.length <= 5
board 和 hand 由字符 'R'、'Y'、'B'、'G' 和 'W' 组成
桌面上一开始的球中，不会有三个及三个以上颜色相同且连着的球",257,,18810,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],36951
评论 (24),robot-room-cleaner,Unknown,,-1,,-1,[],[],-1
评论 (76),the-maze,Unknown,,-1,,-1,[],[],-1
评论 (560),increasing-subsequences,中等,"给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。
数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
  示例 1：
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
示例 2：
输入：nums = [4,4,3,2,1]
输出：[[4,4]]
  提示：
1 <= nums.length <= 15
-100 <= nums[i] <= 100",448,,78863,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/maximum-length-of-pair-chain/'],149002
评论 (324),construct-the-rectangle,简单,"作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 所以，现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：
你设计的矩形页面必须等于给定的目标面积。
宽度 W 不应大于长度 L ，换言之，要求 L >= W 。
长度 L 和宽度 W 之间的差距应当尽可能小。
返回一个 数组 [L, W]，其中 L 和 W 是你按照顺序设计的网页的长度和宽度。
  示例1：
输入: 4
输出: [2, 2]
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。
示例 2:
输入: area = 37
输出: [37,1]
示例 3:
输入: area = 122122
输出: [427,286]
  提示:
1 <= area <= 107",118,,49259,['https://leetcode.cn/tag/math/'],[],81143
评论 (333),reverse-pairs,困难,"给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。
你需要返回给定数组中的重要翻转对的数量。
示例 1:
输入: [1,3,2,3,1]
输出: 2
示例 2:
输入: [2,4,3,5,1]
输出: 3
注意:
给定数组的长度不会超过50000。
输入数组中的所有数字都在32位整数的表示范围内。",354,,31103,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/merge-sort/']","['https://leetcode.cn/problems/count-of-smaller-numbers-after-self/', 'https://leetcode.cn/problems/count-of-range-sum/']",87891
评论 (1.0k),target-sum,中等,"给你一个整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：
例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 ""+2-1"" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
  示例 1：
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
示例 2：
输入：nums = [1], target = 1
输出：1
  提示：
1 <= nums.length <= 20
0 <= nums[i] <= 1000
0 <= sum(nums[i]) <= 1000
-1000 <= target <= 1000",1214,,228404,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/expression-add-operators/'],465507
评论 (803),teemo-attacking,简单,"在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。
当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。
正式地讲，提莫在 t 发起发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。
给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。
返回艾希处于中毒状态的 总 秒数。
  示例 1：
输入：timeSeries = [1,4], duration = 2
输出：4
解释：提莫攻击对艾希的影响如下：
- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。
- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。
艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。
示例 2：
输入：timeSeries = [1,2], duration = 2
输出：3
解释：提莫攻击对艾希的影响如下：
- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。
- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。
艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。
  提示：
1 <= timeSeries.length <= 104
0 <= timeSeries[i], duration <= 107
timeSeries 按 非递减 顺序排列",301,,74036,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']","['https://leetcode.cn/problems/merge-intervals/', 'https://leetcode.cn/problems/can-place-flowers/', 'https://leetcode.cn/problems/dota2-senate/']",122703
评论 (1.1k),next-greater-element-i,简单,"nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。
给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。
对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。
返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。
  示例 1：
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
示例 2：
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
  提示：
1 <= nums1.length <= nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 104
nums1和nums2中所有整数 互不相同
nums1 中的所有整数同样出现在 nums2 中
  进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？",734,,184466,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/monotonic-stack/']","['https://leetcode.cn/problems/next-greater-element-ii/', 'https://leetcode.cn/problems/next-greater-element-iii/', 'https://leetcode.cn/problems/daily-temperatures/']",259049
评论 (62),random-point-in-non-overlapping-rectangles,中等,"给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角角点。设计一个算法来挑选一个随机整数点内的空间所覆盖的一个给定的矩形。矩形周长上的一个点包含在矩形覆盖的空间中。
在一个给定的矩形覆盖的空间内任何整数点都有可能被返回。
请注意 ，整数点是具有整数坐标的点。
实现 Solution 类:
Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。
int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。
  示例 1：
输入: 
[""Solution"",""pick"",""pick"",""pick"",""pick"",""pick""]
[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]
输出: 
[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]

解释：
Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);
solution.pick(); // 返回 [1, -2]
solution.pick(); // 返回 [1, -1]
solution.pick(); // 返回 [-1, -2]
solution.pick(); // 返回 [-2, -2]
solution.pick(); // 返回 [0, 0]
  提示：
1 <= rects.length <= 100
rects[i].length == 4
-109 <= ai < xi <= 109
-109 <= bi < yi <= 109
xi - ai <= 2000
yi - bi <= 2000
所有的矩形不重叠。
pick 最多被调用 104 次。
 ",54,,4208,"['https://leetcode.cn/tag/reservoir-sampling/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/randomized/']","['https://leetcode.cn/problems/random-pick-with-weight/', 'https://leetcode.cn/problems/generate-random-point-in-a-circle/']",10322
评论 (355),diagonal-traverse,中等,"给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。
  示例 1：
输入：mat = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,4,7,5,3,6,8,9]
示例 2：
输入：mat = [[1,2],[3,4]]
输出：[1,2,3,4]
  提示：
m == mat.length
n == mat[i].length
1 <= m, n <= 104
1 <= m * n <= 104
-105 <= mat[i][j] <= 105",297,https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg,60434,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],120778
评论 (28),the-maze-iii,Unknown,,-1,,-1,[],[],-1
评论 (664),keyboard-row,简单,"给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。
美式键盘 中：
第一行由字符 ""qwertyuiop"" 组成。
第二行由字符 ""asdfghjkl"" 组成。
第三行由字符 ""zxcvbnm"" 组成。
  示例 1：
输入：words = [""Hello"",""Alaska"",""Dad"",""Peace""]
输出：[""Alaska"",""Dad""]
示例 2：
输入：words = [""omk""]
输出：[]
示例 3：
输入：words = [""adsdf"",""sfd""]
输出：[""adsdf"",""sfd""]
  提示：
1 <= words.length <= 20
1 <= words[i].length <= 100
words[i] 由英文字母（小写和大写字母）组成",210,,58476,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],78577
评论 (475),find-mode-in-binary-search-tree,简单,"给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。
如果树中有不止一个众数，可以按 任意顺序 返回。
假定 BST 满足如下定义：
结点左子树中所含节点的值 小于等于 当前节点的值
结点右子树中所含节点的值 大于等于 当前节点的值
左子树和右子树都是二叉搜索树
  示例 1：
输入：root = [1,null,2,2]
输出：[2]
示例 2：
输入：root = [0]
输出：[0]
  提示：
树中节点的数目在范围 [1, 104] 内
-105 <= Node.val <= 105
  进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）",461,https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg,100438,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/validate-binary-search-tree/'],188695
评论 (406),ipo,困难,"假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。
给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。
最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。
总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。
答案保证在 32 位有符号整数范围内。
  示例 1：
输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
输出：4
解释：
由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
示例 2：
输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
输出：6
  提示：
1 <= k <= 105
0 <= w <= 109
n == profits.length
n == capital.length
1 <= n <= 105
0 <= profits[i] <= 104
0 <= capital[i] <= 109",231,,31780,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],71563
评论 (675),next-greater-element-ii,中等,"给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。
数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。
  示例 1:
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
示例 2:
输入: nums = [1,2,3,4,3]
输出: [2,3,4,-1,4]
  提示:
1 <= nums.length <= 104
-109 <= nums[i] <= 109",631,,140780,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/monotonic-stack/']","['https://leetcode.cn/problems/next-greater-element-i/', 'https://leetcode.cn/problems/next-greater-element-iii/']",215719
评论 (555),base-7,简单,"给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。
  示例 1:
输入: num = 100
输出: ""202""
示例 2:
输入: num = -7
输出: ""-10""
  提示：
-107 <= num <= 107",179,,74149,['https://leetcode.cn/tag/math/'],[],142287
评论 (37),the-maze-ii,Unknown,,-1,,-1,[],[],-1
评论 (558),relative-ranks,简单,"给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。
运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：
名次第 1 的运动员获金牌 ""Gold Medal"" 。
名次第 2 的运动员获银牌 ""Silver Medal"" 。
名次第 3 的运动员获铜牌 ""Bronze Medal"" 。
从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 ""x""）。
使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。
  示例 1：
输入：score = [5,4,3,2,1]
输出：[""Gold Medal"",""Silver Medal"",""Bronze Medal"",""4"",""5""]
解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。
示例 2：
输入：score = [10,3,8,9,4]
输出：[""Gold Medal"",""5"",""Bronze Medal"",""Silver Medal"",""4""]
解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。
  提示：
n == score.length
1 <= n <= 104
0 <= score[i] <= 106
score 中的所有值 互不相同",179,,64030,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],98108
评论 (655),perfect-number,简单,"对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。
给定一个 整数 n， 如果是完美数，返回 true；否则返回 false。
  示例 1：
输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
示例 2：
输入：num = 7
输出：false
  提示：
1 <= num <= 108",179,,65415,['https://leetcode.cn/tag/math/'],['https://leetcode.cn/problems/self-dividing-numbers/'],133352
评论 (240),most-frequent-subtree-sum,中等,"给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。
一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。
  示例 1：
输入: root = [5,2,-3]
输出: [2,-3,4]
示例 2：
输入: root = [5,2,-5]
输出: [2]
  提示:
节点数在 [1, 104] 范围内
-105 <= Node.val <= 105",145,,18452,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/subtree-of-another-tree/'],26902
评论 (1.4k),fibonacci-number,简单,"斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。
  示例 1：
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
示例 2：
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 3：
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
  提示：
0 <= n <= 30",462,,390596,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/climbing-stairs/', 'https://leetcode.cn/problems/split-array-into-fibonacci-sequence/', 'https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/']",586225
评论 (37),inorder-successor-in-bst-ii,Unknown,,-1,,-1,[],[],-1
评论 (170),game-play-analysis-i,简单,"SQL架构
活动表 Activity：
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
表的主键是 (player_id, event_date)。
这张表展示了一些游戏玩家在游戏平台上的行为活动。
每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。
  写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。
查询结果的格式如下所示：
Activity 表：
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+

Result 表：
+-----------+-------------+
| player_id | first_login |
+-----------+-------------+
| 1         | 2016-03-01  |
| 2         | 2017-06-25  |
| 3         | 2016-03-02  |
+-----------+-------------+",49,,37777,['https://leetcode.cn/tag/database/'],['https://leetcode.cn/problems/game-play-analysis-ii/'],52167
评论 (280),game-play-analysis-ii,Unknown,,-1,,-1,[],[],-1
评论 (519),find-bottom-left-tree-value,中等,"给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。
假设二叉树中至少有一个节点。
  示例 1:
输入: root = [2,1,3]
输出: 1
示例 2:
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
  提示:
二叉树的节点个数的范围是 [1,104]
-231 <= Node.val <= 231 - 1 ",276,,90653,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],123917
评论 (380),freedom-trail,困难,"电子游戏“辐射4”中，任务 “通向自由” 要求玩家到达名为 “Freedom Trail Ring” 的金属表盘，并使用表盘拼写特定关键词才能开门。
给定一个字符串 ring ，表示刻在外环上的编码；给定另一个字符串 key ，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。
最初，ring 的第一个字符与 12:00 方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。
旋转 ring 拼出 key 字符 key[i] 的阶段中：
您可以将 ring 顺时针或逆时针旋转 一个位置 ，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
  示例 1：
  输入: ring = ""godding"", key = ""gd""
输出: 4
解释:
 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 
 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring ""godding"" 2步使它变成 ""ddinggo""。
 当然, 我们还需要1步进行拼写。
 因此最终的输出是 4。
示例 2:
输入: ring = ""godding"", key = ""godding""
输出: 13
  提示：
1 <= ring.length, key.length <= 100
ring 和 key 只包含小写英文字母
保证 字符串 key 一定可以由字符串  ring 旋转拼出",239,,22660,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],44987
评论 (348),find-largest-value-in-each-tree-row,中等,"给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。
  示例1：
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
示例2：
输入: root = [1,2,3]
输出: [1,3]
  提示：
二叉树的节点个数的范围是 [0,104]
-231 <= Node.val <= 231 - 1
 ",194,,63061,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],96001
评论 (470),longest-palindromic-subsequence,中等,"给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
  示例 1：
输入：s = ""bbbab""
输出：4
解释：一个可能的最长回文子序列为 ""bbbb"" 。
示例 2：
输入：s = ""cbbd""
输出：2
解释：一个可能的最长回文子序列为 ""bb"" 。
  提示：
1 <= s.length <= 1000
s 仅由小写英文字母组成",798,,123949,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/longest-palindromic-substring/', 'https://leetcode.cn/problems/palindromic-substrings/', 'https://leetcode.cn/problems/count-different-palindromic-subsequences/']",186418
评论 (239),super-washing-machines,困难,"假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。
在每一步操作中，你可以选择任意 m (1 <= m <= n) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。
给定一个整数数组 machines 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 最少的操作步数 。如果不能使每台洗衣机中衣物的数量相等，则返回 -1 。
  示例 1：
输入：machines = [1,0,5]
输出：3
解释：
第一步:    1     0 <-- 5    =>    1     1     4
第二步:    1 <-- 1 <-- 4    =>    2     1     3    
第三步:    2     1 <-- 3    =>    2     2     2   
示例 2：
输入：machines = [0,3,0]
输出：2
解释：
第一步:    0 <-- 3     0    =>    1     2     0    
第二步:    1     2 --> 0    =>    1     1     1     
示例 3：
输入：machines = [0,2,0]
输出：-1
解释：
不可能让所有三个洗衣机同时剩下相同数量的衣物。
  提示：
n == machines.length
1 <= n <= 104
0 <= machines[i] <= 105",224,,21251,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],41625
评论 (523),coin-change-2,中等,"给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
假设每一种面额的硬币有无限个。 
题目数据保证结果符合 32 位带符号整数。
  示例 1：
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2：
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
示例 3：
输入：amount = 10, coins = [10] 
输出：1
  提示：
1 <= coins.length <= 300
1 <= coins[i] <= 5000
coins 中的所有值 互不相同
0 <= amount <= 5000",820,,162202,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],237073
评论 (176),random-flip-matrix,中等,"给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。
尽量最少调用内置的随机函数，并且优化时间和空间复杂度。
实现 Solution 类：
Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象
int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1
void reset() 将矩阵中所有的值重置为 0
  示例：
输入
[""Solution"", ""flip"", ""flip"", ""flip"", ""reset"", ""flip""]
[[3, 1], [], [], [], [], []]
输出
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

解释
Solution solution = new Solution(3, 1);
solution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
solution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同
solution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]
solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回
solution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
  提示：
1 <= m, n <= 104
每次调用flip 时，矩阵中至少存在一个值为 0 的格子。
最多调用 1000 次 flip 和 reset 方法。",138,,20319,"['https://leetcode.cn/tag/reservoir-sampling/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/randomized/']",[],43517
评论 (814),detect-capital,简单,"我们定义，在以下情况时，单词的大写用法是正确的：
全部字母都是大写，比如 ""USA"" 。
单词中所有字母都不是大写，比如 ""leetcode"" 。
如果单词不只含有一个字母，只有首字母大写， 比如 ""Google"" 。
给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。
  示例 1：
输入：word = ""USA""
输出：true
示例 2：
输入：word = ""FlaG""
输出：false
  提示：
1 <= word.length <= 100
word 由小写和大写英文字母组成",205,,74472,['https://leetcode.cn/tag/string/'],[],129852
评论 (800),longest-uncommon-subsequence-i,简单,"给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列  的长度。如果不存在，则返回 -1 。
「最长特殊序列」 定义如下：该序列为 某字符串独有的最长子序列（即不能是其他字符串的子序列） 。
字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。
例如，""abc"" 是 ""aebdc"" 的子序列，因为删除 ""aebdc"" 中斜体加粗的字符可以得到 ""abc"" 。 ""aebdc"" 的子序列还包括 ""aebdc"" 、 ""aeb"" 和 """" (空字符串)。
  示例 1：
输入: a = ""aba"", b = ""cdc""
输出: 3
解释: 最长特殊序列可为 ""aba"" (或 ""cdc"")，两者均为自身的子序列且不是对方的子序列。
示例 2：
输入：a = ""aaa"", b = ""bbb""
输出：3
解释: 最长特殊序列是 ""aaa"" 和 ""bbb"" 。
示例 3：
输入：a = ""aaa"", b = ""aaa""
输出：-1
解释: 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。
  提示：
1 <= a.length, b.length <= 100
a 和 b 由小写英文字母组成",215,,55878,['https://leetcode.cn/tag/string/'],['https://leetcode.cn/problems/longest-uncommon-subsequence-ii/'],75706
评论 (135),longest-uncommon-subsequence-ii,中等,"给定字符串列表 strs ，返回 它们中 最长的特殊序列 。如果最长特殊序列不存在，返回 -1 。
最长特殊序列 定义如下：该序列为某字符串 独有的最长子序列（即不能是其他字符串的子序列）。
 s 的 子序列可以通过删去字符串 s 中的某些字符实现。
例如，""abc"" 是 ""aebdc"" 的子序列，因为您可以删除""aebdc""中的下划线字符来得到 ""abc"" 。""aebdc""的子序列还包括""aebdc""、 ""aeb"" 和 """" (空字符串)。
  示例 1：
输入: strs = [""aba"",""cdc"",""eae""]
输出: 3
示例 2:
输入: strs = [""aaa"",""aaa"",""aa""]
输出: -1
  提示:
2 <= strs.length <= 50
1 <= strs[i].length <= 10
strs[i] 只包含小写英文字母",93,,9502,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/longest-uncommon-subsequence-i/'],25415
评论 (748),continuous-subarray-sum,中等,"给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：
子数组大小 至少为 2 ，且
子数组元素总和为 k 的倍数。
如果存在，返回 true ；否则，返回 false 。
如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。
  示例 1：
输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
示例 2：
输入：nums = [23,2,6,4,7], k = 6
输出：true
解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。
示例 3：
输入：nums = [23,2,6,4,7], k = 13
输出：false
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 109
0 <= sum(nums[i]) <= 231 - 1
1 <= k <= 231 - 1",436,,80513,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/prefix-sum/']",['https://leetcode.cn/problems/subarray-sum-equals-k/'],287645
评论 (666),longest-word-in-dictionary-through-deleting,中等,"给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。
如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。
  示例 1：
输入：s = ""abpcplea"", dictionary = [""ale"",""apple"",""monkey"",""plea""]
输出：""apple""
示例 2：
输入：s = ""abpcplea"", dictionary = [""a"",""b"",""c""]
输出：""a""
  提示：
1 <= s.length <= 1000
1 <= dictionary.length <= 1000
1 <= dictionary[i].length <= 1000
s 和 dictionary[i] 仅由小写英文字母组成",302,,86338,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/longest-word-in-dictionary/'],173211
评论 (460),contiguous-array,中等,"给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。
  示例 1:
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
示例 2:
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
  提示：
1 <= nums.length <= 105
nums[i] 不是 0 就是 1",559,,55583,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']",['https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/'],102423
评论 (381),beautiful-arrangement,中等,"假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：
perm[i] 能够被 i 整除
i 能够被 perm[i] 整除
给你一个整数 n ，返回可以构造的 优美排列 的 数量 。
  示例 1：
输入：n = 2
输出：2
解释：
第 1 个优美的排列是 [1,2]：
    - perm[1] = 1 能被 i = 1 整除
    - perm[2] = 2 能被 i = 2 整除
第 2 个优美的排列是 [2,1]:
    - perm[1] = 2 能被 i = 1 整除
    - i = 2 能被 perm[2] = 1 整除
示例 2：
输入：n = 1
输出：1
  提示：
1 <= n <= 15",294,,38806,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",['https://leetcode.cn/problems/beautiful-arrangement-ii/'],52975
评论 (13),word-abbreviation,Unknown,,-1,,-1,[],[],-1
评论 (397),random-pick-with-weight,中等,"给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。
请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w) 。
例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。
  示例 1：
输入：
[""Solution"",""pickIndex""]
[[[1]],[]]
输出：
[null,0]
解释：
Solution solution = new Solution([1]);
solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。
示例 2：
输入：
[""Solution"",""pickIndex"",""pickIndex"",""pickIndex"",""pickIndex"",""pickIndex""]
[[[1,3]],[],[],[],[],[]]
输出：
[null,1,1,1,1,0]
解释：
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。

由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
诸若此类。
  提示：
1 <= w.length <= 104
1 <= w[i] <= 105
pickIndex 将被调用不超过 104 次",237,,41484,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/randomized/']","['https://leetcode.cn/problems/random-pick-index/', 'https://leetcode.cn/problems/random-pick-with-blacklist/', 'https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/']",86411
评论 (448),minesweeper,中等,"让我们一起来玩扫雷游戏！
给你一个大小为 m x n 二维字符矩阵 board ，表示扫雷游戏的盘面，其中：
'M' 代表一个 未挖出的 地雷，
'E' 代表一个 未挖出的 空方块，
'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 已挖出的 空白方块，
数字（'1' 到 '8'）表示有多少地雷与这块 已挖出的 方块相邻，
'X' 则表示一个 已挖出的 地雷。
给你一个整数数组 click ，其中 click = [clickr, clickc] 表示在所有 未挖出的 方块（'M' 或者 'E'）中的下一个点击位置（clickr 是行下标，clickc 是列下标）。
根据以下规则，返回相应位置被点击后对应的盘面：
如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X' 。
如果一个 没有相邻地雷 的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。
如果一个 至少与一个地雷相邻 的空方块（'E'）被挖出，修改它为数字（'1' 到 '8' ），表示相邻地雷的数量。
如果在此次点击中，若无更多方块可被揭露，则返回盘面。
  示例 1：
输入：board = [[""E"",""E"",""E"",""E"",""E""],[""E"",""E"",""M"",""E"",""E""],[""E"",""E"",""E"",""E"",""E""],[""E"",""E"",""E"",""E"",""E""]], click = [3,0]
输出：[[""B"",""1"",""E"",""1"",""B""],[""B"",""1"",""M"",""1"",""B""],[""B"",""1"",""1"",""1"",""B""],[""B"",""B"",""B"",""B"",""B""]]
示例 2：
输入：board = [[""B"",""1"",""E"",""1"",""B""],[""B"",""1"",""M"",""1"",""B""],[""B"",""1"",""1"",""1"",""B""],[""B"",""B"",""B"",""B"",""B""]], click = [1,2]
输出：[[""B"",""1"",""E"",""1"",""B""],[""B"",""1"",""X"",""1"",""B""],[""B"",""1"",""1"",""1"",""B""],[""B"",""B"",""B"",""B"",""B""]]
  提示：
m == board.length
n == board[i].length
1 <= m, n <= 50
board[i][j] 为 'M'、'E'、'B' 或数字 '1' 到 '8' 中的一个
click.length == 2
0 <= clickr < m
0 <= clickc < n
board[clickr][clickc] 为 'M' 或 'E'",287,https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png,44876,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],69663
评论 (642),minimum-absolute-difference-in-bst,简单,"给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。
差值是一个正数，其数值等于两值之差的绝对值。
  示例 1：
输入：root = [4,2,6,1,3]
输出：1
示例 2：
输入：root = [1,0,48,null,null,12,49]
输出：1
  提示：
树中节点的数目范围是 [2, 104]
0 <= Node.val <= 105
  注意：本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同",344,https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg,115428,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/k-diff-pairs-in-an-array/'],183663
评论 (37),lonely-pixel-i,Unknown,,-1,,-1,[],[],-1
评论 (297),k-diff-pairs-in-an-array,中等,"给定一个整数数组和一个整数 k，你需要在数组里找到 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。
这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：
0 <= i < j < nums.length
|nums[i] - nums[j]| == k
注意，|val| 表示 val 的绝对值。
  示例 1：
输入：nums = [3, 1, 4, 1, 5], k = 2
输出：2
解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
示例 2：
输入：nums = [1, 2, 3, 4, 5], k = 1
输出：4
解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
示例 3：
输入：nums = [1, 3, 1, 5, 4], k = 0
输出：1
解释：数组中只有一个 0-diff 数对，(1, 1)。
  提示：
1 <= nums.length <= 104
-107 <= nums[i] <= 107
0 <= k <= 107",165,,29092,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/minimum-absolute-difference-in-bst/'],75412
评论 (45),lonely-pixel-ii,Unknown,,-1,,-1,[],[],-1
评论 (174),game-play-analysis-iii,Unknown,,-1,,-1,[],[],-1
评论 (191),encode-and-decode-tinyurl,中等,"TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。
加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。
实现 Solution 类：
Solution() 初始化 TinyURL 系统对象。
String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。
String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。
  示例：
输入：url = ""https://leetcode.com/problems/design-tinyurl""
输出：""https://leetcode.com/problems/design-tinyurl""

解释：
Solution obj = new Solution();
string tiny = obj.encode(url); // 返回加密后得到的 TinyURL 。
string ans = obj.decode(tiny); // 返回解密后得到的原本的 URL 。
  提示：
1 <= url.length <= 104
题目数据保证 url 是一个有效的 URL",146,,18598,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/hash-function/']",[],21963
评论 (35),construct-binary-tree-from-string,Unknown,,-1,,-1,[],[],-1
评论 (514),complex-number-multiplication,中等,"复数 可以用字符串表示，遵循 ""实部+虚部i"" 的形式，并满足下述条件：
实部 是一个整数，取值范围是 [-100, 100]
虚部 也是一个整数，取值范围是 [-100, 100]
i2 == -1
给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。
  示例 1：
输入：num1 = ""1+1i"", num2 = ""1+1i""
输出：""0+2i""
解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。
示例 2：
输入：num1 = ""1+-1i"", num2 = ""1+-1i""
输出：""0+-2i""
解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 
  提示：
num1 和 num2 都是有效的复数表示。",137,,40429,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],53993
评论 (822),convert-bst-to-greater-tree,中等,"给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
提醒一下，二叉搜索树满足下列约束条件：
节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。
注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同
  示例 1：
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
示例 2：
输入：root = [0,null,1]
输出：[1,null,1]
示例 3：
输入：root = [1,0,2]
输出：[3,3,2]
示例 4：
输入：root = [3,2,4,1]
输出：[7,9,4,10]
  提示：
树中的节点数介于 0 和 104 之间。
每个节点的值介于 -104 和 104 之间。
树中的所有值 互不相同 。
给定的树为二叉搜索树。",724,,159668,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",[],216529
评论 (427),minimum-time-difference,中等,"给定一个 24 小时制（小时:分钟 ""HH:MM""）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
  示例 1：
输入：timePoints = [""23:59"",""00:00""]
输出：1
示例 2：
输入：timePoints = [""00:00"",""23:59"",""00:00""]
输出：0
  提示：
2 <= timePoints.length <= 2 * 104
timePoints[i] 格式为 ""HH:MM""",197,,53412,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],80359
评论 (903),single-element-in-a-sorted-array,中等,"给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。
请你找出并返回只出现一次的那个数。
你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。
  示例 1:
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:
输入: nums =  [3,3,7,7,10,11,11]
输出: 10
  提示:
1 <= nums.length <= 105
0 <= nums[i] <= 105",510,,96387,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],158352
评论 (782),reverse-string-ii,简单,"给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
  示例 1：
输入：s = ""abcdefg"", k = 2
输出：""bacdfeg""
示例 2：
输入：s = ""abcd"", k = 2
输出：""bacd""
  提示：
1 <= s.length <= 104
s 仅由小写英文组成
1 <= k <= 104",299,,115929,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/reverse-string/', 'https://leetcode.cn/problems/reverse-words-in-a-string-iii/']",195022
评论 (491),01-matrix,中等,"给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。
两个相邻元素间的距离为 1 。
  示例 1：
输入：mat = [[0,0,0],[0,1,0],[0,0,0]]
输出：[[0,0,0],[0,1,0],[0,0,0]]
示例 2：
输入：mat = [[0,0,0],[0,1,0],[1,1,1]]
输出：[[0,0,0],[0,1,0],[1,2,1]]
  提示：
m == mat.length
n == mat[i].length
1 <= m, n <= 104
1 <= m * n <= 104
mat[i][j] is either 0 or 1.
mat 中至少有一个 0 ",697,,102931,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],222685
评论 (986),diameter-of-binary-tree,简单,"给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
  示例 :
给定二叉树
          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
  注意：两结点之间的路径长度是以它们之间边的数目表示。",1044,,220433,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],386842
评论 (18),output-contest-matches,Unknown,,-1,,-1,[],[],-1
评论 (38),boundary-of-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (208),remove-boxes,困难,"给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。
你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k * k 个积分。
返回 你能获得的最大积分和 。
  示例 1：
输入：boxes = [1,3,2,2,2,3,4,3,1]
输出：23
解释：
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----> [1, 3, 3, 3, 1] (1*1=1 分) 
----> [1, 1] (3*3=9 分) 
----> [] (2*2=4 分)
示例 2：
输入：boxes = [1,1,1]
输出：9
示例 3：
输入：boxes = [1]
输出：1
  提示：
1 <= boxes.length <= 100
1 <= boxes[i] <= 100",345,,16367,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/strange-printer/'],26259
评论 (895),number-of-provinces,中等,"有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。
返回矩阵中 省份 的数量。
  示例 1：
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
示例 2：
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
  提示：
1 <= n <= 200
n == isConnected.length
n == isConnected[i].length
isConnected[i][j] 为 1 或 0
isConnected[i][i] == 1
isConnected[i][j] == isConnected[j][i]",793,,211586,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']","['https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/', 'https://leetcode.cn/problems/robot-return-to-origin/', 'https://leetcode.cn/problems/sentence-similarity/', 'https://leetcode.cn/problems/sentence-similarity-ii/', 'https://leetcode.cn/problems/the-earliest-moment-when-everyone-become-friends/']",340895
评论 (25),split-array-with-equal-sum,Unknown,,-1,,-1,[],[],-1
评论 (43),binary-tree-longest-consecutive-sequence-ii,Unknown,,-1,,-1,[],[],-1
评论 (338),game-play-analysis-iv,Unknown,,-1,,-1,[],[],-1
评论 (684),student-attendance-record-i,简单,"给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
'A'：Absent，缺勤
'L'：Late，迟到
'P'：Present，到场
如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
按 总出勤 计，学生缺勤（'A'）严格 少于两天。
学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。
  示例 1：
输入：s = ""PPALLP""
输出：true
解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。
示例 2：
输入：s = ""PPALLL""
输出：false
解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。
  提示：
1 <= s.length <= 1000
s[i] 为 'A'、'L' 或 'P'",132,,66478,['https://leetcode.cn/tag/string/'],['https://leetcode.cn/problems/student-attendance-record-ii/'],117110
评论 (322),student-attendance-record-ii,困难,"可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
'A'：Absent，缺勤
'L'：Late，迟到
'P'：Present，到场
如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
按 总出勤 计，学生缺勤（'A'）严格 少于两天。
学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。
  示例 1：
输入：n = 2
输出：8
解释：
有 8 种长度为 2 的记录将被视为可奖励：
""PP"" , ""AP"", ""PA"", ""LP"", ""PL"", ""AL"", ""LA"", ""LL"" 
只有""AA""不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
示例 2：
输入：n = 1
输出：3
示例 3：
输入：n = 10101
输出：183236316
  提示：
1 <= n <= 105",267,,25820,['https://leetcode.cn/tag/dynamic-programming/'],['https://leetcode.cn/problems/student-attendance-record-i/'],44744
评论 (334),optimal-division,中等,"给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -> 2 / 3 / 4 。
但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。
示例：
输入: [1000,100,10,2]
输出: ""1000/(100/10/2)""
解释:
1000/(100/10/2) = 1000/((100/10)/2) = 200
但是，以下加粗的括号 ""1000/((100/10)/2)"" 是冗余的，
因为他们并不影响操作的优先级，所以你需要返回 ""1000/(100/10/2)""。

其他用例:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2
说明:
输入数组的长度在 [1, 10] 之间。
数组中每个元素的大小都在 [2, 1000] 之间。
每个测试用例只有一个最优除法解。",187,,28603,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],44005
评论 (366),brick-wall,中等,"你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。
你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。
给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。
  示例 1：
输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
输出：2
示例 2：
输入：wall = [[1],[1],[1]]
输出：3
  提示：
n == wall.length
1 <= n <= 104
1 <= wall[i].length <= 104
1 <= sum(wall[i].length) <= 2 * 104
对于每一行 i ，sum(wall[i]) 是相同的
1 <= wall[i][j] <= 231 - 1",284,https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg,51335,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],101047
评论 (11),split-concatenated-strings,Unknown,,-1,,-1,[],[],-1
评论 (236),next-greater-element-iii,中等,"给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。
注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1 。
  示例 1：
输入：n = 12
输出：21
示例 2：
输入：n = 21
输出：-1
  提示：
1 <= n <= 231 - 1",206,,20129,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/next-greater-element-i/', 'https://leetcode.cn/problems/next-greater-element-ii/']",60323
评论 (1.4k),reverse-words-in-a-string-iii,简单,"给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
  示例 1：
输入：s = ""Let's take LeetCode contest""
输出：""s'teL ekat edoCteeL tsetnoc""
示例 2:
输入： s = ""God Ding""
输出：""doG gniD""
  提示：
1 <= s.length <= 5 * 104
s 包含可打印的 ASCII 字符。
s 不包含任何开头或结尾空格。
s 里 至少 有一个词。
s 中的所有单词都用一个空格隔开。",444,,240268,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/reverse-string-ii/'],323907
评论 (73),logical-or-of-two-binary-grids-represented-as-quad-trees,中等,"二进制矩阵中的所有元素不是 0 就是 1 。
给你两个四叉树，quadTree1 和 quadTree2。其中 quadTree1 表示一个 n * n 二进制矩阵，而 quadTree2 表示另一个 n * n 二进制矩阵。
请你返回一个表示 n * n 二进制矩阵的四叉树，它是 quadTree1 和 quadTree2 所表示的两个二进制矩阵进行 按位逻辑或运算 的结果。
注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。
四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：
val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False；
isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}
我们可以按以下步骤为二维区域构建四叉树：
如果当前网格的值相同（即，全为 0 或者全为 1），将 isLeaf 设为 True ，将 val 设为网格相应的值，并将四个子节点都设为 Null 然后停止。
如果当前网格的值不同，将 isLeaf 设为 False， 将 val 设为任意值，然后如下图所示，将当前网格划分为四个子网格。
使用适当的子网格递归每个子节点。
如果你想了解更多关于四叉树的内容，可以参考 wiki 。
四叉树格式：
输出为使用层序遍历后四叉树的序列化形式，其中 null 表示路径终止符，其下面不存在节点。
它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 [isLeaf, val] 。
如果 isLeaf 或者 val 的值为 True ，则表示它在列表 [isLeaf, val] 中的值为 1 ；如果 isLeaf 或者 val 的值为 False ，则表示值为 0 。
  示例 1：
输入：quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]
, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
输出：[[0,0],[1,1],[1,1],[1,1],[1,0]]
解释：quadTree1 和 quadTree2 如上所示。由四叉树所表示的二进制矩阵也已经给出。
如果我们对这两个矩阵进行按位逻辑或运算，则可以得到下面的二进制矩阵，由一个作为结果的四叉树表示。
注意，我们展示的二进制矩阵仅仅是为了更好地说明题意，你无需构造二进制矩阵来获得结果四叉树。
示例 2：
输入：quadTree1 = [[1,0]]
, quadTree2 = [[1,0]]
输出：[[1,0]]
解释：两个数所表示的矩阵大小都为 1*1，值全为 0 
结果矩阵大小为 1*1，值全为 0 。
示例 3：
输入：quadTree1 = [[0,0],[1,0],[1,0],[1,1],[1,1]]
, quadTree2 = [[0,0],[1,1],[1,1],[1,0],[1,1]]
输出：[[1,1]]
示例 4：
输入：quadTree1 = [[0,0],[1,1],[1,0],[1,1],[1,1]]
, quadTree2 = [[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]
输出：[[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]
示例 5：
输入：quadTree1 = [[0,1],[1,0],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
, quadTree2 = [[0,1],[0,1],[1,0],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1]]
输出：[[0,0],[0,1],[0,1],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1],[1,0],[1,0],[1,1],[1,1]]
  提示：
quadTree1 和 quadTree2 都是符合题目要求的四叉树，每个都代表一个 n * n 的矩阵。
n == 2^x ，其中 0 <= x <= 9.",35,,3485,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/divide-and-conquer/']",[],6831
评论 (611),maximum-depth-of-n-ary-tree,简单,"给定一个 N 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。
  示例 1：
输入：root = [1,null,3,2,4,null,5,6]
输出：3
示例 2：
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5
  提示：
树的深度不会超过 1000 。
树的节点数目位于 [0, 104] 之间。",280,,109609,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/']",['https://leetcode.cn/problems/maximum-depth-of-binary-tree/'],147232
评论 (722),subarray-sum-equals-k,中等,"给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
  示例 1：
输入：nums = [1,1,1], k = 2
输出：2
示例 2：
输入：nums = [1,2,3], k = 3
输出：2
  提示：
1 <= nums.length <= 2 * 104
-1000 <= nums[i] <= 1000
-107 <= k <= 107",1493,,227458,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']","['https://leetcode.cn/problems/two-sum/', 'https://leetcode.cn/problems/continuous-subarray-sum/', 'https://leetcode.cn/problems/subarray-product-less-than-k/', 'https://leetcode.cn/problems/find-pivot-index/', 'https://leetcode.cn/problems/subarray-sums-divisible-by-k/']",503776
评论 (603),array-partition-i,简单,"给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。
返回该 最大总和 。
  示例 1：
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
示例 2：
输入：nums = [6,2,6,5,1,2]
输出：9
解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9
  提示：
1 <= n <= 104
nums.length == 2 * n
-104 <= nums[i] <= 104",301,,108833,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/counting-sort/', 'https://leetcode.cn/tag/sorting/']",[],139357
评论 (46),longest-line-of-consecutive-one-in-matrix,Unknown,,-1,,-1,[],[],-1
评论 (547),binary-tree-tilt,简单,"给你一个二叉树的根节点 root ，计算并返回 整个树 的坡度 。
一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
整个树 的坡度就是其所有节点的坡度之和。
  示例 1：
输入：root = [1,2,3]
输出：1
解释：
节点 2 的坡度：|0-0| = 0（没有子节点）
节点 3 的坡度：|0-0| = 0（没有子节点）
节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）
坡度总和：0 + 0 + 1 = 1
示例 2：
输入：root = [4,2,9,3,5,null,7]
输出：15
解释：
节点 3 的坡度：|0-0| = 0（没有子节点）
节点 5 的坡度：|0-0| = 0（没有子节点）
节点 7 的坡度：|0-0| = 0（没有子节点）
节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）
节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）
节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）
坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15
示例 3：
输入：root = [21,7,14,1,1,2,2,3,3]
输出：9
  提示：
树中节点数目的范围在 [0, 104] 内
-1000 <= Node.val <= 1000",265,https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg,65611,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],99921
评论 (360),find-the-closest-palindrome,困难,"给定一个表示整数的字符串 n ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。
“最近的”定义为两个整数差的绝对值最小。
  示例 1:
输入: n = ""123""
输出: ""121""
示例 2:
输入: n = ""1""
输出: ""0""
解释: 0 和 2是最近的回文，但我们返回最小的，也就是 0。
  提示:
1 <= n.length <= 18
n 只由数字组成
n 不含前导 0
n 代表在 [1, 1018 - 1] 范围内的整数",260,,23242,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],76442
评论 (143),array-nesting,中等,"索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。
假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。
  示例 1:
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
  提示：
N是[1, 20,000]之间的整数。
A中不含有重复的元素。
A中的元素大小在[0, N-1]之间。",205,,17733,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/array/']","['https://leetcode.cn/problems/nested-list-weight-sum/', 'https://leetcode.cn/problems/flatten-nested-list-iterator/', 'https://leetcode.cn/problems/nested-list-weight-sum-ii/']",29793
评论 (706),reshape-the-matrix,简单,"在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。
给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。
重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。
如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。
  示例 1：
输入：mat = [[1,2],[3,4]], r = 1, c = 4
输出：[[1,2,3,4]]
示例 2：
输入：mat = [[1,2],[3,4]], r = 2, c = 4
输出：[[1,2],[3,4]]
  提示：
m == mat.length
n == mat[i].length
1 <= m, n <= 100
-1000 <= mat[i][j] <= 1000
1 <= r, c <= 300",309,https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg,106093,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],159628
评论 (1.0k),permutation-in-string,中等,"给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。
换句话说，s1 的排列之一是 s2 的 子串 。
  示例 1：
输入：s1 = ""ab"" s2 = ""eidbaooo""
输出：true
解释：s2 包含 s1 的排列之一 (""ba"").
示例 2：
输入：s1= ""ab"" s2 = ""eidboaoo""
输出：false
  提示：
1 <= s1.length, s2.length <= 104
s1 和 s2 仅包含小写字母",682,,190627,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/minimum-window-substring/', 'https://leetcode.cn/problems/find-all-anagrams-in-a-string/']",434225
评论 (19),maximum-vacation-days,Unknown,,-1,,-1,[],[],-1
评论 (266),median-employee-salary,Unknown,,-1,,-1,[],[],-1
评论 (192),managers-with-at-least-5-direct-reports,Unknown,,-1,,-1,[],[],-1
评论 (157),find-median-given-frequency-of-numbers,Unknown,,-1,,-1,[],[],-1
评论 (762),subtree-of-another-tree,简单,"给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。
二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。
  示例 1：
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
示例 2：
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
  提示：
root 树上的节点数量范围是 [1, 2000]
subRoot 树上的节点数量范围是 [1, 1000]
-104 <= root.val <= 104
-104 <= subRoot.val <= 104",731,,125307,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/string-matching/', 'https://leetcode.cn/tag/hash-function/']","['https://leetcode.cn/problems/count-univalue-subtrees/', 'https://leetcode.cn/problems/most-frequent-subtree-sum/']",263349
评论 (16),squirrel-simulation,Unknown,,-1,,-1,[],[],-1
评论 (248),winning-candidate,Unknown,,-1,,-1,[],[],-1
评论 (690),distribute-candies,简单,"Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。
医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。
给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的 最多 种类数。
  示例 1：
输入：candyType = [1,1,2,2,3,3]
输出：3
解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。
示例 2：
输入：candyType = [1,1,2,3]
输出：2
解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。
示例 3：
输入：candyType = [6,6,6,6]
输出：1
解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。
  提示：
n == candyType.length
2 <= n <= 104
n 是一个偶数
-105 <= candyType[i] <= 105",207,,95606,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],134665
评论 (282),out-of-boundary-paths,中等,"给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。
给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。
  示例 1：
输入：m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
输出：6
示例 2：
输入：m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1
输出：12
  提示：
1 <= m, n <= 50
0 <= maxMove <= 50
0 <= startRow < m
0 <= startColumn < n",243,https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png,30414,['https://leetcode.cn/tag/dynamic-programming/'],['https://leetcode.cn/problems/knight-probability-in-chessboard/'],64748
评论 (135),employee-bonus,Unknown,,-1,,-1,[],[],-1
评论 (310),get-highest-answer-rate-question,Unknown,,-1,,-1,[],[],-1
评论 (257),find-cumulative-salary-of-an-employee,Unknown,,-1,,-1,[],[],-1
评论 (146),count-student-number-in-departments,Unknown,,-1,,-1,[],[],-1
评论 (674),shortest-unsorted-continuous-subarray,中等,"给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
请你找出符合题意的 最短 子数组，并输出它的长度。
  示例 1：
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
示例 2：
输入：nums = [1,2,3,4]
输出：0
示例 3：
输入：nums = [1]
输出：0
  提示：
1 <= nums.length <= 104
-105 <= nums[i] <= 105
  进阶：你可以设计一个时间复杂度为 O(n) 的解决方案吗？",857,,130705,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/monotonic-stack/']",[],317706
评论 (69),kill-process,Unknown,,-1,,-1,[],[],-1
评论 (367),delete-operation-for-two-strings,中等,"给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。
每步 可以删除任意一个字符串中的一个字符。
  示例 1：
输入: word1 = ""sea"", word2 = ""eat""
输出: 2
解释: 第一步将 ""sea"" 变为 ""ea"" ，第二步将 ""eat ""变为 ""ea""
示例  2:
输入：word1 = ""leetcode"", word2 = ""etco""
输出：4
  提示：
1 <= word1.length, word2.length <= 500
word1 和 word2 只包含小写英文字母",425,,78840,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/edit-distance/', 'https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/']",121863
评论 (167),find-customer-referee,简单,"SQL架构
给定表 customer ，里面保存了所有客户信息和他们的推荐人。
+------+------+-----------+
| id   | name | referee_id|
+------+------+-----------+
|    1 | Will |      NULL |
|    2 | Jane |      NULL |
|    3 | Alex |         2 |
|    4 | Bill |      NULL |
|    5 | Zack |         1 |
|    6 | Mark |         2 |
+------+------+-----------+
写一个查询语句，返回一个客户列表，列表中客户的推荐人的编号都 不是 2。
对于上面的示例数据，结果为：
+------+
| name |
+------+
| Will |
| Jane |
| Bill |
| Zack |
+------+",49,,41139,['https://leetcode.cn/tag/database/'],[],58009
评论 (228),investments-in-2016,Unknown,,-1,,-1,[],[],-1
评论 (179),customer-placing-the-largest-number-of-orders,简单,"SQL架构
表: Orders
+-----------------+----------+
| Column Name     | Type     |
+-----------------+----------+
| order_number    | int      |
| customer_number | int      |
+-----------------+----------+
Order_number是该表的主键。
此表包含关于订单ID和客户ID的信息。
  编写一个SQL查询，为下了 最多订单 的客户查找 customer_number 。
测试用例生成后， 恰好有一个客户 比任何其他客户下了更多的订单。
查询结果格式如下所示。
  示例 1:
输入: 
Orders 表:
+--------------+-----------------+
| order_number | customer_number |
+--------------+-----------------+
| 1            | 1               |
| 2            | 2               |
| 3            | 3               |
| 4            | 3               |
+--------------+-----------------+
输出: 
+-----------------+
| customer_number |
+-----------------+
| 3               |
+-----------------+
解释: 
customer_number 为 '3' 的顾客有两个订单，比顾客 '1' 或者 '2' 都要多，因为他们只有一个订单。
所以结果是该顾客的 customer_number ，也就是 3 。
  进阶： 如果有多位顾客订单数并列最多，你能找到他们所有的 customer_number 吗？",49,,29337,['https://leetcode.cn/tag/database/'],[],40147
评论 (224),erect-the-fence,困难,"在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。
  示例 1:
输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
输出: [[1,1],[2,0],[4,2],[3,3],[2,4]]
解释:
示例 2:
输入: [[1,2],[2,2],[4,2]]
输出: [[1,2],[2,2],[4,2]]
解释:

即使树都在一条直线上，你也需要先用绳子包围它们。
  注意:
所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。
输入的整数在 0 到 100 之间。
花园至少有一棵树。
所有树的坐标都是不同的。
输入的点没有顺序。输出顺序也没有要求。",202,,16312,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],26411
评论 (18),design-in-memory-file-system,Unknown,,-1,,-1,[],[],-1
评论 (567),n-ary-tree-preorder-traversal,简单,"给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。

示例 1：
输入：root = [1,null,3,2,4,null,5,6]
输出：[1,3,5,6,2,4]
示例 2：
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]
  提示：
节点总数在范围 [0, 104]内
0 <= Node.val <= 104
n 叉树的高度小于或等于 1000
  进阶：递归法很简单，你可以使用迭代法完成此题吗?",277,,146763,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/']","['https://leetcode.cn/problems/binary-tree-preorder-traversal/', 'https://leetcode.cn/problems/n-ary-tree-level-order-traversal/', 'https://leetcode.cn/problems/n-ary-tree-postorder-traversal/']",192727
评论,n-ary-tree-postorder-traversal,简单,"给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
  示例 1：
输入：root = [1,null,3,2,4,null,5,6]
输出：[5,6,3,2,4,1]
示例 2：
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]
  提示：
节点总数在范围 [0, 104] 内
0 <= Node.val <= 104
n 叉树的高度小于或等于 1000
  进阶：递归法很简单，你可以使用迭代法完成此题吗?",248,,107216,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/']","['https://leetcode.cn/problems/binary-tree-postorder-traversal/', 'https://leetcode.cn/problems/n-ary-tree-level-order-traversal/', 'https://leetcode.cn/problems/n-ary-tree-preorder-traversal/']",137557
评论 (318),tag-validator,困难,"给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：
代码必须被合法的闭合标签包围。否则，代码是无效的。
闭合标签（不一定合法）要严格符合格式：<TAG_NAME>TAG_CONTENT</TAG_NAME>。其中，<TAG_NAME>是起始标签，</TAG_NAME>是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是合法的。
合法的 TAG_NAME 仅含有大写字母，长度在范围 [1,9] 之间。否则，该 TAG_NAME 是不合法的。
合法的 TAG_CONTENT 可以包含其他合法的闭合标签，cdata （请参考规则7）和任意字符（注意参考规则1）除了不匹配的<、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，TAG_CONTENT 是不合法的。
一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。
一个<，如果你找不到一个后续的>与之匹配，是不合法的。并且当你找到一个<或</时，所有直到下一个>的前的字符，都应当被解析为 TAG_NAME（不一定合法）。
cdata 有如下格式：<![CDATA[CDATA_CONTENT]]>。CDATA_CONTENT 的范围被定义成 <![CDATA[ 和后续的第一个 ]]>之间的字符。
CDATA_CONTENT 可以包含任意字符。cdata 的功能是阻止验证器解析CDATA_CONTENT，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为常规字符。
合法代码的例子:
输入: ""<DIV>This is the first line <![CDATA[<div>]]></DIV>""

输出: True

解释: 

代码被包含在了闭合的标签内： <DIV> 和 </DIV> 。

TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 

即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。

所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。


输入: ""<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>""

输出: True

解释:

我们首先将代码分割为： start_tag|tag_content|end_tag 。

start_tag -> ""<DIV>""

end_tag -> ""</DIV>""

tag_content 也可被分割为： text1|cdata|text2 。

text1 -> "">>  ![cdata[]] ""

cdata -> ""<![CDATA[<div>]>]]>"" ，其中 CDATA_CONTENT 为 ""<div>]>""

text2 -> ""]]>>]""


start_tag 不是 ""<DIV>>>"" 的原因参照规则 6 。
cdata 不是 ""<![CDATA[<div>]>]]>]]>"" 的原因参照规则 7 。
不合法代码的例子:
输入: ""<A>  <B> </A>   </B>""
输出: False
解释: 不合法。如果 ""<A>"" 是闭合的，那么 ""<B>"" 一定是不匹配的，反之亦然。

输入: ""<DIV>  div tag is not closed  <DIV>""
输出: False

输入: ""<DIV>  unmatched <  </DIV>""
输出: False

输入: ""<DIV> closed tags with invalid tag name  <b>123</b> </DIV>""
输出: False

输入: ""<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>""
输出: False

输入: ""<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>""
输出: False
注意:
为简明起见，你可以假设输入的代码（包括提到的任意字符）只包含数字, 字母, '<','>','/','!','[',']'和' '。",102,,16318,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/add-bold-tag-in-string/'],31204
评论 (92),fraction-addition-and-subtraction,中等,"给定一个表示分数加减运算的字符串 expression ，你需要返回一个字符串形式的计算结果。 
这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。
  示例 1:
输入: expression = ""-1/2+1/2""
输出: ""0/1""
 示例 2:
输入: expression = ""-1/2+1/2+1/3""
输出: ""1/3""
示例 3:
输入: expression = ""1/3-1/2""
输出: ""-1/6""
  提示:
输入和输出字符串只包含 '0' 到 '9' 的数字，以及 '/', '+' 和 '-'。 
输入和输出分数格式均为 ±分子/分母。如果输入的第一个分数或者输出的分数是正数，则 '+' 会被省略掉。
输入只包含合法的最简分数，每个分数的分子与分母的范围是  [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。
输入的分数个数范围是 [1,10]。
最终结果的分子与分母保证是 32 位整数范围内的有效整数。",67,,5861,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",['https://leetcode.cn/problems/solve-the-equation/'],11107
评论 (174),valid-square,中等,"给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。
点的坐标 pi 表示为 [xi, yi] 。输入 不是 按任何顺序给出的。
一个 有效的正方形 有四条等边和四个等角(90度角)。
  示例 1:
输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]
输出: True
示例 2:
输入：p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]
输出：false
示例 3:
输入：p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]
输出：true
  提示:
p1.length == p2.length == p3.length == p4.length == 2
-104 <= xi, yi <= 104",90,,10569,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/math/']",[],23951
评论 (444),longest-harmonious-subsequence,简单,"和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
  示例 1：
输入：nums = [1,3,2,2,5,2,3,7]
输出：5
解释：最长的和谐子序列是 [3,2,2,2,3]
示例 2：
输入：nums = [1,2,3,4]
输出：2
示例 3：
输入：nums = [1,1,1,1]
输出：0
  提示：
1 <= nums.length <= 2 * 104
-109 <= nums[i] <= 109",321,,67510,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],119326
评论 (493),big-countries,简单,"SQL架构
World 表：
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| name        | varchar |
| continent   | varchar |
| area        | int     |
| population  | int     |
| gdp         | int     |
+-------------+---------+
name 是这张表的主键。
这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。
  如果一个国家满足下述两个条件之一，则认为该国是 大国 ：
面积至少为 300 万平方公里（即，3000000 km2），或者
人口至少为 2500 万（即 25000000）
编写一个 SQL 查询以报告 大国 的国家名称、人口和面积。
按 任意顺序 返回结果表。
查询结果格式如下例所示。
  示例：
输入：
World 表：
+-------------+-----------+---------+------------+--------------+
| name        | continent | area    | population | gdp          |
+-------------+-----------+---------+------------+--------------+
| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |
| Albania     | Europe    | 28748   | 2831741    | 12960000000  |
| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |
| Andorra     | Europe    | 468     | 78115      | 3712000000   |
| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |
+-------------+-----------+---------+------------+--------------+
输出：
+-------------+------------+---------+
| name        | population | area    |
+-------------+------------+---------+
| Afghanistan | 25500100   | 652230  |
| Algeria     | 37100000   | 2381741 |
+-------------+------------+---------+",220,,144953,['https://leetcode.cn/tag/database/'],[],198574
评论 (585),classes-more-than-5-students,简单,"SQL架构
表: Courses
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| student     | varchar |
| class       | varchar |
+-------------+---------+
(student, class)是该表的主键列。
该表的每一行表示学生的名字和他们注册的班级。
  编写一个SQL查询来报告 至少有5个学生 的所有类。
以 任意顺序 返回结果表。
查询结果格式如下所示。
  示例 1:
输入: 
Courses table:
+---------+----------+
| student | class    |
+---------+----------+
| A       | Math     |
| B       | English  |
| C       | Math     |
| D       | Biology  |
| E       | Math     |
| F       | Computer |
| G       | Math     |
| H       | Math     |
| I       | Math     |
+---------+----------+
输出: 
+---------+ 
| class   | 
+---------+ 
| Math    | 
+---------+
解释: 
-数学课有6个学生，所以我们包括它。
-英语课有1名学生，所以我们不包括它。
-生物课有1名学生，所以我们不包括它。
-计算机课有1个学生，所以我们不包括它。",242,,105363,['https://leetcode.cn/tag/database/'],[],229076
评论 (212),friend-requests-i-overall-acceptance-rate,Unknown,,-1,,-1,[],[],-1
评论 (462),range-addition-ii,简单,"给你一个 m x n 的矩阵 M ，初始化时所有的 0 和一个操作数组 op ，其中 ops[i] = [ai, bi] 意味着当所有的 0 <= x < ai 和 0 <= y < bi 时， M[x][y] 应该加 1。
在 执行完所有操作后 ，计算并返回 矩阵中最大整数的个数 。
  示例 1:
输入: m = 3, n = 3，ops = [[2,2],[3,3]]
输出: 4
解释: M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
示例 2:
输入: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]
输出: 4
示例 3:
输入: m = 3, n = 3, ops = []
输出: 9
  提示:
1 <= m, n <= 4 * 104
0 <= ops.length <= 104
ops[i].length == 2
1 <= ai <= m
1 <= bi <= n",161,,45459,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/range-addition/'],79417
评论 (488),minimum-index-sum-of-two-lists,简单,"假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。
  示例 1:
输入: list1 = [""Shogun"", ""Tapioca Express"", ""Burger King"", ""KFC""]，list2 = [""Piatti"", ""The Grill at Torrey Pines"", ""Hungry Hunter Steakhouse"", ""Shogun""]
输出: [""Shogun""]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。
示例 2:
输入:list1 = [""Shogun"", ""Tapioca Express"", ""Burger King"", ""KFC""]，list2 = [""KFC"", ""Shogun"", ""Burger King""]
输出: [""Shogun""]
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。
  提示:
1 <= list1.length, list2.length <= 1000
1 <= list1[i].length, list2[i].length <= 30 
list1[i] 和 list2[i] 由空格 ' ' 和英文字母组成。
list1 的所有字符串都是 唯一 的。
list2 中的所有字符串都是 唯一 的。",218,,74409,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/intersection-of-two-linked-lists/'],130063
评论 (234),non-negative-integers-without-consecutive-ones,困难,"给定一个正整数 n ，返回范围在 [0, n] 都非负整数中，其二进制表示不包含 连续的 1 的个数。
  示例 1:
输入: n = 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
示例 2:
输入: n = 1
输出: 2
示例 3:
输入: n = 2
输出: 3
  提示:
1 <= n <= 109",281,,20867,['https://leetcode.cn/tag/dynamic-programming/'],"['https://leetcode.cn/problems/house-robber/', 'https://leetcode.cn/problems/house-robber-ii/', 'https://leetcode.cn/problems/ones-and-zeroes/']",43095
评论 (676),human-traffic-of-stadium,困难,"SQL架构
表：Stadium
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| visit_date    | date    |
| people        | int     |
+---------------+---------+
visit_date 是表的主键
每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)
每天只有一行记录，日期随着 id 的增加而增加
  编写一个 SQL 查询以找出每行的人数大于或等于 100 且 id 连续的三行或更多行记录。
返回按 visit_date 升序排列 的结果表。
查询结果格式如下所示。
  示例 1:
输入：
Stadium 表:
+------+------------+-----------+
| id   | visit_date | people    |
+------+------------+-----------+
| 1    | 2017-01-01 | 10        |
| 2    | 2017-01-02 | 109       |
| 3    | 2017-01-03 | 150       |
| 4    | 2017-01-04 | 99        |
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-09 | 188       |
+------+------------+-----------+
输出：
+------+------------+-----------+
| id   | visit_date | people    |
+------+------------+-----------+
| 5    | 2017-01-05 | 145       |
| 6    | 2017-01-06 | 1455      |
| 7    | 2017-01-07 | 199       |
| 8    | 2017-01-09 | 188       |
+------+------------+-----------+
解释：
id 为 5、6、7、8 的四行 id 连续，并且每行都有 >= 100 的人数记录。
请注意，即使第 7 行和第 8 行的 visit_date 不是连续的，输出也应当包含第 8 行，因为我们只需要考虑 id 连续的记录。
不输出 id 为 2 和 3 的行，因为至少需要三条 id 连续的记录。",257,,39404,['https://leetcode.cn/tag/database/'],[],80182
评论 (237),friend-requests-ii-who-has-the-most-friends,Unknown,,-1,,-1,[],[],-1
评论 (256),consecutive-available-seats,Unknown,,-1,,-1,[],[],-1
评论 (44),design-compressed-string-iterator,Unknown,,-1,,-1,[],[],-1
评论 (939),can-place-flowers,简单,"假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。
  示例 1：
输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
示例 2：
输入：flowerbed = [1,0,0,0,1], n = 2
输出：false
  提示：
1 <= flowerbed.length <= 2 * 104
flowerbed[i] 为 0 或 1
flowerbed 中不存在相邻的两朵花
0 <= n <= flowerbed.length",454,,133419,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']","['https://leetcode.cn/problems/teemo-attacking/', 'https://leetcode.cn/problems/asteroid-collision/']",405458
评论 (607),construct-string-from-binary-tree,简单,"给你二叉树的根节点 root ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。
空节点使用一对空括号对 ""()"" 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。
  示例 1：
输入：root = [1,2,3,4]
输出：""1(2(4))(3)""
解释：初步转化后得到 ""1(2(4)())(3()())"" ，但省略所有不必要的空括号对后，字符串应该是""1(2(4))(3)"" 。
示例 2：
输入：root = [1,2,3,null,4]
输出：""1(2()(4))(3)""
解释：和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。
  提示：
树中节点的数目范围是 [1, 104]
-1000 <= Node.val <= 1000",332,,61823,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/construct-binary-tree-from-string/', 'https://leetcode.cn/problems/find-duplicate-subtrees/']",98073
评论 (268),sales-person,简单,"SQL架构
表: SalesPerson
+-----------------+---------+
| Column Name     | Type    |
+-----------------+---------+
| sales_id        | int     |
| name            | varchar |
| salary          | int     |
| commission_rate | int     |
| hire_date       | date    |
+-----------------+---------+
sales_id 是该表的主键列。
该表的每一行都显示了销售人员的姓名和 ID ，以及他们的工资、佣金率和雇佣日期。
  表: Company
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| com_id      | int     |
| name        | varchar |
| city        | varchar |
+-------------+---------+
com_id 是该表的主键列。
该表的每一行都表示公司的名称和 ID ，以及公司所在的城市。
  表: Orders
+-------------+------+
| Column Name | Type |
+-------------+------+
| order_id    | int  |
| order_date  | date |
| com_id      | int  |
| sales_id    | int  |
| amount      | int  |
+-------------+------+
order_id 是该表的主键列。
com_id 是 Company 表中 com_id 的外键。
sales_id 是来自销售员表 sales_id 的外键。
该表的每一行包含一个订单的信息。这包括公司的 ID 、销售人员的 ID 、订单日期和支付的金额。
  编写一个SQL查询，报告没有任何与名为 “RED” 的公司相关的订单的所有销售人员的姓名。
以 任意顺序 返回结果表。
查询结果格式如下所示。
  示例：
输入：
SalesPerson 表:
+----------+------+--------+-----------------+------------+
| sales_id | name | salary | commission_rate | hire_date  |
+----------+------+--------+-----------------+------------+
| 1        | John | 100000 | 6               | 4/1/2006   |
| 2        | Amy  | 12000  | 5               | 5/1/2010   |
| 3        | Mark | 65000  | 12              | 12/25/2008 |
| 4        | Pam  | 25000  | 25              | 1/1/2005   |
| 5        | Alex | 5000   | 10              | 2/3/2007   |
+----------+------+--------+-----------------+------------+
Company 表:
+--------+--------+----------+
| com_id | name   | city     |
+--------+--------+----------+
| 1      | RED    | Boston   |
| 2      | ORANGE | New York |
| 3      | YELLOW | Boston   |
| 4      | GREEN  | Austin   |
+--------+--------+----------+
Orders 表:
+----------+------------+--------+----------+--------+
| order_id | order_date | com_id | sales_id | amount |
+----------+------------+--------+----------+--------+
| 1        | 1/1/2014   | 3      | 4        | 10000  |
| 2        | 2/1/2014   | 4      | 5        | 5000   |
| 3        | 3/1/2014   | 1      | 1        | 50000  |
| 4        | 4/1/2014   | 1      | 4        | 25000  |
+----------+------------+--------+----------+--------+
输出：
+------+
| name |
+------+
| Amy  |
| Mark |
| Alex |
+------+
解释：
根据表 orders 中的订单 '3' 和 '4' ，容易看出只有 'John' 和 'Pam' 两个销售员曾经向公司 'RED' 销售过。
所以我们需要输出表 salesperson 中所有其他人的名字。",57,,25292,['https://leetcode.cn/tag/database/'],[],37254
评论 (251),tree-node,中等,"SQL架构
给定一个表 tree，id 是树节点的编号， p_id 是它父节点的 id 。
+----+------+
| id | p_id |
+----+------+
| 1  | null |
| 2  | 1    |
| 3  | 1    |
| 4  | 2    |
| 5  | 2    |
+----+------+
树中每个节点属于以下三种类型之一：
叶子：如果这个节点没有任何孩子节点。
根：如果这个节点是整棵树的根，即没有父节点。
内部节点：如果这个节点既不是叶子节点也不是根节点。
  写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。上面样例的结果为：
  +----+------+
| id | Type |
+----+------+
| 1  | Root |
| 2  | Inner|
| 3  | Leaf |
| 4  | Leaf |
| 5  | Leaf |
+----+------+
  解释
节点 '1' 是根节点，因为它的父节点是 NULL ，同时它有孩子节点 '2' 和 '3' 。
节点 '2' 是内部节点，因为它有父节点 '1' ，也有孩子节点 '4' 和 '5' 。
节点 '3', '4' 和 '5' 都是叶子节点，因为它们都有父节点同时没有孩子节点。
样例中树的形态如下：
       1
   /   \
                      2       3
                    /   \
                  4       5
  注意
如果树中只有一个节点，你只需要输出它的根属性。",77,,18042,['https://leetcode.cn/tag/database/'],[],28367
评论 (104),find-duplicate-file-in-system,中等,"给你一个目录信息列表 paths ，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按 任意顺序 返回。
一组重复的文件至少包括 两个 具有完全相同内容的文件。
输入 列表中的单个目录信息字符串的格式如下：
""root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)""
这意味着，在目录 root/d1/d2/.../dm 下，有 n 个文件 ( f1.txt, f2.txt ... fn.txt ) 的内容分别是 ( f1_content, f2_content ... fn_content ) 。注意：n >= 1 且 m >= 0 。如果 m = 0 ，则表示该目录是根目录。
输出 是由 重复文件路径组 构成的列表。其中每个组由所有具有相同内容文件的文件路径组成。文件路径是具有下列格式的字符串：
""directory_path/file_name.txt""
  示例 1：
输入：paths = [""root/a 1.txt(abcd) 2.txt(efgh)"",""root/c 3.txt(abcd)"",""root/c/d 4.txt(efgh)"",""root 4.txt(efgh)""]
输出：[[""root/a/2.txt"",""root/c/d/4.txt"",""root/4.txt""],[""root/a/1.txt"",""root/c/3.txt""]]
示例 2：
输入：paths = [""root/a 1.txt(abcd) 2.txt(efgh)"",""root/c 3.txt(abcd)"",""root/c/d 4.txt(efgh)""]
输出：[[""root/a/2.txt"",""root/c/d/4.txt""],[""root/a/1.txt"",""root/c/3.txt""]]
  提示：
1 <= paths.length <= 2 * 104
1 <= paths[i].length <= 3000
1 <= sum(paths[i].length) <= 5 * 105
paths[i] 由英文字母、数字、字符 '/'、'.'、'('、')' 和 ' ' 组成
你可以假设在同一目录中没有任何文件或目录共享相同的名称。
你可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用单个空格分隔。
  进阶：
假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？
如果文件内容非常大（GB级别），您将如何修改您的解决方案？
如果每次只能读取 1 kb 的文件，您将如何修改解决方案？
修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？
如何确保您发现的重复文件不是误报？",91,,8035,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],15995
评论 (144),triangle-judgement,Unknown,,-1,,-1,[],[],-1
评论 (337),valid-triangle-number,中等,"给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。
  示例 1:
输入: nums = [2,2,3,4]
输出: 3
解释:有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
示例 2:
输入: nums = [4,2,3,4]
输出: 4
  提示:
1 <= nums.length <= 1000
0 <= nums[i] <= 1000",387,,66499,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/3sum-smaller/'],124317
评论 (137),shortest-distance-in-a-plane,Unknown,,-1,,-1,[],[],-1
评论 (128),shortest-distance-in-a-line,Unknown,,-1,,-1,[],[],-1
评论 (227),second-degree-follower,Unknown,,-1,,-1,[],[],-1
评论 (234),average-salary-departments-vs-company,Unknown,,-1,,-1,[],[],-1
评论 (26),add-bold-tag-in-string,Unknown,,-1,,-1,[],[],-1
评论 (974),merge-two-binary-trees,简单,"给你两棵二叉树： root1 和 root2 。
想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。
返回合并后的二叉树。
注意: 合并过程必须从两个树的根节点开始。
  示例 1：
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
示例 2：
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
  提示：
两棵树中的节点数目在范围 [0, 2000] 内
-104 <= Node.val <= 104",980,https://assets.leetcode.com/uploads/2021/02/05/merge.jpg,283515,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],359112
评论 (101),students-report-by-geography,Unknown,,-1,,-1,[],[],-1
评论 (144),biggest-single-number,Unknown,,-1,,-1,[],[],-1
评论 (452),not-boring-movies,简单,"SQL架构
某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。
作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。
  例如，下表 cinema:
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
对于上面的例子，则正确的输出是为：
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
 ",150,,110789,['https://leetcode.cn/tag/database/'],[],143477
评论 (492),task-scheduler,中等,"给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。
然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的 最短时间 。
  示例 1：
输入：tasks = [""A"",""A"",""A"",""B"",""B"",""B""], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
示例 2：
输入：tasks = [""A"",""A"",""A"",""B"",""B"",""B""], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
[""A"",""A"",""A"",""B"",""B"",""B""]
[""A"",""B"",""A"",""B"",""A"",""B""]
[""B"",""B"",""B"",""A"",""A"",""A""]
...
诸如此类
示例 3：
输入：tasks = [""A"",""A"",""A"",""A"",""A"",""A"",""B"",""C"",""D"",""E"",""F"",""G""], n = 2
输出：16
解释：一种可能的解决方案是：
     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
  提示：
1 <= task.length <= 104
tasks[i] 是大写英文字母
n 的取值范围为 [0, 100]",907,,100315,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/rearrange-string-k-distance-apart/', 'https://leetcode.cn/problems/reorganize-string/']",172157
评论 (279),design-circular-queue,中等,"设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
你的实现应该支持如下操作：
MyCircularQueue(k): 构造器，设置队列长度为 k 。
Front: 从队首获取元素。如果队列为空，返回 -1 。
Rear: 获取队尾元素。如果队列为空，返回 -1 。
enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
isEmpty(): 检查循环队列是否为空。
isFull(): 检查循环队列是否已满。
  示例：
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
  提示：
所有的值都在 0 至 1000 的范围内；
操作数将在 1 至 1000 的范围内；
请不要使用内置的队列库。",284,,82348,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/linked-list/']",['https://leetcode.cn/problems/design-circular-deque/'],185514
评论 (170),add-one-row-to-tree,中等,"给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。
注意，根节点 root 位于深度 1 。
加法规则如下:
给定整数 depth，对于深度为 depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。
cur 原来的左子树应该是新的左子树根的左子树。
cur 原来的右子树应该是新的右子树根的右子树。
如果 depth == 1 意味着 depth - 1 根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。
  示例 1:
输入: root = [4,2,6,3,1,5], val = 1, depth = 2
输出: [4,1,1,2,null,null,6,3,1,5]
示例 2:
输入: root = [4,2,null,3,1], val = 1, depth = 3
输出:  [4,2,null,1,1,3,null,null,1]
  提示:
节点数在 [1, 104] 范围内
树的深度在 [1, 104]范围内
-100 <= Node.val <= 100
-105 <= val <= 105
1 <= depth <= the depth of tree + 1",114,,13920,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],25377
评论 (27),maximum-distance-in-arrays,Unknown,,-1,,-1,[],[],-1
评论 (37),minimum-factorization,Unknown,,-1,,-1,[],[],-1
评论 (680),exchange-seats,中等,"SQL架构
表: Seat
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
+-------------+---------+
Id是该表的主键列。
该表的每一行都表示学生的姓名和ID。
Id是一个连续的增量。
  编写SQL查询来交换每两个连续的学生的座位号。如果学生的数量是奇数，则最后一个学生的id不交换。
按 id 升序 返回结果表。
查询结果格式如下所示。
  示例 1:
输入: 
Seat 表:
+----+---------+
| id | student |
+----+---------+
| 1  | Abbot   |
| 2  | Doris   |
| 3  | Emerson |
| 4  | Green   |
| 5  | Jeames  |
+----+---------+
输出: 
+----+---------+
| id | student |
+----+---------+
| 1  | Doris   |
| 2  | Abbot   |
| 3  | Green   |
| 4  | Emerson |
| 5  | Jeames  |
+----+---------+
解释:
请注意，如果学生人数为奇数，则不需要更换最后一名学生的座位。",308,,55733,['https://leetcode.cn/tag/database/'],[],81934
评论 (385),swap-salary,简单,"SQL架构
Salary 表：
+-------------+----------+
| Column Name | Type     |
+-------------+----------+
| id          | int      |
| name        | varchar  |
| sex         | ENUM     |
| salary      | int      |
+-------------+----------+
id 是这个表的主键。
sex 这一列的值是 ENUM 类型，只能从 ('m', 'f') 中取。
本表包含公司雇员的信息。
  请你编写一个 SQL 查询来交换所有的 'f' 和 'm' （即，将所有 'f' 变为 'm' ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。
注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。
查询结果如下例所示。
  示例 1:
输入：
Salary 表：
+----+------+-----+--------+
| id | name | sex | salary |
+----+------+-----+--------+
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
+----+------+-----+--------+
输出：
+----+------+-----+--------+
| id | name | sex | salary |
+----+------+-----+--------+
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
+----+------+-----+--------+
解释：
(1, A) 和 (3, C) 从 'm' 变为 'f' 。
(2, B) 和 (4, D) 从 'f' 变为 'm' 。",310,,111305,['https://leetcode.cn/tag/database/'],[],136518
评论 (594),maximum-product-of-three-numbers,简单,"给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。
  示例 1：
输入：nums = [1,2,3]
输出：6
示例 2：
输入：nums = [1,2,3,4]
输出：24
示例 3：
输入：nums = [-1,-2,-3]
输出：-6
  提示：
3 <= nums.length <= 104
-1000 <= nums[i] <= 1000",376,,94346,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/maximum-product-subarray/'],180056
评论 (214),k-inverse-pairs-array,困难,"给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。
逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。
由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。
示例 1:
输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
示例 2:
输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
说明:
 n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。",238,,19808,['https://leetcode.cn/tag/dynamic-programming/'],[],38269
评论 (200),course-schedule-iii,困难,"这里有 n 门不同的在线课程，按从 1 到 n 编号。给你一个数组 courses ，其中 courses[i] = [durationi, lastDayi] 表示第 i 门课将会 持续 上 durationi 天课，并且必须在不晚于 lastDayi 的时候完成。
你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。
返回你最多可以修读的课程数目。
  示例 1：
输入：courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出：3
解释：
这里一共有 4 门课程，但是你最多可以修 3 门：
首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。
第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。
第三，修第 2 门课，耗时 200 天，在第 1300 天完成。
第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。
示例 2：
输入：courses = [[1,2]]
输出：1
示例 3：
输入：courses = [[3,2],[4,3]]
输出：0
  提示:
1 <= courses.length <= 104
1 <= durationi, lastDayi <= 104",330,,25801,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/course-schedule/', 'https://leetcode.cn/problems/course-schedule-ii/']",55820
评论 (15),design-excel-sum-formula,Unknown,,-1,,-1,[],[],-1
评论 (277),smallest-range-covering-elements-from-k-lists,困难,"你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。
我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。
  示例 1：
输入：nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出：[20,24]
解释： 
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。
示例 2：
输入：nums = [[1,2,3],[1,2,3],[1,2,3]]
输出：[1,1]
  提示：
nums.length == k
1 <= k <= 3500
1 <= nums[i].length <= 50
-105 <= nums[i][j] <= 105
nums[i] 按非递减顺序排列
 ",353,,21401,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],35538
评论 (525),sum-of-square-numbers,中等,"给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。
  示例 1：
输入：c = 5
输出：true
解释：1 * 1 + 2 * 2 = 5
示例 2：
输入：c = 3
输出：false
  提示：
0 <= c <= 231 - 1",356,,111007,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/']",['https://leetcode.cn/problems/valid-perfect-square/'],285323
评论 (14),find-the-derangement-of-an-array,Unknown,,-1,,-1,[],[],-1
评论 (32),design-log-storage-system,Unknown,,-1,,-1,[],[],-1
评论 (124),exclusive-time-of-functions,中等,"有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于  0 和 n-1 之间的唯一标识符。
函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。
给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 ""{function_id}:{""start"" | ""end""}:{timestamp}"" 进行格式化的字符串。例如，""0:start:3"" 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 ""1:end:2"" 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。
函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。
以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。
  示例 1：
输入：n = 2, logs = [""0:start:0"",""1:start:2"",""1:end:5"",""0:end:6""]
输出：[3,4]
解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 
函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 
函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 
所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 
示例 2：
输入：n = 1, logs = [""0:start:0"",""0:start:2"",""0:end:5"",""0:start:6"",""0:end:6"",""0:end:7""]
输出：[8]
解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
函数 0（初始调用）恢复执行，并立刻再次调用它自身。
函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。
函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。
所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。
示例 3：
输入：n = 2, logs = [""0:start:0"",""0:start:2"",""0:end:5"",""1:start:6"",""1:end:6"",""0:end:7""]
输出：[7,1]
解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
函数 0（初始调用）恢复执行，并立刻调用函数 1 。
函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。
函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。
所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 
示例 4：
输入：n = 2, logs = [""0:start:0"",""0:start:2"",""0:end:5"",""1:start:7"",""1:end:7"",""0:end:8""]
输出：[8,1]
示例 5：
输入：n = 1, logs = [""0:start:0"",""0:end:0""]
输出：[1]
  提示：
1 <= n <= 100
1 <= logs.length <= 500
0 <= function_id < n
0 <= timestamp <= 109
两个开始事件不会在同一时间戳发生
两个结束事件不会在同一时间戳发生
每道函数都有一个对应 ""start"" 日志的 ""end"" 日志",154,https://assets.leetcode.com/uploads/2019/04/05/diag1b.png,12682,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/']",[],22236
评论 (592),average-of-levels-in-binary-tree,简单,"给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。
  示例 1：
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
示例 2:
输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]
  提示：
树中节点数量在 [1, 104] 范围内
-231 <= Node.val <= 231 - 1",343,,103394,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/binary-tree-level-order-traversal/', 'https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/']",148760
评论 (326),shopping-offers,中等,"在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。
给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。
还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的价格。
返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。
  示例 1：
输入：price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
输出：14
解释：有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 
大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 
大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 
需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。
示例 2：
输入：price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
输出：11
解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。
可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 
需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 
不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。
  提示：
n == price.length
n == needs.length
1 <= n <= 6
0 <= price[i] <= 10
0 <= needs[i] <= 10
1 <= special.length <= 100
special[i].length == n + 1
0 <= special[i][j] <= 50",328,,31293,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",[],48524
评论 (310),decode-ways-ii,困难,"一条包含字母 A-Z 的消息通过以下的方式进行了 编码 ：
'A' -> ""1""
'B' -> ""2""
...
'Z' -> ""26""
要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，""11106"" 可以映射为：
""AAJF"" 对应分组 (1 1 10 6)
""KJF"" 对应分组 (11 10 6)
注意，像 (1 11 06) 这样的分组是无效的，因为 ""06"" 不可以映射为 'F' ，因为 ""6"" 与 ""06"" 不同。
除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 ""1*"" 可以表示 ""11""、""12""、""13""、""14""、""15""、""16""、""17""、""18"" 或 ""19"" 中的任意一条消息。对 ""1*"" 进行解码，相当于解码该字符串可以表示的任何编码消息。
给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。
由于答案数目可能非常大，返回 109 + 7 的 模 。
  示例 1：
输入：s = ""*""
输出：9
解释：这一条编码消息可以表示 ""1""、""2""、""3""、""4""、""5""、""6""、""7""、""8"" 或 ""9"" 中的任意一条。
可以分别解码成字符串 ""A""、""B""、""C""、""D""、""E""、""F""、""G""、""H"" 和 ""I"" 。
因此，""*"" 总共有 9 种解码方法。
示例 2：
输入：s = ""1*""
输出：18
解释：这一条编码消息可以表示 ""11""、""12""、""13""、""14""、""15""、""16""、""17""、""18"" 或 ""19"" 中的任意一条。
每种消息都可以由 2 种方法解码（例如，""11"" 可以解码成 ""AA"" 或 ""K""）。
因此，""1*"" 共有 9 * 2 = 18 种解码方法。
示例 3：
输入：s = ""2*""
输出：15
解释：这一条编码消息可以表示 ""21""、""22""、""23""、""24""、""25""、""26""、""27""、""28"" 或 ""29"" 中的任意一条。
""21""、""22""、""23""、""24""、""25"" 和 ""26"" 由 2 种解码方法，但 ""27""、""28"" 和 ""29"" 仅有 1 种解码方法。
因此，""2*"" 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。
  提示：
1 <= s.length <= 105
s[i] 是 0 - 9 中的一位数字或字符 '*'",191,,21383,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/decode-ways/'],56944
评论 (163),solve-the-equation,中等,"求解一个给定的方程，将x以字符串 ""x=#value"" 的形式返回。该方程仅包含 '+' ， '-' 操作，变量 x 和其对应系数。
如果方程没有解，请返回 ""No solution"" 。如果方程有无限解，则返回 “Infinite solutions” 。
如果方程中只有一个解，要保证返回值 'x' 是一个整数。
  示例 1：
输入: equation = ""x+5-3+x=6+x-2""
输出: ""x=2""
示例 2:
输入: equation = ""x=x""
输出: ""Infinite solutions""
示例 3:
输入: equation = ""2x=x""
输出: ""x=0""
    提示:
3 <= equation.length <= 1000
equation 只有一个 '='.
equation 方程由整数组成，其绝对值在 [0, 100] 范围内，不含前导零和变量 'x' 。 ",87,,12487,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",['https://leetcode.cn/problems/fraction-addition-and-subtraction/'],29411
评论 (160),design-circular-deque,中等,"设计实现双端队列。
实现 MyCircularDeque 类:
MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。
boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。
boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。
boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。
boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。
int getFront() )：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。
int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。
boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false  。
boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。
  示例 1：
输入
[""MyCircularDeque"", ""insertLast"", ""insertLast"", ""insertFront"", ""insertFront"", ""getRear"", ""isFull"", ""deleteLast"", ""insertFront"", ""getFront""]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
输出
[null, true, true, true, false, 2, true, true, true, 4]

解释
MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);           // 返回 true
circularDeque.insertLast(2);           // 返回 true
circularDeque.insertFront(3);           // 返回 true
circularDeque.insertFront(4);           // 已经满了，返回 false
circularDeque.getRear();      // 返回 2
circularDeque.isFull();            // 返回 true
circularDeque.deleteLast();           // 返回 true
circularDeque.insertFront(4);           // 返回 true
circularDeque.getFront();    // 返回 4
 
  提示：
1 <= k <= 1000
0 <= value <= 1000
insertFront, insertLast, deleteFront, deleteLast, getFront, , ,   调用次数不大于 2000 次",118,,27457,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/linked-list/']",['https://leetcode.cn/problems/design-circular-queue/'],51858
评论 (23),design-search-autocomplete-system,Unknown,,-1,,-1,[],[],-1
评论 (663),maximum-average-subarray-i,简单,"给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。
请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。
任何误差小于 10-5 的答案都将被视为正确答案。
  示例 1：
输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
示例 2：
输入：nums = [5], k = 1
输出：5.00000
  提示：
n == nums.length
1 <= k <= n <= 105
-104 <= nums[i] <= 104",245,,79401,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/']",['https://leetcode.cn/problems/maximum-average-subarray-ii/'],178891
评论 (11),maximum-average-subarray-ii,Unknown,,-1,,-1,[],[],-1
评论 (538),set-mismatch,简单,"集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。
给定一个数组 nums 代表了集合 S 发生错误后的结果。
请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
  示例 1：
输入：nums = [1,2,2,4]
输出：[2,3]
示例 2：
输入：nums = [1,1]
输出：[1,2]
  提示：
2 <= nums.length <= 104
1 <= nums[i] <= 104",267,,82535,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/find-the-duplicate-number/'],197388
评论 (182),maximum-length-of-pair-chain,中等,"给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。
现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。
给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。
  示例：
输入：[[1,2], [2,3], [3,4]]
输出：2
解释：最长的数对链是 [1,2] -> [3,4]
  提示：
给出数对的个数在 [1, 1000] 范围内。",219,,28884,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/longest-increasing-subsequence/', 'https://leetcode.cn/problems/increasing-subsequences/']",49521
评论 (779),palindromic-substrings,中等,"给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。
子字符串 是字符串中的由连续字符组成的一个序列。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
  示例 1：
输入：s = ""abc""
输出：3
解释：三个回文子串: ""a"", ""b"", ""c""
示例 2：
输入：s = ""aaa""
输出：6
解释：6个回文子串: ""a"", ""a"", ""a"", ""aa"", ""aa"", ""aaa""
  提示：
1 <= s.length <= 1000
s 由小写英文字母组成",875,,183947,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/longest-palindromic-substring/', 'https://leetcode.cn/problems/longest-palindromic-subsequence/', 'https://leetcode.cn/problems/palindromic-substrings/']",277218
评论 (238),replace-words,中等,"在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。
现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。
你需要输出替换之后的句子。
  示例 1：
输入：dictionary = [""cat"",""bat"",""rat""], sentence = ""the cattle was rattled by the battery""
输出：""the cat was rat by the bat""
示例 2：
输入：dictionary = [""a"",""b"",""c""], sentence = ""aadsfasf absbs bbab cadsfafs""
输出：""a a b c""
  提示：
1 <= dictionary.length <= 1000
1 <= dictionary[i].length <= 100
dictionary[i] 仅由小写字母组成。
1 <= sentence.length <= 10^6
sentence 仅由小写字母和空格组成。
sentence 中单词的总量在范围 [1, 1000] 内。
sentence 中每个单词的长度在范围 [1, 1000] 内。
sentence 中单词之间由一个空格隔开。
sentence 没有前导或尾随空格。
 ",166,,28177,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/implement-trie-prefix-tree/'],47109
评论 (489),dota2-senate,中等,"Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)
Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：
禁止一名参议员的权利：
参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。
宣布胜利：
          如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。
  给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。
以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。
假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。
  示例 1：
输入：""RD""
输出：""Radiant""
解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人
示例 2：
输入：""RDD""
输出：""Dire""
解释：
第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
  提示：
给定字符串的长度在 [1, 10,000] 之间.
 ",235,,31825,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/teemo-attacking/'],66478
评论 (502),2-keys-keyboard,中等,"最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：
Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
Paste（粘贴）：粘贴 上一次 复制的字符。
给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。
  示例 1：
输入：3
输出：3
解释：
最初, 只有一个字符 'A'。
第 1 步, 使用 Copy All 操作。
第 2 步, 使用 Paste 操作来获得 'AA'。
第 3 步, 使用 Paste 操作来获得 'AAA'。
示例 2：
输入：n = 1
输出：0
  提示：
1 <= n <= 1000",461,,57058,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/4-keys-keyboard/', 'https://leetcode.cn/problems/broken-calculator/']",99951
评论 (37),4-keys-keyboard,Unknown,,-1,,-1,[],[],-1
评论 (201),find-duplicate-subtrees,中等,"给定一棵二叉树 root，返回所有重复的子树。
对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。
如果两棵树具有相同的结构和相同的结点值，则它们是重复的。
  示例 1：
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
示例 2：
输入：root = [2,1,1]
输出：[[1]]
示例 3：
输入：root = [2,2,2,3,null,3,null]
输出：[[2,3],[3]]
  提示：
树中的结点数在[1,10^4]范围内。
-200 <= Node.val <= 200",418,,51061,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/', 'https://leetcode.cn/problems/serialize-and-deserialize-bst/', 'https://leetcode.cn/problems/construct-string-from-binary-tree/']",87699
评论 (538),two-sum-iv-input-is-a-bst,简单,"给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。
  示例 1：
输入: root = [5,3,6,2,4,null,7], k = 9
输出: true
示例 2：
输入: root = [5,3,6,2,4,null,7], k = 28
输出: false
  提示:
二叉树的节点个数的范围是  [1, 104].
-104 <= Node.val <= 104
root 为二叉搜索树
-105 <= k <= 105",396,https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg,91813,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/two-sum/', 'https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/', 'https://leetcode.cn/problems/two-sum-iii-data-structure-design/', 'https://leetcode.cn/problems/two-sum-bsts/']",145418
评论 (586),maximum-binary-tree,中等,"给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:
创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。
  示例 1：
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
示例 2：
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
  提示：
1 <= nums.length <= 1000
0 <= nums[i] <= 1000
nums 中的所有整数 互不相同",432,https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg,102247,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/monotonic-stack/']",['https://leetcode.cn/problems/maximum-binary-tree-ii/'],125942
评论 (152),print-binary-tree,中等,"在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：
行数 m 应当等于给定二叉树的高度。
列数 n 应当总是奇数。
根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。
每个未使用的空间应包含一个空的字符串""""。
使用相同的规则输出子树。
示例 1:
输入:
     1
    /
   2
输出:
[["""", ""1"", """"],
 [""2"", """", """"]]
示例 2:
输入:
     1
    / \
   2   3
    \
     4
输出:
[["""", """", """", ""1"", """", """", """"],
 ["""", ""2"", """", """", """", ""3"", """"],
 ["""", """", ""4"", """", """", """", """"]]
示例 3:
输入:
      1
     / \
    2   5
   / 
  3 
 / 
4 
输出:
[["""",  """",  """", """",  """", """", """", ""1"", """",  """",  """",  """",  """", """", """"]
 ["""",  """",  """", ""2"", """", """", """", """",  """",  """",  """",  ""5"", """", """", """"]
 ["""",  ""3"", """", """",  """", """", """", """",  """",  """",  """",  """",  """", """", """"]
 [""4"", """",  """", """",  """", """", """", """",  """",  """",  """",  """",  """", """", """"]]
注意: 二叉树的高度在范围 [1, 10] 中。",124,,11528,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],19074
评论 (27),coin-path,Unknown,,-1,,-1,[],[],-1
评论,robot-return-to-origin,简单,"在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。
移动顺序由字符串 moves 表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。
如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。
注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。
  示例 1:
输入: moves = ""UD""
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
示例 2:
输入: moves = ""LL""
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
  提示:
1 <= moves.length <= 2 * 104
moves 只包含字符 'U', 'D', 'L' 和 'R'",228,,89743,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",['https://leetcode.cn/problems/number-of-provinces/'],114408
评论 (240),find-k-closest-elements,中等,"给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。
整数 a 比整数 b 更接近 x 需要满足：
|a - x| < |b - x| 或者
|a - x| == |b - x| 且 a < b
  示例 1：
输入：arr = [1,2,3,4,5], k = 4, x = 3
输出：[1,2,3,4]
示例 2：
输入：arr = [1,2,3,4,5], k = 4, x = -1
输出：[1,2,3,4]
  提示：
1 <= k <= arr.length
1 <= arr.length <= 104
arr 按 升序 排列
-104 <= arr[i], x <= 104",322,,38819,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/guess-number-higher-or-lower/', 'https://leetcode.cn/problems/guess-number-higher-or-lower-ii/', 'https://leetcode.cn/problems/find-k-th-smallest-pair-distance/']",84863
评论 (353),split-array-into-consecutive-subsequences,中等,"给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个长度至少为 3 的子序列，其中每个子序列都由连续整数组成。
如果可以完成上述分割，则返回 true ；否则，返回 false 。
  示例 1：
输入: [1,2,3,3,4,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3
3, 4, 5
示例 2：
输入: [1,2,3,3,4,4,5,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3, 4, 5
3, 4, 5
示例 3：
输入: [1,2,3,4,4,5]
输出: False
  提示：
1 <= nums.length <= 10000",372,,31452,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/heap-priority-queue/']",['https://leetcode.cn/problems/top-k-frequent-elements/'],57964
评论 (11),remove-9,Unknown,,-1,,-1,[],[],-1
评论 (600),image-smoother,简单,"图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。
每个单元格的  平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。
如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。
给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。
  示例 1:
输入:img = [[1,1,1],[1,0,1],[1,1,1]]
输出:[[0, 0, 0],[0, 0, 0], [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
示例 2:
输入: img = [[100,200,100],[200,50,200],[100,200,100]]
输出: [[137,141,137],[141,138,141],[137,141,137]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
  提示:
m == img.length
n == img[i].length
1 <= m, n <= 200
0 <= img[i][j] <= 255",169,https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg,46212,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],71643
评论 (402),maximum-width-of-binary-tree,中等,"给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。
每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。
示例 1:
输入: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
示例 2:
输入: 

          1
         /  
        3    
       / \       
      5   3     

输出: 2
解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。
示例 3:
输入: 

          1
         / \
        3   2 
       /        
      5      

输出: 2
解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。
示例 4:
输入: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
输出: 8
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
注意: 答案在32位有符号整数的表示范围内。",360,,44867,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],109451
评论 (30),equal-tree-partition,Unknown,,-1,,-1,[],[],-1
评论 (189),strange-printer,困难,"有台奇怪的打印机有以下两个特殊要求：
打印机每次只能打印由 同一个字符 组成的序列。
每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。
给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。
  示例 1：
输入：s = ""aaabbb""
输出：2
解释：首先打印 ""aaa"" 然后打印 ""bbb""。
示例 2：
输入：s = ""aba""
输出：2
解释：首先打印 ""aaa"" 然后在第二个位置打印 ""b"" 覆盖掉原来的字符 'a'。
  提示：
1 <= s.length <= 100
s 由小写英文字母组成",261,,23904,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/remove-boxes/'],36536
评论 (734),non-decreasing-array,中等,"给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。
  示例 1:
输入: nums = [4,2,3]
输出: true
解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。
示例 2:
输入: nums = [4,2,1]
输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
  提示：
n == nums.length
1 <= n <= 104
-105 <= nums[i] <= 105",669,,84938,['https://leetcode.cn/tag/array/'],[],309999
评论 (37),path-sum-iv,Unknown,,-1,,-1,[],[],-1
评论 (107),beautiful-arrangement-ii,中等,"给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数，并同时满足下述条件：
假设该列表是 answer = [a1, a2, a3, ... , an] ，那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数。
返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。
  示例 1：
输入：n = 3, k = 1
输出：[1, 2, 3]
解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1
示例 2：
输入：n = 3, k = 2
输出：[1, 3, 2]
解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2
  提示：
1 <= k < n <= 104
 ",108,,9533,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/beautiful-arrangement/'],15312
评论 (209),kth-smallest-number-in-multiplication-table,困难,"几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？
给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。
例 1：
输入: m = 3, n = 3, k = 5
输出: 3
解释: 
乘法表:
1 2 3
2 4 6
3 6 9

第5小的数字是 3 (1, 2, 2, 3, 3).
例 2：
输入: m = 2, n = 3, k = 6
输出: 6
解释: 
乘法表:
1 2 3
2 4 6

第6小的数字是 6 (1, 2, 2, 3, 4, 6).
注意：
m 和 n 的范围在 [1, 30000] 之间。
k 的范围在 [1, m * n] 之间。",315,,27401,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']","['https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/', 'https://leetcode.cn/problems/find-k-th-smallest-pair-distance/', 'https://leetcode.cn/problems/k-th-smallest-prime-fraction/']",46805
评论 (411),trim-a-binary-search-tree,中等,"给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。
所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
  示例 1：
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
示例 2：
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
  提示：
树中节点数在范围 [1, 104] 内
0 <= Node.val <= 104
树中每个节点的值都是 唯一 的
题目数据保证输入是一棵有效的二叉搜索树
0 <= low <= high <= 104",540,https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg,60790,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",[],91131
评论 (266),maximum-swap,中等,"给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
示例 1 :
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
示例 2 :
输入: 9973
输出: 9973
解释: 不需要交换。
注意:
给定数字的范围是 [0, 108]",240,,26163,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/create-maximum-number/'],56751
评论 (577),second-minimum-node-in-a-binary-tree,简单,"给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，即 root.val = min(root.left.val, root.right.val) 总成立。
给出这样的一个二叉树，你需要输出所有节点中的 第二小的值 。
如果第二小的值不存在的话，输出 -1 。
  示例 1：
输入：root = [2,2,5,null,null,5,7]
输出：5
解释：最小的值是 2 ，第二小的值是 5 。
示例 2：
输入：root = [2,2,2]
输出：-1
解释：最小的值是 2, 但是不存在第二小的值。
  提示：
树中节点数目在范围 [1, 25] 内
1 <= Node.val <= 231 - 1
对于树中每个节点 root.val == min(root.left.val, root.right.val)",260,https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg,60797,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/kth-smallest-element-in-a-bst/'],125897
评论 (53),bulb-switcher-ii,中等,"现有一个房间，墙上挂有 n 只已经打开的灯泡和 4 个按钮。在进行了 m 次未知操作后，你需要返回这 n 只灯泡可能有多少种不同的状态。
假设这 n 只灯泡被编号为 [1, 2, 3 ..., n]，这 4 个按钮的功能如下：
将所有灯泡的状态反转（即开变为关，关变为开）
将编号为偶数的灯泡的状态反转
将编号为奇数的灯泡的状态反转
将编号为 3k+1 的灯泡的状态反转（k = 0, 1, 2, ...)
示例 1:
输入: n = 1, m = 1.
输出: 2
说明: 状态为: [开], [关]
示例 2:
输入: n = 2, m = 1.
输出: 3
说明: 状态为: [开, 关], [关, 开], [关, 关]
示例 3:
输入: n = 3, m = 1.
输出: 4
说明: 状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].
注意： n 和 m 都属于 [0, 1000].",94,,4701,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/bulb-switcher/'],8715
评论 (317),number-of-longest-increasing-subsequence,中等,"给定一个未排序的整数数组 nums ， 返回最长递增子序列的个数 。
注意 这个数列必须是 严格 递增的。
  示例 1:
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:
输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
  提示: 
1 <= nums.length <= 2000
-106 <= nums[i] <= 106",601,,63919,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/longest-increasing-subsequence/', 'https://leetcode.cn/problems/longest-continuous-increasing-subsequence/']",144985
评论 (698),longest-continuous-increasing-subsequence,简单,"给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
  示例 1：
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
示例 2：
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
  提示：
1 <= nums.length <= 104
-109 <= nums[i] <= 109",286,,128851,['https://leetcode.cn/tag/array/'],"['https://leetcode.cn/problems/number-of-longest-increasing-subsequence/', 'https://leetcode.cn/problems/minimum-window-subsequence/']",244388
评论 (246),cut-off-trees-for-golf-event,困难,"你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：
0 表示障碍，无法触碰
1 表示地面，可以行走
比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度
每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。
你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。
你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。
可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。
  示例 1：
输入：forest = [[1,2,3],[0,0,4],[7,6,5]]
输出：6
解释：沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。
示例 2：
输入：forest = [[1,2,3],[0,0,0],[7,6,5]]
输出：-1
解释：由于中间一行被障碍阻塞，无法访问最下面一行中的树。
示例 3：
输入：forest = [[2,3,4],[0,0,5],[8,7,6]]
输出：6
解释：可以按与示例 1 相同的路径来砍掉所有的树。
(0,0) 位置的树，可以直接砍去，不用算步数。
  提示：
m == forest.length
n == forest[i].length
1 <= m, n <= 50
0 <= forest[i][j] <= 109",166,https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg,13524,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],26014
评论 (117),implement-magic-dictionary,中等,"设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。
实现 MagicDictionary 类：
MagicDictionary() 初始化对象
void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同
bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。
  示例：
输入
[""MagicDictionary"", ""buildDict"", ""search"", ""search"", ""search"", ""search""]
[[], [[""hello"", ""leetcode""]], [""hello""], [""hhllo""], [""hell""], [""leetcoded""]]
输出
[null, null, false, true, false, false]

解释
MagicDictionary magicDictionary = new MagicDictionary();
magicDictionary.buildDict([""hello"", ""leetcode""]);
magicDictionary.search(""hello""); // 返回 False
magicDictionary.search(""hhllo""); // 将第二个 'h' 替换为 'e' 可以匹配 ""hello"" ，所以返回 True
magicDictionary.search(""hell""); // 返回 False
magicDictionary.search(""leetcoded""); // 返回 False
  提示：
1 <= dictionary.length <= 100
1 <= dictionary[i].length <= 100
dictionary[i] 仅由小写英文字母组成
dictionary 中的所有字符串 互不相同
1 <= searchWord.length <= 100
searchWord 仅由小写英文字母组成
buildDict 仅在 search 之前调用一次
最多调用 100 次 search",112,,10802,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/implement-trie-prefix-tree/', 'https://leetcode.cn/problems/longest-word-in-dictionary/']",18017
评论 (384),map-sum-pairs,中等,"设计一个 map ，满足以下几点:
字符串表示键，整数表示值
返回具有前缀等于给定字符串的键的值的总和
实现一个 MapSum 类：
MapSum() 初始化 MapSum 对象
void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对 key-value 将被替代成新的键值对。
int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。
  示例 1：
输入：
[""MapSum"", ""insert"", ""sum"", ""insert"", ""sum""]
[[], [""apple"", 3], [""ap""], [""app"", 2], [""ap""]]
输出：
[null, null, 3, null, 5]

解释：
MapSum mapSum = new MapSum();
mapSum.insert(""apple"", 3);  
mapSum.sum(""ap"");           // 返回 3 (apple = 3)
mapSum.insert(""app"", 2);    
mapSum.sum(""ap"");           // 返回 5 (apple + app = 3 + 2 = 5)
  提示：
1 <= key.length, prefix.length <= 50
key 和 prefix 仅由小写英文字母组成
1 <= val <= 1000
最多调用 50 次 insert 和 sum",204,,40939,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],61651
评论 (350),valid-parenthesis-string,中等,"给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
任何左括号 ( 必须有相应的右括号 )。
任何右括号 ) 必须有相应的左括号 ( 。
左括号 ( 必须在对应的右括号之前 )。
* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
一个空字符串也被视为有效字符串。
示例 1:
输入: ""()""
输出: True
示例 2:
输入: ""(*)""
输出: True
示例 3:
输入: ""(*))""
输出: True
注意:
字符串大小将在 [1，100] 范围内。",478,,54561,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/special-binary-string/'],140116
评论 (406),24-game,困难,"给定一个长度为4的整数数组 cards 。你有 4 张卡片，每张卡片上都包含一个范围在 [1,9] 的数字。您应该使用运算符 ['+', '-', '*', '/'] 和括号 '(' 和 ')' 将这些卡片上的数字排列成数学表达式，以获得值24。
你须遵守以下规则:
除法运算符 '/' 表示实数除法，而不是整数除法。
例如， 4 /(1 - 2 / 3)= 4 /(1 / 3)= 12 。
每个运算都在两个数字之间。特别是，不能使用 “-” 作为一元运算符。
例如，如果 cards =[1,1,1,1] ，则表达式 “-1 -1 -1 -1” 是 不允许 的。
你不能把数字串在一起
例如，如果 cards =[1,2,1,2] ，则表达式 “12 + 12” 无效。
如果可以得到这样的表达式，其计算结果为 24 ，则返回 true ，否则返回 false 。
  示例 1:
输入: cards = [4, 1, 8, 7]
输出: true
解释: (8-4) * (7-1) = 24
示例 2:
输入: cards = [1, 2, 1, 2]
输出: false
  提示:
cards.length == 4
1 <= cards[i] <= 9",375,,32734,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/backtracking/']",[],60772
评论 (607),valid-palindrome-ii,简单,"给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
  示例 1:
输入: s = ""aba""
输出: true
示例 2:
输入: s = ""abca""
输出: true
解释: 你可以删除c字符。
示例 3:
输入: s = ""abc""
输出: false
  提示:
1 <= s.length <= 105
s 由小写英文字母组成",494,,109650,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/valid-palindrome/'],273472
评论 (34),next-closest-time,Unknown,,-1,,-1,[],[],-1
评论 (712),baseball-game,简单,"你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。
比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：
整数 x - 表示本回合新获得分数 x
""+"" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
""D"" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
""C"" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
请你返回记录中所有得分的总和。
  示例 1：
输入：ops = [""5"",""2"",""C"",""D"",""+""]
输出：30
解释：
""5"" - 记录加 5 ，记录现在是 [5]
""2"" - 记录加 2 ，记录现在是 [5, 2]
""C"" - 使前一次得分的记录无效并将其移除，记录现在是 [5].
""D"" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].
""+"" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].
所有得分的总和 5 + 10 + 15 = 30
示例 2：
输入：ops = [""5"",""-2"",""4"",""C"",""D"",""9"",""+"",""+""]
输出：27
解释：
""5"" - 记录加 5 ，记录现在是 [5]
""-2"" - 记录加 -2 ，记录现在是 [5, -2]
""4"" - 记录加 4 ，记录现在是 [5, -2, 4]
""C"" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]
""D"" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]
""9"" - 记录加 9 ，记录现在是 [5, -2, -4, 9]
""+"" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]
""+"" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]
所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27
示例 3：
输入：ops = [""1""]
输出：1
  提示：
1 <= ops.length <= 1000
ops[i] 为 ""C""、""D""、""+""，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]
对于 ""+"" 操作，题目数据保证记录此操作时前面总是存在两个有效的分数
对于 ""C"" 和 ""D"" 操作，题目数据保证记录此操作时前面总是存在一个有效的分数",251,,81184,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],112541
评论 (30),k-empty-slots,Unknown,,-1,,-1,[],[],-1
评论 (482),redundant-connection,中等,"树可以看成是一个连通且 无环 的 无向 图。
给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。
请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。
  示例 1：
输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]
示例 2：
输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
  提示:
n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ai < bi <= edges.length
ai != bi
edges 中无重复元素
给定的图是连通的 ",466,,74136,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']","['https://leetcode.cn/problems/redundant-connection-ii/', 'https://leetcode.cn/problems/accounts-merge/']",110529
评论 (248),redundant-connection-ii,困难,"在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。
输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。
结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。
返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。
  示例 1：
输入：edges = [[1,2],[1,3],[2,3]]
输出：[2,3]
示例 2：
输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
输出：[4,1]
  提示：
n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ui, vi <= n",302,https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg,22731,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']",['https://leetcode.cn/problems/redundant-connection/'],53734
评论 (495),repeated-string-match,中等,"给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。
注意：字符串 ""abc"" 重复叠加 0 次是 """"，重复叠加 1 次是 ""abc""，重复叠加 2 次是 ""abcabc""。
  示例 1：
输入：a = ""abcd"", b = ""cdabcdab""
输出：3
解释：a 重复叠加三遍后为 ""abcdabcdabcd"", 此时 b 是其子串。
示例 2：
输入：a = ""a"", b = ""aa""
输出：2
示例 3：
输入：a = ""a"", b = ""a""
输出：1
示例 4：
输入：a = ""abc"", b = ""wxyz""
输出：-1
  提示：
1 <= a.length <= 104
1 <= b.length <= 104
a 和 b 由小写英文字母组成",269,,44978,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/']",['https://leetcode.cn/problems/repeated-substring-pattern/'],112268
评论 (309),longest-univalue-path,中等,"给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。
两个节点之间的路径长度 由它们之间的边数表示。
  示例 1:
输入：root = [5,4,5,1,1,5]
输出：2
示例 2:
输入：root = [1,4,5,4,4,5]
输出：2
  提示:
树的节点数的范围是 [0, 104] 
-1000 <= Node.val <= 1000
树的深度将不超过 1000 ",565,,45598,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/binary-tree-maximum-path-sum/', 'https://leetcode.cn/problems/count-univalue-subtrees/', 'https://leetcode.cn/problems/path-sum-iii/']",101362
评论 (406),knight-probability-in-chessboard,中等,"在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。
象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。
每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。
骑士继续移动，直到它走了 k 步或离开了棋盘。
返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。
  示例 1：
输入: n = 3, k = 2, row = 0, column = 0
输出: 0.0625
解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。
在每一个位置上，也有两种移动可以让骑士留在棋盘上。
骑士留在棋盘上的总概率是0.0625。
示例 2：
输入: n = 1, k = 0, row = 0, column = 0
输出: 1.00000
  提示:
1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n",289,,32251,['https://leetcode.cn/tag/dynamic-programming/'],['https://leetcode.cn/problems/out-of-boundary-paths/'],55352
评论 (284),maximum-sum-of-3-non-overlapping-subarrays,困难,"给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、且全部数字和（3 * k 项）最大的子数组，并返回这三个子数组。
以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。如果有多个结果，返回字典序最小的一个。
  示例 1：
输入：nums = [1,2,1,2,6,7,5,1], k = 2
输出：[0,3,5]
解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。
也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。
示例 2：
输入：nums = [1,2,1,2,1,2,1,2,1], k = 2
输出：[0,2,4]
  提示：
1 <= nums.length <= 2 * 104
1 <= nums[i] < 216
1 <= k <= floor(nums.length / 3)",317,,21095,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/'],37442
评论 (454),employee-importance,中等,"给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。
比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。
  示例：
输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
输出：11
解释：
员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。
  提示：
一个员工最多有一个 直系 领导，但是可以有多个 直系 下属
员工数量不超过 2000 。",261,,60251,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/hash-table/']",['https://leetcode.cn/problems/nested-list-weight-sum/'],92457
评论 (183),stickers-to-spell-word,困难,"我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。
您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。
返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。
注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。
  示例 1：
输入： stickers = [""with"",""example"",""science""], target = ""thehat""
输出：3
解释：
我们可以使用 2 个 ""with"" 贴纸，和 1 个 ""example"" 贴纸。
把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。
此外，这是形成目标字符串所需的最小贴纸数量。
示例 2:
输入：stickers = [""notice"",""possible""], target = ""basicbasic""
输出：-1
解释：我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。
  提示:
n == stickers.length
1 <= n <= 50
1 <= stickers[i].length <= 10
1 <= target.length <= 15
stickers[i] 和 target 由小写英文单词组成",225,,20277,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",['https://leetcode.cn/problems/ransom-note/'],32711
评论 (544),top-k-frequent-words,中等,"给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。
返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。
  示例 1：
输入: words = [""i"", ""love"", ""leetcode"", ""i"", ""love"", ""coding""], k = 2
输出: [""i"", ""love""]
解析: ""i"" 和 ""love"" 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 ""i"" 在 ""love"" 之前。
示例 2：
输入: [""the"", ""day"", ""is"", ""sunny"", ""the"", ""the"", ""the"", ""sunny"", ""is"", ""is""], k = 4
输出: [""the"", ""is"", ""sunny"", ""day""]
解析: ""the"", ""is"", ""sunny"" 和 ""day"" 是出现次数最多的四个单词，
    出现次数依次为 4, 3, 2 和 1 次。
  注意：
1 <= words.length <= 500
1 <= words[i] <= 10
words[i] 由小写英文字母组成。
k 的取值范围是 [1, 不同 words[i] 的数量]
  进阶：尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。",456,,81848,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/bucket-sort/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/top-k-frequent-elements/', 'https://leetcode.cn/problems/k-closest-points-to-origin/']",143939
评论 (629),binary-number-with-alternating-bits,简单,"给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。
  示例 1：
输入：n = 5
输出：true
解释：5 的二进制表示是：101
示例 2：
输入：n = 7
输出：false
解释：7 的二进制表示是：111.
示例 3：
输入：n = 11
输出：false
解释：11 的二进制表示是：1011.
  提示：
1 <= n <= 231 - 1",207,,69034,['https://leetcode.cn/tag/bit-manipulation/'],['https://leetcode.cn/problems/number-of-1-bits/'],105624
评论 (51),number-of-distinct-islands,Unknown,,-1,,-1,[],[],-1
评论 (970),max-area-of-island,中等,"给你一个大小为 m x n 的二进制矩阵 grid 。
岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
岛屿的面积是岛上值为 1 的单元格的数目。
计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
  示例 1：
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
示例 2：
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 50
grid[i][j] 为 0 或 1",781,https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg,205090,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/number-of-islands/', 'https://leetcode.cn/problems/island-perimeter/']",303395
评论 (498),count-binary-substrings,简单,"给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是成组连续的。
重复出现（不同位置）的子串也要统计它们出现的次数。
  示例 1：
输入：s = ""00110011""
输出：6
解释：6 个子串满足具有相同数量的连续 1 和 0 ：""0011""、""01""、""1100""、""10""、""0011"" 和 ""01"" 。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，""00110011"" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。
示例 2：
输入：s = ""10101""
输出：4
解释：有 4 个子串：""10""、""01""、""10""、""01"" ，具有相同数量的连续 1 和 0 。
  提示：
1 <= s.length <= 105
s[i] 为 '0' 或 '1'",455,,60045,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/encode-and-decode-strings/'],94296
评论 (811),degree-of-an-array,简单,"给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。
你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。
  示例 1：
输入：nums = [1,2,2,3,1]
输出：2
解释：
输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。
连续子数组里面拥有相同度的有如下所示：
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。
示例 2：
输入：nums = [1,2,2,3,1,4,2]
输出：6
解释：
数组的度是 3 ，因为元素 2 重复出现 3 次。
所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。
  提示：
nums.length 在 1 到 50,000 范围内。
nums[i] 是一个在 0 到 49,999 范围内的整数。",411,,75908,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",['https://leetcode.cn/problems/maximum-subarray/'],126333
评论 (286),partition-to-k-equal-sum-subsets,中等,"给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。
  示例 1：
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
示例 2:
输入: nums = [1,2,3,4], k = 3
输出: false
  提示：
1 <= k <= len(nums) <= 16
0 < nums[i] < 10000
每个元素的频率在 [1,4] 范围内",563,,47605,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",['https://leetcode.cn/problems/partition-equal-subset-sum/'],114299
评论 (40),falling-squares,困难,"在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。
第 i 个掉落的方块（positions[i] = (left, side_length)）是正方形，其中 left 表示该方块最左边的点位置(positions[i][0])，side_length 表示该方块的边长(positions[i][1])。
每个方块的底部边缘平行于数轴（即 x 轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。
方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，因为只有底边才具有粘性。
  返回一个堆叠高度列表 ans 。每一个堆叠高度 ans[i] 表示在通过 positions[0], positions[1], ..., positions[i] 表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。
    示例 1:
输入: [[1, 2], [2, 3], [6, 1]]
输出: [2, 5, 5]
解释:

第一个方块 positions[0] = [1, 2] 掉落：
_aa
_aa
-------
方块最大高度为 2 。

第二个方块 positions[1] = [2, 3] 掉落：
__aaa
__aaa
__aaa
_aa__
_aa__
--------------
方块最大高度为5。
大的方块保持在较小的方块的顶部，不论它的重心在哪里，因为方块的底部边缘有非常大的粘性。

第三个方块 positions[1] = [6, 1] 掉落：
__aaa
__aaa
__aaa
_aa
_aa___a
-------------- 
方块最大高度为5。

因此，我们返回结果[2, 5, 5]。
  示例 2:
输入: [[100, 100], [200, 100]]
输出: [100, 100]
解释: 相邻的方块不会过早地卡住，只有它们的底部边缘才能粘在表面上。
  注意:
1 <= positions.length <= 1000.
1 <= positions[i][0] <= 10^8.
1 <= positions[i][1] <= 10^6.
 ",73,,3932,"['https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/ordered-set/']",['https://leetcode.cn/problems/the-skyline-problem/'],7902
评论 (635),search-in-a-binary-search-tree,简单,"给定二叉搜索树（BST）的根节点 root 和一个整数值 val。
你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。
  示例 1:
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
Example 2:
输入：root = [4,2,7,1,3], val = 5
输出：[]
  提示：
数中节点数在 [1, 5000] 范围内
1 <= Node.val <= 107
root 是二叉搜索树
1 <= val <= 107",279,https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg,170237,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/closest-binary-search-tree-value/', 'https://leetcode.cn/problems/insert-into-a-binary-search-tree/']",219801
评论 (460),insert-into-a-binary-search-tree,中等,"给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。
注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。
  示例 1：
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
示例 2：
输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
示例 3：
输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
  提示：
树中的节点数将在 [0, 104]的范围内。
-108 <= Node.val <= 108
所有值 Node.val 是 独一无二 的。
-108 <= val <= 108
保证 val 在原始BST中不存在。",312,https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg,124465,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/search-in-a-binary-search-tree/'],173067
评论 (50),search-in-a-sorted-array-of-unknown-size,Unknown,,-1,,-1,[],[],-1
评论 (537),kth-largest-element-in-a-stream,简单,"设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。
请实现 KthLargest 类：
KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。
  示例：
输入：
[""KthLargest"", ""add"", ""add"", ""add"", ""add"", ""add""]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
  提示：
1 <= k <= 104
0 <= nums.length <= 104
-104 <= nums[i] <= 104
-104 <= val <= 104
最多调用 add 方法 104 次
题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素",352,,73126,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/data-stream/', 'https://leetcode.cn/tag/heap-priority-queue/']",['https://leetcode.cn/problems/kth-largest-element-in-an-array/'],140561
评论 (997),binary-search,简单,"给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
  提示：
你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。",831,,609394,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",['https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/'],1120367
评论 (442),design-hashset,简单,"不使用任何内建的哈希表库设计一个哈希集合（HashSet）。
实现 MyHashSet 类：
void add(key) 向哈希集合中插入值 key 。
bool contains(key) 返回哈希集合中是否存在这个值 key 。
void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。
  示例：
输入：
[""MyHashSet"", ""add"", ""add"", ""contains"", ""contains"", ""add"", ""contains"", ""remove"", ""contains""]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
输出：
[null, null, null, true, false, null, true, null, false]

解释：
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // 返回 True
myHashSet.contains(3); // 返回 False ，（未找到）
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // 返回 True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // 返回 False ，（已移除）
  提示：
0 <= key <= 106
最多调用 104 次 add、remove 和 contains",235,,84270,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/hash-function/']",['https://leetcode.cn/problems/design-hashmap/'],131999
评论 (372),design-hashmap,简单,"不使用任何内建的哈希表库设计一个哈希映射（HashMap）。
实现 MyHashMap 类：
MyHashMap() 用空映射初始化对象
void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。
int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。
void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。
  示例：
输入：
[""MyHashMap"", ""put"", ""put"", ""get"", ""get"", ""put"", ""get"", ""remove"", ""get""]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
输出：
[null, null, null, 1, -1, null, 1, null, -1]

解释：
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]
myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]
myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）
myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]
myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]
myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]
  提示：
0 <= key, value <= 106
最多调用 104 次 put、get 和 remove 方法",299,,76870,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/hash-function/']",['https://leetcode.cn/problems/design-hashset/'],120331
评论 (497),design-linked-list,中等,"设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
在链表类中实现这些功能：
get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。
  示例：
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
  提示：
所有val值都在 [1, 1000] 之内。
操作次数将在  [1, 1000] 之内。
请不要使用内置的 LinkedList 库。",457,,117929,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/linked-list/']",[],350671
评论 (46),insert-into-a-sorted-circular-linked-list,Unknown,,-1,,-1,[],[],-1
评论 (867),to-lower-case,简单,"给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。
  示例 1：
输入：s = ""Hello""
输出：""hello""
示例 2：
输入：s = ""here""
输出：""here""
示例 3：
输入：s = ""LOVELY""
输出：""lovely""
  提示：
1 <= s.length <= 100
s 由 ASCII 字符集中的可打印字符组成",204,,107410,['https://leetcode.cn/tag/string/'],[],138935
评论 (77),random-pick-with-blacklist,困难,"给定一个整数 n 和一个 无重复 黑名单整数数组 blacklist 。设计一种算法，从 [0, n - 1] 范围内的任意整数中选取一个 未加入 黑名单 blacklist 的整数。任何在上述范围内且不在黑名单 blacklist 中的整数都应该有 同等的可能性 被返回。
优化你的算法，使它最小化调用语言 内置 随机函数的次数。
实现 Solution 类:
Solution(int n, int[] blacklist) 初始化整数 n 和被加入黑名单 blacklist 的整数
int pick() 返回一个范围为 [0, n - 1] 且不在黑名单 blacklist 中的随机整数
  示例 1：
输入
[""Solution"", ""pick"", ""pick"", ""pick"", ""pick"", ""pick"", ""pick"", ""pick""]
[[7, [2, 3, 5]], [], [], [], [], [], [], []]
输出
[null, 0, 4, 1, 6, 1, 0, 4]

解释
Solution solution = new Solution(7, [2, 3, 5]);
solution.pick(); // 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，
                 // 0、1、4和6的返回概率必须相等(即概率为1/4)。
solution.pick(); // 返回 4
solution.pick(); // 返回 1
solution.pick(); // 返回 6
solution.pick(); // 返回 1
solution.pick(); // 返回 0
solution.pick(); // 返回 4
  提示:
1 <= n <= 109
0 <= blacklist.length <- min(105, n - 1)
0 <= blacklist[i] < n
blacklist 中所有值都 不同
 pick 最多被调用 2 * 104 次",99,,9652,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/randomized/']","['https://leetcode.cn/problems/random-pick-index/', 'https://leetcode.cn/problems/random-pick-with-weight/']",25440
评论 (16),number-of-distinct-islands-ii,Unknown,,-1,,-1,[],[],-1
评论 (166),minimum-ascii-delete-sum-for-two-strings,中等,"给定两个字符串s1 和 s2，返回 使两个字符串相等所需删除字符的 ASCII 值的最小和 。
  示例 1:
输入: s1 = ""sea"", s2 = ""eat""
输出: 231
解释: 在 ""sea"" 中删除 ""s"" 并将 ""s"" 的值(115)加入总和。
在 ""eat"" 中删除 ""t"" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
示例 2:
输入: s1 = ""delete"", s2 = ""leet""
输出: 403
解释: 在 ""delete"" 中删除 ""dee"" 字符串变成 ""let""，
将 100[d]+101[e]+101[e] 加入总和。在 ""leet"" 中删除 ""e"" 将 101[e] 加入总和。
结束时，两个字符串都等于 ""let""，结果即为 100+101+101+101 = 403 。
如果改为将两个字符串转换为 ""lee"" 或 ""eet""，我们会得到 433 或 417 的结果，比答案更大。
  提示:
0 <= s1.length, s2.length <= 1000
s1 和 s2 由小写英文字母组成",274,,21878,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/edit-distance/', 'https://leetcode.cn/problems/longest-increasing-subsequence/', 'https://leetcode.cn/problems/delete-operation-for-two-strings/']",32302
评论 (452),subarray-product-less-than-k,中等,"给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。
  示例 1：
输入：nums = [10,5,2,6], k = 100
输出：8
解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。
示例 2：
输入：nums = [1,2,3], k = 0
输出：0
  提示: 
1 <= nums.length <= 3 * 104
1 <= nums[i] <= 1000
0 <= k <= 106",552,,76459,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/maximum-product-subarray/', 'https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/', 'https://leetcode.cn/problems/subarray-sum-equals-k/', 'https://leetcode.cn/problems/two-sum-less-than-k/']",157167
评论 (605),best-time-to-buy-and-sell-stock-with-transaction-fee,中等,"给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。
你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
返回获得利润的最大值。
注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
  示例 1：
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
示例 2：
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
  提示：
1 <= prices.length <= 5 * 104
1 <= prices[i] < 5 * 104
0 <= fee < 5 * 104",717,,149059,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/'],201613
评论 (46),range-module,困难,"Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 半开区间 的范围并查询它们。
半开区间 [left, right) 表示所有 left <= x < right 的实数 x 。
实现 RangeModule 类:
RangeModule() 初始化数据结构的对象。
void addRange(int left, int right) 添加 半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。
boolean queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true ，否则返回 false 。
void removeRange(int left, int right) 停止跟踪 半开区间 [left, right) 中当前正在跟踪的每个实数。
  示例 1：
输入
[""RangeModule"", ""addRange"", ""removeRange"", ""queryRange"", ""queryRange"", ""queryRange""]
[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]
输出
[null, null, null, true, false, true]

解释
RangeModule rangeModule = new RangeModule();
rangeModule.addRange(10, 20);
rangeModule.removeRange(14, 16);
rangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）
rangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）
rangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）
  提示：
1 <= left < right <= 109
在单个测试用例中，对 addRange 、  queryRange 和 removeRange 的调用总数不超过 104 次",113,,4146,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/ordered-set/']","['https://leetcode.cn/problems/merge-intervals/', 'https://leetcode.cn/problems/insert-interval/', 'https://leetcode.cn/problems/data-stream-as-disjoint-intervals/']",9503
评论 (52),max-stack,Unknown,,-1,,-1,[],[],-1
评论 (738),1-bit-and-2-bit-characters,简单,"有两种特殊字符：
第一种字符可以用一比特 0 表示
第二种字符可以用两比特（10 或 11）表示
给你一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一个一比特字符，则返回 true 。
  示例 1:
输入: bits = [1, 0, 0]
输出: true
解释: 唯一的解码方式是将其解析为一个两比特字符和一个一比特字符。
所以最后一个字符是一比特字符。
示例 2:
输入：bits = [1,1,1,0]
输出：false
解释：唯一的解码方式是将其解析为两比特字符和两比特字符。
所以最后一个字符不是一比特字符。
  提示:
1 <= bits.length <= 1000
bits[i] 为 0 或 1",279,,62412,['https://leetcode.cn/tag/array/'],['https://leetcode.cn/problems/gray-code/'],112545
评论 (480),maximum-length-of-repeated-subarray,中等,"给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。
  示例 1：
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
示例 2：
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
  提示：
1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 100",713,,125571,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",['https://leetcode.cn/problems/minimum-size-subarray-sum/'],221162
评论 (72),find-k-th-smallest-pair-distance,困难,"给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。
示例 1:
输入：
nums = [1,3,1]
k = 1
输出：0 
解释：
所有数对如下：
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。
提示:
2 <= len(nums) <= 10000.
0 <= nums[i] < 1000000.
1 <= k <= len(nums) * (len(nums) - 1) / 2.",246,,12026,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/', 'https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/', 'https://leetcode.cn/problems/find-k-closest-elements/', 'https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/', 'https://leetcode.cn/problems/k-th-smallest-prime-fraction/']",30823
评论 (569),longest-word-in-dictionary,简单,"给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。
若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。
  示例 1：
输入：words = [""w"",""wo"",""wor"",""worl"", ""world""]
输出：""world""
解释： 单词""world""可由""w"", ""wo"", ""wor"", 和 ""worl""逐步添加一个字母组成。
示例 2：
输入：words = [""a"", ""banana"", ""app"", ""appl"", ""ap"", ""apply"", ""apple""]
输出：""apple""
解释：""apply"" 和 ""apple"" 都能由词典中的单词组成。但是 ""apple"" 的字典序小于 ""apply"" 
  提示：
1 <= words.length <= 1000
1 <= words[i].length <= 30
所有输入的字符串 words[i] 都只包含小写字母。",304,,58625,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/', 'https://leetcode.cn/problems/implement-magic-dictionary/']",112901
评论 (358),accounts-merge,中等,"给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。
现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。
合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。
  示例 1：
输入：accounts = [[""John"", ""johnsmith@mail.com"", ""john00@mail.com""], [""John"", ""johnnybravo@mail.com""], [""John"", ""johnsmith@mail.com"", ""john_newyork@mail.com""], [""Mary"", ""mary@mail.com""]]
输出：[[""John"", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [""John"", ""johnnybravo@mail.com""], [""Mary"", ""mary@mail.com""]]
解释：
第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 ""johnsmith@mail.com""。 
第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。
可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，
['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。
示例 2：
输入：accounts = [[""Gabe"",""Gabe0@m.co"",""Gabe3@m.co"",""Gabe1@m.co""],[""Kevin"",""Kevin3@m.co"",""Kevin5@m.co"",""Kevin0@m.co""],[""Ethan"",""Ethan5@m.co"",""Ethan4@m.co"",""Ethan0@m.co""],[""Hanzo"",""Hanzo3@m.co"",""Hanzo1@m.co"",""Hanzo0@m.co""],[""Fern"",""Fern5@m.co"",""Fern1@m.co"",""Fern0@m.co""]]
输出：[[""Ethan"",""Ethan0@m.co"",""Ethan4@m.co"",""Ethan5@m.co""],[""Gabe"",""Gabe0@m.co"",""Gabe1@m.co"",""Gabe3@m.co""],[""Hanzo"",""Hanzo0@m.co"",""Hanzo1@m.co"",""Hanzo3@m.co""],[""Kevin"",""Kevin0@m.co"",""Kevin3@m.co"",""Kevin5@m.co""],[""Fern"",""Fern0@m.co"",""Fern1@m.co"",""Fern5@m.co""]]
  提示：
1 <= accounts.length <= 1000
2 <= accounts[i].length <= 10
1 <= accounts[i][j].length <= 30
accounts[i][0] 由英文字母组成
accounts[i][j] (for j > 0) 是有效的邮箱地址",357,,33211,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/redundant-connection/', 'https://leetcode.cn/problems/sentence-similarity/', 'https://leetcode.cn/problems/sentence-similarity-ii/']",69902
评论 (83),remove-comments,中等,"给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第 i 行源码。 这表示每行源码由 '\n' 分隔。
在 C++ 中有两种注释风格，行内注释和块注释。
字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。
字符串/* 表示一个块注释，它表示直到下一个（非重叠）出现的*/之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。
第一个有效注释优先于其他注释。
如果字符串//出现在块注释中会被忽略。
同样，如果字符串/*出现在行或块注释中也会被忽略。
如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。
样例中没有控制字符，单引号或双引号字符。
比如，source = ""string s = ""/* Not a comment. */"";"" 不会出现在测试样例里。
此外，没有其他内容（如定义或宏）会干扰注释。
我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。
最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。
从源代码中删除注释后，需要以相同的格式返回源代码。
  示例 1:
输入: source = [""/*Test program */"", ""int main()"", ""{ "", ""  // variable declaration "", ""int a, b, c;"", ""/* This is a test"", ""   multiline  "", ""   comment for "", ""   testing */"", ""a = b + c;"", ""}""]
输出: [""int main()"",""{ "",""  "",""int a, b, c;"",""a = b + c;"",""}""]
解释: 示例代码可以编排成这样:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}
第 1 行和第 6-9 行的字符串 /* 表示块注释。第 4 行的字符串 // 表示行注释。
编排后: 
int main()
{ 
  
int a, b, c;
a = b + c;
}
示例 2:
输入: source = [""a/*comment"", ""line"", ""more_comment*/b""]
输出: [""ab""]
解释: 原始的 source 字符串是 ""a/*comment\nline\nmore_comment*/b"", 其中我们用粗体显示了换行符。删除注释后，隐含的换行符被删除，留下字符串 ""ab"" 用换行符分隔成数组时就是 [""ab""].
  提示:
1 <= source.length <= 100
0 <= source[i].length <= 80
source[i] 由可打印的 ASCII 字符组成。
每个块注释都会被闭合。
给定的源码中不会有单引号、双引号或其他控制字符。",72,,6217,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/mini-parser/', 'https://leetcode.cn/problems/ternary-expression-parser/']",18947
评论 (26),candy-crush,Unknown,,-1,,-1,[],[],-1
评论 (793),find-pivot-index,简单,"给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
  示例 1：
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
示例 2：
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
示例 3：
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
  提示：
1 <= nums.length <= 104
-1000 <= nums[i] <= 1000
  注意：本题与主站 1991 题相同：https://leetcode-cn.com/problems/find-the-middle-index-in-array/",401,,182649,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",['https://leetcode.cn/problems/subarray-sum-equals-k/'],374728
评论 (430),split-linked-list-in-parts,中等,"给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。
每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。
这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。
返回一个由上述 k 部分组成的数组。
  示例 1：
输入：head = [1,2,3], k = 5
输出：[[1],[2],[3],[],[]]
解释：
第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。
最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。
示例 2：
输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3
输出：[[1,2,3,4],[5,6,7],[8,9,10]]
解释：
输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。
  提示：
链表中节点的数目在范围 [0, 1000]
0 <= Node.val <= 1000
1 <= k <= 50",253,https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg,54172,['https://leetcode.cn/tag/linked-list/'],"['https://leetcode.cn/problems/rotate-list/', 'https://leetcode.cn/problems/odd-even-linked-list/']",89355
评论 (318),number-of-atoms,困难,"给你一个字符串化学式 formula ，返回 每种原子的数量 。
原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。
如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。
例如，""H2O"" 和 ""H2O2"" 是可行的，但 ""H1O2"" 这个表达是不可行的。
两个化学式连在一起可以构成新的化学式。
例如 ""H2O2He3Mg4"" 也是化学式。
由括号括起的化学式并佐以数字（可选择性添加）也是化学式。
例如 ""(H2O2)"" 和 ""(H2O2)3"" 是化学式。
返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。
  示例 1：
输入：formula = ""H2O""
输出：""H2O""
解释：原子的数量是 {'H': 2, 'O': 1}。
示例 2：
输入：formula = ""Mg(OH)2""
输出：""H2MgO2""
解释：原子的数量是 {'H': 2, 'Mg': 1, 'O': 2}。
示例 3：
输入：formula = ""K4(ON(SO3)2)2""
输出：""K4N2O14S4""
解释：原子的数量是 {'K': 4, 'N': 2, 'O': 14, 'S': 4}。
  提示：
1 <= formula.length <= 1000
formula 由英文字母、数字、'(' 和 ')' 组成
formula 总是有效的化学式",252,,24098,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/decode-string/', 'https://leetcode.cn/problems/encode-string-with-shortest-length/', 'https://leetcode.cn/problems/parse-lisp-expression/']",43697
评论 (27),minimum-window-subsequence,Unknown,,-1,,-1,[],[],-1
评论 (636),self-dividing-numbers,简单,"自除数 是指可以被它包含的每一位数整除的数。
例如，128 是一个 自除数 ，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
自除数 不允许包含 0 。
给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。
  示例 1：
输入：left = 1, right = 22
输出：[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
示例 2:
输入：left = 47, right = 85
输出：[48,55,66,77]
  提示：
1 <= left <= right <= 104",236,,71110,['https://leetcode.cn/tag/math/'],['https://leetcode.cn/problems/perfect-number/'],90192
评论 (110),my-calendar-i,中等,"实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。
当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。
日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start <= x < end 。
实现 MyCalendar 类：
MyCalendar() 初始化日历对象。
boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中。
  示例：
输入：
[""MyCalendar"", ""book"", ""book"", ""book""]
[[], [10, 20], [15, 25], [20, 30]]
输出：
[null, true, false, true]

解释：
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。
myCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。
  提示：
0 <= start < end <= 109
每个测试用例，调用 book 方法的次数最多不超过 1000 次。",123,,14019,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/ordered-set/']","['https://leetcode.cn/problems/my-calendar-ii/', 'https://leetcode.cn/problems/my-calendar-iii/']",26013
评论 (54),count-different-palindromic-subsequences,困难,"给定一个字符串 s，返回 s 中不同的非空「回文子序列」个数 。
通过从 s 中删除 0 个或多个字符来获得子序列。
如果一个字符序列与它反转后的字符序列一致，那么它是「回文字符序列」。
如果有某个 i , 满足 ai != bi ，则两个序列 a1, a2, ... 和 b1, b2, ... 不同。
注意：
结果可能很大，你需要对 109 + 7 取模 。
  示例 1：
输入：s = 'bccb'
输出：6
解释：6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。
注意：'bcb' 虽然出现两次但仅计数一次。
示例 2：
输入：s = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'
输出：104860361
解释：共有 3104860382 个不同的非空回文子序列，104860361 对 109 + 7 取模后的值。
  提示：
1 <= s.length <= 1000
s[i] 仅包含 'a', 'b', 'c' 或 'd' ",162,,4653,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/longest-palindromic-subsequence/'],9305
评论 (37),my-calendar-ii,中等,"实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。
MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start <= x < end。
当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。
每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。
请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)
  示例：
MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(50, 60); // returns true
MyCalendar.book(10, 40); // returns true
MyCalendar.book(5, 15); // returns false
MyCalendar.book(5, 10); // returns true
MyCalendar.book(25, 55); // returns true
解释： 
前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。
第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。
第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。
第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；
时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。
  提示：
每个测试用例，调用 MyCalendar.book 函数最多不超过 1000次。
调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。",115,,5672,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/ordered-set/']","['https://leetcode.cn/problems/my-calendar-i/', 'https://leetcode.cn/problems/my-calendar-iii/']",11174
评论 (68),my-calendar-iii,困难,"当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。
给你一些日程安排 [start, end) ，请你在每个日程安排添加后，返回一个整数 k ，表示所有先前日程安排会产生的最大 k 次预订。
实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。
MyCalendarThree() 初始化对象。
int book(int start, int end) 返回一个整数 k ，表示日历中存在的 k 次预订的最大值。
  示例：
输入：
[""MyCalendarThree"", ""book"", ""book"", ""book"", ""book"", ""book"", ""book""]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
输出：
[null, 1, 1, 2, 3, 3, 3]

解释：
MyCalendarThree myCalendarThree = new MyCalendarThree();
myCalendarThree.book(10, 20); // 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
myCalendarThree.book(50, 60); // 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
myCalendarThree.book(10, 40); // 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。
myCalendarThree.book(5, 15); // 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。
myCalendarThree.book(5, 10); // 返回 3
myCalendarThree.book(25, 55); // 返回 3
  提示：
0 <= start < end <= 109
每个测试用例，调用 book 函数最多不超过 400次",85,,4961,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/ordered-set/']","['https://leetcode.cn/problems/my-calendar-i/', 'https://leetcode.cn/problems/my-calendar-ii/']",7857
评论 (794),flood-fill,简单,"有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。
你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。
为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。
最后返回 经过上色渲染后的图像 。
  示例 1:
输入: image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。
示例 2:
输入: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2
输出: [[2,2,2],[2,2,2]]
  提示:
m == image.length
n == image[i].length
1 <= m, n <= 50
0 <= image[i][j], newColor < 216
0 <= sr < m
0 <= sc < n",332,,111596,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/island-perimeter/'],191942
评论 (35),sentence-similarity,Unknown,,-1,,-1,[],[],-1
评论 (273),asteroid-collision,中等,"给定一个整数数组 asteroids，表示在同一行的行星。
对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。
找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。
  示例 1：
输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
示例 2：
输入：asteroids = [8,-8]
输出：[]
解释：8 和 -8 碰撞后，两者都发生爆炸。
示例 3：
输入：asteroids = [10,2,-5]
输出：[10]
解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。
  提示：
2 <= asteroids.length <= 104
-1000 <= asteroids[i] <= 1000
asteroids[i] != 0",237,,29643,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/']",['https://leetcode.cn/problems/can-place-flowers/'],71751
评论 (47),parse-lisp-expression,困难,"给你一个类似 Lisp 语句的字符串表达式 expression，求出其计算结果。
表达式语法如下所示:
表达式可以为整数，let 表达式，add 表达式，mult 表达式，或赋值的变量。表达式的结果总是一个整数。
(整数可以是正整数、负整数、0)
let 表达式采用 ""(let v1 e1 v2 e2 ... vn en expr)"" 的形式，其中 let 总是以字符串 ""let""来表示，接下来会跟随一对或多对交替的变量和表达式，也就是说，第一个变量 v1被分配为表达式 e1 的值，第二个变量 v2 被分配为表达式 e2 的值，依次类推；最终 let 表达式的值为 expr表达式的值。
add 表达式表示为 ""(add e1 e2)"" ，其中 add 总是以字符串 ""add"" 来表示，该表达式总是包含两个表达式 e1、e2 ，最终结果是 e1 表达式的值与 e2 表达式的值之 和 。
mult 表达式表示为 ""(mult e1 e2)"" ，其中 mult 总是以字符串 ""mult"" 表示，该表达式总是包含两个表达式 e1、e2，最终结果是 e1 表达式的值与 e2 表达式的值之 积 。
在该题目中，变量名以小写字符开始，之后跟随 0 个或多个小写字符或数字。为了方便，""add"" ，""let"" ，""mult"" 会被定义为 ""关键字"" ，不会用作变量名。
最后，要说一下作用域的概念。计算变量名所对应的表达式时，在计算上下文中，首先检查最内层作用域（按括号计），然后按顺序依次检查外部作用域。测试用例中每一个表达式都是合法的。有关作用域的更多详细信息，请参阅示例。
  示例 1：
输入：expression = ""(let x 2 (mult x (let x 3 y 4 (add x y))))""
输出：14
解释：
计算表达式 (add x y), 在检查变量 x 值时，
在变量的上下文中由最内层作用域依次向外检查。
首先找到 x = 3, 所以此处的 x 值是 3 。
示例 2：
输入：expression = ""(let x 3 x 2 x)""
输出：2
解释：let 语句中的赋值运算按顺序处理即可。
示例 3：
输入：expression = ""(let x 1 y 2 x (add x y) (add x y))""
输出：5
解释：
第一个 (add x y) 计算结果是 3，并且将此值赋给了 x 。 
第二个 (add x y) 计算结果是 3 + 2 = 5 。
  提示：
1 <= expression.length <= 2000
exprssion 中不含前导和尾随空格
expressoin 中的不同部分（token）之间用单个空格进行分隔
答案和所有中间计算结果都符合 32-bit 整数范围
测试用例中的表达式均为合法的且最终结果为整数",81,,1867,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/ternary-expression-parser/', 'https://leetcode.cn/problems/number-of-atoms/', 'https://leetcode.cn/problems/basic-calculator-iv/']",3928
评论 (39),sentence-similarity-ii,Unknown,,-1,,-1,[],[],-1
评论 (406),monotone-increasing-digits,中等,"当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。
给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。
  示例 1:
输入: n = 10
输出: 9
示例 2:
输入: n = 1234
输出: 1234
示例 3:
输入: n = 332
输出: 299
  提示:
0 <= n <= 109",257,,59083,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/remove-k-digits/'],118205
评论 (1.2k),daily-temperatures,中等,"给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。
  示例 1:
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:
输入: temperatures = [30,60,90]
输出: [1,1,0]
  提示：
1 <= temperatures.length <= 105
30 <= temperatures[i] <= 100",1158,,302905,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/monotonic-stack/']",['https://leetcode.cn/problems/next-greater-element-i/'],438084
评论 (602),delete-and-earn,中等,"给你一个整数数组 nums ，你可以对它进行一些操作。
每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。
开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。
  示例 1：
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
示例 2：
输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
  提示：
1 <= nums.length <= 2 * 104
1 <= nums[i] <= 104",628,,79214,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/house-robber/'],126316
评论 (79),cherry-pickup,困难,"一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：
0 表示这个格子是空的，所以你可以穿过它。
1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
-1 表示这个格子里有荆棘，挡着你的路。
你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：
从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。
示例 1:
输入: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
输出: 5
解释： 
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。
说明:
grid 是一个 N * N 的二维数组，N的取值范围是1 <= N <= 50。
每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。
可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。",208,,5205,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/minimum-path-sum/', 'https://leetcode.cn/problems/dungeon-game/']",13527
评论 (31),closest-leaf-in-a-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (359),network-delay-time,中等,"有 n 个网络节点，标记为 1 到 n。
给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。
  示例 1：
输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
示例 2：
输入：times = [[1,2,1]], n = 2, k = 1
输出：1
示例 3：
输入：times = [[1,2,1]], n = 2, k = 2
输出：-1
  提示：
1 <= k <= n <= 100
1 <= times.length <= 6000
times[i].length == 3
1 <= ui, vi <= n
ui != vi
0 <= wi <= 100
所有 (ui, vi) 对都 互不相同（即，不含重复边）",548,,78440,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/shortest-path/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],144939
评论 (671),find-smallest-letter-greater-than-target,简单,"给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。
在比较时，字母是依序循环出现的。举个例子：
如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'
  示例 1：
输入: letters = [""c"", ""f"", ""j""]，target = ""a""
输出: ""c""
示例 2:
输入: letters = [""c"",""f"",""j""], target = ""c""
输出: ""f""
示例 3:
输入: letters = [""c"",""f"",""j""], target = ""d""
输出: ""f""
  提示：
2 <= letters.length <= 104
letters[i] 是一个小写字母
letters 按非递减顺序排序
letters 最少包含两个不同的字母
target 是一个小写字母",226,,88421,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],179406
评论 (60),prefix-and-suffix-search,困难,"设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。
实现 WordFilter 类：
WordFilter(string[] words) 使用词典中的单词 words 初始化对象。
f(string prefix, string suffix) 返回词典中具有前缀 prefix 和后缀suffix 的单词的下标。如果存在不止一个满足要求的下标，返回其中 最大的下标 。如果不存在这样的单词，返回 -1 。
  示例
输入：
[""WordFilter"", ""f""]
[[[""apple""]], [""a"", ""e""]]
输出：
[null, 0]

解释：
WordFilter wordFilter = new WordFilter([""apple""]);
wordFilter.f(""a"", ""e""); // 返回 0 ，因为下标为 0 的单词的 prefix = ""a"" 且 suffix = 'e"" 。
  提示：
1 <= words.length <= 15000
1 <= words[i].length <= 10
1 <= prefix.length, suffix.length <= 10
words[i]、prefix 和 suffix 仅由小写英文字母组成
最多对函数 f 进行 15000 次调用",87,,3918,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/design-add-and-search-words-data-structure/'],9567
评论 (1.5k),min-cost-climbing-stairs,简单,"给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。
  示例 1：
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
示例 2：
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
  提示：
2 <= cost.length <= 1000
0 <= cost[i] <= 999",905,,212367,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/climbing-stairs/'],343071
评论 (622),largest-number-at-least-twice-of-others,简单,"给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。
请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。
  示例 1：
输入：nums = [3,6,1,0]
输出：1
解释：6 是最大的整数，对于数组中的其他整数，6 至少是数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。
示例 2：
输入：nums = [1,2,3,4]
输出：-1
解释：4 没有超过 3 的两倍大，所以返回 -1 。
示例 3：
输入：nums = [1]
输出：0
解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。
  提示：
1 <= nums.length <= 50
0 <= nums[i] <= 100
nums 中的最大元素是唯一的",171,,83112,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],181225
评论 (451),shortest-completing-word,简单,"给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出 words 中的 最短补全词 。
补全词 是一个包含 licensePlate 中所有字母的单词。忽略 licensePlate 中的 数字和空格 。不区分大小写。如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。
例如：licensePlate = ""aBc 12c""，那么它的补全词应当包含字母 'a'、'b' （忽略大写）和两个 'c' 。可能的 补全词 有 ""abccdef""、""caaacab"" 以及 ""cbca"" 。
请返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 第一个 出现的那个。
  示例 1：
输入：licensePlate = ""1s3 PSt"", words = [""step"", ""steps"", ""stripe"", ""stepple""]
输出：""steps""
解释：最短补全词应该包括 ""s""、""p""、""s""（忽略大小写） 以及 ""t""。
""step"" 包含 ""t""、""p""，但只包含一个 ""s""，所以它不符合条件。
""steps"" 包含 ""t""、""p"" 和两个 ""s""。
""stripe"" 缺一个 ""s""。
""stepple"" 缺一个 ""s""。
因此，""steps"" 是唯一一个包含所有字母的单词，也是本例的答案。
示例 2：
输入：licensePlate = ""1s3 456"", words = [""looks"", ""pest"", ""stew"", ""show""]
输出：""pest""
解释：licensePlate 只包含字母 ""s"" 。所有的单词都包含字母 ""s"" ，其中 ""pest""、""stew""、和 ""show"" 三者最短。答案是 ""pest"" ，因为它是三个单词中在 words 里最靠前的那个。
  提示：
1 <= licensePlate.length <= 7
licensePlate 由数字、大小写字母或空格 ' ' 组成
1 <= words.length <= 1000
1 <= words[i].length <= 15
words[i] 由小写英文字母组成",116,,41650,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],61445
评论 (43),contain-virus,困难,"病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。
假设世界由 m x n 的二维矩阵 isInfected 组成， isInfected[i][j] == 0 表示该区域未感染病毒，而  isInfected[i][j] == 1 表示该区域已感染病毒。可以在任意 2 个相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。
每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且 保证唯一 。
你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。
  示例 1：
输入: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]
输出: 10
解释:一共有两块被病毒感染的区域。
在第一天，添加 5 墙隔离病毒区域的左侧。病毒传播后的状态是:

第二天，在右侧添加 5 个墙来隔离病毒区域。此时病毒已经被完全控制住了。
示例 2：
输入: isInfected = [[1,1,1],[1,0,1],[1,1,1]]
输出: 4
解释: 虽然只保存了一个小区域，但却有四面墙。
注意，防火墙只建立在两个不同区域的共享边界上。
示例 3:
输入: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]
输出: 13
解释: 在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙。
  提示:
m == isInfected.length
n == isInfected[i].length
1 <= m, n <= 50
isInfected[i][j] is either 0 or 1
在整个描述的过程中，总有一个相邻的病毒区域，它将在下一轮 严格地感染更多未受污染的方块 
 ",48,,1979,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],3922
评论 (22),number-of-corner-rectangles,Unknown,,-1,,-1,[],[],-1
评论 (16),ip-to-cidr,Unknown,,-1,,-1,[],[],-1
评论 (493),open-the-lock,中等,"你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。
锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。
列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。
  示例 1:
输入：deadends = [""0201"",""0101"",""0102"",""1212"",""2002""], target = ""0202""
输出：6
解释：
可能的移动序列为 ""0000"" -> ""1000"" -> ""1100"" -> ""1200"" -> ""1201"" -> ""1202"" -> ""0202""。
注意 ""0000"" -> ""0001"" -> ""0002"" -> ""0102"" -> ""0202"" 这样的序列是不能解锁的，
因为当拨动到 ""0102"" 时这个锁就会被锁定。
示例 2:
输入: deadends = [""8888""], target = ""0009""
输出：1
解释：把最后一位反向旋转一次即可 ""0000"" -> ""0009""。
示例 3:
输入: deadends = [""8887"",""8889"",""8878"",""8898"",""8788"",""8988"",""7888"",""9888""], target = ""8888""
输出：-1
解释：无法旋转到目标数字且不被锁定。
  提示：
1 <= deadends.length <= 500
deadends[i].length == 4
target.length == 4
target 不在 deadends 之中
target 和 deadends[i] 仅由若干位数字组成",492,,91958,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],173581
评论 (74),cracking-the-safe,困难,"有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。
你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。
举个例子，假设密码是 ""345""，你可以输入 ""012345"" 来打开它，只是你输入了 6 个字符.
请返回一个能打开保险箱的最短字符串。
  示例1:
输入: n = 1, k = 2
输出: ""01""
说明: ""10""也可以打开保险箱。
  示例2:
输入: n = 2, k = 2
输出: ""00110""
说明: ""01100"", ""10011"", ""11001"" 也能打开保险箱。
  提示：
n 的范围是 [1, 4]。
k 的范围是 [1, 10]。
k^n 最大可能为 4096。
 ",99,,4289,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/eulerian-circuit/']",[],7042
评论 (129),reach-a-number,中等,"在一根无限长的数轴上，你站在0的位置。终点在target的位置。
你可以做一些数量的移动 numMoves :
每次你可以选择向左或向右移动。
第 i 次移动（从  i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。
给定整数 target ，返回 到达目标所需的 最小 移动次数(即最小 numMoves ) 。
  示例 1:
输入: target = 2
输出: 3
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。
示例 2:
输入: target = 3
输出: 2
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 3 。
  提示:
-109 <= target <= 109
target != 0",174,,10125,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],22952
评论 (18),pour-water,Unknown,,-1,,-1,[],[],-1
评论 (105),pyramid-transition-matrix,中等,"你正在把积木堆成金字塔。每个块都有一个颜色，用一个字母表示。每一行的块比它下面的行 少一个块 ，并且居中。
为了使金字塔美观，只有特定的 三角形图案 是允许的。一个三角形的图案由 两个块 和叠在上面的 单个块 组成。模式是以三个字母字符串的列表形式 allowed 给出的，其中模式的前两个字符分别表示左右底部块，第三个字符表示顶部块。
例如，""ABC"" 表示一个三角形图案，其中一个 “C” 块堆叠在一个 'A' 块(左)和一个 'B' 块(右)之上。请注意，这与 ""BAC"" 不同，""B"" 在左下角，""A"" 在右下角。
你从底部的一排积木 bottom 开始，作为一个单一的字符串，你 必须 使用作为金字塔的底部。
在给定 bottom 和 allowed 的情况下，如果你能一直构建到金字塔顶部，使金字塔中的 每个三角形图案 都是允许的，则返回 true ，否则返回 false 。
  示例 1：
输入：bottom = ""BCD"", allowed = [""BCG"", ""CDE"", ""GEA"", ""FFF""]
输出：true
解释：允许的三角形模式显示在右边。
从最底层(第3层)开始，我们可以在第2层构建“CE”，然后在第1层构建“E”。
金字塔中有三种三角形图案，分别是“BCC”、“CDE”和“CEA”。都是允许的。
示例 2：
输入：bottom = ""AABA"", allowed = [""AAA"", ""AAB"", ""ABA"", ""ABB"", ""BAC""]
输出：false
解释：允许的三角形模式显示在右边。
从最底层(游戏邦注:即第4个关卡)开始，创造第3个关卡有多种方法，但如果尝试所有可能性，你便会在创造第1个关卡前陷入困境。
  提示：
2 <= bottom.length <= 6
0 <= allowed.length <= 216
allowed[i].length == 3
所有输入字符串中的字母来自集合 {'A', 'B', 'C', 'D', 'E', 'F', 'G'}。
 allowed 中所有值都是 唯一的
 ",75,,5457,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/']",[],9947
评论 (33),set-intersection-size-at-least-two,困难,"一个整数区间 [a, b]  ( a < b ) 代表着从 a 到 b 的所有连续整数，包括 a 和 b。
给你一组整数区间intervals，请找到一个最小的集合 S，使得 S 里的元素与区间intervals中的每一个整数区间都至少有2个元素相交。
输出这个最小集合S的大小。
示例 1:
输入: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]
输出: 3
解释:
考虑集合 S = {2, 3, 4}. S与intervals中的四个区间都有至少2个相交的元素。
且这是S最小的情况，故我们输出3。
示例 2:
输入: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]
输出: 5
解释:
最小的集合S = {1, 2, 3, 4, 5}.
注意:
intervals 的长度范围为[1, 3000]。
intervals[i] 长度为 2，分别代表左、右边界。
intervals[i][j] 的值是 [0, 10^8]范围内的整数。",62,,2954,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],6855
评论 (45),bold-words-in-string,Unknown,,-1,,-1,[],[],-1
评论 (24),employee-free-time,Unknown,,-1,,-1,[],[],-1
评论 (59),find-anagram-mappings,Unknown,,-1,,-1,[],[],-1
评论 (43),special-binary-string,困难,"特殊的二进制序列是具有以下两个性质的二进制序列：
0 的数量与 1 的数量相等。
二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。
给定一个特殊的二进制序列 S，以字符串形式表示。定义一个操作 为首先选择 S 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)
在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？
示例 1:
输入: S = ""11011000""
输出: ""11100100""
解释:
将子串 ""10"" （在S[1]出现） 和 ""1100"" （在S[3]出现）进行交换。
这是在进行若干次操作后按字典序排列最大的结果。
说明:
S 的长度不超过 50。
S 保证为一个满足上述定义的特殊 的二进制序列。",82,,2479,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/valid-parenthesis-string/'],4150
评论 (373),prime-number-of-set-bits-in-binary-representation,简单,"给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。
计算置位位数 就是二进制表示中 1 的个数。
例如， 21 的二进制表示 10101 有 3 个计算置位。
  示例 1：
输入：left = 6, right = 10
输出：4
解释：
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)
共计 4 个计算置位为质数的数字。
示例 2：
输入：left = 10, right = 15
输出：5
解释：
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)
共计 5 个计算置位为质数的数字。
  提示：
1 <= left <= right <= 106
0 <= right - left <= 104",129,,51573,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/number-of-1-bits/'],68155
评论 (691),partition-labels,中等,"字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
  示例：
输入：S = ""ababcbacadefegdehijhklij""
输出：[9,7,8]
解释：
划分结果为 ""ababcbaca"", ""defegde"", ""hijhklij""。
每个字母最多出现在一个片段中。
像 ""ababcbacadefegde"", ""hijhklij"" 的划分是错误的，因为划分的片段数较少。
  提示：
S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。",734,,115433,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/merge-intervals/'],150579
评论 (59),largest-plus-sign,中等,"在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。mines[i] = [xi, yi]表示 grid[xi][yi] == 0
返回  grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。
一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。
  示例 1：
输入: n = 5, mines = [[4, 2]]
输出: 2
解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。
示例 2：
输入: n = 1, mines = [[0, 0]]
输出: 0
解释: 没有加号标志，返回 0 。
  提示：
1 <= n <= 500
1 <= mines.length <= 5000
0 <= xi, yi < n
每一对 (xi, yi) 都 不重复",101,,5052,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/maximal-square/'],10164
评论 (510),couples-holding-hands,困难,"n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。
人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。
返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次交换可选择任意两人，让他们站起来交换座位。
  示例 1:
输入: row = [0,2,1,3]
输出: 1
解释: 只需要交换row[1]和row[2]的位置即可。
示例 2:
输入: row = [3,2,0,1]
输出: 0
解释: 无需交换座位，所有的情侣都已经可以手牵手了。
  提示:
2n == row.length
2 <= n <= 30
n 是偶数
0 <= row[i] < 2n
row 中所有元素均无重复",341,,32426,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']","['https://leetcode.cn/problems/first-missing-positive/', 'https://leetcode.cn/problems/missing-number/', 'https://leetcode.cn/problems/k-similar-strings/']",48906
评论 (554),toeplitz-matrix,简单,"给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。
如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。
  示例 1：
输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
输出：true
解释：
在上述矩阵中, 其对角线为: 
""[9]"", ""[5, 5]"", ""[1, 1, 1]"", ""[2, 2, 2]"", ""[3, 3]"", ""[4]""。 
各条对角线上的所有元素均相同, 因此答案是 True 。
示例 2：
输入：matrix = [[1,2],[2,2]]
输出：false
解释：
对角线 ""[1, 2]"" 上的元素不同。
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 20
0 <= matrix[i][j] <= 99
  进阶：
如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？
如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？",264,https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg,60846,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/valid-word-square/'],86251
评论 (365),reorganize-string,中等,"给定一个字符串 s ，检查是否能重新排布其中的字母，使得两相邻的字符不同。
返回 s 的任意可能的重新排列。若不可行，返回空字符串 """" 。
  示例 1:
输入: s = ""aab""
输出: ""aba""
示例 2:
输入: s = ""aaab""
输出: """"
  提示:
1 <= s.length <= 500
s 只包含小写字母",408,,45079,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/rearrange-string-k-distance-apart/', 'https://leetcode.cn/problems/task-scheduler/']",93928
评论 (66),max-chunks-to-make-sorted-ii,困难,"这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。
arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。
我们最多能将数组分成多少块？
示例 1:
输入: arr = [5,4,3,2,1]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 
示例 2:
输入: arr = [2,1,3,4,4]
输出: 4
解释:
我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。
然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 
注意:
arr的长度在[1, 2000]之间。
arr[i]的大小在[0, 10**8]之间。",124,,7515,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/monotonic-stack/']",['https://leetcode.cn/problems/max-chunks-to-make-sorted/'],14446
评论 (128),max-chunks-to-make-sorted,中等,"给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。
我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。
返回数组能分成的最多块数量。
  示例 1:
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
示例 2:
输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
  提示:
n == arr.length
1 <= n <= 10
0 <= arr[i] < n
arr 中每个元素都 不同",190,,17184,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/monotonic-stack/']",['https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/'],29463
评论 (55),basic-calculator-iv,困难,"给定一个表达式如 expression = ""e + 8 - a + 5"" 和一个求值映射，如 {""e"": 1}（给定的形式为 evalvars = [""e""] 和 evalints = [1]），返回表示简化表达式的标记列表，例如 [""-1*a"",""14""]
表达式交替使用块和符号，每个块和符号之间有一个空格。
块要么是括号中的表达式，要么是变量，要么是非负整数。
变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像 ""2x"" 或 ""-x"" 这样的前导系数或一元运算符 。
表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。
例如，expression = ""1 + 2 * 3"" 的答案是 [""7""]。
输出格式如下：
对于系数非零的每个自变量项，我们按字典排序的顺序将自变量写在一个项中。
例如，我们永远不会写像 “b*a*c” 这样的项，只写 “a*b*c”。
项的次数等于被乘的自变量的数目，并计算重复项。我们先写出答案的最大次数项，用字典顺序打破关系，此时忽略词的前导系数。
例如，""a*a*b*c"" 的次数为 4。
项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数 1 仍然要打印出来。
格式良好的一个示例答案是 [""-2*a*a*a"", ""3*a*a*b"", ""3*b*b"", ""4*a"", ""5*c"", ""-6""] 。
系数为 0 的项（包括常数项）不包括在内。
例如，“0” 的表达式输出为 [] 。
  示例 1：
输入：expression = ""e + 8 - a + 5"", evalvars = [""e""], evalints = [1]
输出：[""-1*a"",""14""]
示例 2：
输入：expression = ""e - 8 + temperature - pressure"",
evalvars = [""e"", ""temperature""], evalints = [1, 12]
输出：[""-1*pressure"",""5""]
示例 3：
输入：expression = ""(e + 8) * (e - 8)"", evalvars = [], evalints = []
输出：[""1*e*e"",""-64""]
  提示：
1 <= expression.length <= 250
expression 由小写英文字母，数字 '+', '-', '*', '(', ')', ' ' 组成
expression 不包含任何前空格或后空格
expression 中的所有符号都用一个空格隔开
0 <= evalvars.length <= 100
1 <= evalvars[i].length <= 20
evalvars[i] 由小写英文字母组成
evalints.length == evalvars.length
-100 <= evalints[i] <= 100",46,,1453,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']","['https://leetcode.cn/problems/parse-lisp-expression/', 'https://leetcode.cn/problems/basic-calculator-iii/']",2543
评论 (1.0k),jewels-and-stones,简单," 给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
字母区分大小写，因此 ""a"" 和 ""A"" 是不同类型的石头。
  示例 1：
输入：jewels = ""aA"", stones = ""aAAbbbb""
输出：3
示例 2：
输入：jewels = ""z"", stones = ""ZZ""
输出：0
  提示：
1 <= jewels.length, stones.length <= 50
jewels 和 stones 仅由英文字母组成
jewels 中的所有字符都是 唯一的",702,,165800,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],194615
评论 (71),basic-calculator-iii,Unknown,,-1,,-1,[],[],-1
评论 (275),sliding-puzzle,困难,"在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示。一次 移动 定义为选择 0 与一个相邻的数字（上下左右）进行交换.
最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。
给出一个谜板的初始状态 board ，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。
  示例 1：
输入：board = [[1,2,3],[4,0,5]]
输出：1
解释：交换 0 和 5 ，1 步完成
示例 2:
输入：board = [[1,2,3],[5,4,0]]
输出：-1
解释：没有办法完成谜板
示例 3:
输入：board = [[4,1,2],[5,0,3]]
输出：5
解释：
最少完成谜板的最少移动次数是 5 ，
一种移动路径:
尚未移动: [[4,1,2],[5,0,3]]
移动 1 次: [[4,1,2],[0,5,3]]
移动 2 次: [[0,1,2],[4,5,3]]
移动 3 次: [[1,0,2],[4,5,3]]
移动 4 次: [[1,2,0],[4,5,3]]
移动 5 次: [[1,2,3],[4,5,0]]
  提示：
board.length == 2
board[i].length == 3
0 <= board[i][j] <= 5
board[i][j] 中每个值都 不同",258,,27940,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],39591
评论 (20),minimize-max-distance-to-gas-station,Unknown,,-1,,-1,[],[],-1
评论 (69),global-and-local-inversions,中等,"给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。
全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：
0 <= i < j < n
nums[i] > nums[j]
局部倒置 的数目等于满足下述条件的下标 i 的数目：
0 <= i < n - 1
nums[i] > nums[i + 1]
当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。
  示例 1：
输入：nums = [1,0,2]
输出：true
解释：有 1 个全局倒置，和 1 个局部倒置。
示例 2：
输入：nums = [1,2,0]
输出：false
解释：有 2 个全局倒置，和 1 个局部倒置。
  提示：
n == nums.length
1 <= n <= 5000
0 <= nums[i] < n
nums 中的所有整数 互不相同
nums 是范围 [0, n - 1] 内所有数字组成的一个排列",83,,6083,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],13275
评论 (29),split-bst,Unknown,,-1,,-1,[],[],-1
评论 (74),swap-adjacent-in-lr-string,中等,"在一个由 'L' , 'R' 和 'X' 三个字符组成的字符串（例如""RXXLRXRXL""）中进行移动操作。一次移动操作指用一个""LX""替换一个""XL""，或者用一个""XR""替换一个""RX""。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。
  示例 :
输入: start = ""RXXLRXRXL"", end = ""XRLXXRRLX""
输出: True
解释:
我们可以通过以下几步将start转换成end:
RXXLRXRXL ->
XRXLRXRXL ->
XRLXRXRXL ->
XRLXXRRXL ->
XRLXXRRLX
  提示：
1 <= len(start) = len(end) <= 10000。
start和end中的字符串仅限于'L', 'R'和'X'。",118,,6612,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],20327
评论 (303),swim-in-rising-water,困难,"在一个 n x n 的整数矩阵 grid 中，每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。
当开始下雨时，在时间为 t 时，水池中的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。
你从坐标方格的左上平台 (0，0) 出发。返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间 。
  示例 1:
输入: grid = [[0,2],[1,3]]
输出: 3
解释:
时间为0时，你位于坐标方格的位置为 (0, 0)。
此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。
等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置
示例 2:
输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
输出: 16
解释: 最终的路线用加粗进行了标记。
我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的
  提示:
n == grid.length
n == grid[i].length
1 <= n <= 50
0 <= grid[i][j] < n2
grid[i][j] 中每个值 均无重复",234,,27385,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],46566
评论 (179),k-th-symbol-in-grammar,中等,"我们构建了一个包含 n 行( 索引从 1  开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。
例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。
给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）

示例 1:
输入: n = 1, k = 1
输出: 0
解释: 第一行：0
示例 2:
输入: n = 2, k = 1
输出: 0
解释: 
第一行: 0 
第二行: 01
示例 3:
输入: n = 2, k = 2
输出: 1
解释:
第一行: 0
第二行: 01
  提示:
1 <= n <= 30
1 <= k <= 2n - 1",153,,20728,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']",[],47395
评论 (248),reaching-points,困难,"给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。
从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。
  示例 1:
输入: sx = 1, sy = 1, tx = 3, ty = 5
输出: true
解释:
可以通过以下一系列转换从起点转换到终点：
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)
示例 2:
输入: sx = 1, sy = 1, tx = 2, ty = 2 
输出: false
示例 3:
输入: sx = 1, sy = 1, tx = 1, ty = 1 
输出: true
  提示:
1 <= sx, sy, tx, ty <= 109",252,,24593,['https://leetcode.cn/tag/math/'],[],64859
评论 (625),rabbits-in-forest,中等,"森林中有未知数量的兔子。提问其中若干只兔子 ""还有多少只兔子与你（指被提问的兔子）颜色相同?"" ，将答案收集到一个整数数组 answers 中，其中 answers[i] 是第 i 只兔子的回答。
给你数组 answers ，返回森林中兔子的最少数量。
  示例 1：
输入：answers = [1,1,2]
输出：5
解释：
两只回答了 ""1"" 的兔子可能有相同的颜色，设为红色。 
之后回答了 ""2"" 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 ""2"" 的兔子为蓝色。 
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 
因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。
示例 2：
输入：answers = [10,10,10]
输出：11
  提示：
1 <= answers.length <= 1000
0 <= answers[i] < 1000",218,,48236,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/']",[],79841
评论 (24),transform-to-chessboard,困难,"一个 n x n 的二维网络 board 仅由 0 和 1 组成 。每次移动，你能任意交换两列或是两行的位置。
返回 将这个矩阵变为  “棋盘”  所需的最小移动次数 。如果不存在可行的变换，输出 -1。
“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。
  示例 1:
输入: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
输出: 2
解释:一种可行的变换方式如下，从左到右：
第一次移动交换了第一列和第二列。
第二次移动交换了第二行和第三行。
示例 2:
输入: board = [[0, 1], [1, 0]]
输出: 0
解释: 注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘.
示例 3:
输入: board = [[1, 0], [1, 0]]
输出: -1
解释: 任意的变换都不能使这个输入变为合法的棋盘。
  提示：
n == board.length
n == board[i].length
2 <= n <= 30
board[i][j] 将只包含 0或 1",45,,1846,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/matrix/']",[],4358
评论 (542),minimum-distance-between-bst-nodes,简单,"给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。
差值是一个正数，其数值等于两值之差的绝对值。
  示例 1：
输入：root = [4,2,6,1,3]
输出：1
示例 2：
输入：root = [1,0,48,null,null,12,49]
输出：1
  提示：
树中节点的数目范围是 [2, 100]
0 <= Node.val <= 105
  注意：本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同",219,,76844,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/binary-tree-inorder-traversal/'],128396
评论 (527),letter-case-permutation,中等,"给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。
返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。
  示例 1：
输入：s = ""a1b2""
输出：[""a1b2"", ""a1B2"", ""A1b2"", ""A1B2""]
示例 2:
输入: s = ""3z4""
输出: [""3z4"",""3Z4""]
  提示:
1 <= s.length <= 12
s 由小写英文字母、大写英文字母和数字组成",384,,64596,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/subsets/', 'https://leetcode.cn/problems/brace-expansion/']",92313
评论 (429),is-graph-bipartite,中等,"存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：
不存在自环（graph[u] 不包含 u）。
不存在平行边（graph[u] 不包含重复值）。
如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）
这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。
二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。
如果图是二分图，返回 true ；否则，返回 false 。
  示例 1：
输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
输出：false
解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。
示例 2：
输入：graph = [[1,3],[0,2],[1,3],[0,2]]
输出：true
解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。
  提示：
graph.length == n
1 <= n <= 100
0 <= graph[u].length < n
0 <= graph[u][i] <= n - 1
graph[u] 不会包含 u
graph[u] 的所有值 互不相同
如果 graph[u] 包含 v，那么 graph[v] 也会包含 u",369,https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg,56423,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']",[],106561
评论 (253),k-th-smallest-prime-fraction,困难,"给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数  组成，且其中所有整数互不相同。
对于每对满足 0 <= i < j < arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。
那么第 k 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。
  示例 1：
输入：arr = [1,2,3,5], k = 3
输出：[2,5]
解释：已构造好的分数,排序后如下所示: 
1/5, 1/3, 2/5, 1/2, 3/5, 2/3
很明显第三个最小的分数是 2/5
示例 2：
输入：arr = [1,7], k = 1
输出：[1,7]
  提示：
2 <= arr.length <= 1000
1 <= arr[i] <= 3 * 104
arr[0] == 1
arr[i] 是一个 素数 ，i > 0
arr 中的所有数字 互不相同 ，且按 严格递增 排序
1 <= k <= arr.length * (arr.length - 1) / 2",215,,27304,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/', 'https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/', 'https://leetcode.cn/problems/find-k-th-smallest-pair-distance/']",40271
评论 (347),cheapest-flights-within-k-stops,中等,"有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。
现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。
  示例 1：
输入: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
输出: 200
解释: 
城市航班图如下


从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。
示例 2：
输入: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
输出: 500
解释: 
城市航班图如下


从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。
  提示：
1 <= n <= 100
0 <= flights.length <= (n * (n - 1) / 2)
flights[i].length == 3
0 <= fromi, toi < n
fromi != toi
1 <= pricei <= 104
航班没有重复，且不存在自环
0 <= src, dst, k < n
src != dst",485,,52500,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/shortest-path/', 'https://leetcode.cn/tag/heap-priority-queue/']",['https://leetcode.cn/problems/maximum-vacation-days/'],134744
评论 (284),rotated-digits,中等,"我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。
如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。
现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？
  示例：
输入: 10
输出: 4
解释: 
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。
  提示：
N 的取值范围是 [1, 10000]。",107,,19944,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],32574
评论 (262),escape-the-ghosts,中等,"你在进行一个简化版的吃豆人游戏。你从 [0, 0] 点开始出发，你的目的地是 target = [xtarget, ytarget] 。地图上有一些阻碍者，以数组 ghosts 给出，第 i 个阻碍者从 ghosts[i] = [xi, yi] 出发。所有输入均为 整数坐标 。
每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 1 个单位 的新位置。当然，也可以选择 不动 。所有动作 同时 发生。
如果你可以在任何阻碍者抓住你 之前 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者 同时 到达了一个位置（包括目的地） 都不算 是逃脱成功。
只有在你有可能成功逃脱时，输出 true ；否则，输出 false 。
  示例 1：
输入：ghosts = [[1,0],[0,3]], target = [0,1]
输出：true
解释：你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。 
示例 2：
输入：ghosts = [[1,0]], target = [2,0]
输出：false
解释：你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。 
示例 3：
输入：ghosts = [[2,0]], target = [1,0]
输出：false
解释：阻碍者可以和你同时达到目的地。 
  提示：
1 <= ghosts.length <= 100
ghosts[i].length == 2
-104 <= xi, yi <= 104
同一位置可能有 多个阻碍者 。
target.length == 2
-104 <= xtarget, ytarget <= 104",95,,21881,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],31781
评论 (82),domino-and-tromino-tiling,中等,"有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 ""L"" 的托米诺形。两种形状都可以旋转。
给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。
平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。
  示例 1:
输入: n = 3
输出: 5
解释: 五种不同的方法如上所示。
示例 2:
输入: n = 1
输出: 1
  提示：
1 <= n <= 1000",113,,5176,['https://leetcode.cn/tag/dynamic-programming/'],[],11172
评论 (180),custom-sort-string,中等,"给定两个字符串 order 和 s 。order 的所有单词都是 唯一 的，并且以前按照一些自定义的顺序排序。
对 s 的字符进行置换，使其与排序的 order 相匹配。更具体地说，如果在 order 中的字符 x 出现字符 y 之前，那么在排列后的字符串中， x 也应该出现在 y 之前。
返回 满足这个性质的 s 的任意排列 。
  示例 1:
输入: order = ""cba"", s = ""abcd""
输出: ""cbad""
解释: 
“a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。
因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。
示例 2:
输入: order = ""cbafg"", s = ""abcd""
输出: ""cbad""
  提示:
1 <= order.length <= 26
1 <= s.length <= 200
order 和 s 由小写英文字母组成
order 中的所有字符都 不同",103,,13998,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],20103
评论 (121),number-of-matching-subsequences,中等,"给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。
字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。
例如， “ace” 是 “abcde” 的子序列。
  示例 1:
输入: s = ""abcde"", words = [""a"",""bb"",""acd"",""ace""]
输出: 3
解释: 有三个是 s 的子序列的单词: ""a"", ""acd"", ""ace""。
Example 2:
输入: s = ""dsahjpjauf"", words = [""ahjpjau"",""ja"",""ahbwzgqnuk"",""tnmlanowax""]
输出: 2
  提示:
1 <= s.length <= 5 * 104
1 <= words.length <= 5000
1 <= words[i].length <= 50
words[i]和 s 都只由小写字母组成。",201,,11294,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/is-subsequence/'],24054
评论 (87),preimage-size-of-factorial-zeroes-function,困难," f(x) 是 x! 末尾是 0 的数量。回想一下 x! = 1 * 2 * 3 * ... * x，且 0! = 1 。
例如， f(3) = 0 ，因为 3! = 6 的末尾没有 0 ；而 f(11) = 2 ，因为 11!= 39916800 末端有 2 个 0 。
给定 k，找出返回能满足 f(x) = k 的非负整数 x 的数量。
  示例 1：
输入：k = 0
输出：5
解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。
示例 2：
输入：k = 5
输出：0
解释：没有匹配到这样的 x!，符合 k = 5 的条件。
示例 3:
输入: k = 3
输出: 5
  提示:
0 <= k <= 109",88,,7879,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",['https://leetcode.cn/problems/factorial-trailing-zeroes/'],19456
评论 (516),valid-tic-tac-toe-state,中等,"给你一个字符串数组 board 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 board 所显示的状态时，才返回 true 。
井字游戏的棋盘是一个 3 x 3 数组，由字符 ' '，'X' 和 'O' 组成。字符 ' ' 代表一个空位。
以下是井字游戏的规则：
玩家轮流将字符放入空位（' '）中。
玩家 1 总是放字符 'X' ，而玩家 2 总是放字符 'O' 。
'X' 和 'O' 只允许放置在空位中，不允许对已放有字符的位置进行填充。
当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。
当所有位置非空时，也算为游戏结束。
如果游戏结束，玩家不允许再放置字符。
  示例 1：
输入：board = [""O  "",""   "",""   ""]
输出：false
解释：玩家 1 总是放字符 ""X"" 。
示例 2：
输入：board = [""XOX"","" X "",""   ""]
输出：false
解释：玩家应该轮流放字符。
示例 3:
输入：board = [""XOX"",""O O"",""XOX""]
输出：true
  提示：
board.length == 3
board[i].length == 3
board[i][j] 为 'X'、'O' 或 ' '",108,https://assets.leetcode.com/uploads/2021/05/15/tictactoe1-grid.jpg,29406,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/design-tic-tac-toe/'],75599
评论 (91),number-of-subarrays-with-bounded-maximum,中等,"给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。
生成的测试用例保证结果符合 32-bit 整数范围。
  示例 1：
输入：nums = [2,1,4,3], left = 2, right = 3
输出：3
解释：满足条件的三个子数组：[2], [2, 1], [3]
示例 2：
输入：nums = [2,9,2,5,6], left = 2, right = 8
输出：7
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 109
0 <= left <= right <= 109",179,,10486,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/']",[],19849
评论 (529),rotate-string,简单,"给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。
s 的 旋转操作 就是将 s 最左边的字符移动到最右边。 
例如, 若 s = 'abcde'，在旋转一次之后结果就是'bcdea' 。
  示例 1:
输入: s = ""abcde"", goal = ""cdeab""
输出: true
示例 2:
输入: s = ""abcde"", goal = ""abced""
输出: false
  提示:
1 <= s.length, goal.length <= 100
s 和 goal 由小写英文字母组成",253,,68223,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/']",[],108217
评论 (553),all-paths-from-source-to-target,中等,"给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）
 graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。
  示例 1：
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
示例 2：
输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
  提示：
n == graph.length
2 <= n <= 15
0 <= graph[i][j] < n
graph[i][j] != i（即不存在自环）
graph[i] 中的所有元素 互不相同
保证输入为 有向无环图（DAG）
 ",287,,68398,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/backtracking/']",[],86709
评论 (251),smallest-rotation-with-highest-score,困难,"给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] 的形式。此后，任何值小于或等于其索引的项都可以记作一分。
例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 > 0 [不计分]、3 > 1 [不计分]、0 <= 2 [计 1 分]、2 <= 3 [计 1 分]，4 <= 4 [计 1 分]。
在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最小的下标 k 。
  示例 1：
输入：nums = [2,3,1,4,0]
输出：3
解释：
下面列出了每个 k 的得分：
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
所以我们应当选择 k = 3，得分最高。
示例 2：
输入：nums = [1,3,0,2,4]
输出：0
解释：
nums 无论怎么变化总是有 3 分。
所以我们将选择最小的 k，即 0。
  提示：
1 <= nums.length <= 105
0 <= nums[i] < nums.length",214,,19609,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],31927
评论 (65),champagne-tower,中等,"我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。
从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）
例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。
现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从0开始）。
  示例 1:
输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.00000
解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。

示例 2:
输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.50000
解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。
示例 3:
输入: poured = 100000009, query_row = 33, query_glass = 17
输出: 1.00000
  提示:
0 <= poured <= 109
0 <= query_glass <= query_row < 100",114,,7636,['https://leetcode.cn/tag/dynamic-programming/'],[],18004
评论 (27),similar-rgb-color,Unknown,,-1,,-1,[],[],-1
评论 (74),minimum-swaps-to-make-sequences-increasing,困难,"我们有两个长度相等且不为空的整型数组 nums1 和 nums2 。在一次操作中，我们可以交换 nums1[i] 和 nums2[i]的元素。
例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素，得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。
返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。
数组 arr 严格递增 且  arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1] 。
注意：
用例保证可以实现操作。
  示例 1:
输入: nums1 = [1,3,5,4], nums2 = [1,2,3,7]
输出: 1
解释: 
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。
示例 2:
输入: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]
输出: 1
  提示:
2 <= nums1.length <= 105
nums2.length == nums1.length
0 <= nums1[i], nums2[i] <= 2 * 105",234,,8733,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],20381
评论 (318),find-eventual-safe-states,中等,"有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph表示， graph[i]是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i]中的每个节点都有一条边。
如果一个节点没有连出的有向边，则它是 终端节点 。如果没有出边，则节点为终端节点。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。
返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。
  示例 1：
输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出：[2,4,5,6]
解释：示意图如上。
节点 5 和节点 6 是终端节点，因为它们都没有出边。
从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。
示例 2：
输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
输出：[4]
解释:
只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。
  提示：
n == graph.length
1 <= n <= 104
0 <= graph[i].length <= n
0 <= graph[i][j] <= n - 1
graph[i] 按严格递增顺序排列。
图中可能包含自环。
图中边的数目在范围 [1, 4 * 104] 内。",325,,36523,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']",[],62595
评论 (207),bricks-falling-when-hit,困难,"有一个 m x n 的二元网格 grid ，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：
一块砖直接连接到网格的顶部，或者
至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时
给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而 掉落 。一旦砖块掉落，它会 立即 从网格 grid 中消失（即，它不会落在其他稳定的砖块上）。
返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。
注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。
  示例 1：
输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
输出：[2]
解释：网格开始为：
[[1,0,0,0]，
 [1,1,1,0]]
消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0]
 [0,1,1,0]]
两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
[[1,0,0,0],
 [0,0,0,0]]
因此，结果为 [2] 。
示例 2：
输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
输出：[0,0]
解释：网格开始为：
[[1,0,0,0],
 [1,1,0,0]]
消除 (1,1) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [1,0,0,0]]
剩下的砖都很稳定，所以不会掉落。网格保持不变：
[[1,0,0,0], 
 [1,0,0,0]]
接下来消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [0,0,0,0]]
剩下的砖块仍然是稳定的，所以不会有砖块掉落。
因此，结果为 [0,0] 。
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 200
grid[i][j] 为 0 或 1
1 <= hits.length <= 4 * 104
hits[i].length == 2
0 <= xi <= m - 1
0 <= yi <= n - 1
所有 (xi, yi) 互不相同",235,,13095,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],27476
评论 (674),unique-morse-code-words,简单,"国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:
'a' 对应 "".-"" ，
'b' 对应 ""-..."" ，
'c' 对应 ""-.-."" ，以此类推。
为了方便，所有 26 个英文字母的摩尔斯密码表如下：
["".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",""...-"","".--"",""-..-"",""-.--"",""--..""]
给你一个字符串数组 words ，每个单词可以写成每个字母对应摩尔斯密码的组合。
例如，""cab"" 可以写成 ""-.-..--..."" ，(即 ""-.-."" + "".-"" + ""-..."" 字符串的结合)。我们将这样一个连接过程称作 单词翻译 。
对 words 中所有单词进行单词翻译，返回不同 单词翻译 的数量。
  示例 1：
输入: words = [""gin"", ""zen"", ""gig"", ""msg""]
输出: 2
解释: 
各单词翻译如下:
""gin"" -> ""--...-.""
""zen"" -> ""--...-.""
""gig"" -> ""--...--.""
""msg"" -> ""--...--.""

共有 2 种不同翻译, ""--...-."" 和 ""--...--."".
示例 2：
输入：words = [""a""]
输出：1
  提示：
1 <= words.length <= 100
1 <= words[i].length <= 12
words[i] 由小写英文字母组成",234,,71878,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],87407
评论 (59),split-array-with-same-average,困难,"给定你一个整数数组 nums
我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空，并且 average(A) == average(B) 。
如果可以完成则返回true ， 否则返回 false  。
注意：对于数组 arr ,  average(arr) 是 arr 的所有元素除以 arr 长度的和。
  示例 1:
输入: nums = [1,2,3,4,5,6,7,8]
输出: true
解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。
示例 2:
输入: nums = [3,1]
输出: false
  提示:
1 <= nums.length <= 30
0 <= nums[i] <= 104",91,,3603,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],12107
评论 (568),number-of-lines-to-write-string,简单,"我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， widths[1] 代表 'b' 需要的单位，...， widths[25] 代表 'z' 需要的单位。
现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。
示例 1:
输入: 
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = ""abcdefghijklmnopqrstuvwxyz""
输出: [3, 60]
解释: 
所有的字符拥有相同的占用单位10。所以书写所有的26个字母，
我们需要2个整行和占用60个单位的一行。
示例 2:
输入: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = ""bbbcccdddaaa""
输出: [2, 4]
解释: 
除去字母'a'所有的字符都是相同的单位10，并且字符串 ""bbbcccdddaa"" 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.
最后一个字母 'a' 将会被写到第二行，因为第一行只剩下2个单位了。
所以，这个答案是2行，第二行有4个单位宽度。
  注:
字符串 S 的长度在 [1, 1000] 的范围。
S 只包含小写字母。
widths 是长度为 26的数组。
widths[i] 值的范围在 [2, 10]。",120,,47474,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],68726
评论 (621),max-increase-to-keep-city-skyline,中等,"给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。
城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。
我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。
在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。
  示例 1：
输入：grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
输出：35
解释：建筑物的高度如上图中心所示。
用红色绘制从不同方向观看得到的天际线。
在不影响天际线的情况下，增加建筑物的高度：
gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]
示例 2：
输入：grid = [[0,0,0],[0,0,0],[0,0,0]]
输出：0
解释：增加任何建筑物的高度都会导致天际线的变化。
  提示：
n == grid.length
n == grid[r].length
2 <= n <= 50
0 <= grid[r][c] <= 100",223,https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png,47932,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],54091
评论 (65),soup-servings,中等,"有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：
提供 100ml 的 汤A 和 0ml 的 汤B 。
提供 75ml 的 汤A 和 25ml 的 汤B 。
提供 50ml 的 汤A 和 50ml 的 汤B 。
提供 25ml 的 汤A 和 75ml 的 汤B 。
当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。
注意 不存在先分配 100 ml 汤B 的操作。
需要返回的值： 汤A 先分配完的概率 +  汤A和汤B 同时分配完的概率 / 2。返回值在正确答案 10-5 的范围内将被认为是正确的。
  示例 1:
输入: n = 50
输出: 0.62500
解释:如果我们选择前两个操作，A 首先将变为空。
对于第三个操作，A 和 B 会同时变为空。
对于第四个操作，B 首先将变为空。
所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。
示例 2:
输入: n = 100
输出: 0.71875
  提示:
0 <= n <= 109",75,,5236,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/probability-and-statistics/']",[],10832
评论 (75),expressive-words,中等,"有时候人们会用重复写一些字母来表示额外的感受，比如 ""hello"" -> ""heeellooo"", ""hi"" -> ""hiii""。我们将相邻字母都相同的一串字符定义为相同字母组，例如：""h"", ""eee"", ""ll"", ""ooo""。
对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。
例如，以 ""hello"" 为例，我们可以对字母组 ""o"" 扩张得到 ""hellooo""，但是无法以同样的方法得到 ""helloo"" 因为字母组 ""oo"" 长度小于 3。此外，我们可以进行另一种扩张 ""ll"" -> ""lllll"" 以获得 ""helllllooo""。如果 S = ""helllllooo""，那么查询词 ""hello"" 是可扩张的，因为可以对它执行这两种扩张操作使得 query = ""hello"" -> ""hellooo"" -> ""helllllooo"" = S。
输入一组查询单词，输出其中可扩张的单词数量。
  示例：
输入： 
S = ""heeellooo""
words = [""hello"", ""hi"", ""helo""]
输出：1
解释：
我们能通过扩张 ""hello"" 的 ""e"" 和 ""o"" 来得到 ""heeellooo""。
我们不能通过扩张 ""helo"" 来得到 ""heeellooo"" 因为 ""ll"" 的长度小于 3 。
  提示：
0 <= len(S) <= 100。
0 <= len(words) <= 100。
0 <= len(words[i]) <= 100。
S 和所有在 words 中的单词都只由小写字母组成。",56,,5884,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],14036
评论 (216),chalkboard-xor-game,困难,"黑板上写着一个非负整数数组 nums[i] 。
Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。
并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0 ，这个玩家获胜。
假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。
  示例 1：
输入: nums = [1,1,2]
输出: false
解释: 
Alice 有两个选择: 擦掉数字 1 或 2。
如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。
如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。
示例 2:
输入: nums = [0,1]
输出: true
示例 3:
输入: nums = [1,2,3]
输出: true
  提示：
1 <= nums.length <= 1000
0 <= nums[i] < 216",137,,17683,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/brainteaser/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/game-theory/']",[],24304
评论 (245),subdomain-visit-count,中等,"网站域名 ""discuss.leetcode.com"" 由多个子域名组成。顶级域名为 ""com"" ，二级域名为 ""leetcode.com"" ，最低一级为 ""discuss.leetcode.com"" 。当访问域名 ""discuss.leetcode.com"" 时，同时也会隐式访问其父域名 ""leetcode.com"" 以及 ""com"" 。
计数配对域名 是遵循 ""rep d1.d2.d3"" 或 ""rep d1.d2"" 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。
例如，""9001 discuss.leetcode.com"" 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。
给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。
  示例 1：
输入：cpdomains = [""9001 discuss.leetcode.com""]
输出：[""9001 leetcode.com"",""9001 discuss.leetcode.com"",""9001 com""]
解释：例子中仅包含一个网站域名：""discuss.leetcode.com""。
按照前文描述，子域名 ""leetcode.com"" 和 ""com"" 都会被访问，所以它们都被访问了 9001 次。
示例 2：
输入：cpdomains = [""900 google.mail.com"", ""50 yahoo.com"", ""1 intel.mail.com"", ""5 wiki.org""]
输出：[""901 mail.com"",""50 yahoo.com"",""900 google.mail.com"",""5 wiki.org"",""5 org"",""1 intel.mail.com"",""951 com""]
解释：按照前文描述，会访问 ""google.mail.com"" 900 次，""yahoo.com"" 50 次，""intel.mail.com"" 1 次，""wiki.org"" 5 次。
而对于父域名，会访问 ""mail.com"" 900 + 1 = 901 次，""com"" 900 + 50 + 1 = 951 次，和 ""org"" 5 次。
  提示：
1 <= cpdomain.length <= 100
1 <= cpdomain[i].length <= 100
cpdomain[i] 会遵循 ""repi d1i.d2i.d3i"" 或 ""repi d1i.d2i"" 格式
repi 是范围 [1, 104] 内的一个整数
d1i、d2i 和 d3i 由小写英文字母组成",109,,17814,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],25047
评论 (284),largest-triangle-area,简单,"给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。
示例:
输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
输出: 2
解释: 
这五个点如下图所示。组成的橙色三角形是最大的，面积为2。
注意:
3 <= points.length <= 50.
不存在重复的点。
 -50 <= points[i][j] <= 50.
结果误差值在 10^-6 以内都认为是正确答案。",173,,32498,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/largest-perimeter-triangle/'],47022
评论 (101),largest-sum-of-averages,中等,"给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。
注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。
返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。
  示例 1:
输入: nums = [9,1,2,3,9], k = 3
输出: 20.00000
解释: 
nums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. 
我们也可以把 nums 分成[9, 1], [2], [3, 9]. 
这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.
示例 2:
输入: nums = [1,2,3,4,5,6,7], k = 4
输出: 20.50000
  提示:
1 <= nums.length <= 100
1 <= nums[i] <= 104
1 <= k <= nums.length",220,,9101,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],16178
评论 (266),binary-tree-pruning,中等,"给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。
返回移除了所有不包含 1 的子树的原二叉树。
节点 node 的子树为 node 本身加上所有 node 的后代。
  示例 1：
输入：root = [1,null,0,0,1]
输出：[1,null,0,null,1]
解释：
只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。
示例 2：
输入：root = [1,0,1,0,0,0,1]
输出：[1,null,1,null,1]
示例 3：
输入：root = [1,1,0,1,1,0,1,0]
输出：[1,1,0,1,1,null,1]
  提示：
树中节点的数目在范围 [1, 200] 内
Node.val 为 0 或 1",224,https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png,28518,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],40616
评论 (288),bus-routes,困难,"给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
  示例 1：
输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6
输出：2
解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 
示例 2：
输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
输出：-1
  提示：
1 <= routes.length <= 500.
1 <= routes[i].length <= 105
routes[i] 中的所有值 互不相同
sum(routes[i].length) <= 105
0 <= routes[i][j] < 106
0 <= source, target < 106",277,,30217,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],69702
评论 (64),ambiguous-coordinates,中等,"我们有一些二维坐标，如 ""(1, 3)"" 或 ""(2, 0.5)""，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。
原始的坐标表示法不会存在多余的零，所以不会出现类似于""00"", ""0.0"", ""0.00"", ""1.0"", ""001"", ""00.01""或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”形式的数字。
最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。
  示例 1:
输入: ""(123)""
输出: [""(1, 23)"", ""(12, 3)"", ""(1.2, 3)"", ""(1, 2.3)""]
示例 2:
输入: ""(00011)""
输出:  [""(0.001, 1)"", ""(0, 0.011)""]
解释: 
0.0, 00, 0001 或 00.01 是不被允许的。
示例 3:
输入: ""(0123)""
输出: [""(0, 123)"", ""(0, 12.3)"", ""(0, 1.23)"", ""(0.1, 23)"", ""(0.1, 2.3)"", ""(0.12, 3)""]
示例 4:
输入: ""(100)""
输出: [(10, 0)]
解释: 
1.0 是不被允许的。
  提示:
4 <= S.length <= 12.
S[0] = ""("", S[S.length - 1] = "")"", 且字符串 S 中的其他元素都是数字。
 ",42,,4466,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],8761
评论 (195),linked-list-components,中等,"给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 nums，该列表是上述链表中整型值的一个子集。
返回列表 nums 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 nums 中）构成的集合。
  示例 1：
输入: head = [0,1,2,3], nums = [0,1,3]
输出: 2
解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。
示例 2：
  输入: head = [0,1,2,3,4], nums = [0,3,1,4]
输出: 2
解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。
  提示：
链表中节点数为n
1 <= n <= 104
0 <= Node.val < n
Node.val 中所有值 不同
1 <= nums.length <= n
0 <= nums[i] < n
nums 中所有值 不同",93,,15514,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/']",[],26117
评论 (51),race-car,困难,"你的赛车可以从位置 0 开始，并且速度为 +1 ，在一条无限长的数轴上行驶。赛车也可以向负方向行驶。赛车可以按照由加速指令 'A' 和倒车指令 'R' 组成的指令序列自动行驶。
当收到指令 'A' 时，赛车这样行驶：
position += speed
speed *= 2
当收到指令 'R' 时，赛车这样行驶：
如果速度为正数，那么speed = -1
否则 speed = 1
当前所处位置不变。
例如，在执行指令 ""AAR"" 后，赛车位置变化为 0 --> 1 --> 3 --> 3 ，速度变化为 1 --> 2 --> 4 --> -1 。
给你一个目标位置 target ，返回能到达目标位置的最短指令序列的长度。
  示例 1：
输入：target = 3
输出：2
解释：
最短指令序列是 ""AA"" 。
位置变化 0 --> 1 --> 3 。
示例 2：
输入：target = 6
输出：5
解释：
最短指令序列是 ""AAARA"" 。
位置变化 0 --> 1 --> 3 --> 7 --> 7 --> 6 。
  提示：
1 <= target <= 104",125,,4470,['https://leetcode.cn/tag/dynamic-programming/'],[],10145
评论 (653),most-common-word,简单,"给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。
题目保证至少有一个词不在禁用列表中，而且答案唯一。
禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。
  示例：
输入: 
paragraph = ""Bob hit a ball, the hit BALL flew far after it was hit.""
banned = [""hit""]
输出: ""ball""
解释: 
""hit"" 出现了3次，但它是一个禁用的单词。
""ball"" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 
注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 ""ball,""）， 
""hit""不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。
  提示：
1 <= 段落长度 <= 1000
0 <= 禁用单词个数 <= 100
1 <= 禁用单词长度 <= 10
答案是唯一的, 且都是小写字母 (即使在 paragraph 里是大写的，即使是一些特定的名词，答案都是小写的。)
paragraph 只包含字母、空格和下列标点符号!?',;.
不存在没有连字符或者带有连字符的单词。
单词里只包含字母，不会出现省略号或者其他标点符号。",182,,52486,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],113195
评论 (530),short-encoding-of-words,中等,"单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：
words.length == indices.length
助记字符串 s 以 '#' 字符结尾
对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 '#' 字符结束（但不包括 '#'）的 子字符串 恰好与 words[i] 相等
给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。
  示例 1：
输入：words = [""time"", ""me"", ""bell""]
输出：10
解释：一组有效编码为 s = ""time#bell#"" 和 indices = [0, 2, 5] 。
words[0] = ""time"" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 ""time#bell#""
words[1] = ""me"" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 ""time#bell#""
words[2] = ""bell"" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 ""time#bell#""
示例 2：
输入：words = [""t""]
输出：2
解释：一组有效编码为 s = ""t#"" 和 indices = [0] 。
  提示：
1 <= words.length <= 2000
1 <= words[i].length <= 7
words[i] 仅由小写字母组成",274,,61353,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],119433
评论 (675),shortest-distance-to-a-character,简单,"给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。
返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。
两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。
  示例 1：
输入：s = ""loveleetcode"", c = ""e""
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。
示例 2：
输入：s = ""aaab"", c = ""b""
输出：[3,2,1,0]
  提示：
1 <= s.length <= 104
s[i] 和 c 均为小写英文字母
题目数据保证 c 在 s 中至少出现一次",300,,65840,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],89801
评论 (48),card-flipping-game,中等,"在桌子上有 N 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。
我们可以先翻转任意张卡片，然后选择其中一张卡片。
如果选中的那张卡片背面的数字 X 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。
哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。
其中, fronts[i] 和 backs[i] 分别代表第 i 张卡片的正面和背面的数字。
如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。
示例：
输入：fronts = [1,2,4,4,7], backs = [1,3,4,1,3]
输出：2
解释：假设我们翻转第二张卡片，那么在正面的数变成了 [1,3,4,4,7] ， 背面的数变成了 [1,2,4,1,3]。
接着我们选择第二张卡片，因为现在该卡片的背面的数是 2，2 与任意卡片上正面的数都不同，所以 2 就是我们想要的数字。
  提示：
1 <= fronts.length == backs.length <= 1000
1 <= fronts[i] <= 2000
1 <= backs[i] <= 2000",20,,3684,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],7244
评论 (55),binary-trees-with-factors,中等,"给出一个含有不重复整数元素的数组 arr ，每个整数 arr[i] 均大于 1。
用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。
满足条件的二叉树一共有多少个？答案可能很大，返回 对 109 + 7 取余 的结果。
  示例 1:
输入: arr = [2, 4]
输出: 3
解释: 可以得到这些二叉树: [2], [4], [4, 2, 2]
示例 2:
输入: arr = [2, 4, 5, 10]
输出: 7
解释: 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].
  提示：
1 <= arr.length <= 1000
2 <= arr[i] <= 109
arr 中的所有值 互不相同",79,,3865,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/dynamic-programming/']",[],9015
评论 (551),goat-latin,简单,"给你一个由若干单词组成的句子 sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。
请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。山羊拉丁文的规则如下：
如果单词以元音开头（'a', 'e', 'i', 'o', 'u'），在单词后添加""ma""。
例如，单词 ""apple"" 变为 ""applema"" 。
如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加""ma""。
例如，单词 ""goat"" 变为 ""oatgma"" 。
根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从 1 开始。
例如，在第一个单词后添加 ""a"" ，在第二个单词后添加 ""aa"" ，以此类推。
返回将 sentence 转换为山羊拉丁文后的句子。
  示例 1：
输入：sentence = ""I speak Goat Latin""
输出：""Imaa peaksmaaa oatGmaaaa atinLmaaaaa""
示例 2：
输入：sentence = ""The quick brown fox jumped over the lazy dog""
输出：""heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa""
  提示：
1 <= sentence.length <= 150
sentence 由英文字母和空格组成
sentence 不含前导或尾随空格
sentence 中的所有单词由单个空格分隔",123,,50551,['https://leetcode.cn/tag/string/'],[],77353
评论 (384),friends-of-appropriate-ages,中等,"在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。
如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：
ages[y] <= 0.5 * ages[x] + 7
ages[y] > ages[x]
ages[y] > 100 && ages[x] < 100
否则，x 将会向 y 发送一条好友请求。
注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。
返回在该社交媒体网站上产生的好友请求总数。
  示例 1：
输入：ages = [16,16]
输出：2
解释：2 人互发好友请求。
示例 2：
输入：ages = [16,17,18]
输出：2
解释：产生的好友请求为 17 -> 16 ，18 -> 17 。
示例 3：
输入：ages = [20,30,100,110,120]
输出：3
解释：产生的好友请求为 110 -> 100 ，120 -> 110 ，120 -> 100 。
  提示：
n == ages.length
1 <= n <= 2 * 104
1 <= ages[i] <= 120",178,,33517,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],73548
评论 (140),most-profit-assigning-work,中等,"你有 n 个工作和 m 个工人。给定三个数组： difficulty, profit 和 worker ，其中:
difficulty[i] 表示第 i 个工作的难度，profit[i] 表示第 i 个工作的收益。
worker[i] 是第 i 个工人的能力，即该工人只能完成难度小于等于 worker[i] 的工作。
每个工人 最多 只能安排 一个 工作，但是一个工作可以 完成多次 。
举个例子，如果 3 个工人都尝试完成一份报酬为 $1 的同样工作，那么总收益为 $3 。如果一个工人不能完成任何工作，他的收益为 $0 。
返回 在把工人分配到工作岗位后，我们所能获得的最大利润 。
  示例 1：
输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
输出: 100 
解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。
示例 2:
输入: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
输出: 0
  提示:
n == difficulty.length
n == profit.length
m == worker.length
1 <= n, m <= 104
1 <= difficulty[i], profit[i], worker[i] <= 105",84,,10758,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],27031
评论 (148),making-a-large-island,困难,"给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。
返回执行此操作后，grid 中最大的岛屿面积是多少？
岛屿 由一组上、下、左、右四个方向相连的 1 形成。
  示例 1:
输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
示例 2:
输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
示例 3:
输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。
  提示：
n == grid.length
n == grid[i].length
1 <= n <= 500
grid[i][j] 为 0 或 1",151,,13384,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],33916
评论 (64),count-unique-characters-of-all-substrings-of-a-given-string,困难,"我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。
例如：s = ""LEETCODE"" ，则其中 ""L"", ""T"",""C"",""O"",""D"" 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。
本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。
由于答案可能非常大，请将结果 mod 10 ^ 9 + 7 后再返回。
  示例 1：
输入: s = ""ABC""
输出: 10
解释: 所有可能的子串为：""A"",""B"",""C"",""AB"",""BC"" 和 ""ABC""。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10
示例 2：
输入: s = ""ABA""
输出: 8
解释: 除了 countUniqueChars(""ABA"") = 1 之外，其余与示例 1 相同。
示例 3：
输入：s = ""LEETCODE""
输出：92
  提示：
0 <= s.length <= 10^5
s 只包含大写英文字符",114,,4623,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],8583
评论 (129),consecutive-numbers-sum,困难,"给定一个正整数 n，返回 连续正整数满足所有数字之和为 n 的组数 。 
  示例 1:
输入: n = 5
输出: 2
解释: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。
示例 2:
输入: n = 9
输出: 3
解释: 9 = 4 + 5 = 2 + 3 + 4
示例 3:
输入: n = 15
输出: 4
解释: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5
  提示:
1 <= n <= 109",144,,10961,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/']",[],29625
评论 (518),positions-of-large-groups,简单,"在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。
例如，在字符串 s = ""abbxxxxzyy"" 中，就含有 ""a"", ""bb"", ""xxxx"", ""z"" 和 ""yy"" 这样的一些分组。
分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 ""xxxx"" 分组用区间表示为 [3,6] 。
我们称所有包含大于或等于三个连续字符的分组为 较大分组 。
找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。
  示例 1：
输入：s = ""abbxxxxzzy""
输出：[[3,6]]
解释：""xxxx"" 是一个起始于 3 且终止于 6 的较大分组。
示例 2：
输入：s = ""abc""
输出：[]
解释：""a"",""b"" 和 ""c"" 均不是符合要求的较大分组。
示例 3：
输入：s = ""abcdddeeeeaabbbcd""
输出：[[3,5],[6,9],[12,14]]
解释：较大分组为 ""ddd"", ""eeee"" 和 ""bbb""
示例 4：
输入：s = ""aba""
输出：[]
  提示：
1 <= s.length <= 1000
s 仅含小写英文字母",131,,54928,['https://leetcode.cn/tag/string/'],[],101149
评论 (69),masking-personal-information,中等,"给你一条个人信息字符串 s ，可能表示一个 邮箱地址 ，也可能表示一串 电话号码 。返回按如下规则 隐藏 个人信息后的结果：
电子邮件地址：
一个电子邮件地址由以下部分组成：
一个 名字 ，由大小写英文字母组成，后面跟着
一个 '@' 字符，后面跟着
一个 域名 ，由大小写英文字母和一个位于中间的 '.' 字符组成。'.' 不会是域名的第一个或者最后一个字符。
要想隐藏电子邮件地址中的个人信息：
名字 和 域名 部分的大写英文字母应当转换成小写英文字母。
名字 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 ""*****"" 替换。
电话号码：
一个电话号码应当按下述格式组成：
电话号码可以由 10-13 位数字组成
后 10 位构成 本地号码
前面剩下的 0-3 位，构成 国家代码
利用 {'+', '-', '(', ')', ' '} 这些 分隔字符 按某种形式对上述数字进行分隔
要想隐藏电话号码中的个人信息：
移除所有 分隔字符
隐藏个人信息后的电话号码应该遵从这种格式：
""***-***-XXXX"" 如果国家代码为 0 位数字
""+*-***-***-XXXX"" 如果国家代码为 1 位数字
""+**-***-***-XXXX"" 如果国家代码为 2 位数字
""+***-***-***-XXXX"" 如果国家代码为 3 位数字
""XXXX"" 是最后 4 位 本地号码
  示例 1：
输入：s = ""LeetCode@LeetCode.com""
输出：""l*****e@leetcode.com""
解释：s 是一个电子邮件地址。
名字和域名都转换为小写，名字的中间用 5 个 * 替换。
示例 2：
输入：s = ""AB@qq.com""
输出：""a*****b@qq.com""
解释：s 是一个电子邮件地址。
名字和域名都转换为小写，名字的中间用 5 个 * 替换。
注意，尽管 ""ab"" 只有两个字符，但中间仍然必须有 5 个 * 。
示例 3：
输入：s = ""1(234)567-890""
输出：""***-***-7890""
解释：s 是一个电话号码。
共计 10 位数字，所以本地号码为 10 位数字，国家代码为 0 位数字。
因此，隐藏后的电话号码应该是 ""***-***-7890"" 。
示例 4：
输入：s = ""86-(10)12345678""
输出：""+**-***-***-5678""
解释：s 是一个电话号码。
共计 12 位数字，所以本地号码为 10 位数字，国家代码为 2 位数字。
因此，隐藏后的电话号码应该是 ""+**-***-***-7890"" 。
  提示：
s 是一个 有效 的电子邮件或者电话号码
如果 s 是一个电子邮件：
8 <= s.length <= 40
s 是由大小写英文字母，恰好一个 '@' 字符，以及 '.' 字符组成
如果 s 是一个电话号码：
10 <= s.length <= 20
s 是由数字、空格、字符 '('、')'、'-' 和 '+' 组成",32,,8736,['https://leetcode.cn/tag/string/'],[],21007
评论 (849),flipping-an-image,简单,"给定一个 n x n 的二进制矩阵 image ，先 水平 翻转图像，然后 反转 图像并返回 结果 。
水平翻转图片就是将图片的每一行都进行翻转，即逆序。
例如，水平翻转 [1,1,0] 的结果是 [0,1,1]。
反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。
例如，反转 [0,1,1] 的结果是 [1,0,0]。
  示例 1：
输入：image = [[1,1,0],[1,0,1],[0,0,0]]
输出：[[1,0,0],[0,1,0],[1,1,1]]
解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
示例 2：
输入：image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
  提示：
n == image.length
n == image[i].length
1 <= n <= 20
images[i][j] == 0 或 1.",276,,92491,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],116414
评论 (87),find-and-replace-in-string,中等,"你会得到一个字符串 s (索引从 0 开始)，你必须对它执行 k 个替换操作。替换操作以三个长度均为 k 的并行数组给出：indices, sources,  targets。
要完成第 i 个替换操作:
检查 子字符串  sources[i] 是否出现在 原字符串 s 的索引 indices[i] 处。
如果没有出现， 什么也不做 。
如果出现，则用 targets[i] 替换 该子字符串。
例如，如果 s = ""abcd"" ， indices[i] = 0 , sources[i] = ""ab""， targets[i] = ""eee"" ，那么替换的结果将是 ""eeecd"" 。
所有替换操作必须 同时 发生，这意味着替换操作不应该影响彼此的索引。测试用例保证元素间不会重叠 。
例如，一个 s = ""abc"" ，  indices = [0,1] ， sources = [""ab""，""bc""] 的测试用例将不会生成，因为 ""ab"" 和 ""bc"" 替换重叠。
在对 s 执行所有替换操作后返回 结果字符串 。
子字符串 是字符串中连续的字符序列。
  示例 1：
输入：s = ""abcd"", indexes = [0,2], sources = [""a"",""cd""], targets = [""eee"",""ffff""]
输出：""eeebffff""
解释：
""a"" 从 s 中的索引 0 开始，所以它被替换为 ""eee""。
""cd"" 从 s 中的索引 2 开始，所以它被替换为 ""ffff""。
示例 2：
输入：s = ""abcd"", indexes = [0,2], sources = [""ab"",""ec""], targets = [""eee"",""ffff""]
输出：""eeecd""
解释：
""ab"" 从 s 中的索引 0 开始，所以它被替换为 ""eee""。
""ec"" 没有从原始的 S 中的索引 2 开始，所以它没有被替换。
  提示：
1 <= s.length <= 1000
k == indices.length == sources.length == targets.length
1 <= k <= 100
0 <= indexes[i] < s.length
1 <= sources[i].length, targets[i].length <= 50
s 仅由小写英文字母组成
sources[i] 和 targets[i] 仅由小写英文字母组成",67,,6459,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],14582
评论 (254),sum-of-distances-in-tree,困难,"给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。
给定整数 n 和数组 edges ， edges[i] = [ai, bi]表示树中的节点 ai 和 bi 之间有一条边。
返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。
  示例 1:
输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
输出: [8,12,6,10,10,10]
解释: 树如图所示。
我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 
也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。
示例 2:
输入: n = 1, edges = []
输出: [0]
示例 3:
输入: n = 2, edges = [[1,0]]
输出: [1,1]
  提示:
1 <= n <= 3 * 104
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
给定的输入保证为有效的树",342,https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist2.jpg,14646,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/distribute-coins-in-binary-tree/'],27606
评论 (80),image-overlap,中等,"给你两个图像 img1 和 img2 ，两个图像的大小都是 n x n ，用大小相同的二进制正方形矩阵表示。二进制矩阵仅由若干 0 和若干 1 组成。
转换 其中一个图像，将所有的 1 向左，右，上，或下滑动任何数量的单位；然后把它放在另一个图像的上面。该转换的 重叠 是指两个图像 都 具有 1 的位置的数目。
请注意，转换 不包括 向任何方向旋转。越过矩阵边界的 1 都将被清除。
最大可能的重叠数量是多少？
  示例 1：
输入：img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]
输出：3
解释：将 img1 向右移动 1 个单位，再向下移动 1 个单位。

两个图像都具有 1 的位置的数目是 3（用红色标识）。
示例 2：
输入：img1 = [[1]], img2 = [[1]]
输出：1
示例 3：
输入：img1 = [[0]], img2 = [[0]]
输出：0
  提示：
n == img1.length == img1[i].length
n == img2.length == img2[i].length
1 <= n <= 30
img1[i][j] 为 0 或 1
img2[i][j] 为 0 或 1",80,,5055,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],8767
评论 (507),rectangle-overlap,简单,"矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。
如果相交的面积为 正 ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
给出两个矩形 rec1 和 rec2 。如果它们重叠，返回 true；否则，返回 false 。
  示例 1：
输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：
输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
示例 3：
输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]
输出：false
  提示：
rect1.length == 4
rect2.length == 4
-109 <= rec1[i], rec2[i] <= 109
rec1 和 rec2 表示一个面积不为零的有效矩形",250,,42937,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/rectangle-area/'],88619
评论 (399),new-21-game,中等,"爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 k 分时抽取数字。 抽取时，她从 [1, maxPts] 的范围中随机获得一个整数作为分数进行累计，其中 maxPts 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得 k 分 或更多分 时，她就停止抽取数字。
爱丽丝的分数不超过 n 的概率是多少？
与实际答案误差不超过 10-5 的答案将被视为正确答案。
  示例 1：
输入：n = 10, k = 1, maxPts = 10
输出：1.00000
解释：爱丽丝得到一张牌，然后停止。
示例 2：
输入：n = 6, k = 1, maxPts = 10
输出：0.60000
解释：爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。
示例 3：
输入：n = 21, k = 17, maxPts = 10
输出：0.73278
  提示：
0 <= k <= n <= 104
1 <= maxPts <= 104",342,,20515,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/probability-and-statistics/']",[],51914
评论 (369),push-dominoes,中等,"n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。
每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。
如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。
就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。
给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：
dominoes[i] = 'L'，表示第 i 张多米诺骨牌被推向左侧，
dominoes[i] = 'R'，表示第 i 张多米诺骨牌被推向右侧，
dominoes[i] = '.'，表示没有推动第 i 张多米诺骨牌。
返回表示最终状态的字符串。
  示例 1：
输入：dominoes = ""RR.L""
输出：""RR.L""
解释：第一张多米诺骨牌没有给第二张施加额外的力。
示例 2：
输入：dominoes = "".L.R...LR..L..""
输出：""LL.RR.LLRRLL..""
  提示：
n == dominoes.length
1 <= n <= 105
dominoes[i] 为 'L'、'R' 或 '.'",270,https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png,36189,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],65257
评论 (330),similar-string-groups,困难,"如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。
例如，""tars"" 和 ""rats"" 是相似的 (交换 0 与 2 的位置)； ""rats"" 和 ""arts"" 也是相似的，但是 ""star"" 不与 ""tars""，""rats""，或 ""arts"" 相似。
总之，它们通过相似性形成了两个关联组：{""tars"", ""rats"", ""arts""} 和 {""star""}。注意，""tars"" 和 ""arts"" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。
给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？
  示例 1：
输入：strs = [""tars"",""rats"",""arts"",""star""]
输出：2
示例 2：
输入：strs = [""omv"",""ovm""]
输出：1
  提示：
1 <= strs.length <= 300
1 <= strs[i].length <= 300
strs[i] 只包含小写字母。
strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。",147,,21011,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],36247
评论 (153),magic-squares-in-grid,中等,"3 x 3 的幻方是一个填充有 从 1 到 9  的不同数字的 3 x 3 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。
给定一个由整数组成的row x col 的 grid，其中有多少个 3 × 3 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。
  示例 1：
输入: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]
输出: 1
解释: 
下面的子矩阵是一个 3 x 3 的幻方：

而这一个不是：

总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。
示例 2:
输出: grid = [[8]]
输入: 0
  提示:
row == grid.length
col == grid[i].length
1 <= row, col <= 10
0 <= grid[i][j] <= 15",57,,9838,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/matrix/']",[],27094
评论 (483),keys-and-rooms,中等,"有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。
当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。
给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。
  示例 1：
输入：rooms = [[1],[2],[3],[]]
输出：true
解释：
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
示例 2：
输入：rooms = [[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。
  提示：
n == rooms.length
2 <= n <= 1000
0 <= rooms[i].length <= 1000
1 <= sum(rooms[i].length) <= 3000
0 <= rooms[i][j] < n
所有 rooms[i] 的值 互不相同",252,,66629,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/']",[],100193
评论,split-array-into-fibonacci-sequence,中等,"给定一个数字字符串 num，比如 ""123456579""，我们可以将它分成「斐波那契式」的序列 [123, 456, 579]。
形式上，斐波那契式 序列是一个非负整数列表 f，且满足：
0 <= f[i] < 231 ，（也就是说，每个整数都符合 32 位 有符号整数类型）
f.length >= 3
对于所有的0 <= i < f.length - 2，都有 f[i] + f[i + 1] = f[i + 2]
另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。
返回从 num 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。
  示例 1：
输入：num = ""1101111""
输出：[11,0,11,11]
解释：输出[110,1,111]也可以。
示例 2：
输入: num = ""112358130""
输出: []
解释: 无法拆分。
示例 3：
输入：""0123""
输出：[]
解释：每个块的数字不能以零开头，因此 ""01""，""2""，""3"" 不是有效答案。
  提示：
1 <= num.length <= 200
num 中只含有数字",254,,30982,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']","['https://leetcode.cn/problems/additive-number/', 'https://leetcode.cn/problems/fibonacci-number/']",63814
评论 (75),guess-the-word,困难,"这是一个 交互式问题 。
我们给出了一个由一些 不同的 单词组成的列表 wordlist ，对于每个 wordlist[i] 长度均为 6 ，这个列表中的一个单词将被选作 secret 。
你可以调用 Master.guess(word) 来猜单词。你所猜的单词应当是存在于原列表并且由 6 个小写字母组成的类型 string 。
此函数将会返回一个 integer ，表示你的猜测与秘密单词 secret 的准确匹配（值和位置同时匹配）的数目。此外，如果你的猜测不在给定的单词列表中，它将返回 -1。
对于每个测试用例，你有 10 次机会来猜出这个单词。当所有调用都结束时，如果您对 Master.guess 的调用在 10 次以内，并且至少有一次猜到 secret ，将判定为通过该用例。
  示例 1:
输入: secret = ""acckzz"", wordlist = [""acckzz"",""ccbazz"",""eiowzz"",""abcczz""]
输出: You guessed the secret word correctly.
解释:
master.guess(""aaaaaa"") 返回 -1, 因为 ""aaaaaa"" 不在 wordlist 中.
master.guess(""acckzz"") 返回 6, 因为 ""acckzz"" 就是秘密，6个字母完全匹配。
master.guess(""ccbazz"") 返回 3, 因为 ""ccbazz"" 有 3 个匹配项。
master.guess(""eiowzz"") 返回 2, 因为 ""eiowzz"" 有 2 个匹配项。
master.guess(""abcczz"") 返回 4, 因为 ""abcczz"" 有 4 个匹配项。
我们调用了 5 次master.guess，其中一次猜到了秘密，所以我们通过了这个测试用例。
 示例 2:
输入: secret = ""hamada"", wordlist = [""hamada"",""khaled""], numguesses = 10
输出: You guessed the secret word correctly.
  提示:
1 <= wordlist.length <= 100
wordlist[i].length == 6
wordlist[i] 只包含小写英文字母
wordlist 中所有字符串都 不同
secret 在 wordlist 中
numguesses == 10",109,,3562,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/game-theory/', 'https://leetcode.cn/tag/interactive/']",[],9218
评论 (858),backspace-string-compare,简单,"给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
  示例 1：
输入：s = ""ab#c"", t = ""ad#c""
输出：true
解释：s 和 t 都会变成 ""ac""。
示例 2：
输入：s = ""ab##"", t = ""c#d#""
输出：true
解释：s 和 t 都会变成 """"。
示例 3：
输入：s = ""a#c"", t = ""b""
输出：false
解释：s 会变成 ""c""，但 t 仍然是 ""b""。
  提示：
1 <= s.length, t.length <= 200
s 和 t 只含有小写字母以及字符 '#'
  进阶：
你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？",431,,135456,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],274658
评论 (384),longest-mountain-in-array,中等,"把符合下列属性的数组 arr 称为 山脉数组 ：
arr.length >= 3
存在下标 i（0 < i < arr.length - 1），满足
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。
  示例 1：
输入：arr = [2,1,4,7,3,2,5]
输出：5
解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。
示例 2：
输入：arr = [2,2,2]
输出：0
解释：不存在山脉子数组。
  提示：
1 <= arr.length <= 104
0 <= arr[i] <= 104
  进阶：
你可以仅用一趟扫描解决此问题吗？
你可以用 O(1) 空间解决此问题吗？",236,,42585,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/enumeration/']",[],100997
评论 (171),shortest-path-visiting-all-nodes,困难,"存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。
给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。
返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。
  示例 1：
输入：graph = [[1,2,3],[0],[0],[0]]
输出：4
解释：一种可能的路径为 [1,0,2,0,3]
示例 2：
输入：graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
输出：4
解释：一种可能的路径为 [0,1,4,2,3]
  提示：
n == graph.length
1 <= n <= 12
0 <= graph[i].length < n
graph[i] 不包含 i
如果 graph[a] 包含 b ，那么 graph[b] 也包含 a
输入的图总是连通图",291,https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg,21585,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],31877
评论,shifting-letters,中等,"有一个由小写字母组成的字符串 s，和一个长度相同的整数数组 shifts。
我们将字母表中的下一个字母称为原字母的 移位 shift() （由于字母表是环绕的， 'z' 将会变成 'a'）。
例如，shift('a') = 'b', shift('t') = 'u', 以及 shift('z') = 'a'。
对于每个 shifts[i] = x ， 我们会将 s 中的前 i + 1 个字母移位 x 次。
返回 将所有这些移位都应用到 s 后最终得到的字符串 。
  示例 1：
输入：s = ""abc"", shifts = [3,5,9]
输出：""rpl""
解释： 
我们以 ""abc"" 开始。
将 S 中的第 1 个字母移位 3 次后，我们得到 ""dbc""。
再将 S 中的前 2 个字母移位 5 次后，我们得到 ""igc""。
最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 ""rpl""。
示例 2:
输入: s = ""aaa"", shifts = [1,2,3]
输出: ""gfd""
  提示:
1 <= s.length <= 105
s 由小写英文字母组成
shifts.length == s.length
0 <= shifts[i] <= 109",62,,11333,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],24905
评论 (260),maximize-distance-to-closest-person,中等,"给你一个数组 seats 表示一排座位，其中 seats[i] = 1 代表有人坐在第 i 个座位上，seats[i] = 0 代表座位 i 上是空的（下标从 0 开始）。
至少有一个空座位，且至少有一人已经坐在座位上。
亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。
返回他到离他最近的人的最大距离。
  示例 1：
输入：seats = [1,0,0,0,1,0,1]
输出：2
解释：
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
因此，他到离他最近的人的最大距离是 2 。 
示例 2：
输入：seats = [1,0,0,0]
输出：3
解释：
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
这是可能的最大距离，所以答案是 3 。
示例 3：
输入：seats = [0,1]
输出：1
  提示：
2 <= seats.length <= 2 * 104
seats[i] 为 0 或 1
至少有一个 空座位
至少有一个 座位上有人",180,https://assets.leetcode.com/uploads/2020/09/10/distance.jpg,18072,['https://leetcode.cn/tag/array/'],['https://leetcode.cn/problems/exam-room/'],41785
评论 (35),rectangle-area-ii,困难,"我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。
计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。
返回 总面积 。因为答案可能太大，返回 109 + 7 的 模 。
  示例 1：
输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
输出：6
解释：如图所示，三个矩形覆盖了总面积为6的区域。
从(1,1)到(2,2)，绿色矩形和红色矩形重叠。
从(1,0)到(2,3)，三个矩形都重叠。
示例 2：
输入：rectangles = [[0,0,1000000000,1000000000]]
输出：49
解释：答案是 1018 对 (109 + 7) 取模的结果， 即 49 。
  提示：
1 <= rectangles.length <= 200
rectanges[i].length = 4
0 <= xi1, yi1, xi2, yi2 <= 109
矩形叠加覆盖后的总面积不会超越 2^63 - 1 ，这意味着可以用一个 64 位有符号整数来保存面积结果。",102,,3187,"['https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/line-sweep/']",[],6987
评论 (348),loud-and-rich,中等,"有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 ""person x ""。
给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。
现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。
  示例 1：
输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
输出：[5,5,2,5,4,5,6,7]
解释： 
answer[0] = 5，
person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
但是目前还不清楚他是否比 person 0 更有钱。
answer[7] = 7，
在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），
最安静（有较低安静值 quiet[x]）的人是 person 7。
其他的答案也可以用类似的推理来解释。
示例 2：
输入：richer = [], quiet = [0]
输出：[0]
  提示：
n == quiet.length
1 <= n <= 500
0 <= quiet[i] < n
quiet 的所有值 互不相同
0 <= richer.length <= n * (n - 1) / 2
0 <= ai, bi < n
ai != bi
richer 中的所有数对 互不相同
对 richer 的观察在逻辑上是一致的",199,,26843,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/array/']",[],42742
评论 (687),peak-index-in-a-mountain-array,简单,"符合下列属性的数组 arr 称为 山脉数组 ：
arr.length >= 3
存在 i（0 < i < arr.length - 1）使得：
arr[0] < arr[1] < ... arr[i-1] < arr[i]
arr[i] > arr[i+1] > ... > arr[arr.length - 1]
给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。
  示例 1：
输入：arr = [0,1,0]
输出：1
示例 2：
输入：arr = [0,2,1,0]
输出：1
示例 3：
输入：arr = [0,10,5,2]
输出：1
示例 4：
输入：arr = [3,4,5,1]
输出：2
示例 5：
输入：arr = [24,69,100,99,79,78,67,36,26,19]
输出：2
  提示：
3 <= arr.length <= 104
0 <= arr[i] <= 106
题目数据保证 arr 是一个山脉数组
  进阶：很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？",260,,106827,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",['https://leetcode.cn/problems/find-peak-element/'],152368
评论 (119),car-fleet,中等,"在一条单行道上，有 n 辆车开往同一目的地。目的地是几英里以外的 target 。
给定两个整数数组 position 和 speed ，长度都是 n ，其中 position[i] 是第 i 辆车的位置， speed[i] 是第 i 辆车的速度(单位是英里/小时)。
一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车 以相同的速度 紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。
车队 是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。
即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。
返回到达目的地的 车队数量 。
  示例 1：
输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
输出：3
解释：
从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。
从 0 处开始的车无法追上其它车，所以它自己就是一个车队。
从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。
请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。
示例 2:
输入: target = 10, position = [3], speed = [3]
输出: 1
解释: 只有一辆车，因此只有一个车队。
示例 3:
输入: target = 100, position = [0,2,4], speed = [4,2,1]
输出: 1
解释:
以0(速度4)和2(速度2)出发的车辆组成车队，在4点相遇。舰队以2的速度前进。
然后，车队(速度2)和以4(速度1)出发的汽车组成一个车队，在6点相遇。舰队以1的速度前进，直到到达目标。
  提示：
n == position.length == speed.length
1 <= n <= 105
0 < target <= 106
0 <= position[i] < target
position 中每个值都 不同
0 < speed[i] <= 106",141,,13043,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/monotonic-stack/']",[],32892
评论 (59),k-similar-strings,困难,"字符串 s1 和 s2 是 k 相似 的(对于某些非负整数 k )，如果我们可以交换 s1 中两个字母的位置正好 k 次，使结果字符串等于 s2 。
给定两个字谜游戏 s1 和 s2 ，返回 s1 和 s2 与 k 相似 的最小 k 。
  示例 1：
输入：s1 = ""ab"", s2 = ""ba""
输出：1
示例 2：
输入：s1 = ""abc"", s2 = ""bca""
输出：2
  提示：
1 <= s1.length <= 20
s2.length == s1.length
s1 和 s2  只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母
s2 是 s1 的一个字谜",118,,4966,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/couples-holding-hands/'],13645
评论 (68),exam-room,中等,"在考场里，一排有 N 个座位，分别编号为 0, 1, 2, ..., N-1 。
当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)
返回 ExamRoom(int N) 类，它有两个公开的函数：其中，函数 ExamRoom.seat() 会返回一个 int （整型数据），代表学生坐的位置；函数 ExamRoom.leave(int p) 代表坐在座位 p 上的学生现在离开了考场。每次调用 ExamRoom.leave(p) 时都保证有学生坐在座位 p 上。
  示例：
输入：[""ExamRoom"",""seat"",""seat"",""seat"",""seat"",""leave"",""seat""], [[10],[],[],[],[],[4],[]]
输出：[null,0,9,4,2,null,5]
解释：
ExamRoom(10) -> null
seat() -> 0，没有人在考场里，那么学生坐在 0 号座位上。
seat() -> 9，学生最后坐在 9 号座位上。
seat() -> 4，学生最后坐在 4 号座位上。
seat() -> 2，学生最后坐在 2 号座位上。
leave(4) -> null
seat() -> 5，学生最后坐在 5 号座位上。
  提示：
1 <= N <= 10^9
在所有的测试样例中 ExamRoom.seat() 和 ExamRoom.leave() 最多被调用 10^4 次。
保证在调用 ExamRoom.leave(p) 时有学生正坐在座位 p 上。",121,,7188,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/ordered-set/']",['https://leetcode.cn/problems/maximize-distance-to-closest-person/'],17445
评论 (175),score-of-parentheses,中等,"给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：
() 得 1 分。
AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。
(A) 得 2 * A 分，其中 A 是平衡括号字符串。
  示例 1：
输入： ""()""
输出： 1
示例 2：
输入： ""(())""
输出： 2
示例 3：
输入： ""()()""
输出： 2
示例 4：
输入： ""(()(()))""
输出： 6
  提示：
S 是平衡括号字符串，且只含有 ( 和 ) 。
2 <= S.length <= 50",284,,19369,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],30664
评论 (42),minimum-cost-to-hire-k-workers,困难,"有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。
现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：
对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。
工资组中的每名工人至少应当得到他们的最低期望工资。
给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。。
  示例 1：
输入： quality = [10,20,5], wage = [70,50,30], k = 2
输出： 105.00000
解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。
示例 2：
输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
输出： 30.66667
解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。
  提示：
n == quality.length == wage.length
1 <= k <= n <= 104
1 <= quality[i], wage[i] <= 104",139,,3758,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],7848
评论 (55),mirror-reflection,中等,"有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为 0， 1，以及 2。
正方形房间的墙壁长度为 p，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器 0 的距离为 q 。
返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。
  示例：
输入： p = 2, q = 1
输出： 2
解释： 这条光线在第一次被反射回左边的墙时就遇到了接收器 2 。
  提示：
1 <= p <= 1000
0 <= q <= p",68,,3535,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/math/']",[],6289
评论 (593),buddy-strings,简单,"给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。
交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j ，接着交换 s[i] 和 s[j] 处的字符。
例如，在 ""abcd"" 中交换下标 0 和下标 2 的元素可以生成 ""cbad"" 。
  示例 1：
输入：s = ""ab"", goal = ""ba""
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 ""ba""，此时 s 和 goal 相等。
示例 2：
输入：s = ""ab"", goal = ""ab""
输出：false
解释：你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 ""ba""，此时 s 和 goal 不相等。
示例 3：
输入：s = ""aa"", goal = ""aa""
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 ""aa""，此时 s 和 goal 相等。
  提示：
1 <= s.length, goal.length <= 2 * 104
s 和 goal 由小写英文字母组成",256,,62394,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],180618
评论 (712),lemonade-change,简单,"在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
注意，一开始你手头没有任何零钱。
给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
  示例 1：
输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
示例 2：
输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
  提示：
1 <= bills.length <= 105
bills[i] 不是 5 就是 10 或是 20 ",323,,120845,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],206393
评论 (359),score-after-flipping-matrix,中等,"有一个二维矩阵 A 其中每个元素的值为 0 或 1 。
移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。
在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。
返回尽可能高的分数。
  示例：
输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
  提示：
1 <= A.length <= 20
1 <= A[0].length <= 20
A[i][j] 是 0 或 1",218,,33349,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],41312
评论 (242),shortest-subarray-with-sum-at-least-k,困难,"给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。
子数组 是数组中 连续 的一部分。
  示例 1：
输入：nums = [1], k = 1
输出：1
示例 2：
输入：nums = [1,2], k = 4
输出：-1
示例 3：
输入：nums = [2,-1,2], k = 3
输出：3
  提示：
1 <= nums.length <= 105
-105 <= nums[i] <= 105
1 <= k <= 109",396,,22040,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/monotonic-queue/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],104588
评论 (434),all-nodes-distance-k-in-binary-tree,中等,"给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 k 。
返回到目标结点 target 距离为 k 的所有结点的值的列表。 答案可以以 任何顺序 返回。
  示例 1：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
输出：[7,4,1]
解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1
示例 2:
输入: root = [1], target = 1, k = 3
输出: []
  提示:
节点数在 [1, 500] 范围内
0 <= Node.val <= 500
Node.val 中所有值 不同
目标结点 target 是树上的结点。
0 <= k <= 1000
 ",540,,42834,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],70179
评论 (59),shortest-path-to-get-all-keys,困难,"给定一个二维网格 grid ，其中：
'.' 代表一个空房间
'#' 代表一堵
'@' 是起点
小写字母代表钥匙
大写字母代表锁
我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。
假设 k 为 钥匙/锁 的个数，且满足 1 <= k <= 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。
返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。
  示例 1：
输入：grid = [""@.a.#"",""###.#"",""b.A.B""]
输出：8
解释：目标是获得所有钥匙，而不是打开所有锁。
示例 2：
输入：grid = [""@..aA"",""..B#."",""....b""]
输出：6
示例 3:
输入: grid = [""@Aa""]
输出: -1
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 30
grid[i][j] 只含有 '.', '#', '@', 'a'-'f' 以及 'A'-'F'
钥匙的数目范围是 [1, 6] 
每个钥匙都对应一个 不同 的字母
每个钥匙正好打开一个对应的锁",105,https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg,3905,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/breadth-first-search/']",[],8234
评论 (138),smallest-subtree-with-all-the-deepest-nodes,中等,"给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。
返回包含原始树中所有 最深节点 的 最小子树 。
如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。
一个节点的 子树 是该节点加上它的所有后代的集合。
  示例 1：
输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：
我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。
示例 2：
输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点。
示例 3：
输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。
  提示：
树中节点的数量在 [1, 500] 范围内。
0 <= Node.val <= 500
每个节点的值都是 独一无二 的。
  注意：本题与力扣 1123 重复：https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves",163,,11613,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-tree/']",[],17231
评论 (90),prime-palindrome,中等,"求出大于或等于 N 的最小回文素数。
回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是素数。
例如，2，3，5，7，11 以及 13 是素数。
回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是回文数。
例如，12321 是回文数。
  示例 1：
输入：6
输出：7
示例 2：
输入：8
输出：11
示例 3：
输入：13
输出：101
  提示：
1 <= N <= 10^8
答案肯定存在，且小于 2 * 10^8。
   ",79,,9092,['https://leetcode.cn/tag/math/'],[],39231
评论 (589),transpose-matrix,简单,"给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。
矩阵的 转置 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。
  示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]
示例 2：
输入：matrix = [[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 1000
1 <= m * n <= 105
-109 <= matrix[i][j] <= 109",223,,90095,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],135020
评论 (513),binary-gap,简单,"给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。
如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，""1001"" 中的两个 1 的距离为 3 。
  示例 1：
输入：n = 22
输出：2
解释：22 的二进制是 ""10110"" 。
在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
第一对相邻的 1 中，两个 1 之间的距离为 2 。
第二对相邻的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。
示例 2：
输入：n = 8
输出：0
解释：8 的二进制是 ""1000"" 。
在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。
示例 3：
输入：n = 5
输出：2
解释：5 的二进制是 ""101"" 。
  提示：
1 <= n <= 109",131,,47632,['https://leetcode.cn/tag/bit-manipulation/'],[],68498
评论 (408),reordered-power-of-2,中等,"给定正整数 n ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。
如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。
  示例 1：
输入：n = 1
输出：true
示例 2：
输入：n = 10
输出：false
  提示：
1 <= n <= 109",148,,34079,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/enumeration/', 'https://leetcode.cn/tag/sorting/']",[],53231
评论 (225),advantage-shuffle,中等,"给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums 的优势可以用满足 nums1[i] > nums2[i] 的索引 i 的数目来描述。
返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。
  示例 1：
输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]
输出：[2,11,7,15]
示例 2：
输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]
输出：[24,32,8,12]
  提示：
1 <= nums1.length <= 105
nums2.length == nums1.length
0 <= nums1[i], nums2[i] <= 109",186,,-1,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],-1
评论 (112),minimum-number-of-refueling-stops,困难,"汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。
沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。
假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。
当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。
为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。
注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。
  示例 1：
输入：target = 1, startFuel = 1, stations = []
输出：0
解释：我们可以在不加油的情况下到达目的地。
示例 2：
输入：target = 100, startFuel = 1, stations = [[10,100]]
输出：-1
解释：我们无法抵达目的地，甚至无法到达第一个加油站。
示例 3：
输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
输出：2
解释：
我们出发时有 10 升燃料。
我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。
然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），
并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。
我们沿途在1两个加油站停靠，所以返回 2 。
  提示：
1 <= target, startFuel, stations[i][1] <= 10^9
0 <= stations.length <= 500
0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target",220,,12311,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],34526
评论 (586),leaf-similar-trees,简单,"请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。
举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。
如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。
如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。
  示例 1：
输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
输出：true
示例 2：
输入：root1 = [1,2,3], root2 = [1,3,2]
输出：false
  提示：
给定的两棵树结点数在 [1, 200] 范围内
给定的两棵树上的值在 [0, 200] 范围内",186,,65400,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],100433
评论 (129),length-of-longest-fibonacci-subsequence,中等,"如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：
n >= 3
对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}
给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。
（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）
  示例 1：
输入: arr = [1,2,3,4,5,6,7,8]
输出: 5
解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。
示例 2：
输入: arr = [1,3,7,11,12,14,18]
输出: 3
解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。
  提示：
3 <= arr.length <= 1000
1 <= arr[i] < arr[i + 1] <= 10^9",229,,20512,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/fibonacci-number/'],38827
评论 (285),walking-robot-simulation,中等,"机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：
-2 ：向左转 90 度
-1 ：向右转 90 度
1 <= x <= 9 ：向前移动 x 个单位长度
在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] = (xi, yi) 。
机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。
返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）
  注意：
北表示 +Y 方向。
东表示 +X 方向。
南表示 -Y 方向。
西表示 -X 方向。
  示例 1：
输入：commands = [4,-1,3], obstacles = []
输出：25
解释：
机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 3 个单位，到达 (3, 4)
距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25
示例 2：
输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出：65
解释：机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)
4. 左转
5. 向北走 4 个单位，到达 (1, 8)
距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65
  提示：
1 <= commands.length <= 104
commands[i] is one of the values in the list [-2,-1,1,2,3,4,5,6,7,8,9].
0 <= obstacles.length <= 104
-3 * 104 <= xi, yi <= 3 * 104
答案保证小于 231",164,,23439,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],55481
评论 (314),koko-eating-bananas,中等,"珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。
珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  
珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。
  示例 1：
输入：piles = [3,6,7,11], h = 8
输出：4
示例 2：
输入：piles = [30,11,23,4,20], h = 5
输出：30
示例 3：
输入：piles = [30,11,23,4,20], h = 6
输出：23
  提示：
1 <= piles.length <= 104
piles.length <= h <= 109
1 <= piles[i] <= 109",302,,70694,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",['https://leetcode.cn/problems/minimize-max-distance-to-gas-station/'],143972
评论 (1.1k),middle-of-the-linked-list,简单,"给定一个头结点为 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
  示例 1：
输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：
输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
  提示：
给定链表的结点数介于 1 和 100 之间。",573,,251117,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],355321
评论 (686),stone-game,中等,"Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。
游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。
Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。
假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。
  示例 1：
输入：piles = [5,3,4,5]
输出：true
解释：
Alice 先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。
如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。
示例 2：
输入：piles = [3,7,2,3]
输出：true
  提示：
2 <= piles.length <= 500
piles.length 是 偶数
1 <= piles[i] <= 500
sum(piles[i]) 是 奇数",428,,79966,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",[],105080
评论 (47),nth-magical-number,困难,"一个正整数如果能被 a 或 b 整除，那么它是神奇的。
给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。
  示例 1：
输入：n = 1, a = 2, b = 3
输出：2
示例 2：
输入：n = 4, a = 2, b = 3
输出：6
  提示：
1 <= n <= 109
2 <= a, b <= 4 * 104
 ",100,,5366,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],18266
评论 (245),profitable-schemes,困难,"集团里有 n 名员工，他们可以完成各种各样的工作创造利润。
第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。
工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。
有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。
  示例 1：
输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
输出：2
解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。
示例 2：
输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
输出：7
解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。
  提示：
1 <= n <= 100
0 <= minProfit <= 100
1 <= group.length <= 100
1 <= group[i] <= 100
profit.length == group.length
0 <= profit[i] <= 100",243,,24154,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],43663
评论 (75),decoded-string-at-index,中等,"给定一个编码字符串 S。请你找出 解码字符串 并将其写入磁带。解码时，从编码字符串中 每次读取一个字符 ，并采取以下步骤：
如果所读的字符是字母，则将该字母写在磁带上。
如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。
现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。
  示例 1：
输入：S = ""leet2code3"", K = 10
输出：""o""
解释：
解码后的字符串为 ""leetleetcodeleetleetcodeleetleetcode""。
字符串中的第 10 个字母是 ""o""。
示例 2：
输入：S = ""ha22"", K = 5
输出：""h""
解释：
解码后的字符串为 ""hahahaha""。第 5 个字母是 ""h""。
示例 3：
输入：S = ""a2345678999999999999999"", K = 1
输出：""a""
解释：
解码后的字符串为 ""a"" 重复 8301530446056247680 次。第 1 个字母是 ""a""。
  提示：
2 <= S.length <= 100
S 只包含小写字母与数字 2 到 9 。
S 以字母开头。
1 <= K <= 10^9
题目保证 K 小于或等于解码字符串的长度。
解码后的字符串保证少于 2^63 个字母。",167,,7053,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],27149
评论 (462),boats-to-save-people,中等,"给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。
每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。
返回 承载所有人所需的最小船数 。
  示例 1：
输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)
示例 2：
输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)
示例 3：
输入：people = [3,5,3,4], limit = 5
输出：4
解释：4 艘船分别载 (3), (3), (4), (5)
  提示：
1 <= people.length <= 5 * 104
1 <= people[i] <= limit <= 3 * 104",232,,57088,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],106043
评论 (29),reachable-nodes-in-subdivided-graph,困难,"给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。
图用由边组成的二维数组 edges 表示，其中 edges[i] = [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。
要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, ..., xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], ..., [xcnti+1, xcnti], [xcnti, vi] 。
现在得到一个 新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。
给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数 。
  示例 1：
输入：edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
输出：13
解释：边的细分情况如上图所示。
可以到达的节点已经用黄色标注出来。
示例 2：
输入：edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
输出：23
示例 3：
输入：edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
输出：1
解释：节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。
  提示：
0 <= edges.length <= min(n * (n - 1) / 2, 104)
edges[i].length == 3
0 <= ui < vi < n
图中 不存在平行边
0 <= cnti <= 104
0 <= maxMoves <= 109
1 <= n <= 3000",56,https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png,2665,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/shortest-path/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],5344
评论 (529),projection-area-of-3d-shapes,简单,"在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。
每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。
现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。
投影 就像影子，将 三维 形体映射到一个 二维 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。
返回 所有三个投影的总面积 。
  示例 1：
输入：[[1,2],[3,4]]
输出：17
解释：这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。
示例 2:
输入：grid = [[2]]
输出：5
示例 3：
输入：[[1,0],[0,2]]
输出：8
  提示：
n == grid.length == grid[i].length
1 <= n <= 50
0 <= grid[i][j] <= 50",139,,42073,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/matrix/']",[],54908
评论 (387),uncommon-words-from-two-sentences,简单,"句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。
如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。
给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。
  示例 1：
输入：s1 = ""this apple is sweet"", s2 = ""this apple is sour""
输出：[""sweet"",""sour""]
示例 2：
输入：s1 = ""apple apple"", s2 = ""banana""
输出：[""banana""]
  提示：
1 <= s1.length, s2.length <= 200
s1 和 s2 由小写英文字母和空格组成
s1 和 s2 都不含前导或尾随空格
s1 和 s2 中的所有单词间均由单个空格分隔",159,,43101,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],59908
评论 (69),spiral-matrix-iii,中等,"在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始
这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。
现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。
每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。
最终，我们到过网格的所有 R * C 个空间。
按照访问顺序返回表示网格位置的坐标列表。
  示例 1：
输入：R = 1, C = 4, r0 = 0, c0 = 0
输出：[[0,0],[0,1],[0,2],[0,3]]
  示例 2：
输入：R = 5, C = 6, r0 = 1, c0 = 4
输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
  提示：
1 <= R <= 100
1 <= C <= 100
0 <= r0 < R
0 <= c0 < C",76,,6052,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],8651
评论 (141),possible-bipartition,中等,"给定一组 n 人（编号为 1, 2, ..., n）， 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。
给定整数 n 和数组 dislikes ，其中 dislikes[i] = [ai, bi] ，表示不允许将编号为 ai 和  bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。
  示例 1：
输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]
输出：true
解释：group1 [1,4], group2 [2,3]
示例 2：
输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]
输出：false
示例 3：
输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
输出：false
  提示：
1 <= n <= 2000
0 <= dislikes.length <= 104
dislikes[i].length == 2
1 <= dislikes[i][j] <= n
ai < bi
dislikes 中每一组都 不同
 ",171,,16252,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']",[],33789
评论 (679),super-egg-drop,困难,"给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
  示例 1：
输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
示例 2：
输入：k = 2, n = 6
输出：3
示例 3：
输入：k = 3, n = 14
输出：4
  提示：
1 <= k <= 100
1 <= n <= 104",816,,63684,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],214144
评论 (501),fair-candy-swap,简单,"爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 aliceSizes 和 bobSizes ，aliceSizes[i] 是爱丽丝拥有的第 i 盒糖果中的糖果数量，bobSizes[j] 是鲍勃拥有的第 j 盒糖果中的糖果数量。
两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。
返回一个整数数组 answer，其中 answer[0] 是爱丽丝必须交换的糖果盒中的糖果的数目，answer[1] 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 任何一个 。题目测试用例保证存在与输入对应的答案。
  示例 1：
输入：aliceSizes = [1,1], bobSizes = [2,2]
输出：[1,2]
示例 2：
输入：aliceSizes = [1,2], bobSizes = [2,3]
输出：[1,2]
示例 3：
输入：aliceSizes = [2], bobSizes = [1,3]
输出：[2,3]
示例 4：
输入：aliceSizes = [1,2,5], bobSizes = [2,4]
输出：[5,4]
  提示：
1 <= aliceSizes.length, bobSizes.length <= 104
1 <= aliceSizes[i], bobSizes[j] <= 105
爱丽丝和鲍勃的糖果总数量不同。
题目数据保证对于给定的输入至少存在一个有效答案。",196,,60319,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],94266
评论 (162),construct-binary-tree-from-preorder-and-postorder-traversal,中等,"给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。
如果存在多个答案，您可以返回其中 任何 一个。
  示例 1：
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
示例 2:
输入: preorder = [1], postorder = [1]
输出: [1]
  提示：
1 <= preorder.length <= 30
1 <= preorder[i] <= preorder.length
preorder 中所有值都 不同
postorder.length == preorder.length
1 <= postorder[i] <= postorder.length
postorder 中所有值都 不同
保证 preorder 和 postorder 是同一棵二叉树的前序遍历和后序遍历",252,,24954,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/binary-tree/']",[],36838
评论 (146),find-and-replace-pattern,中等,"你有一个单词列表 words 和一个模式  pattern，你想知道 words 中的哪些单词与模式匹配。
如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。
（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）
返回 words 中与给定模式匹配的单词列表。
你可以按任何顺序返回答案。
  示例：
输入：words = [""abc"",""deq"",""mee"",""aqq"",""dkd"",""ccc""], pattern = ""abb""
输出：[""mee"",""aqq""]
解释：
""mee"" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。
""ccc"" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。
因为 a 和 b 映射到同一个字母。
  提示：
1 <= words.length <= 50
1 <= pattern.length = words[i].length <= 20",126,,10109,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],13816
评论 (31),sum-of-subsequence-widths,困难,"一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。
给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。
子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。
  示例 1：
输入：nums = [2,1,3]
输出：6
解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。
相应的宽度是 0, 0, 0, 1, 1, 2, 2 。
宽度之和是 6 。
示例 2：
输入：nums = [2]
输出：0
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 105",55,,3401,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",[],9901
评论 (642),surface-area-of-3d-shapes,简单,"给你一个 n * n 的网格 grid ，上面放置着一些 1 x 1 x 1 的正方体。每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。
放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。
请你返回最终这些形体的总表面积。
注意：每个形体的底面也需要计入表面积中。
  示例 1：
输入：grid = [[1,2],[3,4]]
输出：34
示例 2：
输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
输出：32
示例 3：
输入：grid = [[2,2,2],[2,1,2],[2,2,2]]
输出：46
  提示：
n == grid.length
n == grid[i].length
1 <= n <= 50
0 <= grid[i][j] <= 50",160,https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg,35277,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/matrix/']",[],55201
评论 (216),groups-of-special-equivalent-strings,中等,"给你一个字符串数组 words。
一步操作中，你可以交换字符串 words[i] 的任意两个偶数下标对应的字符或任意两个奇数下标对应的字符。
对两个字符串 words[i] 和 words[j] 而言，如果经过任意次数的操作，words[i] == words[j] ，那么这两个字符串是 特殊等价 的。
例如，words[i] = ""zzxy"" 和 words[j] = ""xyzz"" 是一对 特殊等价 字符串，因为可以按 ""zzxy"" -> ""xzzy"" -> ""xyzz"" 的操作路径使 words[i] == words[j] 。
现在规定，words 的 一组特殊等价字符串 就是 words 的一个同时满足下述条件的非空子集：
该组中的每一对字符串都是 特殊等价 的
该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 不会 与该组内任何字符串特殊等价）
返回 words 中 特殊等价字符串组 的数量。
  示例 1：
输入：words = [""abcd"",""cdab"",""cbad"",""xyzz"",""zzxy"",""zzyx""]
输出：3
解释：
其中一组为 [""abcd"", ""cdab"", ""cbad""]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。
另外两组分别是 [""xyzz"", ""zzxy""] 和 [""zzyx""]。特别需要注意的是，""zzxy"" 不与 ""zzyx"" 特殊等价。
示例 2：
输入：words = [""abc"",""acb"",""bac"",""bca"",""cab"",""cba""]
输出：3
解释：3 组 [""abc"",""cba""]，[""acb"",""bca""]，[""bac"",""cab""]
  提示：
1 <= words.length <= 1000
1 <= words[i].length <= 20
所有 words[i] 都只由小写字母组成。
所有 words[i] 都具有相同的长度。",110,,11628,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],15998
评论 (129),all-possible-full-binary-trees,中等,"满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。
返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。
答案中每个树的每个结点都必须有 node.val=0。
你可以按任何顺序返回树的最终列表。
  示例：
输入：7
输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
解释：
  提示：
1 <= N <= 20",257,,15717,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",[],20236
评论 (93),maximum-frequency-stack,困难,"设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。
实现 FreqStack 类:
FreqStack() 构造一个空的堆栈。
void push(int val) 将一个整数 val 压入栈顶。
int pop() 删除并返回堆栈中出现频率最高的元素。
如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。
  示例 1：
输入：
[""FreqStack"",""push"",""push"",""push"",""push"",""push"",""push"",""pop"",""pop"",""pop"",""pop""],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
输出：[null,null,null,null,null,null,null,5,7,5,4]
解释：
FreqStack = new FreqStack();
freqStack.push (5);//堆栈为 [5]
freqStack.push (7);//堆栈是 [5,7]
freqStack.push (5);//堆栈是 [5,7,5]
freqStack.push (7);//堆栈是 [5,7,5,7]
freqStack.push (4);//堆栈是 [5,7,5,7,4]
freqStack.push (5);//堆栈是 [5,7,5,7,4,5]
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。
freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。
freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。
  提示：
0 <= val <= 109
push 和 pop 的操作数不大于 2 * 104。
输入保证在调用 pop 之前堆栈中至少有一个元素。",234,,11545,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/ordered-set/']",[],19703
评论 (657),monotonic-array,简单,"如果数组是单调递增或单调递减的，那么它是 单调 的。
如果对于所有 i <= j，nums[i] <= nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i <= j，nums[i]> = nums[j]，那么数组 nums 是单调递减的。
当给定的数组 nums 是单调数组时返回 true，否则返回 false。
  示例 1：
输入：nums = [1,2,2,3]
输出：true
示例 2：
输入：nums = [6,5,4,4]
输出：true
示例 3：
输入：nums = [1,3,2]
输出：false
  提示：
1 <= nums.length <= 105
-105 <= nums[i] <= 105",163,,69032,['https://leetcode.cn/tag/array/'],[],119229
评论 (501),increasing-order-search-tree,简单,"给你一棵二叉搜索树的 root ，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。
  示例 1：
输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
示例 2：
输入：root = [5,1,7]
输出：[1,null,5,null,7]
  提示：
树中节点数的取值范围是 [1, 100]
0 <= Node.val <= 1000",279,https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg,69655,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",[],93941
评论 (56),bitwise-ors-of-subarrays,中等,"我们有一个非负整数数组 arr 。
对于每个（连续的）子数组 sub = [arr[i], arr[i + 1], ..., arr[j]] （ i <= j），我们对 sub 中的每个元素进行按位或操作，获得结果 arr[i] | arr[i + 1] | ... | arr[j] 。
返回可能结果的数量。 多次出现的结果在最终答案中仅计算一次。
  示例 1：
输入：arr = [0]
输出：1
解释：
只有一个可能的结果 0 。
示例 2：
输入：arr = [1,1,2]
输出：3
解释：
可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。
产生的结果为 1，1，2，1，3，3 。
有三个唯一值，所以答案是 3 。
示例 3：
输入：arr = [1,2,4]
输出：6
解释：
可能的结果是 1，2，3，4，6，以及 7 。
  提示：
1 <= nums.length <= 5 * 104
0 <= nums[i] <= 109",112,,6564,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],18428
评论 (49),orderly-queue,困难,"给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。
返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串 。
  示例 1：
输入：s = ""cba"", k = 1
输出：""acb""
解释：
在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
示例 2：
输入：s = ""baaca"", k = 3
输出：""aaabc""
解释：
在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。
  提示：
1 <= k <= S.length <= 1000
s 只由小写字母组成。",60,,5266,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],9703
评论 (53),rle-iterator,中等,"我们可以使用游程编码(即 RLE )来编码一个整数序列。在偶数长度 encoding ( 从 0 开始 )的游程编码数组中，对于所有偶数 i ，encoding[i] 告诉我们非负整数 encoding[i + 1] 在序列中重复的次数。
例如，序列 arr = [8,8,8,5,5] 可以被编码为 encoding =[3,8,2,5] 。encoding =[3,8,0,9,2,5] 和 encoding =[2,8,1,8,2,5] 也是 arr 有效的 RLE 。
给定一个游程长度的编码数组，设计一个迭代器来遍历它。
实现 RLEIterator 类:
RLEIterator(int[] encoded) 用编码后的数组初始化对象。
int next(int n) 以这种方式耗尽后 n 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 -1 。
  示例 1：
输入：
[""RLEIterator"",""next"",""next"",""next"",""next""]
[[[3,8,0,9,2,5]],[2],[1],[1],[2]]
输出：
[null,8,8,5,-1]
解释：
RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // 这映射到序列 [8,8,8,5,5]。
rLEIterator.next(2); // 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。
rLEIterator.next(1); // 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。
rLEIterator.next(1); // 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。
rLEIterator.next(2); // 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，
但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。
  提示：
2 <= encoding.length <= 1000
encoding.length 为偶
0 <= encoding[i] <= 109
1 <= n <= 109
每个测试用例调用next 不高于 1000 次 ",45,,4259,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/iterator/']",[],8408
评论 (218),online-stock-span,中等,"编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。
今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。
例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。
  示例：
输入：[""StockSpanner"",""next"",""next"",""next"",""next"",""next"",""next"",""next""], [[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。

注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
  提示：
调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5。
每个测试用例最多可以调用  10000 次 StockSpanner.next。
在所有测试用例中，最多调用 150000 次 StockSpanner.next。
此问题的总时间限制减少了 50%。",175,,24756,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/data-stream/', 'https://leetcode.cn/tag/monotonic-stack/']",[],44308
评论 (60),numbers-at-most-n-given-digit-set,困难,"给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = ['1','3','5']，我们可以写数字，如 '13', '551', 和 '1351315'。
返回 可以生成的小于或等于给定整数 n 的正整数的个数 。
  示例 1：
输入：digits = [""1"",""3"",""5"",""7""], n = 100
输出：20
解释：
可写出的 20 个数字是：
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.
示例 2：
输入：digits = [""1"",""4"",""9""], n = 1000000000
输出：29523
解释：
我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，
81 个四位数字，243 个五位数字，729 个六位数字，
2187 个七位数字，6561 个八位数字和 19683 个九位数字。
总共，可以使用D中的数字写出 29523 个整数。
示例 3:
输入：digits = [""7""], n = 8
输出：1
  提示：
1 <= digits.length <= 9
digits[i].length == 1
digits[i] 是从 '1' 到 '9' 的数
digits 中的所有值都 不同 
digits 按 非递减顺序 排列
1 <= n <= 109",93,,4762,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],13071
评论 (39),valid-permutations-for-di-sequence,困难,"给定一个长度为 n 的字符串 s ，其中 s[i] 是:
“D” 意味着减少，或者
“I” 意味着增加
有效排列 是对有 n + 1 个在 [0, n]  范围内的整数的一个排列 perm ，使得对所有的 i：
如果 s[i] == 'D'，那么 perm[i] > perm[i+1]，以及；
如果 s[i] == 'I'，那么 perm[i] < perm[i+1]。
返回 有效排列  perm的数量 。因为答案可能很大，所以请返回你的答案对 109 + 7 取余。
  示例 1：
输入：s = ""DID""
输出：5
解释：
(0, 1, 2, 3) 的五个有效排列是：
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)
示例 2:
输入: s = ""D""
输出: 1
  提示:
n == s.length
1 <= n <= 200
s[i] 不是 'I' 就是 'D'",113,,3324,['https://leetcode.cn/tag/dynamic-programming/'],[],6057
评论 (404),fruit-into-baskets,中等,"你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。
你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。
  示例 1：
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
示例 2：
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
示例 3：
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
示例 4：
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
  提示：
1 <= fruits.length <= 105
0 <= fruits[i] < fruits.length",212,,48632,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sliding-window/']",[],110855
评论 (1.1k),sort-array-by-parity,简单,"给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。
返回满足此条件的 任一数组 作为答案。
  示例 1：
输入：nums = [3,1,2,4]
输出：[2,4,3,1]
解释：[4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。
示例 2：
输入：nums = [0]
输出：[0]
  提示：
1 <= nums.length <= 5000
0 <= nums[i] <= 5000",316,,106318,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],149139
评论 (57),super-palindromes,困难,"如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。
现在，给定两个正整数 L 和 R （以字符串形式表示），返回包含在范围 [L, R] 中的超级回文数的数目。
  示例：
输入：L = ""4"", R = ""1000""
输出：4
解释：
4，9，121，以及 484 是超级回文数。
注意 676 不是一个超级回文数： 26 * 26 = 676，但是 26 不是回文数。
  提示：
1 <= len(L) <= 18
1 <= len(R) <= 18
L 和 R 是表示 [1, 10^18) 范围的整数的字符串。
int(L) <= int(R)
 ",40,,2861,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/']",[],9626
评论 (176),sum-of-subarray-minimums,中等,"给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。
由于答案可能很大，因此 返回答案模 10^9 + 7 。
  示例 1：
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
示例 2：
输入：arr = [11,81,94,43,3]
输出：444
  提示：
1 <= arr.length <= 3 * 104
1 <= arr[i] <= 3 * 104
 ",361,,16652,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/monotonic-stack/']",[],49493
评论 (567),smallest-range-i,简单,"给你一个整数数组 nums，和一个整数 k 。
在一个操作中，您可以选择 0 <= i < nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。
nums 的 分数 是 nums 中最大和最小元素的差值。 
在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。
  示例 1：
输入：nums = [1], k = 0
输出：0
解释：分数是 max(nums) - min(nums) = 1 - 1 = 0。
示例 2：
输入：nums = [0,10], k = 2
输出：6
解释：将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。
示例 3：
输入：nums = [1,3,6], k = 3
输出：0
解释：将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。
  提示：
1 <= nums.length <= 104
0 <= nums[i] <= 104
0 <= k <= 104",162,,49873,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],67093
评论 (348),snakes-and-ladders,中等,"给你一个大小为 n x n 的整数矩阵 board ，方格按从 1 到 n2 编号，编号遵循 转行交替方式 ，从左下角开始 （即，从 board[n - 1][0] 开始）每一行交替方向。
玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。
每一回合，玩家需要从当前方格 curr 开始出发，按下述要求前进：
选定目标方格 next ，目标方格的编号符合范围 [curr + 1, min(curr + 6, n2)] 。
该选择模拟了掷 六面体骰子 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。
传送玩家：如果目标方格 next 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 next 。 
当玩家到达编号 n2 的方格时，游戏结束。
r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。编号为 1 和 n2 的方格上没有蛇或梯子。
注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 不能 继续移动。
举个例子，假设棋盘是 [[-1,4],[-1,3]] ，第一次移动，玩家的目标方格是 2 。那么这个玩家将会顺着梯子到达方格 3 ，但 不能 顺着方格 3 上的梯子前往方格 4 。
返回达到编号为 n2 的方格所需的最少移动次数，如果不可能，则返回 -1。
  示例 1：
输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
输出：4
解释：
首先，从方格 1 [第 5 行，第 0 列] 开始。 
先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。
然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。
接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 
最后决定移动到方格 36 , 游戏结束。 
可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 
示例 2：
输入：board = [[-1,-1],[-1,3]]
输出：1
  提示：
n == board.length == board[i].length
2 <= n <= 20
grid[i][j] 的值是 -1 或在范围 [1, n2] 内
编号为 1 和 n2 的方格上没有蛇或梯子",92,https://assets.leetcode.com/uploads/2018/09/23/snakes.png,17380,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],38104
评论 (67),smallest-range-ii,中等,"给你一个整数数组 nums，和一个整数 k 。
对于每个下标 i（0 <= i < nums.length），将 nums[i] 变成 nums[i] + k 或 nums[i] - k 。
nums 的 分数 是 nums 中最大元素和最小元素的差值。
在更改每个下标对应的值之后，返回 nums 的最小 分数 。
  示例 1：
输入：nums = [1], k = 0
输出：0
解释：分数 = max(nums) - min(nums) = 1 - 1 = 0 。
示例 2：
输入：nums = [0,10], k = 2
输出：6
解释：将数组变为 [2, 8] 。分数 = max(nums) - min(nums) = 8 - 2 = 6 。
示例 3：
输入：nums = [1,3,6], k = 3
输出：3
解释：将数组变为 [4, 6, 3] 。分数 = max(nums) - min(nums) = 6 - 3 = 3 。
  提示：
1 <= nums.length <= 104
0 <= nums[i] <= 104
0 <= k <= 104",136,,8639,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",[],25671
评论 (355),online-election,中等,"给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。
对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。
在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。
实现 TopVotedCandidate 类：
TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。
int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。
  示例：
输入：
[""TopVotedCandidate"", ""q"", ""q"", ""q"", ""q"", ""q"", ""q""]
[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]
输出：
[null, 0, 1, 1, 0, 0, 1]

解释：
TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);
topVotedCandidate.q(3); // 返回 0 ，在时刻 3 ，票数分布为 [0] ，编号为 0 的候选人领先。
topVotedCandidate.q(12); // 返回 1 ，在时刻 12 ，票数分布为 [0,1,1] ，编号为 1 的候选人领先。
topVotedCandidate.q(25); // 返回 1 ，在时刻 25 ，票数分布为 [0,1,1,0,0,1] ，编号为 1 的候选人领先。（在平局的情况下，1 是最近获得投票的候选人）。
topVotedCandidate.q(15); // 返回 0
topVotedCandidate.q(24); // 返回 0
topVotedCandidate.q(8); // 返回 1
  提示：
1 <= persons.length <= 5000
times.length == persons.length
0 <= persons[i] < persons.length
0 <= times[i] <= 109
times 是一个严格递增的有序数组
times[0] <= t <= 109
每个测试用例最多调用 104 次 q",145,,28149,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/']",[],52198
评论 (925),sort-an-array,中等,"给你一个整数数组 nums，请你将该数组升序排列。
  示例 1：
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
示例 2：
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
  提示：
1 <= nums.length <= 5 * 104
-5 * 104 <= nums[i] <= 5 * 104",570,,371617,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/bucket-sort/', 'https://leetcode.cn/tag/counting-sort/', 'https://leetcode.cn/tag/radix-sort/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/', 'https://leetcode.cn/tag/merge-sort/']",[],668416
评论 (333),cat-and-mouse,困难,"两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。
图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。
老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。
在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。
此外，猫无法移动到洞中（节点 0）。
然后，游戏在出现以下三种情形之一时结束：
如果猫和老鼠出现在同一个节点，猫获胜。
如果老鼠到达洞中，老鼠获胜。
如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。
给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：
如果老鼠获胜，则返回 1；
如果猫获胜，则返回 2；
如果平局，则返回 0 。
  示例 1：
输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
输出：0
示例 2：
输入：graph = [[1,3],[0],[3],[0,2]]
输出：1
  提示：
3 <= graph.length <= 50
1 <= graph[i].length < graph.length
0 <= graph[i][j] < graph.length
graph[i][j] != i
graph[i] 互不相同
猫和老鼠在游戏中总是移动",276,https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg,17077,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",[],29752
评论 (589),x-of-a-kind-in-a-deck-of-cards,简单,"给定一副牌，每张牌上都写着一个整数。
此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
每组都有 X 张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回 true。
  示例 1：
输入：deck = [1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
示例 2：
输入：deck = [1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。

提示：
1 <= deck.length <= 104
0 <= deck[i] < 104",257,,53309,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/number-theory/']",[],138599
评论 (123),partition-array-into-disjoint-intervals,中等,"给定一个数组 nums ，将其划分为两个连续子数组 left 和 right， 使得：
left 中的每个元素都小于或等于 right 中的每个元素。
left 和 right 都是非空的。
left 的长度要尽可能小。
在完成这样的分组后返回 left 的 长度 。
用例可以保证存在这样的划分方法。
  示例 1：
输入：nums = [5,0,3,8,6]
输出：3
解释：left = [5,0,3]，right = [8,6]
示例 2：
输入：nums = [1,1,1,0,6,12]
输出：4
解释：left = [1,1,1,0]，right = [6,12]
  提示：
2 <= nums.length <= 105
0 <= nums[i] <= 106
可以保证至少有一种方法能够按题目所描述的那样对 nums 进行划分。",95,,11616,['https://leetcode.cn/tag/array/'],[],24727
评论 (88),word-subsets,中等,"给你两个字符串数组 words1 和 words2。
现在，如果 b 中的每个字母都出现在 a 中，包括重复出现的字母，那么称字符串 b 是字符串 a 的 子集 。
例如，""wrr"" 是 ""warrior"" 的子集，但不是 ""world"" 的子集。
如果对 words2 中的每一个单词 b，b 都是 a 的子集，那么我们称 words1 中的单词 a 是 通用单词 。
以数组形式返回 words1 中所有的通用单词。你可以按 任意顺序 返回答案。
  示例 1：
输入：words1 = [""amazon"",""apple"",""facebook"",""google"",""leetcode""], words2 = [""e"",""o""]
输出：[""facebook"",""google"",""leetcode""]
示例 2：
输入：words1 = [""amazon"",""apple"",""facebook"",""google"",""leetcode""], words2 = [""l"",""e""]
输出：[""apple"",""google"",""leetcode""]
示例 3：
输入：words1 = [""amazon"",""apple"",""facebook"",""google"",""leetcode""], words2 = [""e"",""oo""]
输出：[""facebook"",""google""]
示例 4：
输入：words1 = [""amazon"",""apple"",""facebook"",""google"",""leetcode""], words2 = [""lo"",""eo""]
输出：[""google"",""leetcode""]
示例 5：
输入：words1 = [""amazon"",""apple"",""facebook"",""google"",""leetcode""], words2 = [""ec"",""oc"",""ceo""]
输出：[""facebook"",""leetcode""]
  提示：
1 <= words1.length, words2.length <= 104
1 <= words1[i].length, words2[i].length <= 10
words1[i] 和 words2[i] 仅由小写英文字母组成
words1 中的所有字符串 互不相同",77,,7485,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],16573
评论 (667),reverse-only-letters,简单,"给你一个字符串 s ，根据下述规则反转字符串：
所有非英文字母保留在原有位置。
所有英文字母（小写或大写）位置反转。
返回反转后的 s 。
  示例 1：
输入：s = ""ab-cd""
输出：""dc-ba""
示例 2：
输入：s = ""a-bC-dEf-ghIj""
输出：""j-Ih-gfE-dCba""
示例 3：
输入：s = ""Test1ng-Leet=code-Q!""
输出：""Qedo1ct-eeLg=ntse-T!""
  提示
1 <= s.length <= 100
s 仅由 ASCII 值在范围 [33, 122] 的字符组成
s 不含 '\""' 或 '\\'",169,,68195,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],113314
评论 (257),maximum-sum-circular-subarray,中等,"给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。
环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。
子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i <= k1, k2 <= j 其中 k1 % n == k2 % n 。
  示例 1：
输入：nums = [1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3
示例 2：
输入：nums = [5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
示例 3：
输入：nums = [3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
  提示：
n == nums.length
1 <= n <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104",367,,40826,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/monotonic-queue/']",[],110265
评论 (114),complete-binary-tree-inserter,中等,"完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。
设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。
实现 CBTInserter 类:
CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；
CBTInserter.insert(int v)  向树中插入一个值为 Node.val == val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值；
CBTInserter.get_root() 将返回树的头节点。
  示例 1：
输入
[""CBTInserter"", ""insert"", ""insert"", ""get_root""]
[[[1, 2]], [3], [4], []]
输出
[null, 1, 2, [1, 2, 3, 4]]

解释
CBTInserter cBTInserter = new CBTInserter([1, 2]);
cBTInserter.insert(3);  // 返回 1
cBTInserter.insert(4);  // 返回 2
cBTInserter.get_root(); // 返回 [1, 2, 3, 4]
  提示：
树中节点数量范围为 [1, 1000] 
0 <= Node.val <= 5000
root 是完全二叉树
0 <= val <= 5000 
每个测试用例最多调用 insert 和 get_root 操作 104 次",67,,7904,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/binary-tree/']",[],11996
评论 (27),number-of-music-playlists,困难,"你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：
每首歌至少播放一次。
一首歌只有在其他 K 首歌播放完之后才能再次播放。
返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。
  示例 1：
输入：N = 3, L = 3, K = 1
输出：6
解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].
示例 2：
输入：N = 2, L = 3, K = 0
输出：6
解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]
示例 3：
输入：N = 2, L = 3, K = 1
输出：2
解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]
  提示：
0 <= K < N <= L <= 100",95,,2337,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/combinatorics/']",[],4686
评论 (304),minimum-add-to-make-parentheses-valid,中等,"只有满足下面几点之一，括号字符串才是有效的：
它是一个空字符串，或者
它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
它可以被写作 (A)，其中 A 是有效字符串。
给定一个括号字符串 s ，移动N次，你就可以在字符串的任何位置插入一个括号。
例如，如果 s = ""()))"" ，你可以插入一个开始括号为 ""(()))"" 或结束括号为 ""())))"" 。
返回 为使结果字符串 s 有效而必须添加的最少括号数。
  示例 1：
输入：s = ""())""
输出：1
示例 2：
输入：s = ""(((""
输出：3
  提示：
1 <= s.length <= 1000
s 只包含 '(' 和 ')' 字符。",134,,30071,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],40182
评论 (697),sort-array-by-parity-ii,简单,"给定一个非负整数数组 nums，  nums 中一半整数是 奇数 ，一半整数是 偶数 。
对数组进行排序，以便当 nums[i] 为奇数时，i 也是 奇数 ；当 nums[i] 为偶数时， i 也是 偶数 。
你可以返回 任何满足上述条件的数组作为答案 。
  示例 1：
输入：nums = [4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
示例 2：
输入：nums = [2,3]
输出：[2,3]
  提示：
2 <= nums.length <= 2 * 104
nums.length 是偶数
nums 中一半是偶数
0 <= nums[i] <= 1000
  进阶：可以不使用额外空间解决问题吗？",240,,97539,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],136786
评论 (84),3sum-with-multiplicity,中等,"给定一个整数数组 arr ，以及一个整数 target 作为目标值，返回满足 i < j < k 且 arr[i] + arr[j] + arr[k] == target 的元组 i, j, k 的数量。
由于结果会非常大，请返回 109 + 7 的模。
  示例 1：
输入：arr = [1,1,2,2,3,3,4,4,5,5], target = 8
输出：20
解释：
按值枚举(arr[i], arr[j], arr[k])：
(1, 2, 5) 出现 8 次；
(1, 3, 4) 出现 8 次；
(2, 2, 4) 出现 2 次；
(2, 3, 3) 出现 2 次。
示例 2：
输入：arr = [1,1,2,2,2,2], target = 5
输出：12
解释：
arr[i] = 1, arr[j] = arr[k] = 2 出现 12 次：
我们从 [1,1] 中选择一个 1，有 2 种情况，
从 [2,2,2,2] 中选出两个 2，有 6 种情况。
  提示：
3 <= arr.length <= 3000
0 <= arr[i] <= 100
0 <= target <= 300",95,,7711,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],21792
评论 (120),minimize-malware-spread,困难,"给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j。 
一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。
  示例 1：
输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输出：0
示例 2：
输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
输出：0
示例 3：
输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
输出：1
  提示：
n == graph.length
n == graph[i].length
2 <= n <= 300
graph[i][j] == 0 或 1.
graph[i][j] == graph[j][i]
graph[i][i] == 1
1 <= initial.length <= n
0 <= initial[i] <= n - 1
initial 中所有整数均不重复",71,,7937,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],22186
评论 (716),long-pressed-name,简单,"你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。
你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。
  示例 1：
输入：name = ""alex"", typed = ""aaleex""
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2：
输入：name = ""saeed"", typed = ""ssaaedd""
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
  提示：
1 <= name.length, typed.length <= 1000
name 和 typed 的字符都是小写字母",230,,54729,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],142869
评论 (125),flip-string-to-monotone-increasing,中等,"如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。
给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。
返回使 s 单调递增的最小翻转次数。
  示例 1：
输入：s = ""00110""
输出：1
解释：翻转最后一位得到 00111.
示例 2：
输入：s = ""010110""
输出：2
解释：翻转得到 011111，或者是 000111。
示例 3：
输入：s = ""00011000""
输出：2
解释：翻转得到 00000000。
  提示：
1 <= s.length <= 105
s[i] 为 '0' 或 '1'",155,,10309,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],18496
评论 (76),three-equal-parts,困难,"给定一个由 0 和 1 组成的数组 arr ，将数组分成  3 个非空的部分 ，使得所有这些部分表示相同的二进制值。
如果可以做到，请返回任何 [i, j]，其中 i+1 < j，这样一来：
arr[0], arr[1], ..., arr[i] 为第一部分；
arr[i + 1], arr[i + 2], ..., arr[j - 1] 为第二部分；
arr[j], arr[j + 1], ..., arr[arr.length - 1] 为第三部分。
这三个部分所表示的二进制值相等。
如果无法做到，就返回 [-1, -1]。
注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。
  示例 1：
输入：arr = [1,0,1,0,1]
输出：[0,3]
示例 2：
输入：arr = [1,1,0,1,1]
输出：[-1,-1]
示例 3:
输入：arr = [1,1,0,0,1]
输出：[0,2]
  提示：
3 <= arr.length <= 3 * 104
arr[i] 是 0 或 1",62,,4030,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],11659
评论 (37),minimize-malware-spread-ii,困难,"给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示。在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。
一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
我们可以从 initial 中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。
请返回移除后能够使 M(initial) 最小化的节点。如果有多个节点满足条件，返回索引 最小的节点 。
  示例 1：
输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输入：0
示例 2：
输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
输出：1
示例 3：
输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
输出：1
  提示：
n == graph.length
n == graph[i].length
2 <= n <= 300
graph[i][j] 是 0 或 1.
graph[i][j] == graph[j][i]
graph[i][i] == 1
1 <= initial.length < n
0 <= initial[i] <= n - 1
 initial 中每个整数都不同",45,,2787,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],6477
评论 (366),unique-email-addresses,简单,"每个 有效电子邮件地址 都由一个 本地名 和一个 域名 组成，以 '@' 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 '.' 或 '+' 。
例如，在 alice@leetcode.com中， alice 是 本地名 ，而 leetcode.com 是 域名 。
如果在电子邮件地址的 本地名 部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 不适用于域名 。
例如，""alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。
如果在 本地名 中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 不适用于域名 。
例如 m.y+name@email.com 将转发到 my@email.com。
可以同时使用这两个规则。
给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。
  示例 1：
输入：emails = [""test.email+alex@leetcode.com"",""test.e.mail+bob.cathy@leetcode.com"",""testemail+david@lee.tcode.com""]
输出：2
解释：实际收到邮件的是 ""testemail@leetcode.com"" 和 ""testemail@lee.tcode.com""。
示例 2：
输入：emails = [""a@leetcode.com"",""b@leetcode.com"",""c@leetcode.com""]
输出：3

提示：
1 <= emails.length <= 100
1 <= emails[i].length <= 100
emails[i] 由小写英文字母、'+'、'.' 和 '@' 组成
每个 emails[i] 都包含有且仅有一个 '@' 字符
所有本地名和域名都不为空
本地名不会以 '+' 字符作为开头",174,,29214,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],45227
评论 (332),binary-subarrays-with-sum,中等,"给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。
子数组 是数组的一段连续部分。
  示例 1：
输入：nums = [1,0,1,0,1], goal = 2
输出：4
解释：
有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]
示例 2：
输入：nums = [0,0,0,0,0], goal = 0
输出：15
  提示：
1 <= nums.length <= 3 * 104
nums[i] 不是 0 就是 1
0 <= goal <= nums.length",237,,38118,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",[],69651
评论 (293),minimum-falling-path-sum,中等,"给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。
下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。
  示例 1：
输入：matrix = [[2,1,3],[6,5,4],[7,8,9]]
输出：13
解释：如图所示，为和最小的两条下降路径
示例 2：
输入：matrix = [[-19,57],[-40,-5]]
输出：-59
解释：如图所示，为和最小的下降路径
  提示：
n == matrix.length == matrix[i].length
1 <= n <= 100
-100 <= matrix[i][j] <= 100",173,,38968,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],58114
评论 (91),beautiful-array,中等,"对于某些固定的 N，如果数组 A 是整数 1, 2, ..., N 组成的排列，使得：
对于每个 i < j，都不存在 k 满足 i < k < j 使得 A[k] * 2 = A[i] + A[j]。
那么数组 A 是漂亮数组。
  给定 N，返回任意漂亮数组 A（保证存在一个）。
  示例 1：
输入：4
输出：[2,1,4,3]
示例 2：
输入：5
输出：[3,1,2,5,4]
  提示：
1 <= N <= 1000
 ",176,,10592,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/divide-and-conquer/']",[],16432
评论 (568),number-of-recent-calls,简单,"写一个 RecentCounter 类来计算特定时间范围内最近的请求。
请你实现 RecentCounter 类：
RecentCounter() 初始化计数器，请求数为 0 。
int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
保证 每次对 ping 的调用都使用比之前更大的 t 值。
  示例 1：
输入：
[""RecentCounter"", ""ping"", ""ping"", ""ping"", ""ping""]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
  提示：
1 <= t <= 109
保证每次对 ping 调用所使用的 t 值都 严格递增
至多调用 ping 方法 104 次",174,,81250,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/data-stream/']",[],105372
评论 (202),shortest-bridge,中等,"在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）
现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。
返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）
  示例 1：
输入：A = [[0,1],[1,0]]
输出：1
示例 2：
输入：A = [[0,1,0],[0,0,0],[0,0,1]]
输出：2
示例 3：
输入：A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
输出：1
  提示：
2 <= A.length == A[0].length <= 100
A[i][j] == 0 或 A[i][j] == 1",246,,33084,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],69059
评论 (100),knight-dialer,中等,"象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。
象棋骑士可能的移动方式如下图所示:
我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。
给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。
你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。
因为答案可能很大，所以输出答案模 109 + 7.
  示例 1：
输入：n = 1
输出：10
解释：我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。
示例 2：
输入：n = 2
输出：20
解释：我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
示例 3：
输入：n = 3131
输出：136006598
解释：注意取模
  提示：
1 <= n <= 5000",115,,7643,['https://leetcode.cn/tag/dynamic-programming/'],[],15577
评论 (28),stamping-the-sequence,困难,"你想要用小写字母组成一个目标字符串 target。 
开始的时候，序列由 target.length 个 '?' 记号组成。而你有一个小写字母印章 stamp。
在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 10 * target.length  个回合。
举个例子，如果初始序列为 ""?????""，而你的印章 stamp 是 ""abc""，那么在第一回合，你可以得到 ""abc??""、""?abc?""、""??abc""。（请注意，印章必须完全包含在序列的边界内才能盖下去。）
如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。
例如，如果序列是 ""ababc""，印章是 ""abc""，那么我们就可以返回与操作 ""?????"" -> ""abc??"" -> ""ababc"" 相对应的答案 [0, 2]；
另外，如果可以印出序列，那么需要保证可以在 10 * target.length 个回合内完成。任何超过此数字的答案将不被接受。
  示例 1：
输入：stamp = ""abc"", target = ""ababc""
输出：[0,2]
（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）
示例 2：
输入：stamp = ""abca"", target = ""aabcaca""
输出：[3,0,1]
  提示：
1 <= stamp.length <= target.length <= 1000
stamp 和 target 只包含小写字母。",44,,1994,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/string/']",[],4972
评论 (519),reorder-data-in-log-files,简单,"给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。
有两种不同类型的日志：
字母日志：除标识符之外，所有字均由小写字母组成
数字日志：除标识符之外，所有字均由数字组成
请按下述规则将日志重新排序：
所有 字母日志 都排在 数字日志 之前。
字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。
数字日志 应该保留原来的相对顺序。
返回日志的最终顺序。
  示例 1：
输入：logs = [""dig1 8 1 5 1"",""let1 art can"",""dig2 3 6"",""let2 own kit dig"",""let3 art zero""]
输出：[""let1 art can"",""let3 art zero"",""let2 own kit dig"",""dig1 8 1 5 1"",""dig2 3 6""]
解释：
字母日志的内容都不同，所以顺序为 ""art can"", ""art zero"", ""own kit dig"" 。
数字日志保留原来的相对顺序 ""dig1 8 1 5 1"", ""dig2 3 6"" 。
示例 2：
输入：logs = [""a1 9 2 3 1"",""g1 act car"",""zo4 4 7"",""ab1 off key dog"",""a8 act zoo""]
输出：[""g1 act car"",""a8 act zoo"",""ab1 off key dog"",""a1 9 2 3 1"",""zo4 4 7""]
  提示：
1 <= logs.length <= 100
3 <= logs[i].length <= 100
logs[i] 中，字与字之间都用 单个 空格分隔
题目数据保证 logs[i] 都有一个标识符，并且在标识符之后至少存在一个字",188,,38287,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],59894
评论 (749),range-sum-of-bst,简单,"给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
  示例 1：
输入：root = [10,5,15,3,7,null,18], low = 7, high = 15
输出：32
示例 2：
输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
输出：23
  提示：
树中节点数目在范围 [1, 2 * 104] 内
1 <= Node.val <= 105
1 <= low <= high <= 105
所有 Node.val 互不相同",288,https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg,108719,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",[],132465
评论 (50),minimum-area-rectangle,中等,"给定在 xy 平面上的一组点，确定由这些点组成的矩形的最小面积，其中矩形的边平行于 x 轴和 y 轴。
如果没有任何矩形，就返回 0。
  示例 1：
输入：[[1,1],[1,3],[3,1],[3,3],[2,2]]
输出：4
示例 2：
输入：[[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]
输出：2
  提示：
1 <= points.length <= 500
0 <= points[i][0] <= 40000
0 <= points[i][1] <= 40000
所有的点都是不同的。",114,,7054,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",[],14939
评论 (60),distinct-subsequences-ii,困难,"给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。
字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。
例如，""ace"" 是 ""abcde"" 的一个子序列，但 ""aec"" 不是。
  示例 1：
输入：s = ""abc""
输出：7
解释：7 个不同的子序列分别是 ""a"", ""b"", ""c"", ""ab"", ""ac"", ""bc"", 以及 ""abc""。
示例 2：
输入：s = ""aba""
输出：6
解释：6 个不同的子序列分别是 ""a"", ""b"", ""ab"", ""ba"", ""aa"" 以及 ""aba""。
示例 3：
输入：s = ""aaa""
输出：3
解释：3 个不同的子序列分别是 ""a"", ""aa"" 以及 ""aaa""。
  提示：
1 <= s.length <= 2000
s 仅由小写英文字母组成
 ",117,,6241,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],14601
评论 (461),valid-mountain-array,简单,"给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。
让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组：
arr.length >= 3
在 0 < i < arr.length - 1 条件下，存在 i 使得：
arr[0] < arr[1] < ... arr[i-1] < arr[i]
arr[i] > arr[i+1] > ... > arr[arr.length - 1]
    示例 1：
输入：arr = [2,1]
输出：false
示例 2：
输入：arr = [3,5,5]
输出：false
示例 3：
输入：arr = [0,3,2,1]
输出：true
  提示：
1 <= arr.length <= 104
0 <= arr[i] <= 104",176,,67484,['https://leetcode.cn/tag/array/'],[],171631
评论 (728),di-string-match,简单,"由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:
如果 perm[i] < perm[i + 1] ，那么 s[i] == 'I' 
如果 perm[i] > perm[i + 1] ，那么 s[i] == 'D' 
给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。
  示例 1：
输入：s = ""IDID""
输出：[0,4,1,3,2]
示例 2：
输入：s = ""III""
输出：[0,1,2,3]
示例 3：
输入：s = ""DDI""
输出：[3,2,0,1]
  提示：
1 <= s.length <= 105
s 只包含字符 ""I"" 或 ""D""",391,,59246,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],76516
评论 (45),find-the-shortest-superstring,困难,"给定一个字符串数组 words，找到以 words 中每个字符串作为子字符串的最短字符串。如果有多个有效最短字符串满足题目条件，返回其中 任意一个 即可。
我们可以假设 words 中没有字符串是 words 中另一个字符串的子字符串。
  示例 1：
输入：words = [""alex"",""loves"",""leetcode""]
输出：""alexlovesleetcode""
解释：""alex""，""loves""，""leetcode"" 的所有排列都会被接受。
示例 2：
输入：words = [""catg"",""ctaagt"",""gcta"",""ttca"",""atgcatc""]
输出：""gctaagttcatgcatc""
  提示：
1 <= words.length <= 12
1 <= words[i].length <= 20
words[i] 由小写英文字母组成
words 中的所有字符串 互不相同",105,,2491,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],5365
评论 (596),delete-columns-to-make-sorted,简单,"给你由 n 个小写字母字符串组成的数组 strs，其中每个字符串长度相等。
这些字符串可以每个一行，排成一个网格。例如，strs = [""abc"", ""bce"", ""cae""] 可以排列为：
abc
bce
cae
你需要找出并删除 不是按字典序升序排列的 列。在上面的例子（下标从 0 开始）中，列 0（'a', 'b', 'c'）和列 2（'c', 'e', 'e'）都是按升序排列的，而列 1（'b', 'c', 'a'）不是，所以要删除列 1 。
返回你需要删除的列数。
  示例 1：
输入：strs = [""cba"",""daf"",""ghi""]
输出：1
解释：网格示意如下：
  cba
  daf
  ghi
列 0 和列 2 按升序排列，但列 1 不是，所以只需要删除列 1 。
示例 2：
输入：strs = [""a"",""b""]
输出：0
解释：网格示意如下：
  a
  b
只有列 0 这一列，且已经按升序排列，所以不用删除任何列。
示例 3：
输入：strs = [""zyx"",""wvu"",""tsr""]
输出：3
解释：网格示意如下：
  zyx
  wvu
  tsr
所有 3 列都是非升序排列的，所以都要删除。
  提示：
n == strs.length
1 <= n <= 100
1 <= strs[i].length <= 1000
strs[i] 由小写英文字母组成",94,,52752,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],76149
评论 (364),minimum-increment-to-make-array-unique,中等,"给你一个整数数组 nums 。每次 move 操作将会选择任意一个满足 0 <= i < nums.length 的下标 i，并将 nums[i] 递增 1。
返回使 nums 中的每个值都变成唯一的所需要的最少操作次数。
  示例 1：
输入：nums = [1,2,2]
输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
示例 2：
输入：nums = [3,2,1,2,1,7]
输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 105",208,,38581,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],79922
评论 (244),validate-stack-sequences,中等,"给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。
  示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
  提示：
1 <= pushed.length <= 1000
0 <= pushed[i] <= 1000
pushed 的所有元素 互不相同
popped.length == pushed.length
popped 是 pushed 的一个排列",243,,36617,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],57531
评论 (318),most-stones-removed-with-same-row-or-column,中等,"n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。
如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。
给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。
  示例 1：
输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
示例 2：
输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出：3
解释：一种移除 3 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
示例 3：
输入：stones = [[0,0]]
输出：0
解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。
  提示：
1 <= stones.length <= 1000
0 <= xi, yi <= 104
不会有两块石头放在同一个坐标点上",267,,28555,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']",[],46712
评论 (130),bag-of-tokens,中等,"你的初始 能量 为 P，初始 分数 为 0，只有一包令牌 tokens 。其中 tokens[i] 是第 i 个令牌的值（下标从 0 开始）。
令牌可能的两种使用方法如下：
如果你至少有 token[i] 点 能量 ，可以将令牌 i 置为正面朝上，失去 token[i] 点 能量 ，并得到 1 分 。
如果我们至少有 1 分 ，可以将令牌 i 置为反面朝上，获得 token[i] 点 能量 ，并失去 1 分 。
每个令牌 最多 只能使用一次，使用 顺序不限 ，不需 使用所有令牌。
在使用任意数量的令牌后，返回我们可以得到的最大 分数 。
  示例 1：
输入：tokens = [100], P = 50
输出：0
解释：无法使用唯一的令牌，因为能量和分数都太少了。
示例 2：
输入：tokens = [100,200], P = 150
输出：1
解释：令牌 0 正面朝上，能量变为 50，分数变为 1 。不必使用令牌 1 ，因为你无法使用它来提高分数。
示例 3：
输入：tokens = [100,200,300,400], P = 200
输出：2
解释：按下面顺序使用令牌可以得到 2 分：
1. 令牌 0 正面朝上，能量变为 100 ，分数变为 1
2. 令牌 3 正面朝下，能量变为 500 ，分数变为 0
3. 令牌 1 正面朝上，能量变为 300 ，分数变为 1
4. 令牌 2 正面朝上，能量变为 0 ，分数变为 2
  提示：
0 <= tokens.length <= 1000
0 <= tokens[i], P < 104",74,,7960,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],20016
评论 (172),largest-time-for-given-digits,中等,"给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。
24 小时格式为 ""HH:MM"" ，其中 HH 在 00 到 23 之间，MM 在 00 到 59 之间。最小的 24 小时制时间是 00:00 ，而最大的是 23:59 。从 00:00 （午夜）开始算起，过得越久，时间越大。
以长度为 5 的字符串，按 ""HH:MM"" 格式返回答案。如果不能确定有效时间，则返回空字符串。
  示例 1：
输入：arr = [1,2,3,4]
输出：""23:41""
解释：有效的 24 小时制时间是 ""12:34""，""12:43""，""13:24""，""13:42""，""14:23""，""14:32""，""21:34""，""21:43""，""23:14"" 和 ""23:41"" 。这些时间中，""23:41"" 是最大时间。
示例 2：
输入：arr = [5,5,5,5]
输出：""""
解释：不存在有效的 24 小时制时间，因为 ""55:55"" 无效。
示例 3：
输入：arr = [0,0,0,0]
输出：""00:00""
示例 4：
输入：arr = [0,0,1,0]
输出：""10:00""
  提示：
arr.length == 4
0 <= arr[i] <= 9",80,,9728,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/enumeration/']",[],25966
评论 (177),reveal-cards-in-increasing-order,中等,"牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。
最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。
现在，重复执行以下步骤，直到显示所有卡牌为止：
从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。
如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。
如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。
返回能以递增顺序显示卡牌的牌组顺序。
答案中的第一张牌被认为处于牌堆顶部。
  示例：
输入：[17,13,11,2,3,5,7]
输出：[2,13,3,11,5,17,7]
解释：
我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。
重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。
我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。
我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。
我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。
我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。
我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。
我们展示 13，然后将 17 移到底部。牌组现在是 [17]。
我们显示 17。
由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。
  提示：
1 <= A.length <= 1000
1 <= A[i] <= 10^6
对于所有的 i != j，A[i] != A[j]",166,,11682,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/simulation/']",[],14924
评论 (174),flip-equivalent-binary-trees,中等,"我们可以为二叉树 T 定义一个 翻转操作 ，如下所示：选择任意节点，然后交换它的左子树和右子树。
只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转 等价 于二叉树 Y。
这些树由根节点 root1 和 root2 给出。如果两个二叉树是否是翻转 等价 的函数，则返回 true ，否则返回 false 。
  示例 1：
输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
输出：true
解释：我们翻转值为 1，3 以及 5 的三个节点。
示例 2:
输入: root1 = [], root2 = []
输出: true
示例 3:
输入: root1 = [], root2 = [1]
输出: false
  提示：
每棵树节点数在 [0, 100] 范围内
每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数",125,,13731,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],20649
评论 (48),largest-component-size-by-common-factor,困难,"给定一个由不同正整数的组成的非空数组 nums ，考虑下面的图：
有 nums.length 个节点，按从 nums[0] 到 nums[nums.length - 1] 标记；
只有当 nums[i] 和 nums[j] 共用一个大于 1 的公因数时，nums[i] 和 nums[j]之间才有一条边。
返回 图中最大连通组件的大小 。
  示例 1：
输入：nums = [4,6,15,35]
输出：4
示例 2：
输入：nums = [20,50,9,63]
输出：2
示例 3：
输入：nums = [2,3,6,7,4,12,21,39]
输出：8
  提示：
1 <= nums.length <= 2 * 104
1 <= nums[i] <= 105
nums 中所有值都 不同",77,,3887,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],10491
评论 (632),verifying-an-alien-dictionary,简单,"某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。
给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。
  示例 1：
输入：words = [""hello"",""leetcode""], order = ""hlabcdefgijkmnopqrstuvwxyz""
输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。
示例 2：
输入：words = [""word"",""world"",""row""], order = ""worldabcefghijkmnpqstuvxyz""
输出：false
解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。
示例 3：
输入：words = [""apple"",""app""], order = ""abcdefghijklmnopqrstuvwxyz""
输出：false
解释：当前三个字符 ""app"" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 ""apple"" > ""app""，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。
  提示：
1 <= words.length <= 100
1 <= words[i].length <= 20
order.length == 26
在 words[i] 和 order 中的所有字符都是英文小写字母。",208,,46940,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],81139
评论 (450),array-of-doubled-pairs,中等,"给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足 “对于每个 0 <= i < len(arr) / 2，都有 arr[2 * i + 1] = 2 * arr[2 * i]” 时，返回 true；否则，返回 false。
  示例 1：
输入：arr = [3,1,3,6]
输出：false
示例 2：
输入：arr = [2,1,2,6]
输出：false
示例 3：
输入：arr = [4,-2,2,-4]
输出：true
解释：可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]
  提示：
0 <= arr.length <= 3 * 104
arr.length 是偶数
-105 <= arr[i] <= 105",181,,40146,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],103258
评论 (54),delete-columns-to-make-sorted-ii,中等,"给定由 n 个字符串组成的数组 strs，其中每个字符串长度相等。
选取一个删除索引序列，对于 strs 中的每个字符串，删除对应每个索引处的字符。
比如，有 strs = [""abcdef"", ""uvwxyz""]，删除索引序列 {0, 2, 3}，删除后 strs 为[""bef"", ""vyz""]。
假设，我们选择了一组删除索引 answer，那么在执行删除操作之后，最终得到的数组的元素是按 字典序（strs[0] <= strs[1] <= strs[2] ... <= strs[n - 1]）排列的，然后请你返回 answer.length 的最小可能值。
  示例 1：
输入：strs = [""ca"",""bb"",""ac""]
输出：1
解释： 
删除第一列后，strs = [""a"", ""b"", ""c""]。
现在 strs 中元素是按字典排列的 (即，strs[0] <= strs[1] <= strs[2])。
我们至少需要进行 1 次删除，因为最初 strs 不是按字典序排列的，所以答案是 1。
示例 2：
输入：strs = [""xc"",""yb"",""za""]
输出：0
解释：
strs 的列已经是按字典序排列了，所以我们不需要删除任何东西。
注意 strs 的行不需要按字典序排列。
也就是说，strs[0][0] <= strs[0][1] <= ... 不一定成立。
示例 3：
输入：strs = [""zyx"",""wvu"",""tsr""]
输出：3
解释：
我们必须删掉每一列。
  提示：
n == strs.length
1 <= n <= 100
1 <= strs[i].length <= 100
strs[i] 由小写英文字母组成",71,,4161,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],12207
评论 (47),tallest-billboard,困难,"你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。
你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。
返回 广告牌的最大可能安装高度 。如果没法安装广告牌，请返回 0 。
  示例 1：
输入：[1,2,3,6]
输出：6
解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
示例 2：
输入：[1,2,3,4,5,6]
输出：10
解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。
示例 3：
输入：[1,2]
输出：0
解释：没法安装广告牌，所以返回 0。
  提示：
0 <= rods.length <= 20
1 <= rods[i] <= 1000
sum(rods[i]) <= 5000",119,,4937,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],11076
评论 (163),prison-cells-after-n-days,中等,"8 间牢房排成一排，每间牢房不是有人住就是空着。
每天，无论牢房是被占用或空置，都会根据以下规则进行更改：
如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。
否则，它就会被空置。
（请注意，由于监狱中的牢房排成一行，所以行中的第一个和最后一个房间无法有两个相邻的房间。）
我们用以下方式描述监狱的当前状态：如果第 i 间牢房被占用，则 cell[i]==1，否则 cell[i]==0。
根据监狱的初始状态，在 N 天后返回监狱的状况（和上述 N 种变化）。
  示例 1：
输入：cells = [0,1,0,1,1,0,0,1], N = 7
输出：[0,0,1,1,0,0,0,0]
解释：
下表概述了监狱每天的状况：
Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
Day 7: [0, 0, 1, 1, 0, 0, 0, 0]
示例 2：
输入：cells = [1,0,0,1,0,0,1,0], N = 1000000000
输出：[0,0,1,1,1,1,1,0]
  提示：
cells.length == 8
cells[i] 的值为 0 或 1 
1 <= N <= 10^9",119,,16297,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/']",[],44678
评论 (204),check-completeness-of-a-binary-tree,中等,"给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。
在一个 完全二叉树 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 1 到 2h 节点之间的最后一级 h 。
  示例 1：
输入：root = [1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
示例 2：
输入：root = [1,2,3,4,5,null,7]
输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
  提示：
树的结点数在范围  [1, 100] 内。
1 <= Node.val <= 1000",197,,36433,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],67115
评论 (279),regions-cut-by-slashes,中等,"在由 1 x 1 方格组成的 n x n 网格 grid 中，每个 1 x 1 方块由 '/'、'\' 或空格构成。这些字符会将方块划分为一些共边的区域。
给定网格 grid 表示为一个字符串数组，返回 区域的数量 。
请注意，反斜杠字符是转义的，因此 '\' 用 '\\' 表示。
  示例 1：
输入：grid = ["" /"",""/ ""]
输出：2
示例 2：
输入：grid = ["" /"",""  ""]
输出：1
示例 3：
输入：grid = [""/\\"",""\\/""]
输出：5
解释：回想一下，因为 \ 字符是转义的，所以 ""/\\"" 表示 /\，而 ""\\/"" 表示 \/。
  提示：
n == grid.length == grid[i].length
1 <= n <= 30
grid[i][j] 是 '/'、'\'、或 ' '",305,,21135,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']",[],28457
评论 (34),delete-columns-to-make-sorted-iii,困难,"给定由 n 个小写字母字符串组成的数组 strs ，其中每个字符串长度相等。
选取一个删除索引序列，对于 strs 中的每个字符串，删除对应每个索引处的字符。
比如，有 strs = [""abcdef"",""uvwxyz""] ，删除索引序列 {0, 2, 3} ，删除后为 [""bef"", ""vyz""] 。
假设，我们选择了一组删除索引 answer ，那么在执行删除操作之后，最终得到的数组的行中的 每个元素 都是按字典序排列的（即 (strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1]) 和 (strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1]) ，依此类推）。
请返回 answer.length 的最小可能值 。
  示例 1：
输入：strs = [""babca"",""bbazb""]
输出：3
解释：
删除 0、1 和 4 这三列后，最终得到的数组是 A = [""bc"", ""az""]。
这两行是分别按字典序排列的（即，A[0][0] <= A[0][1] 且 A[1][0] <= A[1][1]）。
注意，A[0] > A[1] —— 数组 A 不一定是按字典序排列的。
示例 2：
输入：strs = [""edcba""]
输出：4
解释：如果删除的列少于 4 列，则剩下的行都不会按字典序排列。
示例 3：
输入：strs = [""ghi"",""def"",""abc""]
输出：0
解释：所有行都已按字典序排列。
  提示：
n == strs.length
1 <= n <= 100
1 <= strs[i].length <= 100
strs[i] 由小写英文字母组成",65,,2577,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],4474
评论 (693),n-repeated-element-in-size-2n-array,简单,"给你一个整数数组 nums ，该数组具有以下属性：
nums.length == 2 * n.
nums 包含 n + 1 个 不同的 元素
nums 中恰有一个元素重复 n 次
找出并返回重复了 n 次的那个元素。
  示例 1：
输入：nums = [1,2,3,3]
输出：3
示例 2：
输入：nums = [2,1,2,5,3,2]
输出：2
示例 3：
输入：nums = [5,1,5,2,5,3,5,4]
输出：5
  提示：
2 <= n <= 5000
nums.length == 2 * n
0 <= nums[i] <= 104
nums 由 n + 1 个 不同的 元素组成，且其中一个元素恰好重复 n 次",168,,71872,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],102103
评论 (111),maximum-width-ramp,中等,"给定一个整数数组 A，坡是元组 (i, j)，其中  i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。
找出 A 中的坡的最大宽度，如果不存在，返回 0 。
  示例 1：
输入：[6,0,8,2,1,5]
输出：4
解释：
最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.
示例 2：
输入：[9,8,1,0,1,9,4,0,4,1]
输出：7
解释：
最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.
  提示：
2 <= A.length <= 50000
0 <= A[i] <= 50000
 ",169,,17100,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/monotonic-stack/']",[],37864
评论 (42),minimum-area-rectangle-ii,中等,"给定在 xy 平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边不一定平行于 x 轴和 y 轴。
如果没有任何矩形，就返回 0。
  示例 1：
输入：[[1,2],[2,1],[1,0],[0,1]]
输出：2.00000
解释：最小面积的矩形出现在 [1,2],[2,1],[1,0],[0,1] 处，面积为 2。
示例 2：
输入：[[0,1],[2,1],[1,1],[1,0],[2,0]]
输出：1.00000
解释：最小面积的矩形出现在 [1,0],[1,1],[2,1],[2,0] 处，面积为 1。
示例 3：
输入：[[0,3],[1,2],[3,1],[1,3],[2,1]]
输出：0
解释：没法从这些点中组成任何矩形。
示例 4：
输入：[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]
输出：2.00000
解释：最小面积的矩形出现在 [2,1],[2,3],[3,3],[3,1] 处，面积为 2。
  提示：
1 <= points.length <= 50
0 <= points[i][0] <= 40000
0 <= points[i][1] <= 40000
所有的点都是不同的。
与真实值误差不超过 10^-5 的答案将视为正确结果。",57,,2991,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],5864
评论 (34),least-operators-to-express-number,困难,"给定一个正整数 x，我们将会写出一个形如 x (op1) x (op2) x (op3) x ... 的表达式，其中每个运算符 op1，op2，… 可以是加、减、乘、除（+，-，*，或是 /）之一。例如，对于 x = 3，我们可以写出表达式 3 * 3 / 3 + 3 - 3，该式的值为 3 。
在写这样的表达式时，我们需要遵守下面的惯例：
除运算符（/）返回有理数。
任何地方都没有括号。
我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。
不允许使用一元否定运算符（-）。例如，“x - x” 是一个有效的表达式，因为它只使用减法，但是 “-x + x” 不是，因为它使用了否定运算符。 
我们希望编写一个能使表达式等于给定的目标值 target 且运算符最少的表达式。返回所用运算符的最少数量。
  示例 1：
输入：x = 3, target = 19
输出：5
解释：3 * 3 + 3 * 3 + 3 / 3 。表达式包含 5 个运算符。
示例 2：
输入：x = 5, target = 501
输出：8
解释：5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5 。表达式包含 8 个运算符。
示例 3：
输入：x = 100, target = 100000000
输出：3
解释：100 * 100 * 100 * 100 。表达式包含 3 个运算符。
  提示：
2 <= x <= 100
1 <= target <= 2 * 108",51,,1769,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],3955
评论 (667),univalued-binary-tree,简单,"如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
只有给定的树是单值二叉树时，才返回 true；否则返回 false。
  示例 1：
输入：[1,1,1,1,1,null,1]
输出：true
示例 2：
输入：[2,2,2,5,2]
输出：false
  提示：
给定树的节点数范围是 [1, 100]。
每个节点的值都是整数，范围为 [0, 99] 。",130,,53377,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],74913
评论 (45),vowel-spellchecker,中等,"在给定单词列表 wordlist 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。
对于给定的查询单词 query，拼写检查器将会处理两类拼写错误：
大小写：如果查询匹配单词列表中的某个单词（不区分大小写），则返回的正确单词与单词列表中的大小写相同。
例如：wordlist = [""yellow""], query = ""YellOw"": correct = ""yellow""
例如：wordlist = [""Yellow""], query = ""yellow"": correct = ""Yellow""
例如：wordlist = [""yellow""], query = ""yellow"": correct = ""yellow""
元音错误：如果在将查询单词中的元音 ('a', 'e', 'i', 'o', 'u')  分别替换为任何元音后，能与单词列表中的单词匹配（不区分大小写），则返回的正确单词与单词列表中的匹配项大小写相同。
例如：wordlist = [""YellOw""], query = ""yollow"": correct = ""YellOw""
例如：wordlist = [""YellOw""], query = ""yeellow"": correct = """" （无匹配项）
例如：wordlist = [""YellOw""], query = ""yllw"": correct = """" （无匹配项）
此外，拼写检查器还按照以下优先级规则操作：
当查询完全匹配单词列表中的某个单词（区分大小写）时，应返回相同的单词。
当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。
当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。
如果该查询在单词列表中没有匹配项，则应返回空字符串。
给出一些查询 queries，返回一个单词列表 answer，其中 answer[i] 是由查询 query = queries[i] 得到的正确单词。
  示例 1：
输入：wordlist = [""KiTe"",""kite"",""hare"",""Hare""], queries = [""kite"",""Kite"",""KiTe"",""Hare"",""HARE"",""Hear"",""hear"",""keti"",""keet"",""keto""]
输出：[""kite"",""KiTe"",""KiTe"",""Hare"",""hare"","""","""",""KiTe"","""",""KiTe""]
示例 2:
输入：wordlist = [""yellow""], queries = [""YellOw""]
输出：[""yellow""]
  提示：
1 <= wordlist.length, queries.length <= 5000
1 <= wordlist[i].length, queries[i].length <= 7
wordlist[i] 和 queries[i] 只包含英文字母",35,,3623,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],8728
评论 (128),numbers-with-same-consecutive-differences,中等,"返回所有长度为 n 且满足其每两个连续位上的数字之间的差的绝对值为 k 的 非负整数 。
请注意，除了 数字 0 本身之外，答案中的每个数字都 不能 有前导零。例如，01 有一个前导零，所以是无效的；但 0 是有效的。
你可以按 任何顺序 返回答案。
  示例 1：
输入：n = 3, k = 7
输出：[181,292,707,818,929]
解释：注意，070 不是一个有效的数字，因为它有前导零。
示例 2：
输入：n = 2, k = 1
输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
示例 3：
输入：n = 2, k = 0
输出：[11,22,33,44,55,66,77,88,99]
示例 4：
输入：n = 2, k = 2
输出：[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]
  提示：
2 <= n <= 9
0 <= k <= 9",75,,9535,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/backtracking/']",[],19694
评论 (284),binary-tree-cameras,困难,"给定一个二叉树，我们在树的节点上安装摄像头。
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
计算监控树的所有节点所需的最小摄像头数量。
  示例 1：
输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
示例 2：
输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。

提示：
给定树的节点数的范围是 [1, 1000]。
每个节点的值都是 0。",408,,37547,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/distribute-coins-in-binary-tree/'],73302
评论 (503),pancake-sorting,中等,"给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。
一次煎饼翻转的执行过程如下：
选择一个整数 k ，1 <= k <= arr.length
反转子数组 arr[0...k-1]（下标从 0 开始）
例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。
以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。
  示例 1：
输入：[3,2,4,1]
输出：[4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 arr = [3, 2, 4, 1]
第一次翻转后（k = 4）：arr = [1, 4, 2, 3]
第二次翻转后（k = 2）：arr = [4, 1, 2, 3]
第三次翻转后（k = 4）：arr = [3, 2, 1, 4]
第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。 
示例 2：
输入：[1,2,3]
输出：[]
解释：
输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。
  提示：
1 <= arr.length <= 100
1 <= arr[i] <= arr.length
arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列）",262,,41658,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],61356
评论 (165),powerful-integers,中等,"给定三个整数 x 、 y 和 bound ，返回 值小于或等于 bound 的所有 强整数 组成的列表 。
如果某一整数可以表示为 xi + yj ，其中整数 i >= 0 且 j >= 0，那么我们认为该整数是一个 强整数 。
你可以按 任何顺序 返回答案。在你的回答中，每个值 最多 出现一次。
  示例 1：
输入：x = 2, y = 3, bound = 10
输出：[2,3,4,5,7,9,10]
解释： 
2 = 20 + 30
3 = 21 + 30
4 = 20 + 31
5 = 21 + 31
7 = 22 + 31
9 = 23 + 30
10 = 20 + 32
示例 2：
输入：x = 3, y = 5, bound = 15
输出：[2,4,6,8,10,14]
  提示：
1 <= x, y <= 100
0 <= bound <= 106",56,,12208,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/']",[],29616
评论 (106),flip-binary-tree-to-match-preorder-traversal,中等,"给你一棵二叉树的根节点 root ，树中有 n 个节点，每个节点都有一个不同于其他节点且处于 1 到 n 之间的值。
另给你一个由 n 个值组成的行程序列 voyage ，表示 预期 的二叉树 先序遍历 结果。
通过交换节点的左右子树，可以 翻转 该二叉树中的任意节点。例，翻转节点 1 的效果如下：
请翻转 最少 的树中节点，使二叉树的 先序遍历 与预期的遍历行程 voyage 相匹配 。 
如果可以，则返回 翻转的 所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 [-1]。
  示例 1：
输入：root = [1,2], voyage = [2,1]
输出：[-1]
解释：翻转节点无法令先序遍历匹配预期行程。
示例 2：
输入：root = [1,2,3], voyage = [1,3,2]
输出：[1]
解释：交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。
示例 3：
输入：root = [1,2,3], voyage = [1,2,3]
输出：[]
解释：先序遍历已经匹配预期行程，所以不需要翻转节点。
  提示：
树中的节点数目为 n
n == voyage.length
1 <= n <= 100
1 <= Node.val, voyage[i] <= n
树中的所有值 互不相同
voyage 中的所有值 互不相同",93,https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg,8331,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],18632
评论 (28),equal-rational-numbers,困难,"给定两个字符串 s 和 t ，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回 true 。字符串中可以使用括号来表示有理数的重复部分。
有理数 最多可以用三个部分来表示：整数部分 <IntegerPart>、小数非重复部分 <NonRepeatingPart> 和小数重复部分 <(><RepeatingPart><)>。数字可以用以下三种方法之一来表示：
<IntegerPart> 
例： 0 ,12 和 123 
<IntegerPart><.><NonRepeatingPart>
例： 0.5 , 1. , 2.12 和 123.0001
<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> 
例： 0.1(6) ， 1.(9)， 123.00(1212)
十进制展开的重复部分通常在一对圆括号内表示。例如：
1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)
  示例 1：
输入：s = ""0.(52)"", t = ""0.5(25)""
输出：true
解释：因为 ""0.(52)"" 代表 0.52525252...，而 ""0.5(25)"" 代表 0.52525252525.....，则这两个字符串表示相同的数字。
示例 2：
输入：s = ""0.1666(6)"", t = ""0.166(66)""
输出：true
示例 3：
输入：s = ""0.9(9)"", t = ""1.""
输出：true
解释：""0.9(9)"" 代表 0.999999999... 永远重复，等于 1 。[有关说明，请参阅此链接]
""1."" 表示数字 1，其格式正确：(IntegerPart) = ""1"" 且 (NonRepeatingPart) = """" 。
  提示：
每个部分仅由数字组成。
整数部分 <IntegerPart> 不会以零开头。（零本身除外）
1 <= <IntegerPart>.length <= 4
0 <= <NonRepeatingPart>.length <= 4
1 <= <RepeatingPart>.length <= 4",22,,1628,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],4031
评论 (554),k-closest-points-to-origin,中等,"给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点 (0,0) 最近的 k 个点。
这里，平面上两点之间的距离是 欧几里德距离（ √(x1 - x2)2 + (y1 - y2)2 ）。
你可以按 任何顺序 返回答案。除了点坐标的顺序之外，答案 确保 是 唯一 的。
  示例 1：
输入：points = [[1,3],[-2,2]], k = 1
输出：[[-2,2]]
解释： 
(1, 3) 和原点之间的距离为 sqrt(10)，
(-2, 2) 和原点之间的距离为 sqrt(8)，
由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。
我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。
示例 2：
输入：points = [[3,3],[5,-1],[-2,4]], k = 2
输出：[[3,3],[-2,4]]
（答案 [[-2,4],[3,3]] 也会被接受。）
  提示：
1 <= k <= points.length <= 104
-104 < xi, yi < 104",339,,80465,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/quickselect/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']","['https://leetcode.cn/problems/kth-largest-element-in-an-array/', 'https://leetcode.cn/problems/top-k-frequent-elements/', 'https://leetcode.cn/problems/top-k-frequent-words/']",124203
评论 (286),subarray-sums-divisible-by-k,中等,"给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的（连续、非空） 子数组 的数目。
子数组 是数组的 连续 部分。
  示例 1：
输入：nums = [4,5,0,-2,-3,1], k = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
示例 2:
输入: nums = [5], k = 9
输出: 0
  提示:
1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
2 <= k <= 104",362,,46152,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']",['https://leetcode.cn/problems/subarray-sum-equals-k/'],97796
评论 (76),odd-even-jump,困难,"给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。
你可以按以下方式从索引 i 向后跳转到索引 j（其中 i < j）：
在进行奇数跳跃时（如，第 1，3，5... 次跳跃），你将会跳到索引 j，使得 A[i] <= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。
在进行偶数跳跃时（如，第 2，4，6... 次跳跃），你将会跳到索引 j，使得 A[i] >= A[j]，A[j] 是可能的最大值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。
（对于某些索引 i，可能无法进行合乎要求的跳跃。）
如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。
返回好的起始索引的数量。
  示例 1：
输入：[10,13,12,14,15]
输出：2
解释： 
从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。
从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。
从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。
从起始索引 i = 4 出发，我们已经到达数组末尾。
总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。
示例 2：
输入：[2,3,1,1,4]
输出：3
解释：
从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：

在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。

在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。

在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。

我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。

类似地，我们可以推断：
从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。
从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。
从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。
从起始索引 i = 4 出发，我们已经到达数组末尾。
总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。
示例 3：
输入：[5,1,3,4,2]
输出：3
解释： 
我们可以从起始索引 1，2，4 出发到达数组末尾。
  提示：
1 <= A.length <= 20000
0 <= A[i] < 100000",140,,4028,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/monotonic-stack/']",[],8778
评论 (424),largest-perimeter-triangle,简单,"给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。
  示例 1：
输入：nums = [2,1,2]
输出：5
示例 2：
输入：nums = [1,2,1]
输出：0
  提示：
3 <= nums.length <= 104
1 <= nums[i] <= 106",192,,67270,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",['https://leetcode.cn/problems/largest-triangle-area/'],114607
评论 (1.3k),squares-of-a-sorted-array,简单,"给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
  示例 1：
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
示例 2：
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
  提示：
1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 已按 非递减顺序 排序
  进阶：
请你设计时间复杂度为 O(n) 的算法解决本问题",541,,334983,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']","['https://leetcode.cn/problems/merge-sorted-array/', 'https://leetcode.cn/problems/sort-transformed-array/']",485566
评论 (426),longest-turbulent-subarray,中等,"给定一个整数数组 arr ，返回 arr 的 最大湍流子数组的长度 。
如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 湍流子数组 。
更正式地来说，当 arr 的子数组 A[i], A[i+1], ..., A[j] 满足仅满足下列条件时，我们称其为湍流子数组：
若 i <= k < j ：
当 k 为奇数时， A[k] > A[k+1]，且
当 k 为偶数时，A[k] < A[k+1]；
或 若 i <= k < j ：
当 k 为偶数时，A[k] > A[k+1] ，且
当 k 为奇数时， A[k] < A[k+1]。
  示例 1：
输入：arr = [9,4,2,10,7,8,8,1,9]
输出：5
解释：arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
示例 2：
输入：arr = [4,8,12,16]
输出：2
示例 3：
输入：arr = [100]
输出：1
  提示：
1 <= arr.length <= 4 * 104
0 <= arr[i] <= 109",201,,47016,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/']",['https://leetcode.cn/problems/maximum-subarray/'],99008
评论 (102),distribute-coins-in-binary-tree,中等,"给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。
在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。
返回使每个结点上只有一枚硬币所需的移动次数。
  示例 1：
输入：[3,0,0]
输出：2
解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。
示例 2：
输入：[0,3,0]
输出：3
解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。
示例 3：
输入：[1,0,2]
输出：2
示例 4：
输入：[1,0,0,null,3]
输出：4
  提示：
1<= N <= 100
0 <= node.val <= N",302,,10455,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/sum-of-distances-in-tree/', 'https://leetcode.cn/problems/binary-tree-cameras/']",14535
评论 (217),unique-paths-iii,困难,"在二维网格 grid 上，有 4 种类型的方格：
1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。
每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。
  示例 1：
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
示例 2：
输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
输出：4
解释：我们有以下四条路径： 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
示例 3：
输入：[[0,1],[2,0]]
输出：0
解释：
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。
  提示：
1 <= grid.length * grid[0].length <= 20",203,,17121,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/matrix/']","['https://leetcode.cn/problems/sudoku-solver/', 'https://leetcode.cn/problems/unique-paths-ii/', 'https://leetcode.cn/problems/word-search-ii/']",23242
评论 (306),time-based-key-value-store,中等,"设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。
实现 TimeMap 类：
TimeMap() 初始化数据结构对象
void set(String key, String value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。
String get(String key, int timestamp)
返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev <= timestamp 。
如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。
如果没有值，则返回空字符串（""""）。
  示例：
输入：
[""TimeMap"", ""set"", ""get"", ""get"", ""set"", ""get"", ""get""]
[[], [""foo"", ""bar"", 1], [""foo"", 1], [""foo"", 3], [""foo"", ""bar2"", 4], [""foo"", 4], [""foo"", 5]]
输出：
[null, null, ""bar"", ""bar"", null, ""bar2"", ""bar2""]

解释：
TimeMap timeMap = new TimeMap();
timeMap.set(""foo"", ""bar"", 1);  // 存储键 ""foo"" 和值 ""bar"" ，时间戳 timestamp = 1   
timeMap.get(""foo"", 1);         // 返回 ""bar""
timeMap.get(""foo"", 3);         // 返回 ""bar"", 因为在时间戳 3 和时间戳 2 处没有对应 ""foo"" 的值，所以唯一的值位于时间戳 1 处（即 ""bar""） 。
timeMap.set(""foo"", ""bar2"", 4); // 存储键 ""foo"" 和值 ""bar2"" ，时间戳 timestamp = 4  
timeMap.get(""foo"", 4);         // 返回 ""bar2""
timeMap.get(""foo"", 5);         // 返回 ""bar2""
  提示：
1 <= key.length, value.length <= 100
key 和 value 由小写英文字母和数字组成
1 <= timestamp <= 107
set 操作中的时间戳 timestamp 都是严格递增的
最多调用 set 和 get 操作 2 * 105 次",166,,24054,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-search/']",[],45242
评论 (39),triples-with-bitwise-and-equal-to-zero,困难,"给定一个整数数组 A，找出索引为 (i, j, k) 的三元组，使得：
0 <= i < A.length
0 <= j < A.length
0 <= k < A.length
A[i] & A[j] & A[k] == 0，其中 & 表示按位与（AND）操作符。
  示例：
输入：[2,1,3]
输出：12
解释：我们可以选出如下 i, j, k 三元组：
(i=0, j=0, k=1) : 2 & 2 & 1
(i=0, j=1, k=0) : 2 & 1 & 2
(i=0, j=1, k=1) : 2 & 1 & 1
(i=0, j=1, k=2) : 2 & 1 & 3
(i=0, j=2, k=1) : 2 & 3 & 1
(i=1, j=0, k=0) : 1 & 2 & 2
(i=1, j=0, k=1) : 1 & 2 & 1
(i=1, j=0, k=2) : 1 & 2 & 3
(i=1, j=1, k=0) : 1 & 1 & 2
(i=1, j=2, k=0) : 1 & 3 & 2
(i=2, j=0, k=1) : 3 & 2 & 1
(i=2, j=1, k=0) : 3 & 1 & 2
  提示：
1 <= A.length <= 1000
0 <= A[i] < 2^16",42,,3127,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],5593
评论 (419),minimum-cost-for-tickets,中等,"在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有 三种不同的销售方式 ：
一张 为期一天 的通行证售价为 costs[0] 美元；
一张 为期七天 的通行证售价为 costs[1] 美元；
一张 为期三十天 的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张 为期 7 天 的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回 你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费 。
  示例 1：
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
示例 2：
输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
输出：17
解释：
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 
在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。
在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 
你总共花了 $17，并完成了你计划的每一天旅行。
  提示：
1 <= days.length <= 365
1 <= days[i] <= 365
days 按顺序严格递增
costs.length == 3
1 <= costs[i] <= 1000",456,,36607,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/coin-change/'],57743
评论 (132),string-without-aaa-or-bbb,中等,"给定两个整数 a 和 b ，返回 任意 字符串 s ，要求满足：
s 的长度为 a + b，且正好包含a 个 'a' 字母与 b 个 'b' 字母；
子串 'aaa' 没有出现在 s 中；
子串 'bbb' 没有出现在 s 中。
  示例 1：
输入：a = 1, b = 2
输出：""abb""
解释：""abb"", ""bab"" 和 ""bba"" 都是正确答案。
示例 2：
输入：a = 4, b = 1
输出：""aabaa""
  提示：
0 <= a, b <= 100
对于给定的 a 和 b，保证存在满足要求的 s ",73,,10632,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],25036
评论 (271),sum-of-even-numbers-after-queries,中等,"给出一个整数数组 A 和一个查询数组 queries。
对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。
（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）
返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。
  示例：
输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
输出：[8,6,2,4]
解释：
开始时，数组为 [1,2,3,4]。
将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。
将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。
将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。
将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。
  提示：
1 <= A.length <= 10000
-10000 <= A[i] <= 10000
1 <= queries.length <= 10000
-10000 <= queries[i][0] <= 10000
0 <= queries[i][1] < A.length",71,,17530,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],29013
评论 (283),interval-list-intersections,中等,"给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。
返回这 两个区间列表的交集 。
形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。
两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。
  示例 1：
输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
示例 2：
输入：firstList = [[1,3],[5,9]], secondList = []
输出：[]
示例 3：
输入：firstList = [], secondList = [[4,8],[10,12]]
输出：[]
示例 4：
输入：firstList = [[1,7]], secondList = [[3,10]]
输出：[[3,7]]
  提示：
0 <= firstList.length, secondList.length <= 1000
firstList.length + secondList.length >= 1
0 <= starti < endi <= 109
endi < starti+1
0 <= startj < endj <= 109
endj < startj+1",285,https://assets.leetcode.com/uploads/2019/01/30/interval1.png,44592,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/']","['https://leetcode.cn/problems/merge-intervals/', 'https://leetcode.cn/problems/merge-sorted-array/', 'https://leetcode.cn/problems/employee-free-time/']",65212
评论 (386),vertical-order-traversal-of-a-binary-tree,困难,"给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。
对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。
二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。
返回二叉树的 垂序遍历 序列。
  示例 1：
输入：root = [3,9,20,null,null,15,7]
输出：[[9],[3,15],[20],[7]]
解释：
列 -1 ：只有结点 9 在此列中。
列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列  1 ：只有结点 20 在此列中。
列  2 ：只有结点 7 在此列中。
示例 2：
输入：root = [1,2,3,4,5,6,7]
输出：[[4],[2],[1,5,6],[3],[7]]
解释：
列 -2 ：只有结点 4 在此列中。
列 -1 ：只有结点 2 在此列中。
列  0 ：结点 1 、5 和 6 都在此列中。
          1 在上面，所以它出现在前面。
          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。
列  1 ：只有结点 3 在此列中。
列  2 ：只有结点 7 在此列中。
示例 3：
输入：root = [1,2,3,4,6,5,7]
输出：[[4],[2],[1,5,6],[3],[7]]
解释：
这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。
因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。
  提示：
树中结点数目总数在范围 [1, 1000] 内
0 <= Node.val <= 1000",191,https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg,26928,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-tree/']",[],50397
评论 (150),smallest-string-starting-from-leaf,中等,"给定一颗根结点为 root 的二叉树，树中的每一个结点都有一个 [0, 25] 范围内的值，分别代表字母 'a' 到 'z'。
返回 按字典序最小 的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。
注：字符串中任何较短的前缀在 字典序上 都是 较小 的：
例如，在字典序上 ""ab"" 比 ""aba"" 要小。叶结点是指没有子结点的结点。 
节点的叶节点是没有子节点的节点。
  示例 1：
输入：root = [0,1,2,3,4,3,4]
输出：""dba""
示例 2：
输入：root = [25,1,3,1,3,0,2]
输出：""adz""
示例 3：
输入：root = [2,2,1,null,1,0,null,0]
输出：""abc""
  提示：
给定树的结点数在 [1, 8500] 范围内
0 <= Node.val <= 25",83,,11849,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-tree/']","['https://leetcode.cn/problems/sum-root-to-leaf-numbers/', 'https://leetcode.cn/problems/binary-tree-paths/']",23515
评论 (557),add-to-array-form-of-integer,简单,"整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。
例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。
给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。
  示例 1：
输入：num = [1,2,0,0], k = 34
输出：[1,2,3,4]
解释：1200 + 34 = 1234
示例 2：
输入：num = [2,7,4], k = 181
输出：[4,5,5]
解释：274 + 181 = 455
示例 3：
输入：num = [2,1,5], k = 806
输出：[1,0,2,1]
解释：215 + 806 = 1021
  提示：
1 <= num.length <= 104
0 <= num[i] <= 9
num 不包含任何前导零，除了零本身
1 <= k <= 104",199,,61036,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']","['https://leetcode.cn/problems/add-two-numbers/', 'https://leetcode.cn/problems/plus-one/', 'https://leetcode.cn/problems/add-binary/', 'https://leetcode.cn/problems/add-strings/']",129982
评论 (344),satisfiability-of-equality-equations,中等,"给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：""a==b"" 或 ""a!=b""。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 
  示例 1：
输入：[""a==b"",""b!=a""]
输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
示例 2：
输入：[""b==a"",""a==b""]
输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
示例 3：
输入：[""a==b"",""b==c"",""a==c""]
输出：true
示例 4：
输入：[""a==b"",""b!=c"",""c==a""]
输出：false
示例 5：
输入：[""c==c"",""b==d"",""x!=z""]
输出：true
  提示：
1 <= equations.length <= 500
equations[i].length == 4
equations[i][0] 和 equations[i][3] 是小写字母
equations[i][1] 要么是 '='，要么是 '!'
equations[i][2] 是 '='",236,,41558,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],80063
评论 (107),broken-calculator,中等,"在显示着数字 startValue 的坏计算器上，我们可以执行以下两种操作：
双倍（Double）：将显示屏上的数字乘 2；
递减（Decrement）：将显示屏上的数字减 1 。
给定两个整数 startValue 和 target 。返回显示数字 target 所需的最小操作数。
  示例 1：
输入：startValue = 2, target = 3
输出：2
解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
示例 2：
输入：startValue = 5, target = 8
输出：2
解释：先递减，再双倍 {5 -> 4 -> 8}.
示例 3：
输入：startValue = 3, target = 10
输出：3
解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.
  提示：
1 <= x, y <= 109",147,,10254,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/']",['https://leetcode.cn/problems/2-keys-keyboard/'],19641
评论 (269),subarrays-with-k-different-integers,困难,"给定一个正整数数组 nums和一个整数 k ，返回 num 中 「好子数组」 的数目。
如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。
例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。
子数组 是数组的 连续 部分。
  示例 1：
输入：nums = [1,2,1,2,3], k = 2
输出：7
解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
示例 2：
输入：nums = [1,2,1,3,4], k = 3
输出：3
解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
  提示：
1 <= nums.length <= 2 * 104
1 <= nums[i], k <= nums.length",383,,26721,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/longest-substring-without-repeating-characters/', 'https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/', 'https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/']",57732
评论 (545),cousins-in-binary-tree,简单,"在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。
  示例 1：
输入：root = [1,2,3,4], x = 4, y = 3
输出：false
示例 2：
输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
示例 3：
输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false
  提示：
二叉树的节点数介于 2 到 100 之间。
每个节点的值都是唯一的、范围为 1 到 100 的整数。
 ",268,,57209,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/binary-tree-level-order-traversal/'],102801
评论 (804),rotting-oranges,中等,"在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：
值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。
返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。
  示例 1：
输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
输出：4
示例 2：
输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
示例 3：
输入：grid = [[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 10
grid[i][j] 仅为 0、1 或 2",559,,82050,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/walls-and-gates/'],160776
评论 (246),minimum-number-of-k-consecutive-bit-flips,困难,"给定一个二进制数组 nums 和一个整数 k 。
k位翻转 就是从 nums 中选择一个长度为 k 的 子数组 ，同时把子数组中的每一个 0 都改成 1 ，把子数组中的每一个 1 都改成 0 。
返回数组中不存在 0 所需的最小 k位翻转 次数。如果不可能，则返回 -1 。
子数组 是数组的 连续 部分。
  示例 1：
输入：nums = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
示例 2：
输入：nums = [1,1,0], K = 2
输出：-1
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
示例 3：
输入：nums = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
  提示：
1 <= nums.length <= 105
1 <= k <= nums.length",236,,23120,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",['https://leetcode.cn/problems/bulb-switcher/'],43236
评论 (98),number-of-squareful-arrays,困难,"给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。
返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。
  示例 1：
输入：[1,17,8]
输出：2
解释：
[1,8,17] 和 [17,8,1] 都是有效的排列。
示例 2：
输入：[2,2,2]
输出：1
  提示：
1 <= A.length <= 12
0 <= A[i] <= 1e9",88,,5337,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",['https://leetcode.cn/problems/permutations-ii/'],10905
评论 (674),find-the-town-judge,简单,"小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。
如果小镇法官真的存在，那么：
小镇法官不会信任任何人。
每个人（除了小镇法官）都信任这位小镇法官。
只有一个人同时满足属性 1 和属性 2 。
给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。
如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。
  示例 1：
输入：n = 2, trust = [[1,2]]
输出：2
示例 2：
输入：n = 3, trust = [[1,3],[2,3]]
输出：3
示例 3：
输入：n = 3, trust = [[1,3],[2,3],[3,1]]
输出：-1
  提示：
1 <= n <= 1000
0 <= trust.length <= 104
trust[i].length == 2
trust 中的所有trust[i] = [ai, bi] 互不相同
ai != bi
1 <= ai, bi <= n",249,,72482,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",['https://leetcode.cn/problems/find-the-celebrity/'],136803
评论 (136),maximum-binary-tree-ii,中等,"最大树 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。
给你最大树的根节点 root 和一个整数 val 。
就像 之前的问题 那样，给定的树是利用 Construct(a) 例程从列表 a（root = Construct(a)）递归地构建的：
如果 a 为空，返回 null 。
否则，令 a[i] 作为 a 的最大元素。创建一个值为 a[i] 的根节点 root 。
root 的左子树将被构建为 Construct([a[0], a[1], ..., a[i - 1]]) 。
root 的右子树将被构建为 Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]) 。
返回 root 。
请注意，题目没有直接给出 a ，只是给出一个根节点 root = Construct(a) 。
假设 b 是 a 的副本，并在末尾附加值 val。题目数据保证 b 中的值互不相同。
返回 Construct(b) 。
  示例 1：
输入：root = [4,1,3,null,null,2], val = 5
输出：[5,4,null,1,3,null,null,2]
解释：a = [1,4,2,3], b = [1,4,2,3,5]
示例 2：
输入：root = [5,2,4,null,1], val = 3
输出：[5,2,4,null,1,null,3]
解释：a = [2,1,5,4], b = [2,1,5,4,3]
示例 3：
输入：root = [5,2,3,null,1], val = 4
输出：[5,2,4,null,1,3]
解释：a = [2,1,5,3], b = [2,1,5,3,4]
  提示：
树中节点数目在范围 [1, 100] 内
1 <= Node.val <= 100
树中的所有值 互不相同
1 <= val <= 100
 ",60,,8909,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-tree/']",['https://leetcode.cn/problems/maximum-binary-tree/'],14329
评论 (521),available-captures-for-rook,简单,"在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。
车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：
棋手选择主动停下来。
棋子因到达棋盘的边缘而停下。
棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。
你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。
  示例 1：
输入：[[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""."",""."",""p"",""."",""."",""."","".""],[""."",""."",""."",""R"",""."",""."",""."",""p""],[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""."",""."",""p"",""."",""."",""."","".""],[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""."",""."",""."",""."",""."",""."","".""]]
输出：3
解释：
在本例中，车能够捕获所有的卒。
示例 2：
输入：[[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""p"",""p"",""p"",""p"",""p"",""."","".""],[""."",""p"",""p"",""B"",""p"",""p"",""."","".""],[""."",""p"",""B"",""R"",""B"",""p"",""."","".""],[""."",""p"",""p"",""B"",""p"",""p"",""."","".""],[""."",""p"",""p"",""p"",""p"",""p"",""."","".""],[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""."",""."",""."",""."",""."",""."","".""]]
输出：0
解释：
象阻止了车捕获任何卒。
示例 3：
输入：[[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""."",""."",""p"",""."",""."",""."","".""],[""."",""."",""."",""p"",""."",""."",""."","".""],[""p"",""p"",""."",""R"",""."",""p"",""B"","".""],[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""."",""."",""B"",""."",""."",""."","".""],[""."",""."",""."",""p"",""."",""."",""."","".""],[""."",""."",""."",""."",""."",""."",""."","".""]]
输出：3
解释： 
车可以捕获位置 b5，d6 和 f5 的卒。
  提示：
board.length == board[i].length == 8
board[i][j] 可以是 'R'，'.'，'B' 或 'p'
只有一个格子上存在 board[i][j] == 'R'",98,,32297,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],46703
评论 (45),minimum-cost-to-merge-stones,困难,"有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。
每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。
找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。
  示例 1：
输入：stones = [3,2,4,1], K = 2
输出：20
解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。
示例 2：
输入：stones = [3,2,4,1], K = 3
输出：-1
解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.
示例 3：
输入：stones = [3,5,1,2,6], K = 3
输出：25
解释：
从 [3, 5, 1, 2, 6] 开始。
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
合并 [3, 8, 6]，成本为 17，剩下 [17]。
总成本 25，这是可能的最小值。
  提示：
1 <= stones.length <= 30
2 <= K <= 30
1 <= stones[i] <= 100",176,,4802,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']","['https://leetcode.cn/problems/burst-balloons/', 'https://leetcode.cn/problems/minimum-cost-to-connect-sticks/']",11074
评论 (386),grid-illumination,困难,"在大小为 n x n 的网格 grid 上，每个单元格都有一盏灯，最初灯都处于 关闭 状态。
给你一个由灯的位置组成的二维数组 lamps ，其中 lamps[i] = [rowi, coli] 表示 打开 位于 grid[rowi][coli] 的灯。即便同一盏灯可能在 lamps 中多次列出，不会影响这盏灯处于 打开 状态。
当一盏灯处于打开状态，它将会照亮 自身所在单元格 以及同一 行 、同一 列 和两条 对角线 上的 所有其他单元格 。
另给你一个二维数组 queries ，其中 queries[j] = [rowj, colj] 。对于第 j 个查询，如果单元格 [rowj, colj] 是被照亮的，则查询结果为 1 ，否则为 0 。在第 j 次查询之后 [按照查询的顺序] ，关闭 位于单元格 grid[rowj][colj] 上及相邻 8 个方向上（与单元格 grid[rowi][coli] 共享角或边）的任何灯。
返回一个整数数组 ans 作为答案， ans[j] 应等于第 j 次查询 queries[j] 的结果，1 表示照亮，0 表示未照亮。
  示例 1：
输入：n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
输出：[1,0]
解释：最初所有灯都是关闭的。在执行查询之前，打开位于 [0, 0] 和 [4, 4] 的灯。第 0 次查询检查 grid[1][1] 是否被照亮（蓝色方框）。该单元格被照亮，所以 ans[0] = 1 。然后，关闭红色方框中的所有灯。

第 1 次查询检查 grid[1][0] 是否被照亮（蓝色方框）。该单元格没有被照亮，所以 ans[1] = 0 。然后，关闭红色矩形中的所有灯。
示例 2：
输入：n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]
输出：[1,1]
示例 3：
输入：n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]
输出：[1,1,0]
  提示：
1 <= n <= 109
0 <= lamps.length <= 20000
0 <= queries.length <= 20000
lamps[i].length == 2
0 <= rowi, coli < n
queries[j].length == 2
0 <= rowj, colj < n",143,https://assets.leetcode.com/uploads/2020/08/19/illu_1.jpg,18477,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",['https://leetcode.cn/problems/n-queens/'],41054
评论 (557),find-common-characters,简单,"给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。
  示例 1：
输入：words = [""bella"",""label"",""roller""]
输出：[""e"",""l"",""l""]
示例 2：
输入：words = [""cool"",""lock"",""cook""]
输出：[""c"",""o""]
  提示：
1 <= words.length <= 100
1 <= words[i].length <= 100
words[i] 由小写英文字母组成",274,,66834,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/intersection-of-two-arrays-ii/'],92701
评论 (183),check-if-word-is-valid-after-substitutions,中等,"给你一个字符串 s ，请你判断它是否 有效 。
字符串 s 有效 需要满足：假设开始有一个空字符串 t = """" ，你可以执行 任意次 下述操作将 t 转换为 s ：
将字符串 ""abc"" 插入到 t 中的任意位置。形式上，t 变为 tleft + ""abc"" + tright，其中 t == tleft + tright 。注意，tleft 和 tright 可能为 空 。
如果字符串 s 有效，则返回 true；否则，返回 false。
  示例 1：
输入：s = ""aabcbc""
输出：true
解释：
"""" -> ""abc"" -> ""aabcbc""
因此，""aabcbc"" 有效。
示例 2：
输入：s = ""abcabcababcc""
输出：true
解释：
"""" -> ""abc"" -> ""abcabc"" -> ""abcabcabc"" -> ""abcabcababcc""
因此，""abcabcababcc"" 有效。
示例 3：
输入：s = ""abccba""
输出：false
解释：执行操作无法得到 ""abccba"" 。
  提示：
1 <= s.length <= 2 * 104
s 由字母 'a'、'b' 和 'c' 组成",64,,13869,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",['https://leetcode.cn/problems/valid-parentheses/'],23853
评论 (503),max-consecutive-ones-iii,中等,"给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。
  示例 1：
输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：
输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
  提示：
1 <= nums.length <= 105
nums[i] 不是 0 就是 1
0 <= k <= nums.length",420,,90051,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']","['https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/', 'https://leetcode.cn/problems/longest-repeating-character-replacement/', 'https://leetcode.cn/problems/max-consecutive-ones/', 'https://leetcode.cn/problems/max-consecutive-ones-ii/']",149935
评论 (754),maximize-sum-of-array-after-k-negations,简单,"给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
以这种方式修改数组后，返回数组 可能的最大和 。
  示例 1：
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
示例 2：
输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
示例 3：
输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
  提示：
1 <= nums.length <= 104
-100 <= nums[i] <= 100
1 <= k <= 104",253,,84172,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],163244
评论 (461),clumsy-factorial,中等,"通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。
相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。
例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。
另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。
实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。
  示例 1：
输入：4
输出：7
解释：7 = 4 * 3 / 2 + 1
示例 2：
输入：10
输出：12
解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1
  提示：
1 <= N <= 10000
-2^31 <= answer <= 2^31 - 1  （答案保证符合 32 位整数。）",157,,45859,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],73148
评论 (92),minimum-domino-rotations-for-equal-row,中等,"在一排多米诺骨牌中，A[i] 和 B[i] 分别代表第 i 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 1 到 6 的数字同列平铺形成的 —— 该平铺的每一半上都有一个数字。）
我们可以旋转第 i 张多米诺，使得 A[i] 和 B[i] 的值交换。
返回能使 A 中所有值或者 B 中所有值都相同的最小旋转次数。
如果无法做到，返回 -1.
  示例 1：
输入：A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
输出：2
解释：
图一表示：在我们旋转之前， A 和 B 给出的多米诺牌。
如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。
示例 2：
输入：A = [3,5,1,2,3], B = [3,6,3,3,4]
输出：-1
解释：
在这种情况下，不可能旋转多米诺牌使一行的值相等。
  提示：
1 <= A[i], B[i] <= 6
2 <= A.length == B.length <= 20000",95,,7518,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],15931
评论 (251),construct-binary-search-tree-from-preorder-traversal,中等,"给定一个整数数组，它表示BST(即 二叉搜索树 )的 先序遍历 ，构造树并返回其根。
保证 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。
二叉搜索树 是一棵二叉树，其中每个节点， Node.left 的任何后代的值 严格小于 Node.val , Node.right 的任何后代的值 严格大于 Node.val。
二叉树的 前序遍历 首先显示节点的值，然后遍历Node.left，最后遍历Node.right。
  示例 1：
输入：preorder = [8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]
示例 2:
输入: preorder = [1,3]
输出: [1,null,3]
  提示：
1 <= preorder.length <= 100
1 <= preorder[i] <= 10^8
preorder 中的值 互不相同
 ",218,,22526,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/monotonic-stack/']",[],31226
评论 (257),complement-of-base-10-integer,简单,"每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 ""101""，11 可以用二进制 ""1011"" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。
二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 ""101"" 的二进制反码为 ""010""。
给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。
  示例 1：
输入：5
输出：2
解释：5 的二进制表示为 ""101""，其二进制反码为 ""010""，也就是十进制中的 2 。
示例 2：
输入：7
输出：0
解释：7 的二进制表示为 ""111""，其二进制反码为 ""000""，也就是十进制中的 0 。
示例 3：
输入：10
输出：5
解释：10 的二进制表示为 ""1010""，其二进制反码为 ""0101""，也就是十进制中的 5 。
  提示：
0 <= N < 10^9
本题与 476：https://leetcode-cn.com/problems/number-complement/ 相同",75,,18926,['https://leetcode.cn/tag/bit-manipulation/'],[],32082
评论 (185),pairs-of-songs-with-total-durations-divisible-by-60,中等,"在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。
返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望下标数字 i 和 j 满足  i < j 且有 (time[i] + time[j]) % 60 == 0。
  示例 1：
输入：time = [30,20,150,100,40]
输出：3
解释：这三对的总持续时间可被 60 整除：
(time[0] = 30, time[2] = 150): 总持续时间 180
(time[1] = 20, time[3] = 100): 总持续时间 120
(time[1] = 20, time[4] = 40): 总持续时间 60
示例 2：
输入：time = [60,60,60]
输出：3
解释：所有三对的总持续时间都是 120，可以被 60 整除。
  提示：
1 <= time.length <= 6 * 104
1 <= time[i] <= 500",178,,20596,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],44955
评论 (454),capacity-to-ship-packages-within-d-days,中等,"传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。
传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。
  示例 1：
输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 
示例 2：
输入：weights = [3,2,2,4,1,4], days = 3
输出：6
解释：
船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4
示例 3：
输入：weights = [1,2,3,1,1], days = 4
输出：3
解释：
第 1 天：1
第 2 天：2
第 3 天：3
第 4 天：1, 1
  提示：
1 <= days <= weights.length <= 5 * 104
1 <= weights[i] <= 500",468,,76097,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],122677
评论 (85),numbers-with-repeated-digits,困难,"给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。
  示例 1：
输入：n = 20
输出：1
解释：具有至少 1 位重复数字的正数（<= 20）只有 11 。
示例 2：
输入：n = 100
输出：10
解释：具有至少 1 位重复数字的正数（<= 100）有 11，22，33，44，55，66，77，88，99 和 100 。
示例 3：
输入：n = 1000
输出：262
  提示：
1 <= n <= 109",101,,3916,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],10904
评论 (595),partition-array-into-three-parts-with-equal-sum,简单,"给你一个整数数组 arr，只有可以将其划分为三个和相等的 非空 部分时才返回 true，否则返回 false。
形式上，如果可以找出索引 i + 1 < j 且满足 (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]) 就可以将数组三等分。
  示例 1：
输入：arr = [0,2,1,-6,6,-7,9,1,2,0,1]
输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
示例 2：
输入：arr = [0,2,1,-6,6,7,9,-1,2,0,1]
输出：false
示例 3：
输入：arr = [3,3,6,5,-2,2,5,1,-9,4]
输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
  提示：
3 <= arr.length <= 5 * 104
-104 <= arr[i] <= 104",173,,52515,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],134177
评论 (404),best-sightseeing-pair,中等,"给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。
一对景点（i < j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。
返回一对观光景点能取得的最高分。
  示例 1：
输入：values = [8,1,5,2,6]
输出：11
解释：i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11
示例 2：
输入：values = [1,2]
输出：2
  提示：
2 <= values.length <= 5 * 104
1 <= values[i] <= 1000",313,,53552,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],94825
评论 (72),smallest-integer-divisible-by-k,中等,"给定正整数 k ，你需要找出可以被 k 整除的、仅包含数字 1 的最 小 正整数 n 的长度。
返回 n 的长度。如果不存在这样的 n ，就返回-1。
注意： n 不符合 64 位带符号整数。
  示例 1：
输入：k = 1
输出：1
解释：最小的答案是 n = 1，其长度为 1。
示例 2：
输入：k = 2
输出：-1
解释：不存在可被 2 整除的正整数 n 。
示例 3：
输入：k = 3
输出：3
解释：最小的答案是 n = 111，其长度为 3。
  提示：
1 <= k <= 105",51,,5840,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/']",[],16051
评论 (82),binary-string-with-substrings-representing-1-to-n,中等,"给定一个二进制字符串 s 和一个正整数 n，如果对于 [1, n] 范围内的每个整数，其二进制表示都是 s 的 子字符串 ，就返回 true，否则返回 false 。
子字符串 是字符串中连续的字符序列。
  示例 1：
输入：s = ""0110"", n = 3
输出：true
示例 2：
输入：s = ""0110"", n = 4
输出：false
  提示：
1 <= s.length <= 1000
s[i] 不是 '0' 就是 '1'
1 <= n <= 109",38,,6371,['https://leetcode.cn/tag/string/'],[],10952
评论 (40),convert-to-base-2,中等,"给出数字 N，返回由若干 ""0"" 和 ""1""组成的字符串，该字符串为 N 的负二进制（base -2）表示。
除非字符串就是 ""0""，否则返回的字符串中不能含有前导零。
  示例 1：
输入：2
输出：""110""
解释：(-2) ^ 2 + (-2) ^ 1 = 2
示例 2：
输入：3
输出：""111""
解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3
示例 3：
输入：4
输出：""100""
解释：(-2) ^ 2 = 4
  提示：
0 <= N <= 10^9",53,,4205,['https://leetcode.cn/tag/math/'],['https://leetcode.cn/problems/encode-number/'],7447
评论 (444),binary-prefix-divisible-by-5,简单,"给定一个二进制数组 nums ( 索引从0开始 )。
我们将xi 定义为其二进制表示形式为子数组 nums[0..i] (从最高有效位到最低有效位)。
例如，如果 nums =[1,0,1] ，那么 x0 = 1, x1 = 2, 和 x2 = 5。
返回布尔值列表 answer，只有当 xi 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。
  示例 1：
输入：nums = [0,1,1]
输出：[true,false,false]
解释：
输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为 true 。
示例 2：
输入：nums = [1,1,1]
输出：[false,false,false]
  提示：
1 <= nums.length <= 105 
nums[i] 仅为 0 或 1",139,,46483,['https://leetcode.cn/tag/array/'],[],90444
评论 (226),next-greater-node-in-linked-list,中等,"给定一个长度为 n 的链表 head
对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。
返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。
  示例 1：
输入：head = [2,1,5]
输出：[5,5,0]
示例 2：
输入：head = [2,7,4,3,5]
输出：[7,0,5,5,0]
  提示：
链表中节点数为 n
1 <= n <= 104
1 <= Node.val <= 109",199,,25108,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/monotonic-stack/']",[],41465
评论 (395),number-of-enclaves,中等,"给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。
一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。
返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。
  示例 1：
输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
示例 2：
输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：所有 1 都在边界上或可以到达边界。
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 500
grid[i][j] 的值为 0 或 1",172,https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg,43567,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],71121
评论 (487),remove-outermost-parentheses,简单,"有效括号字符串为空 """"、""("" + A + "")"" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。
例如，""""，""()""，""(())()"" 和 ""(()(()))"" 都是有效的括号字符串。
如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。
给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。
对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。
  示例 1：
输入：s = ""(()())(())""
输出：""()()()""
解释：
输入字符串为 ""(()())(())""，原语化分解得到 ""(()())"" + ""(())""，
删除每个部分中的最外层括号后得到 ""()()"" + ""()"" = ""()()()""。
示例 2：
输入：s = ""(()())(())(()(()))""
输出：""()()()()(())""
解释：
输入字符串为 ""(()())(())(()(()))""，原语化分解得到 ""(()())"" + ""(())"" + ""(()(()))""，
删除每个部分中的最外层括号后得到 ""()()"" + ""()"" + ""()(())"" = ""()()()()(())""。
示例 3：
输入：s = ""()()""
输出：""""
解释：
输入字符串为 ""()()""，原语化分解得到 ""()"" + ""()""，
删除每个部分中的最外层括号后得到 """" + """" = """"。
  提示：
1 <= s.length <= 105
s[i] 为 '(' 或 ')'
s 是一个有效括号字符串",199,,63737,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],81185
评论 (239),sum-of-root-to-leaf-binary-numbers,简单,"给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。
例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。
对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。
返回这些数字之和。题目数据保证答案是一个 32 位 整数。
  示例 1：
输入：root = [1,0,1,0,1,0,1]
输出：22
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
示例 2：
输入：root = [0]
输出：0
  提示：
树中的节点数在 [1, 1000] 范围内
Node.val 仅为 0 或 1 ",144,https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png,24290,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],34001
评论 (143),camelcase-matching,中等,"如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。）
给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。
  示例 1：
输入：queries = [""FooBar"",""FooBarTest"",""FootBall"",""FrameBuffer"",""ForceFeedBack""], pattern = ""FB""
输出：[true,false,true,true,false]
示例：
""FooBar"" 可以这样生成：""F"" + ""oo"" + ""B"" + ""ar""。
""FootBall"" 可以这样生成：""F"" + ""oot"" + ""B"" + ""all"".
""FrameBuffer"" 可以这样生成：""F"" + ""rame"" + ""B"" + ""uffer"".
示例 2：
输入：queries = [""FooBar"",""FooBarTest"",""FootBall"",""FrameBuffer"",""ForceFeedBack""], pattern = ""FoBa""
输出：[true,false,true,false,false]
解释：
""FooBar"" 可以这样生成：""Fo"" + ""o"" + ""Ba"" + ""r"".
""FootBall"" 可以这样生成：""Fo"" + ""ot"" + ""Ba"" + ""ll"".
示例 3：
输出：queries = [""FooBar"",""FooBarTest"",""FootBall"",""FrameBuffer"",""ForceFeedBack""], pattern = ""FoBaT""
输入：[false,true,false,false,false]
解释： 
""FooBarTest"" 可以这样生成：""Fo"" + ""o"" + ""Ba"" + ""r"" + ""T"" + ""est"".
  提示：
1 <= queries.length <= 100
1 <= queries[i].length <= 100
1 <= pattern.length <= 100
所有字符串都仅由大写和小写英文字母组成。",44,,8614,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/']",[],15132
评论 (342),video-stitching,中等,"你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。
使用数组 clips 描述所有的视频片段，其中 clips[i] = [starti, endi] 表示：某个视频片段开始于 starti 并于 endi 结束。
甚至可以对这些片段自由地再剪辑：
例如，片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。
我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。
  示例 1：
输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10
输出：3
解释：
选中 [0,2], [8,10], [1,9] 这三个片段。
然后，按下面的方案重制比赛片段：
将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。
现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。
示例 2：
输入：clips = [[0,1],[1,2]], time = 5
输出：-1
解释：
无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。
示例 3：
输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9
输出：3
解释： 
选取片段 [0,4], [4,7] 和 [6,9] 。
  提示：
1 <= clips.length <= 100
0 <= starti <= endi <= 100
1 <= time <= 100",279,,38199,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],69931
评论 (628),divisor-game,简单,"爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。
最初，黑板上有一个数字 n 。在每个玩家的回合，玩家需要执行以下操作：
选出任一 x，满足 0 < x < n 且 n % x == 0 。
用 n - x 替换黑板上的数字 n 。
如果玩家无法执行这些操作，就会输掉游戏。
只有在爱丽丝在游戏中取得胜利时才返回 true 。假设两个玩家都以最佳状态参与游戏。
  示例 1：
输入：n = 2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
示例 2：
输入：n = 3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
  提示：
1 <= n <= 1000",356,,84936,"['https://leetcode.cn/tag/brainteaser/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",[],120019
评论 (169),maximum-difference-between-node-and-ancestor,中等,"给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。
（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）
  示例 1：
输入：root = [8,3,10,1,6,null,14,null,null,4,7,13]
输出：7
解释： 
我们有大量的节点与其祖先的差值，其中一些如下：
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。
示例 2：
输入：root = [1,null,2,null,0,3]
输出：3
  提示：
树中的节点数在 2 到 5000 之间。
0 <= Node.val <= 105",116,https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg,12152,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],17772
评论 (147),longest-arithmetic-subsequence,中等,"给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。
回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], ..., nums[ik] ，且 0 <= i1 < i2 < ... < ik <= nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 <= i < seq.length - 1) 的值都相同，那么序列 seq 是等差的。
  示例 1：
输入：nums = [3,6,9,12]
输出：4
解释： 
整个数组是公差为 3 的等差数列。
示例 2：
输入：nums = [9,4,7,2,10]
输出：3
解释：
最长的等差子序列是 [4,7,10]。
示例 3：
输入：nums = [20,1,15,3,10,5,8]
输出：4
解释：
最长的等差子序列是 [20,15,10,5]。
  提示：
2 <= nums.length <= 1000
0 <= nums[i] <= 500",190,,17273,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],39667
评论 (304),recover-a-tree-from-preorder-traversal,困难,"我们从二叉树的根节点 root 开始进行深度优先搜索。
在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。
如果节点只有一个子节点，那么保证该子节点为左子节点。
给出遍历输出 S，还原树并返回其根节点 root。
  示例 1：
输入：""1-2--3--4-5--6--7""
输出：[1,2,5,3,4,6,7]
示例 2：
输入：""1-2--3---4-5--6---7""
输出：[1,2,5,3,null,6,null,4,null,7]
示例 3：
输入：""1-401--349---90--88""
输出：[1,401,null,349,88,90]
  提示：
原始树中的节点数介于 1 和 1000 之间。
每个节点的值介于 1 和 10 ^ 9 之间。",212,,22634,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-tree/']",[],31033
评论 (214),two-city-scheduling,中等,"公司计划面试 2n 人。给你一个数组 costs ，其中 costs[i] = [aCosti, bCosti] 。第 i 人飞往 a 市的费用为 aCosti ，飞往 b 市的费用为 bCosti 。
返回将每个人都飞到 a 、b 中某座城市的最低费用，要求每个城市都有 n 人抵达。
  示例 1：
输入：costs = [[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 a 市，费用为 10。
第二个人去 a 市，费用为 30。
第三个人去 b 市，费用为 50。
第四个人去 b 市，费用为 20。

最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
示例 2：
输入：costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]
输出：1859
示例 3：
输入：costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]
输出：3086
  提示：
2 * n == costs.length
2 <= costs.length <= 100
costs.length 为偶数
1 <= aCosti, bCosti <= 1000",251,,19800,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],29559
评论 (393),matrix-cells-in-distance-order,简单,"给定四个整数 row ,   cols ,  rCenter 和 cCenter 。有一个 rows x cols 的矩阵，你在单元格上的坐标是 (rCenter, cCenter) 。
返回矩阵中的所有单元格的坐标，并按与 (rCenter, cCenter) 的 距离 从最小到最大的顺序排。你可以按 任何 满足此条件的顺序返回答案。
单元格(r1, c1) 和 (r2, c2) 之间的距离为|r1 - r2| + |c1 - c2|。
  示例 1：
输入：rows = 1, cols = 2, rCenter = 0, cCenter = 0
输出：[[0,0],[0,1]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1]
示例 2：
输入：rows = 2, cols = 2, rCenter = 0, cCenter = 1
输出：[[0,1],[0,0],[1,1],[1,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]
[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。
示例 3：
输入：rows = 2, cols = 3, rCenter = 1, cCenter = 2
输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]
其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。
  提示：
1 <= rows, cols <= 100
0 <= rCenter < rows
0 <= cCenter < cols",127,,43427,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/sorting/']",[],61244
评论 (80),maximum-sum-of-two-non-overlapping-subarrays,中等,"给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）
从形式上看，返回最大的 V，而 V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) 并满足下列条件之一：
  0 <= i < i + L - 1 < j < j + M - 1 < A.length, 或
0 <= j < j + M - 1 < i < i + L - 1 < A.length.
  示例 1：
输入：A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
输出：20
解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。
示例 2：
输入：A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
输出：29
解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。
示例 3：
输入：A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3
输出：31
解释：子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。
  提示：
L >= 1
M >= 1
L + M <= A.length <= 1000
0 <= A[i] <= 1000",128,,6837,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/']",[],11697
评论 (64),stream-of-characters,困难,"设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组 words 中的一个字符串。
例如，words = [""abc"", ""xyz""] 且字符流中逐个依次加入 4 个字符 'a'、'x'、'y' 和 'z' ，你所设计的算法应当可以检测到 ""axyz"" 的后缀 ""xyz"" 与 words 中的字符串 ""xyz"" 匹配。
按下述要求实现 StreamChecker 类：
StreamChecker(String[] words) ：构造函数，用字符串数组 words 初始化数据结构。
boolean query(char letter)：从字符流中接收一个新字符，如果字符流中的任一非空后缀能匹配 words 中的某一字符串，返回 true ；否则，返回 false。
  示例：
输入：
[""StreamChecker"", ""query"", ""query"", ""query"", ""query"", ""query"", ""query"", ""query"", ""query"", ""query"", ""query"", ""query"", ""query""]
[[[""cd"", ""f"", ""kl""]], [""a""], [""b""], [""c""], [""d""], [""e""], [""f""], [""g""], [""h""], [""i""], [""j""], [""k""], [""l""]]
输出：
[null, false, false, false, true, false, true, false, false, false, false, false, true]

解释：
StreamChecker streamChecker = new StreamChecker([""cd"", ""f"", ""kl""]);
streamChecker.query(""a""); // 返回 False
streamChecker.query(""b""); // 返回 False
streamChecker.query(""c""); // 返回n False
streamChecker.query(""d""); // 返回 True ，因为 'cd' 在 words 中
streamChecker.query(""e""); // 返回 False
streamChecker.query(""f""); // 返回 True ，因为 'f' 在 words 中
streamChecker.query(""g""); // 返回 False
streamChecker.query(""h""); // 返回 False
streamChecker.query(""i""); // 返回 False
streamChecker.query(""j""); // 返回 False
streamChecker.query(""k""); // 返回 False
streamChecker.query(""l""); // 返回 True ，因为 'kl' 在 words 中
  提示：
1 <= words.length <= 2000
1 <= words[i].length <= 2000
words[i] 由小写英文字母组成
letter 是一个小写英文字母
最多调用查询 4 * 104 次",82,,3472,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/data-stream/']",[],8072
评论 (149),moving-stones-until-consecutive,中等,"三枚石子放置在数轴上，位置分别为 a，b，c。
每一回合，你可以从两端之一拿起一枚石子（位置最大或最小），并将其放入两端之间的任一空闲位置。形式上，假设这三枚石子当前分别位于位置 x, y, z 且 x < y < z。那么就可以从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x < k < z 且 k != y。
当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。
要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]
  示例 1：
输入：a = 1, b = 2, c = 5
输出：[1, 2]
解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。
示例 2：
输入：a = 4, b = 3, c = 2
输出：[0, 0]
解释：我们无法进行任何移动。
  提示：
1 <= a <= 100
1 <= b <= 100
1 <= c <= 100
a != b, b != c, c != a",43,,12118,"['https://leetcode.cn/tag/brainteaser/', 'https://leetcode.cn/tag/math/']",[],30452
评论 (537),coloring-a-border,中等,"给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
两个网格块属于同一 连通分量 需满足下述全部条件：
两个网格块颜色相同
在上、下、左、右任意一个方向上相邻
连通分量的边界 是指连通分量中满足下述条件之一的所有网格块：
在上、下、左、右任意一个方向上与不属于同一连通分量的网格块相邻
在网格的边界上（第一行/列或最后一行/列）
请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。
  示例 1：
输入：grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出：[[3,3],[3,2]]
示例 2：
输入：grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出：[[1,3,3],[2,3,3]]
示例 3：
输入：grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
输出：[[2,2,2],[2,1,2],[2,2,2]]
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 50
1 <= grid[i][j], color <= 1000
0 <= row < m
0 <= col < n
 ",146,,30218,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/island-perimeter/'],54441
评论 (346),uncrossed-lines,中等,"在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
以这种方法绘制线条，并返回可以绘制的最大连线数。
  示例 1：
输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
示例 2：
输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3
示例 3：
输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2
  提示：
1 <= nums1.length, nums2.length <= 500
1 <= nums1[i], nums2[j] <= 2000
 ",316,https://assets.leetcode.com/uploads/2019/04/26/142.png,50432,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/edit-distance/'],75522
评论 (260),escape-a-large-maze,困难,"在一个 106 x 106 的网格中，每个网格上方格的坐标为 (x, y) 。
现在从源方格 source = [sx, sy] 开始出发，意图赶往目标方格 target = [tx, ty] 。数组 blocked 是封锁的方格列表，其中每个 blocked[i] = [xi, yi] 表示坐标为 (xi, yi) 的方格是禁止通行的。
每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 不 在给出的封锁列表 blocked 上。同时，不允许走出网格。
只有在可以通过一系列的移动从源方格 source 到达目标方格 target 时才返回 true。否则，返回 false。
  示例 1：
输入：blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
输出：false
解释：
从源方格无法到达目标方格，因为我们无法在网格中移动。
无法向北或者向东移动是因为方格禁止通行。
无法向南或者向西移动是因为不能走出网格。
示例 2：
输入：blocked = [], source = [0,0], target = [999999,999999]
输出：true
解释：
因为没有方格被封锁，所以一定可以到达目标方格。
  提示：
0 <= blocked.length <= 200
blocked[i].length == 2
0 <= xi, yi < 106
source.length == target.length == 2
0 <= sx, sy, tx, ty < 106
source != target
题目数据保证 source 和 target 不在封锁列表内",179,,19145,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],40849
评论 (151),valid-boomerang,简单,"给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。
回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。
  示例 1：
输入：points = [[1,1],[2,3],[3,2]]
输出：true
示例 2：
输入：points = [[1,1],[2,2],[3,3]]
输出：false
  提示：
points.length == 3
points[i].length == 2
0 <= xi, yi <= 100",32,,11989,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],27373
评论 (291),binary-search-tree-to-greater-sum-tree,中等,"给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。
提醒一下， 二叉搜索树 满足下列约束条件：
节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。
  示例 1：
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
示例 2：
输入：root = [0,null,1]
输出：[1,null,1]
  提示：
树中的节点数在 [1, 100] 范围内。
0 <= Node.val <= 100
树中的所有值均 不重复 。
  注意：该题目与 538: https://leetcode-cn.com/problems/convert-bst-to-greater-tree/  相同",167,,33911,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",[],42209
评论 (59),minimum-score-triangulation-of-polygon,中等,"你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。
假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。
返回 多边形进行三角剖分后可以得到的最低分 。
  示例 1：
输入：values = [1,2,3]
输出：6
解释：多边形已经三角化，唯一三角形的分数为 6。
示例 2：
输入：values = [3,7,4,5]
输出：144
解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。
示例 3：
输入：values = [1,3,1,4,1,5]
输出：13
解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。
  提示：
n == values.length
3 <= n <= 50
1 <= values[i] <= 100",114,,5687,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],9999
评论 (41),moving-stones-until-consecutive-ii,中等,"在一个长度 无限 的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作 端点石子 。
每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。
值得注意的是，如果石子像 stones = [1,2,5] 这样，你将 无法 移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。
当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。
要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。
  示例 1：
输入：[7,4,9]
输出：[1,2]
解释：
我们可以移动一次，4 -> 8，游戏结束。
或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。
示例 2：
输入：[6,5,4,3,10]
输出：[2,3]
解释：
我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。
或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。
注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。
示例 3：
输入：[100,101,104,102,103]
输出：[0,0]
  提示：
3 <= stones.length <= 10^4
1 <= stones[i] <= 10^9
stones[i] 的值各不相同。
 ",76,,3061,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],5845
评论 (122),robot-bounded-in-circle,中等,"在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。注意:
北方向 是y轴的正方向。
南方向 是y轴的负方向。
东方向 是x轴的正方向。
西方向 是x轴的负方向。
机器人可以接受下列三条指令之一：
""G""：直走 1 个单位
""L""：左转 90 度
""R""：右转 90 度
机器人按顺序执行指令 instructions，并一直重复它们。
只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。
  示例 1：
输入：instructions = ""GGLLGG""
输出：true
解释：机器人最初在(0,0)处，面向北方。
“G”:移动一步。位置:(0,1)方向:北。
“G”:移动一步。位置:(0,2).方向:北。
“L”:逆时针旋转90度。位置:(0,2).方向:西。
“L”:逆时针旋转90度。位置:(0,2)方向:南。
“G”:移动一步。位置:(0,1)方向:南。
“G”:移动一步。位置:(0,0)方向:南。
重复指令，机器人进入循环:(0,0)——>(0,1)——>(0,2)——>(0,1)——>(0,0)。
在此基础上，我们返回true。
示例 2：
输入：instructions = ""GG""
输出：false
解释：机器人最初在(0,0)处，面向北方。
“G”:移动一步。位置:(0,1)方向:北。
“G”:移动一步。位置:(0,2).方向:北。
重复这些指示，继续朝北前进，不会进入循环。
在此基础上，返回false。
示例 3：
输入：instructions = ""GL""
输出：true
解释：机器人最初在(0,0)处，面向北方。
“G”:移动一步。位置:(0,1)方向:北。
“L”:逆时针旋转90度。位置:(0,1).方向:西。
“G”:移动一步。位置:(- 1,1)方向:西。
“L”:逆时针旋转90度。位置:(- 1,1)方向:南。
“G”:移动一步。位置:(- 1,0)方向:南。
“L”:逆时针旋转90度。位置:(- 1,0)方向:东方。
“G”:移动一步。位置:(0,0)方向:东方。
“L”:逆时针旋转90度。位置:(0,0)方向:北。
重复指令，机器人进入循环:(0,0)——>(0,1)——>(- 1,1)——>(- 1,0)——>(0,0)。
在此基础上，我们返回true。
  提示：
1 <= instructions.length <= 100
instructions[i] 仅包含 'G', 'L', 'R'",116,,8976,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],18056
评论 (155),flower-planting-with-no-adjacent,中等,"有 n 个花园，按从 1 到 n 标记。另有数组 paths ，其中 paths[i] = [xi, yi] 描述了花园 xi 到花园 yi 的双向路径。在每个花园中，你打算种下四种花之一。
另外，所有花园 最多 有 3 条路径可以进入或离开.
你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。
以数组形式返回 任一 可行的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用  1、2、3、4 表示。保证存在答案。
  示例 1：
输入：n = 3, paths = [[1,2],[2,3],[3,1]]
输出：[1,2,3]
解释：
花园 1 和 2 花的种类不同。
花园 2 和 3 花的种类不同。
花园 3 和 1 花的种类不同。
因此，[1,2,3] 是一个满足题意的答案。其他满足题意的答案有 [1,2,4]、[1,4,2] 和 [3,2,1]
示例 2：
输入：n = 4, paths = [[1,2],[3,4]]
输出：[1,2,1,2]
示例 3：
输入：n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
输出：[1,2,3,4]
  提示：
1 <= n <= 104
0 <= paths.length <= 2 * 104
paths[i].length == 2
1 <= xi, yi <= n
xi != yi
每个花园 最多 有 3 条路径可以进入或离开",125,,13984,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/']",[],25663
评论 (125),partition-array-for-maximum-sum,中等,"给你一个整数数组 arr，请你将该数组分隔为长度最多为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。
返回将数组分隔变换后能够得到的元素最大和。
  注意，原数组和分隔后的数组对应顺序应当一致，也就是说，你只能选择分隔数组的位置而不能调整数组中的顺序。
  示例 1：
输入：arr = [1,15,7,9,2,5,10], k = 3
输出：84
解释：
因为 k=3 可以分隔成 [1,15,7] [9] [2,5,10]，结果为 [15,15,15,9,10,10,10]，和为 84，是该数组所有分隔变换后元素总和最大的。
若是分隔成 [1] [15,7,9] [2,5,10]，结果就是 [1, 15, 15, 15, 10, 10, 10] 但这种分隔方式的元素总和（76）小于上一种。 
示例 2：
输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
输出：83
示例 3：
输入：arr = [1], k = 1
输出：1
  提示：
1 <= arr.length <= 500
0 <= arr[i] <= 109
1 <= k <= arr.length",140,,9545,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],13642
评论 (338),longest-duplicate-substring,困难,"给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。
返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 """" 。
  示例 1：
输入：s = ""banana""
输出：""ana""
示例 2：
输入：s = ""abcd""
输出：""""
  提示：
2 <= s.length <= 3 * 104
s 由小写英文字母组成",321,,23501,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/suffix-array/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],67012
评论 (210),customers-who-bought-all-products,Unknown,,-1,,-1,[],[],-1
评论 (660),last-stone-weight,简单,"有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
  示例：
输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
  提示：
1 <= stones.length <= 30
1 <= stones[i] <= 1000",211,,75272,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],114505
评论 (818),remove-all-adjacent-duplicates-in-string,简单,"给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
在 S 上反复执行重复项删除操作，直到无法继续删除。
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
  示例：
输入：""abbaca""
输出：""ca""
解释：
例如，在 ""abbaca"" 中，我们可以删除 ""bb"" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 ""aaca""，其中又只有 ""aa"" 可以执行重复项删除操作，所以最后的字符串为 ""ca""。
  提示：
1 <= S.length <= 20000
S 仅由小写英文字母组成。",379,,153134,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],210812
评论 (119),longest-string-chain,中等,"给出一个单词数组 words ，其中每个单词都由小写英文字母组成。
如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的 前身 。
例如，""abc"" 是 ""abac"" 的 前身 ，而 ""cba"" 不是 ""bcad"" 的 前身
词链是单词 [word_1, word_2, ..., word_k] 组成的序列，k >= 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k == 1 的 单词链 。
从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。
  示例 1：
输入：words = [""a"",""b"",""ba"",""bca"",""bda"",""bdca""]
输出：4
解释：最长单词链之一为 [""a"",""ba"",""bda"",""bdca""]
示例 2:
输入：words = [""xbc"",""pcxbcf"",""xb"",""cxbc"",""pcxbc""]
输出：5
解释：所有的单词都可以放入单词链 [""xb"", ""xbc"", ""cxbc"", ""pcxbc"", ""pcxbcf""].
示例 3:
输入：words = [""abcd"",""dbqca""]
输出：1
解释：字链[""abcd""]是最长的字链之一。
[""abcd""，""dbqca""]不是一个有效的单词链，因为字母的顺序被改变了。
  提示：
1 <= words.length <= 1000
1 <= words[i].length <= 16
words[i] 仅由小写英文字母组成。",174,,13604,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],28627
评论 (425),last-stone-weight-ii,中等,"有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。
每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
  示例 1：
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
示例 2：
输入：stones = [31,26,33,21,40]
输出：5
  提示：
1 <= stones.length <= 30
1 <= stones[i] <= 100",457,,70979,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],105510
评论 (139),actors-and-directors-who-cooperated-at-least-three-times,简单,"SQL架构
ActorDirector 表：
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| actor_id    | int     |
| director_id | int     |
| timestamp   | int     |
+-------------+---------+
timestamp 是这张表的主键.
  写一条SQL查询语句获取合作过至少三次的演员和导演的 id 对 (actor_id, director_id)
示例：
ActorDirector 表：
+-------------+-------------+-------------+
| actor_id    | director_id | timestamp   |
+-------------+-------------+-------------+
| 1           | 1           | 0           |
| 1           | 1           | 1           |
| 1           | 1           | 2           |
| 1           | 2           | 3           |
| 1           | 2           | 4           |
| 2           | 1           | 5           |
| 2           | 1           | 6           |
+-------------+-------------+-------------+

Result 表：
+-------------+-------------+
| actor_id    | director_id |
+-------------+-------------+
| 1           | 1           |
+-------------+-------------+
唯一的 id 对是 (1, 1)，他们恰好合作了 3 次。",36,,21326,['https://leetcode.cn/tag/database/'],[],27657
评论 (328),height-checker,简单,"学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。
排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。
给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。
返回满足 heights[i] != expected[i] 的 下标数量 。
  示例：
输入：heights = [1,1,4,2,1,3]
输出：3 
解释：
高度：[1,1,4,2,1,3]
预期：[1,1,1,2,3,4]
下标 2 、4 、5 处的学生高度不匹配。
示例 2：
输入：heights = [5,1,2,3,4]
输出：5
解释：
高度：[5,1,2,3,4]
预期：[1,2,3,4,5]
所有下标的对应学生高度都不匹配。
示例 3：
输入：heights = [1,2,3,4,5]
输出：0
解释：
高度：[1,2,3,4,5]
预期：[1,2,3,4,5]
所有下标的对应学生高度都匹配。
  提示：
1 <= heights.length <= 100
1 <= heights[i] <= 100",103,,35727,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/counting-sort/', 'https://leetcode.cn/tag/sorting/']",[],47063
评论 (641),grumpy-bookstore-owner,中等,"有一个书店老板，他的书店开了 n 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 n 的整数数组 customers ，其中 customers[i] 是在第 i 分钟开始时进入商店的顾客数量，所有这些顾客在第 i 分钟结束后离开。
在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。
当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。
书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 minutes 分钟不生气，但却只能使用一次。
请你返回 这一天营业下来，最多有多少客户能够感到满意 。
  示例 1：
输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
输出：16
解释：书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
示例 2：
输入：customers = [1], grumpy = [0], minutes = 1
输出：1
  提示：
n == customers.length == grumpy.length
1 <= minutes <= n <= 2 * 104
0 <= customers[i] <= 1000
grumpy[i] == 0 or 1",222,,54848,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/']",[],94367
评论 (117),previous-permutation-with-one-swap,中等,"给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。
如果无法这么操作，就请返回原数组。
  示例 1：
输入：arr = [3,2,1]
输出：[3,1,2]
解释：交换 2 和 1
示例 2：
输入：arr = [1,1,5]
输出：[1,1,5]
解释：已经是最小排列
示例 3：
输入：arr = [1,9,4,6,7]
输出：[1,7,4,6,9]
解释：交换 9 和 7
示例 4：
输入：arr = [3,1,1,3]
输出：[1,3,1,3]
解释：交换 1 和 3
  提示：
1 <= arr.length <= 104
1 <= arr[i] <= 104",39,,6809,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],14677
评论 (86),distant-barcodes,中等,"在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。
请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。
  示例 1：
输入：barcodes = [1,1,1,2,2,2]
输出：[2,1,2,1,2,1]
示例 2：
输入：barcodes = [1,1,1,1,2,2,3,3]
输出：[1,3,1,3,2,1,2,1]
  提示：
1 <= barcodes.length <= 10000
1 <= barcodes[i] <= 10000",84,,9497,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],24376
评论 (68),shortest-way-to-form-string,Unknown,,-1,,-1,[],[],-1
评论 (46),confusing-number,Unknown,,-1,,-1,[],[],-1
评论 (25),campus-bikes,Unknown,,-1,,-1,[],[],-1
评论 (19),minimize-rounding-error-to-meet-target,Unknown,,-1,,-1,[],[],-1
评论 (24),all-paths-from-source-lead-to-destination,Unknown,,-1,,-1,[],[],-1
评论 (60),missing-element-in-sorted-array,Unknown,,-1,,-1,[],[],-1
评论 (26),lexicographically-smallest-equivalent-string,Unknown,,-1,,-1,[],[],-1
评论 (40),longest-repeating-substring,Unknown,,-1,,-1,[],[],-1
评论 (37),number-of-valid-subarrays,Unknown,,-1,,-1,[],[],-1
评论 (66),fixed-point,Unknown,,-1,,-1,[],[],-1
评论 (39),index-pairs-of-a-string,Unknown,,-1,,-1,[],[],-1
评论 (15),campus-bikes-ii,Unknown,,-1,,-1,[],[],-1
评论 (15),digit-count-in-range,Unknown,,-1,,-1,[],[],-1
评论 (91),product-sales-analysis-i,Unknown,,-1,,-1,[],[],-1
评论 (106),product-sales-analysis-ii,Unknown,,-1,,-1,[],[],-1
评论 (205),product-sales-analysis-iii,Unknown,,-1,,-1,[],[],-1
评论 (374),greatest-common-divisor-of-strings,简单,"对于字符串 s 和 t，只有在 s = t + ... + t（t 自身连接 1 次或多次）时，我们才认定 “t 能除尽 s”。
给定两个字符串 str1 和 str2 。返回 最长字符串 x，要求满足 x 能除尽 str1 且 X 能除尽 str2 。
  示例 1：
输入：str1 = ""ABCABC"", str2 = ""ABC""
输出：""ABC""
示例 2：
输入：str1 = ""ABABAB"", str2 = ""ABAB""
输出：""AB""
示例 3：
输入：str1 = ""LEET"", str2 = ""CODE""
输出：""""
  提示：
1 <= str1.length, str2.length <= 1000
str1 和 str2 由大写英文字母组成",231,,37575,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],64022
评论 (54),flip-columns-for-maximum-number-of-equal-rows,中等,"给定 m x n 矩阵 matrix 。
你可以从中选出任意数量的列并翻转其上的 每个 单元格。（即翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。）
返回 经过一些翻转后，行与行之间所有值都相等的最大行数 。
  示例 1：
输入：matrix = [[0,1],[1,1]]
输出：1
解释：不进行翻转，有 1 行所有值都相等。
示例 2：
输入：matrix = [[0,1],[1,0]]
输出：2
解释：翻转第一列的值之后，这两行都由相等的值组成。
示例 3：
输入：matrix = [[0,0,0],[0,0,1],[1,1,0]]
输出：2
解释：翻转前两列的值之后，后两行由相等的值组成。
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] == 0 或 1",47,,4110,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/matrix/']",[],6857
评论 (42),adding-two-negabinary-numbers,中等,"给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。
数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，arr = [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 = -3。数组形式 中的数字 arr 也同样不含前导零：即 arr == [0] 或 arr[0] == 1。
返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。
  示例 1：
输入：arr1 = [1,1,1,1,1], arr2 = [1,0,1]
输出：[1,0,0,0,0]
解释：arr1 表示 11，arr2 表示 5，输出表示 16 。
示例 2：
输入：arr1 = [0], arr2 = [0]
输出：[0]
示例 3：
输入：arr1 = [0], arr2 = [1]
输出：[1]
  提示：
1 <= arr1.length, arr2.length <= 1000
arr1[i] 和 arr2[i] 都是 0 或 1
arr1 和 arr2 都没有前导0",36,,2972,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],8547
评论 (210),number-of-submatrices-that-sum-to-target,困难,"给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。
子矩阵 x1, y1, x2, y2 是满足 x1 <= x <= x2 且 y1 <= y <= y2 的所有单元 matrix[x][y] 的集合。
如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如：x1 != x1'），那么这两个子矩阵也不同。
  示例 1：
输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
输出：4
解释：四个只含 0 的 1x1 子矩阵。
示例 2：
输入：matrix = [[1,-1],[-1,1]], target = 0
输出：5
解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。
示例 3：
输入：matrix = [[904]], target = 0
输出：0
  提示：
1 <= matrix.length <= 100
1 <= matrix[0].length <= 100
-1000 <= matrix[i] <= 1000
-10^8 <= target <= 10^8",195,,20003,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/prefix-sum/']",[],29843
评论 (113),project-employees-i,Unknown,,-1,,-1,[],[],-1
评论 (172),project-employees-ii,Unknown,,-1,,-1,[],[],-1
评论 (189),project-employees-iii,Unknown,,-1,,-1,[],[],-1
评论 (351),occurrences-after-bigram,简单,"给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 ""first second third"" 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。
对于每种这样的情况，将第三个词 ""third"" 添加到答案中，并返回答案。
  示例 1：
输入：text = ""alice is a good girl she is a good student"", first = ""a"", second = ""good""
输出：[""girl"",""student""]
示例 2：
输入：text = ""we will we will rock you"", first = ""we"", second = ""will""
输出：[""we"",""rock""]
  提示：
1 <= text.length <= 1000
text 由小写英文字母和空格组成
text 中的所有单词之间都由 单个空格字符 分隔
1 <= first.length, second.length <= 10
first 和 second 由小写英文字母组成",72,,33725,['https://leetcode.cn/tag/string/'],[],51367
评论 (124),letter-tile-possibilities,中等,"你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。
注意：本题中，每个活字字模只能使用一次。
  示例 1：
输入：""AAB""
输出：8
解释：可能的序列为 ""A"", ""B"", ""AA"", ""AB"", ""BA"", ""AAB"", ""ABA"", ""BAA""。
示例 2：
输入：""AAABBC""
输出：188
示例 3：
输入：""V""
输出：1
  提示：
1 <= tiles.length <= 7
tiles 由大写英文字母组成",144,,13949,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],19021
评论 (97),insufficient-nodes-in-root-to-leaf-paths,中等,"给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）
假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。
请你删除所有不足节点，并返回生成的二叉树的根。
  示例 1：
输入：root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1

输出：[1,2,3,4,null,null,7,8,9,null,14]
示例 2：
输入：root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22

输出：[5,4,8,11,null,17,4,7,null,null,null,5]
示例 3：
输入：root = [5,-6,-6], limit = 0
输出：[]
  提示：
给定的树有 1 到 5000 个节点
-10^5 <= node.val <= 10^5
-10^9 <= limit <= 10^9
 ",61,,5627,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],11145
评论 (120),smallest-subsequence-of-distinct-characters,中等,"返回 s 字典序最小的子序列，该子序列包含 s 的所有不同字符，且只包含一次。
注意：该题与 316 https://leetcode.com/problems/remove-duplicate-letters/ 相同
  示例 1：
输入：s = ""bcabc""
输出：""abc""
示例 2：
输入：s = ""cbacdcbc""
输出：""acdb""
  提示：
1 <= s.length <= 1000
s 由小写英文字母组成",154,,19763,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/monotonic-stack/']",[],34007
评论 (170),sales-analysis-i,Unknown,,-1,,-1,[],[],-1
评论 (175),sales-analysis-ii,Unknown,,-1,,-1,[],[],-1
评论 (286),sales-analysis-iii,简单,"SQL架构
Table: Product
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
| unit_price   | int     |
+--------------+---------+
Product_id是该表的主键。
该表的每一行显示每个产品的名称和价格。
Table: Sales
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| seller_id   | int     |
| product_id  | int     |
| buyer_id    | int     |
| sale_date   | date    |
| quantity    | int     |
| price       | int     |
+------ ------+---------+
这个表没有主键，它可以有重复的行。
product_id 是 Product 表的外键。
该表的每一行包含关于一个销售的一些信息。
  编写一个SQL查询，报告2019年春季才售出的产品。即仅在2019-01-01至2019-03-31（含）之间出售的商品。
以 任意顺序 返回结果表。
查询结果格式如下所示。
  示例 1:
输入：
Product table:
+------------+--------------+------------+
| product_id | product_name | unit_price |
+------------+--------------+------------+
| 1          | S8           | 1000       |
| 2          | G4           | 800        |
| 3          | iPhone       | 1400       |
+------------+--------------+------------+
Sales table:
+-----------+------------+----------+------------+----------+-------+
| seller_id | product_id | buyer_id | sale_date  | quantity | price |
+-----------+------------+----------+------------+----------+-------+
| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |
| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |
| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |
| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |
+-----------+------------+----------+------------+----------+-------+
输出：
+-------------+--------------+
| product_id  | product_name |
+-------------+--------------+
| 1           | S8           |
+-------------+--------------+
解释:
id为1的产品仅在2019年春季销售。
id为2的产品在2019年春季销售，但也在2019年春季之后销售。
id 3的产品在2019年春季之后销售。
我们只退回产品1，因为它是2019年春季才销售的产品。",53,,19166,['https://leetcode.cn/tag/database/'],[],34606
评论 (56),sum-of-digits-in-the-minimum-number,Unknown,,-1,,-1,[],[],-1
评论 (66),high-five,Unknown,,-1,,-1,[],[],-1
评论 (42),brace-expansion,Unknown,,-1,,-1,[],[],-1
评论 (12),confusing-number-ii,Unknown,,-1,,-1,[],[],-1
评论 (248),duplicate-zeros,简单,"给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。
注意：请不要在超过该数组长度的位置写入元素。
要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。
  示例 1：
输入：[1,0,2,3,0,4,5,0]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
示例 2：
输入：[1,2,3]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]
  提示：
1 <= arr.length <= 10000
0 <= arr[i] <= 9",119,,23187,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/']",[],39853
评论 (74),largest-values-from-labels,中等,"我们有一个 n 项的集合。给出两个整数数组 values 和 labels ，第 i 个元素的值和标签分别是 values[i] 和 labels[i]。还会给出两个整数 numWanted 和 useLimit 。
从 n 个元素中选择一个子集 s :
子集 s 的大小 小于或等于 numWanted 。
s 中 最多 有相同标签的 useLimit 项。
一个子集的 分数 是该子集的值之和。
返回子集 s 的最大 分数 。
  示例 1：
输入：values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1
输出：9
解释：选出的子集是第一项，第三项和第五项。
示例 2：
输入：values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2
输出：12
解释：选出的子集是第一项，第二项和第三项。
示例 3：
输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1
输出：16
解释：选出的子集是第一项和第四项。
  提示：
n == values.length == labels.length
1 <= n <= 2 * 104
0 <= values[i], labels[i] <= 2 * 104
1 <= numWanted, useLimit <= n",25,,4733,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],8486
评论 (280),shortest-path-in-binary-matrix,中等,"给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。
二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：
路径途经的所有单元格都的值都是 0 。
路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
畅通路径的长度 是该路径途经的单元格总数。
  示例 1：
输入：grid = [[0,1],[1,0]]
输出：2
示例 2：
输入：grid = [[0,0,0],[1,1,0],[1,1,0]]
输出：4
示例 3：
输入：grid = [[1,0,0],[1,1,0],[1,1,0]]
输出：-1
  提示：
n == grid.length
n == grid[i].length
1 <= n <= 100
grid[i][j] 为 0 或 1",196,https://assets.leetcode.com/uploads/2021/02/18/example1_1.png,44701,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],116231
评论 (41),shortest-common-supersequence,困难,"给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。
（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列）
  示例：
输入：str1 = ""abac"", str2 = ""cab""
输出：""cabac""
解释：
str1 = ""abac"" 是 ""cabac"" 的一个子串，因为我们可以删去 ""cabac"" 的第一个 ""c""得到 ""abac""。 
str2 = ""cab"" 是 ""cabac"" 的一个子串，因为我们可以删去 ""cabac"" 末尾的 ""ac"" 得到 ""cab""。
最终我们给出的答案是满足上述属性的最短字符串。
  提示：
1 <= str1.length, str2.length <= 1000
str1 和 str2 都由小写英文字母组成。",92,,3510,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],6832
评论 (59),statistics-from-a-large-sample,中等,"我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 在样本中出现的次数。
计算以下统计数据:
minimum ：样本中的最小元素。
maximum ：样品中的最大元素。
mean ：样本的平均值，计算为所有元素的总和除以元素总数。
median ：
如果样本的元素个数是奇数，那么一旦样本排序后，中位数 median 就是中间的元素。
如果样本中有偶数个元素，那么中位数median 就是样本排序后中间两个元素的平均值。
mode ：样本中出现次数最多的数字。保众数是 唯一 的。
以浮点数数组的形式返回样本的统计信息 [minimum, maximum, mean, median, mode] 。与真实答案误差在 10-5 内的答案都可以通过。
  示例 1：
输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
解释：用count表示的样本为[1,2,2,2,3,3,3,3,3]。
最小值和最大值分别为1和3。
均值是(1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375。
因为样本的大小是偶数，所以中位数是中间两个元素2和3的平均值，也就是2.5。
众数为3，因为它在样本中出现的次数最多。
示例 2：
输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
解释：用count表示的样本为[1,1,1,1,2,2,3,3,3,4,4]。
最小值为1，最大值为4。
平均数是(1+1+1+1+2+2+2+3+3+4+4)/ 11 = 24 / 11 = 2.18181818…(为了显示，输出显示了整数2.18182)。
因为样本的大小是奇数，所以中值是中间元素2。
众数为1，因为它在样本中出现的次数最多。
  提示：
count.length == 256
0 <= count[i] <= 109
1 <= sum(count) <= 109
 count 的众数是 唯一 的",25,,4422,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/probability-and-statistics/']",[],11985
评论 (270),car-pooling,中等,"车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）
给定整数 capacity 和一个数组 trips ,  trip[i] = [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。
当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。
  示例 1：
输入：trips = [[2,1,5],[3,3,7]], capacity = 4
输出：false
示例 2：
输入：trips = [[2,1,5],[3,3,7]], capacity = 5
输出：true
  提示：
1 <= trips.length <= 1000
trips[i].length == 3
1 <= numPassengersi <= 100
0 <= fromi < toi <= 1000
1 <= capacity <= 105",174,,46762,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/simulation/', 'https://leetcode.cn/tag/heap-priority-queue/']",['https://leetcode.cn/problems/meeting-rooms-ii/'],85098
评论 (330),find-in-mountain-array,困难,"（这是一个 交互式问题 ）
给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。
如果不存在这样的下标 index，就请返回 -1。
  何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：
首先，A.length >= 3
其次，在 0 < i < A.length - 1 条件下，存在 i 使得：
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]
  你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：
MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）
MountainArray.length() - 会返回该数组的长度
  注意：
对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。
为了帮助大家更好地理解交互式问题，我们准备了一个样例 “答案”：https://leetcode-cn.com/playground/RKhe3ave，请注意这 不是一个正确答案。
  示例 1：
输入：array = [1,2,3,4,5,3,1], target = 3
输出：2
解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。
示例 2：
输入：array = [0,1,2,4,2,1], target = 3
输出：-1
解释：3 在数组中没有出现，返回 -1。
  提示：
3 <= mountain_arr.length() <= 10000
0 <= target <= 10^9
0 <= mountain_arr.get(index) <= 10^9",151,,23138,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/interactive/']",[],61796
评论 (30),brace-expansion-ii,困难,"如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。
花括号展开的表达式可以看作一个由 花括号、逗号 和 小写英文字母 组成的字符串，定义下面几条语法规则：
如果只给出单一的元素 x，那么表达式表示的字符串就只有 ""x""。R(x) = {x}
例如，表达式 ""a"" 表示字符串 ""a""。
而表达式 ""w"" 就表示字符串 ""w""。
当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...
例如，表达式 ""{a,b,c}"" 表示字符串 ""a"",""b"",""c""。
而表达式 ""{{a,b},{b,c}}"" 也可以表示字符串 ""a"",""b"",""c""。
要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}
例如，表达式 ""{a,b}{c,d}"" 表示字符串 ""ac"",""ad"",""bc"",""bd""。
表达式之间允许嵌套，单一元素与表达式的连接也是允许的。
例如，表达式 ""a{b,c,d}"" 表示字符串 ""ab"",""ac"",""ad""。
例如，表达式 ""a{b,c}{d,e}f{g,h}"" 可以表示字符串 ""abdfg"", ""abdfh"", ""abefg"", ""abefh"", ""acdfg"", ""acdfh"", ""acefg"", ""acefh""。
给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。
假如你希望以「集合」的概念了解此题，也可以通过点击 “显示英文描述” 获取详情。
  示例 1：
输入：expression = ""{a,b}{c,{d,e}}""
输出：[""ac"",""ad"",""ae"",""bc"",""bd"",""be""]
示例 2：
输入：expression = ""{{a,z},a{b,c},{ab,z}}""
输出：[""a"",""ab"",""ac"",""z""]
解释：输出中 不应 出现重复的组合结果。
  提示：
1 <= expression.length <= 60
expression[i] 由 '{'，'}'，',' 或小写英文字母组成
给出的表达式 expression 用以表示一组基于题目描述中语法构造的字符串",56,,2120,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",['https://leetcode.cn/problems/brace-expansion/'],3799
评论 (163),game-play-analysis-v,Unknown,,-1,,-1,[],[],-1
评论 (207),unpopular-books,Unknown,,-1,,-1,[],[],-1
评论 (55),two-sum-less-than-k,Unknown,,-1,,-1,[],[],-1
评论 (53),find-k-length-substrings-with-no-repeated-characters,Unknown,,-1,,-1,[],[],-1
评论 (44),the-earliest-moment-when-everyone-become-friends,Unknown,,-1,,-1,[],[],-1
评论 (53),path-with-maximum-minimum-value,Unknown,,-1,,-1,[],[],-1
评论 (431),distribute-candies-to-people,简单,"排排坐，分糖果。
我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。
给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。
然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。
重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。
返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。
  示例 1：
输入：candies = 7, num_people = 4
输出：[1,2,3,1]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0,0]。
第三次，ans[2] += 3，数组变为 [1,2,3,0]。
第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。
示例 2：
输入：candies = 10, num_people = 3
输出：[5,2,3]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0]。
第三次，ans[2] += 3，数组变为 [1,2,3]。
第四次，ans[0] += 4，最终数组变为 [5,2,3]。
  提示：
1 <= candies <= 10^9
1 <= num_people <= 1000",103,,39016,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],61221
评论 (506),path-in-zigzag-labelled-binary-tree,中等,"在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。
如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；
而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。
给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。
  示例 1：
输入：label = 14
输出：[1,3,4,14]
示例 2：
输入：label = 26
输出：[1,2,6,10,26]
  提示：
1 <= label <= 10^6",175,,30451,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-tree/']",[],40066
评论 (71),filling-bookcase-shelves,中等,"给定一个数组 books ，其中 books[i] = [thicknessi, heighti] 表示第 i 本书的厚度和高度。你也会得到一个整数 shelfWidth 。
按顺序 将这些书摆放到总宽度为 shelfWidth 的书架上。
先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelfWidth ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。
需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。
例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。
每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。
以这种方式布置书架，返回书架整体可能的最小高度。
  示例 1：
输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
输出：6
解释：
3 层书架的高度和为 1 + 3 + 2 = 6 。
第 2 本书不必放在第一层书架上。
示例 2:
输入: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
输出: 4
  提示：
1 <= books.length <= 1000
1 <= thicknessi <= shelfWidth <= 1000
1 <= heighti <= 1000",133,,6137,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],10796
评论 (75),parsing-a-boolean-expression,困难,"给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。
有效的表达式需遵循以下约定：
""t""，运算结果为 True
""f""，运算结果为 False
""!(expr)""，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT）
""&(expr1,expr2,...)""，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 与的运算（AND）
""|(expr1,expr2,...)""，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 或的运算（OR）
  示例 1：
输入：expression = ""!(f)""
输出：true
示例 2：
输入：expression = ""|(f,t)""
输出：true
示例 3：
输入：expression = ""&(t,f)""
输出：false
示例 4：
输入：expression = ""|(&(t,f,t),!(t))""
输出：false
  提示：
1 <= expression.length <= 20000
expression[i] 由 {'(', ')', '&', '|', '!', 't', 'f', ','} 中的字符组成。
expression 是以上述形式给出的有效表达式，表示一个布尔值。",58,,4984,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/string/']",[],8481
评论 (229),new-users-daily-count,Unknown,,-1,,-1,[],[],-1
评论 (482),defanging-an-ip-address,简单,"给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。
所谓无效化 IP 地址，其实就是用 ""[.]"" 代替了每个 "".""。
  示例 1：
输入：address = ""1.1.1.1""
输出：""1[.]1[.]1[.]1""
示例 2：
输入：address = ""255.100.50.0""
输出：""255[.]100[.]50[.]0""
  提示：
给出的 address 是一个有效的 IPv4 地址",81,,74183,['https://leetcode.cn/tag/string/'],[],88535
评论 (529),corporate-flight-bookings,中等,"这里有 n 个航班，它们分别从 1 到 n 进行编号。
有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。
请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。
  示例 1：
输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
示例 2：
输入：bookings = [[1,2,10],[2,2,15]], n = 2
输出：[10,25]
解释：
航班编号        1   2
预订记录 1 ：   10  10
预订记录 2 ：       15
总座位数：      10  25
因此，answer = [10,25]
  提示：
1 <= n <= 2 * 104
1 <= bookings.length <= 2 * 104
bookings[i].length == 3
1 <= firsti <= lasti <= n
1 <= seatsi <= 104",352,,80671,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],132381
评论 (132),delete-nodes-and-return-forest,中等,"给出二叉树的根节点 root，树上每个节点都有一个不同的值。
如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。
返回森林中的每棵树。你可以按任意顺序组织答案。
  示例 1：
输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]
输出：[[1,2,null,4],[6],[7]]
示例 2：
输入：root = [1,2,4,null,3], to_delete = [3]
输出：[[1,2,4]]
  提示：
树中的节点数最大为 1000。
每个节点都有一个介于 1 到 1000 之间的值，且各不相同。
to_delete.length <= 1000
to_delete 包含一些从 1 到 1000、各不相同的值。",177,,15275,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],23818
评论 (519),maximum-nesting-depth-of-two-valid-parentheses-strings,中等,"有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。
嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。
有效括号字符串类型与对应的嵌套深度计算方法如下图所示：
  给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。
不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。
A 或 B 中的元素在原字符串中可以不连续。
A.length + B.length = seq.length
深度最小：max(depth(A), depth(B)) 的可能取值最小。 
划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：
answer[i] = 0，seq[i] 分给 A 。
answer[i] = 1，seq[i] 分给 B 。
如果存在多个满足要求的答案，只需返回其中任意 一个 即可。
  示例 1：
输入：seq = ""(()())""
输出：[0,1,1,1,1,0]
示例 2：
输入：seq = ""()(())()""
输出：[0,0,0,1,1,0,1,1]
解释：本示例答案不唯一。
按此输出 A = ""()()"", B = ""()()"", max(depth(A), depth(B)) = 1，它们的深度最小。
像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = ""()()()"", B = ""()"", max(depth(A), depth(B)) = 1 。 
  提示：
1 < seq.size <= 10000
  有效括号字符串：
仅由 ""("" 和 "")"" 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。
下述几种情况同样属于有效括号字符串：

  1. 空字符串
  2. 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串
  3. 嵌套，可以记作 (A)，其中 A 是有效括号字符串
嵌套深度：
类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：

  1. s 为空时，depth("""") = 0
  2. s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串
  3. s 为嵌套情况，depth(""("" + A + "")"") = 1 + depth(A)，其中 A 是有效括号字符串

例如：""""，""()()""，和 ""()(()())"" 都是有效括号字符串，嵌套深度分别为 0，1，2，而 "")("" 和 ""(()"" 都不是有效括号字符串。",152,,25437,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],33058
评论 (163),highest-grade-for-each-student,Unknown,,-1,,-1,[],[],-1
评论 (116),reported-posts,Unknown,,-1,,-1,[],[],-1
评论 (566),print-in-order,简单,"给你一个类：
public class Foo {
  public void first() { print(""first""); }
  public void second() { print(""second""); }
  public void third() { print(""third""); }
}
三个不同的线程 A、B、C 将会共用一个 Foo 实例。
线程 A 将会调用 first() 方法
线程 B 将会调用 second() 方法
线程 C 将会调用 third() 方法
请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。
提示：
尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。
你看到的输入格式主要是为了确保测试的全面性。
  示例 1：
输入：nums = [1,2,3]
输出：""firstsecondthird""
解释：
有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 second() 方法，线程 C 将会调用 third() 方法。正确的输出是 ""firstsecondthird""。
示例 2：
输入：nums = [1,3,2]
输出：""firstsecondthird""
解释：
输入 [1,3,2] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 third() 方法，线程 C 将会调用 second() 方法。正确的输出是 ""firstsecondthird""。
  提示：
nums 是 [1, 2, 3] 的一组排列",394,,92307,['https://leetcode.cn/tag/concurrency/'],['https://leetcode.cn/problems/print-foobar-alternately/'],141491
评论 (409),print-foobar-alternately,中等,"给你一个类：
class FooBar {
  public void foo() {
    for (int i = 0; i < n; i++) {
      print(""foo"");
    }
  }

  public void bar() {
    for (int i = 0; i < n; i++) {
      print(""bar"");
    }
  }
}
两个不同的线程将会共用一个 FooBar 实例：
线程 A 将会调用 foo() 方法，而
线程 B 将会调用 bar() 方法
请设计修改程序，以确保 ""foobar"" 被输出 n 次。
  示例 1：
输入：n = 1
输出：""foobar""
解释：这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，""foobar"" 将被输出一次。
示例 2：
输入：n = 2
输出：""foobarfoobar""
解释：""foobar"" 将被输出两次。
  提示：
1 <= n <= 1000",160,,52460,['https://leetcode.cn/tag/concurrency/'],"['https://leetcode.cn/problems/print-in-order/', 'https://leetcode.cn/problems/print-zero-even-odd/']",93111
评论 (424),print-zero-even-odd,中等,"现有函数 printNumber 可以用一个整数参数调用，并输出该整数到控制台。
例如，调用 printNumber(7) 将会输出 7 到控制台。
给你类 ZeroEvenOdd 的一个实例，该类中有三个函数：zero、even 和 odd 。ZeroEvenOdd 的相同实例将会传递给三个不同线程：
线程 A：调用 zero() ，只输出 0
线程 B：调用 even() ，只输出偶数
线程 C：调用 odd() ，只输出奇数
修改给出的类，以输出序列 ""010203040506..."" ，其中序列的长度必须为 2n 。
实现 ZeroEvenOdd 类：
ZeroEvenOdd(int n) 用数字 n 初始化对象，表示需要输出的数。
void zero(printNumber) 调用 printNumber 以输出一个 0 。
void even(printNumber) 调用printNumber 以输出偶数。
void odd(printNumber) 调用 printNumber 以输出奇数。
  示例 1：
输入：n = 2
输出：""0102""
解释：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 ""0102""。
示例 2：
输入：n = 5
输出：""0102030405""
  提示：
1 <= n <= 1000",129,,27590,['https://leetcode.cn/tag/concurrency/'],['https://leetcode.cn/problems/print-foobar-alternately/'],52105
评论 (231),building-h2o,中等,"现在有两种线程，氧 oxygen 和氢 hydrogen，你的目标是组织这两种线程来产生水分子。
存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。
氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。
这些线程应该三三成组突破屏障并能立即组合产生一个水分子。
你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。
换句话说:
如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。
如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。
书写满足这些限制条件的氢、氧线程同步代码。
  示例 1:
输入: water = ""HOH""
输出: ""HHO""
解释: ""HOH"" 和 ""OHH"" 依然都是有效解。
示例 2:
输入: water = ""OOHHHH""
输出: ""HHOHHO""
解释: ""HOHHHO"", ""OHHHHO"", ""HHOHOH"", ""HOHHOH"", ""OHHHOH"", ""HHOOHH"", ""HOHOHH"" 和 ""OHHOHH"" 依然都是有效解。
  提示：
3 * n == water.length
1 <= n <= 20
water[i] == 'O' or 'H'
输入字符串 water 中的 'H' 总数将会是 2 * n 。
输入字符串 water 中的 'O' 总数将会是 n 。",109,,21066,['https://leetcode.cn/tag/concurrency/'],[],39776
评论 (44),number-of-days-in-a-month,Unknown,,-1,,-1,[],[],-1
评论 (76),remove-vowels-from-a-string,Unknown,,-1,,-1,[],[],-1
评论 (33),maximum-average-subtree,Unknown,,-1,,-1,[],[],-1
评论 (13),divide-array-into-increasing-sequences,Unknown,,-1,,-1,[],[],-1
评论 (654),relative-sort-array,简单,"给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。
对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。
  示例 1：
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
示例  2:
输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
输出：[22,28,8,6,17,44]
  提示：
1 <= arr1.length, arr2.length <= 1000
0 <= arr1[i], arr2[i] <= 1000
arr2 中的元素 arr2[i]  各不相同 
arr2 中的每个元素 arr2[i] 都出现在 arr1 中",217,,73878,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting-sort/', 'https://leetcode.cn/tag/sorting/']",[],104326
评论 (120),lowest-common-ancestor-of-deepest-leaves,中等,"给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。
回想一下：
叶节点 是二叉树中没有子节点的节点
树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1
如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。
  示例 1：
输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 6、0 和 8 也是叶节点，但是它们的深度是 2 ，而节点 7 和 4 的深度是 3 。
示例 2：
输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点，它是它本身的最近公共祖先。
示例 3：
输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的叶节点是 2 ，最近公共祖先是它自己。
  提示：
树中的节点数将在 [1, 1000] 的范围内。
0 <= Node.val <= 1000
每个节点的值都是 独一无二 的。
  注意：本题与力扣 865 重复：https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/",112,https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png,10119,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-tree/']",[],14269
评论 (142),longest-well-performing-interval,中等,"给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。
我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。
所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。
请你返回「表现良好时间段」的最大长度。
  示例 1：
输入：hours = [9,9,6,0,6,6,9]
输出：3
解释：最长的表现良好时间段是 [9,9,6]。
示例 2：
输入：hours = [6,6,6]
输出：0
  提示：
1 <= hours.length <= 104
0 <= hours[i] <= 16",183,,15830,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/monotonic-stack/']",[],47713
评论 (38),smallest-sufficient-team,困难,"作为项目经理，你规划了一份需求的技能清单 req_skills，并打算从备选人员名单 people 中选出些人组成一个「必要团队」（ 编号为 i 的备选人员 people[i] 含有一份该备选人员掌握的技能列表）。
所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 req_skills 中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：
例如，团队 team = [0, 1, 3] 表示掌握技能分别为 people[0]，people[1]，和 people[3] 的备选人员。
请你返回 任一 规模最小的必要团队，团队成员用人员编号表示。你可以按 任意顺序 返回答案，题目数据保证答案存在。
  示例 1：
输入：req_skills = [""java"",""nodejs"",""reactjs""], people = [[""java""],[""nodejs""],[""nodejs"",""reactjs""]]
输出：[0,2]
示例 2：
输入：req_skills = [""algorithms"",""math"",""java"",""reactjs"",""csharp"",""aws""], people = [[""algorithms"",""math"",""java""],[""algorithms"",""math"",""reactjs""],[""java"",""csharp"",""aws""],[""reactjs"",""csharp""],[""csharp"",""math""],[""aws"",""java""]]
输出：[1,2]
  提示：
1 <= req_skills.length <= 16
1 <= req_skills[i].length <= 16
req_skills[i] 由小写英文字母组成
req_skills 中的所有字符串 互不相同
1 <= people.length <= 60
0 <= people[i].length <= 16
1 <= people[i][j].length <= 16
people[i][j] 由小写英文字母组成
people[i] 中的所有字符串 互不相同
people[i] 中的每个技能是 req_skills 中的技能
题目数据保证「必要团队」一定存在",80,,3718,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],7445
评论 (193),active-businesses,Unknown,,-1,,-1,[],[],-1
评论 (137),user-purchase-platform,Unknown,,-1,,-1,[],[],-1
评论 (389),number-of-equivalent-domino-pairs,简单,"给你一个由一些多米诺骨牌组成的列表 dominoes。
如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。
形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。
在 0 <= i < j < dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。
  示例：
输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]
输出：1
  提示：
1 <= dominoes.length <= 40000
1 <= dominoes[i][j] <= 9",140,,39618,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],72959
评论 (109),shortest-path-with-alternating-colors,中等,"在一个有向图中，节点分别标记为 0, 1, ..., n-1。图中每条边为红色或者蓝色，且存在自环或平行边。
red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。
返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 answer[x] = -1。
  示例 1：
输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
输出：[0,1,-1]
示例 2：
输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
输出：[0,1,-1]
示例 3：
输入：n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]
输出：[0,-1,-1]
示例 4：
输入：n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]
输出：[0,1,2]
示例 5：
输入：n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]
输出：[0,1,1]
  提示：
1 <= n <= 100
red_edges.length <= 400
blue_edges.length <= 400
red_edges[i].length == blue_edges[i].length == 2
0 <= red_edges[i][j], blue_edges[i][j] < n",101,,8218,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/']",[],20819
评论 (57),minimum-cost-tree-from-leaf-values,中等,"给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：
每个节点都有 0 个或是 2 个子节点。
数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）
每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。
在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。
  示例：
输入：arr = [6,2,4]
输出：32
解释：
有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。

    24            24
   /  \          /  \
  12   4        6    8
 /  \               / \
6    2             2   4
  提示：
2 <= arr.length <= 40
1 <= arr[i] <= 15
答案保证是一个 32 位带符号整数，即小于 2^31。",230,,7272,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/monotonic-stack/']",[],11375
评论 (35),maximum-of-absolute-value-expression,中等,"给你两个长度相等的整数数组，返回下面表达式的最大值：
|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|
其中下标 i，j 满足 0 <= i, j < arr1.length。
  示例 1：
输入：arr1 = [1,2,3,4], arr2 = [-1,4,5,6]
输出：13
示例 2：
输入：arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]
输出：20
  提示：
2 <= arr1.length == arr2.length <= 40000
-10^6 <= arr1[i], arr2[i] <= 10^6",61,,3623,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],7831
评论 (136),reported-posts-ii,Unknown,,-1,,-1,[],[],-1
评论 (51),largest-unique-number,Unknown,,-1,,-1,[],[],-1
评论 (39),armstrong-number,Unknown,,-1,,-1,[],[],-1
评论 (53),connecting-cities-with-minimum-cost,Unknown,,-1,,-1,[],[],-1
评论 (41),parallel-courses,Unknown,,-1,,-1,[],[],-1
评论 (804),n-th-tribonacci-number,简单,"泰波那契序列 Tn 定义如下： 
T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
给你整数 n，请返回第 n 个泰波那契数 Tn 的值。
  示例 1：
输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
示例 2：
输入：n = 25
输出：1389537
  提示：
0 <= n <= 37
答案保证是一个 32 位整数，即 answer <= 2^31 - 1。",203,,125025,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",['https://leetcode.cn/problems/climbing-stairs/'],205544
评论 (96),alphabet-board-path,中等,"我们从一块字母板上的位置 (0, 0) 出发，该坐标对应的字符为 board[0][0]。
在本题里，字母板为board = [""abcde"", ""fghij"", ""klmno"", ""pqrst"", ""uvwxy"", ""z""]，如下所示。
我们可以按下面的指令规则行动：
如果方格存在，'U' 意味着将我们的位置上移一行；
如果方格存在，'D' 意味着将我们的位置下移一行；
如果方格存在，'L' 意味着将我们的位置左移一列；
如果方格存在，'R' 意味着将我们的位置右移一列；
'!' 会把在我们当前位置 (r, c) 的字符 board[r][c] 添加到答案中。
（注意，字母板上只存在有字母的位置。）
返回指令序列，用最小的行动次数让答案和目标 target 相同。你可以返回任何达成目标的路径。
  示例 1：
输入：target = ""leet""
输出：""DDR!UURRR!!DDD!""
示例 2：
输入：target = ""code""
输出：""RR!DDRR!UUL!R!""
  提示：
1 <= target.length <= 100
target 仅含有小写英文字母。",43,,7102,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],16057
评论 (116),largest-1-bordered-square,中等,"给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。
  示例 1：
输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
输出：9
示例 2：
输入：grid = [[1,1,0,0]]
输出：1
  提示：
1 <= grid.length <= 100
1 <= grid[0].length <= 100
grid[i][j] 为 0 或 1",92,,10994,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],22573
评论 (82),stone-game-ii,中等,"爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。
爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初，M = 1。
在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 <= X <= 2M。然后，令 M = max(M, X)。
游戏一直持续到所有石子都被拿走。
假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。
  示例 1：
输入：piles = [2,7,9,4,4]
输出：10
解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。
示例 2:
输入：piles = [1,2,3,4,5,100]
输出：104
  提示：
1 <= piles.length <= 100
1 <= piles[i] <= 104",130,,8297,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",[],12591
评论 (173),user-activity-for-the-past-30-days-i,简单,"SQL架构
活动记录表：Activity
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| session_id    | int     |
| activity_date | date    |
| activity_type | enum    |
+---------------+---------+
该表是用户在社交网站的活动记录。
该表没有主键，可能包含重复数据。
activity_type 字段为以下四种值 ('open_session', 'end_session', 'scroll_down', 'send_message')。
每个 session_id 只属于一个用户。
  请写SQL查询出截至 2019-07-27（包含2019-07-27），近 30 天的每日活跃用户数（当天只要有一条活动记录，即为活跃用户）。
以 任意顺序 返回结果表。
查询结果示例如下。
  示例 1:
输入：
Activity table:
+---------+------------+---------------+---------------+
| user_id | session_id | activity_date | activity_type |
+---------+------------+---------------+---------------+
| 1       | 1          | 2019-07-20    | open_session  |
| 1       | 1          | 2019-07-20    | scroll_down   |
| 1       | 1          | 2019-07-20    | end_session   |
| 2       | 4          | 2019-07-20    | open_session  |
| 2       | 4          | 2019-07-21    | send_message  |
| 2       | 4          | 2019-07-21    | end_session   |
| 3       | 2          | 2019-07-21    | open_session  |
| 3       | 2          | 2019-07-21    | send_message  |
| 3       | 2          | 2019-07-21    | end_session   |
| 4       | 3          | 2019-06-25    | open_session  |
| 4       | 3          | 2019-06-25    | end_session   |
+---------+------------+---------------+---------------+
输出：
+------------+--------------+ 
| day        | active_users |
+------------+--------------+ 
| 2019-07-20 | 2            |
| 2019-07-21 | 2            |
+------------+--------------+ 
解释：注意非活跃用户的记录不需要展示。",39,,19457,['https://leetcode.cn/tag/database/'],[],40744
评论 (153),user-activity-for-the-past-30-days-ii,Unknown,,-1,,-1,[],[],-1
评论 (755),longest-common-subsequence,中等,"给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，""ace"" 是 ""abcde"" 的子序列，但 ""aec"" 不是 ""abcde"" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
  示例 1：
输入：text1 = ""abcde"", text2 = ""ace"" 
输出：3  
解释：最长公共子序列是 ""ace"" ，它的长度为 3 。
示例 2：
输入：text1 = ""abc"", text2 = ""abc""
输出：3
解释：最长公共子序列是 ""abc"" ，它的长度为 3 。
示例 3：
输入：text1 = ""abc"", text2 = ""def""
输出：0
解释：两个字符串没有公共子序列，返回 0 。
  提示：
1 <= text1.length, text2.length <= 1000
text1 和 text2 仅由小写英文字符组成。",989,,237678,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],369477
评论 (119),decrease-elements-to-make-array-zigzag,中等,"给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。
如果符合下列情况之一，则数组 A 就是 锯齿数组：
每个偶数索引对应的元素都大于相邻的元素，即 A[0] > A[1] < A[2] > A[3] < A[4] > ...
或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] < A[1] > A[2] < A[3] > A[4] < ...
返回将数组 nums 转换为锯齿数组所需的最小操作次数。
  示例 1：
输入：nums = [1,2,3]
输出：2
解释：我们可以把 2 递减到 0，或把 3 递减到 1。
示例 2：
输入：nums = [9,6,1,6,2]
输出：4
  提示：
1 <= nums.length <= 1000
1 <= nums[i] <= 1000",39,,11281,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],25352
评论 (85),binary-tree-coloring-game,中等,"有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。
  游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，
「一号」玩家从 [1, n] 中取一个值 x（1 <= x <= n）；
「二号」玩家也从 [1, n] 中取一个值 y（1 <= y <= n）且 y != x。
「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。
  之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。
如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。
若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。
  现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。
  示例：
输入：root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
输出：True
解释：第二个玩家可以选择值为 2 的节点。
  提示：
二叉树的根节点为 root，树上由 n 个节点，节点上的值从 1 到 n 各不相同。
n 为奇数。
1 <= x <= n <= 100",83,,7643,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],16115
评论 (71),snapshot-array,中等,"实现支持下列接口的「快照数组」- SnapshotArray：
SnapshotArray(int length) - 初始化一个与指定长度相等的 类数组 的数据结构。初始时，每个元素都等于 0。
void set(index, val) - 会将指定索引 index 处的元素设置为 val。
int snap() - 获取该数组的快照，并返回快照的编号 snap_id（快照号是调用 snap() 的总次数减去 1）。
int get(index, snap_id) - 根据指定的 snap_id 选择快照，并返回该快照指定索引 index 的值。
  示例：
输入：[""SnapshotArray"",""set"",""snap"",""set"",""get""]
     [[3],[0,5],[],[0,6],[0,0]]
输出：[null,null,0,null,5]
解释：
SnapshotArray snapshotArr = new SnapshotArray(3); // 初始化一个长度为 3 的快照数组
snapshotArr.set(0,5);  // 令 array[0] = 5
snapshotArr.snap();  // 获取快照，返回 snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // 获取 snap_id = 0 的快照中 array[0] 的值，返回 5
  提示：
1 <= length <= 50000
题目最多进行50000 次set，snap，和 get的调用 。
0 <= index < length
0 <= snap_id < 我们调用 snap() 的总次数
0 <= val <= 10^9",88,,5909,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/']",[],19211
评论 (54),longest-chunked-palindrome-decomposition,困难,"你会得到一个字符串 text 。你应该把它分成 k 个子字符串 (subtext1, subtext2，…， subtextk) ，要求满足:
subtexti 是非空字符串
所有子字符串的连接等于 text ( 即subtext1 + subtext2 + ... + subtextk == text )
subtexti == subtextk - i + 1 表示所有 i 的有效值( 即 1 <= i <= k )
返回k可能最大值。
  示例 1：
输入：text = ""ghiabcdefhelloadamhelloabcdefghi""
输出：7
解释：我们可以把字符串拆分成 ""(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)""。
示例 2：
输入：text = ""merchant""
输出：1
解释：我们可以把字符串拆分成 ""(merchant)""。
示例 3：
输入：text = ""antaprezatepzapreanta""
输出：11
解释：我们可以把字符串拆分成 ""(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)""。
示例 4：
输入：text = ""aaa""
输出：3
解释：我们可以把字符串拆分成 ""(a)(a)(a)""。
  提示：
1 <= text.length <= 1000
text 仅由小写英文字符组成",41,,5295,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],9359
评论 (118),article-views-i,简单,"SQL架构
Views 表：
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| article_id    | int     |
| author_id     | int     |
| viewer_id     | int     |
| view_date     | date    |
+---------------+---------+
此表无主键，因此可能会存在重复行。
此表的每一行都表示某人在某天浏览了某位作者的某篇文章。
请注意，同一人的 author_id 和 viewer_id 是相同的。
  请编写一条 SQL 查询以找出所有浏览过自己文章的作者，结果按照 id 升序排列。
查询结果的格式如下所示：
Views 表：
+------------+-----------+-----------+------------+
| article_id | author_id | viewer_id | view_date  |
+------------+-----------+-----------+------------+
| 1          | 3         | 5         | 2019-08-01 |
| 1          | 3         | 6         | 2019-08-02 |
| 2          | 7         | 7         | 2019-08-01 |
| 2          | 7         | 6         | 2019-08-02 |
| 4          | 7         | 1         | 2019-07-22 |
| 3          | 4         | 4         | 2019-07-21 |
| 3          | 4         | 4         | 2019-07-21 |
+------------+-----------+-----------+------------+

结果表：
+------+
| id   |
+------+
| 4    |
| 7    |
+------+",26,,16765,['https://leetcode.cn/tag/database/'],[],23476
评论 (115),article-views-ii,Unknown,,-1,,-1,[],[],-1
评论 (95),check-if-a-number-is-majority-element-in-a-sorted-array,Unknown,,-1,,-1,[],[],-1
评论 (36),minimum-swaps-to-group-all-1s-together,Unknown,,-1,,-1,[],[],-1
评论 (25),analyze-user-website-visit-pattern,Unknown,,-1,,-1,[],[],-1
评论 (8),string-transforms-into-another-string,Unknown,,-1,,-1,[],[],-1
评论 (493),day-of-the-year,简单,"给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。返回该日期是当年的第几天。
  示例 1：
输入：date = ""2019-01-09""
输出：9
解释：给定日期是2019年的第九天。
示例 2：
输入：date = ""2019-02-10""
输出：41
  提示：
date.length == 10
date[4] == date[7] == '-'，其他的 date[i] 都是数字
date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日",97,,48022,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],74894
评论 (154),number-of-dice-rolls-with-target-sum,中等,"这里有 n 个一样的骰子，每个骰子上都有 k 个面，分别标号为 1 到 k 。
给定三个整数 n ,  k 和 target ，返回可能的方式(从总共 kn 种方式中)滚动骰子的数量，使正面朝上的数字之和等于 target 。
答案可能很大，你需要对 109 + 7 取模 。
  示例 1：
输入：n = 1, k = 6, target = 3
输出：1
解释：你扔一个有6张脸的骰子。
得到3的和只有一种方法。
示例 2：
输入：n = 2, k = 6, target = 7
输出：6
解释：你扔两个骰子，每个骰子有6个面。
得到7的和有6种方法1+6 2+5 3+4 4+3 5+2 6+1。
示例 3：
输入：n = 30, k = 30, target = 500
输出：222616187
解释：返回的结果必须是对 109 + 7 取模。
  提示：
1 <= n, k <= 30
1 <= target <= 1000",134,,14330,['https://leetcode.cn/tag/dynamic-programming/'],[],29211
评论 (123),swap-for-longest-repeated-character-substring,中等,"如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。
给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。
  示例 1：
输入：text = ""ababa""
输出：3
示例 2：
输入：text = ""aaabaaa""
输出：6
示例 3：
输入：text = ""aaabbaaa""
输出：4
示例 4：
输入：text = ""aaaaa""
输出：5
示例 5：
输入：text = ""abcdef""
输出：1
  提示：
1 <= text.length <= 20000
text 仅由小写英文字母组成。",87,,6605,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],15367
评论 (67),online-majority-element-in-subarray,困难,"设计一个数据结构，有效地找到给定子数组的 多数元素 。
子数组的 多数元素 是在子数组中出现 threshold 次数或次数以上的元素。
实现 MajorityChecker 类:
MajorityChecker(int[] arr) 会用给定的数组 arr 对 MajorityChecker 初始化。
int query(int left, int right, int threshold) 返回子数组中的元素  arr[left...right] 至少出现 threshold 次数，如果不存在这样的元素则返回 -1。
  示例 1：
输入:
[""MajorityChecker"", ""query"", ""query"", ""query""]
[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]
输出：
[null, 1, -1, 2]

解释：
MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // 返回 1
majorityChecker.query(0,3,3); // 返回 -1
majorityChecker.query(2,3,2); // 返回 2
  提示：
1 <= arr.length <= 2 * 104
1 <= arr[i] <= 2 * 104
0 <= left <= right < arr.length
threshold <= right - left + 1
2 * threshold > right - left + 1
调用 query 的次数最多为 104 ",62,,3599,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],10701
评论 (210),market-analysis-i,中等,"SQL架构
Table: Users
+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| user_id        | int     |
| join_date      | date    |
| favorite_brand | varchar |
+----------------+---------+
此表主键是 user_id。
表中描述了购物网站的用户信息，用户可以在此网站上进行商品买卖。
  Table: Orders
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| item_id       | int     |
| buyer_id      | int     |
| seller_id     | int     |
+---------------+---------+
此表主键是 order_id。
外键是 item_id 和（buyer_id，seller_id）。
  Table: Items
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| item_id       | int     |
| item_brand    | varchar |
+---------------+---------+
此表主键是 item_id。
  请写出一条SQL语句以查询每个用户的注册日期和在 2019 年作为买家的订单总数。
以 任意顺序 返回结果表。
查询结果格式如下。
  示例 1:
输入：
Users 表:
+---------+------------+----------------+
| user_id | join_date  | favorite_brand |
+---------+------------+----------------+
| 1       | 2018-01-01 | Lenovo         |
| 2       | 2018-02-09 | Samsung        |
| 3       | 2018-01-19 | LG             |
| 4       | 2018-05-21 | HP             |
+---------+------------+----------------+
Orders 表:
+----------+------------+---------+----------+-----------+
| order_id | order_date | item_id | buyer_id | seller_id |
+----------+------------+---------+----------+-----------+
| 1        | 2019-08-01 | 4       | 1        | 2         |
| 2        | 2018-08-02 | 2       | 1        | 3         |
| 3        | 2019-08-03 | 3       | 2        | 3         |
| 4        | 2018-08-04 | 1       | 4        | 2         |
| 5        | 2018-08-04 | 1       | 3        | 4         |
| 6        | 2019-08-05 | 2       | 2        | 4         |
+----------+------------+---------+----------+-----------+
Items 表:
+---------+------------+
| item_id | item_brand |
+---------+------------+
| 1       | Samsung    |
| 2       | Lenovo     |
| 3       | LG         |
| 4       | HP         |
+---------+------------+
输出：
+-----------+------------+----------------+
| buyer_id  | join_date  | orders_in_2019 |
+-----------+------------+----------------+
| 1         | 2018-01-01 | 1              |
| 2         | 2018-02-09 | 2              |
| 3         | 2018-01-19 | 0              |
| 4         | 2018-05-21 | 0              |
+-----------+------------+----------------+",43,,12142,['https://leetcode.cn/tag/database/'],[],21711
评论 (169),market-analysis-ii,Unknown,,-1,,-1,[],[],-1
评论 (548),find-words-that-can-be-formed-by-characters,简单,"给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。
假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。
注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。
返回词汇表 words 中你掌握的所有单词的 长度之和。
  示例 1：
输入：words = [""cat"",""bt"",""hat"",""tree""], chars = ""atach""
输出：6
解释： 
可以形成字符串 ""cat"" 和 ""hat""，所以答案是 3 + 3 = 6。
示例 2：
输入：words = [""hello"",""world"",""leetcode""], chars = ""welldonehoneyr""
输出：10
解释：
可以形成字符串 ""hello"" 和 ""world""，所以答案是 5 + 5 = 10。
  提示：
1 <= words.length <= 1000
1 <= words[i].length, chars.length <= 100
所有字符串中都仅包含小写英文字母",154,,65376,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],95456
评论 (140),maximum-level-sum-of-a-binary-tree,中等,"给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。
请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。
  示例 1：
输入：root = [1,7,0,7,-8,null,null]
输出：2
解释：
第 1 层各元素之和为 1，
第 2 层各元素之和为 7 + 0 = 7，
第 3 层各元素之和为 7 + -8 = -1，
所以我们返回第 2 层的层号，它的层内元素之和最大。
示例 2：
输入：root = [989,null,10250,98693,-89388,null,null,null,-32127]
输出：2
  提示：
树中的节点数在 [1, 104]范围内
-105 <= Node.val <= 105",51,,12578,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],19944
评论 (433),as-far-from-land-as-possible,中等,"你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。
请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。
我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。
  示例 1：
输入：grid = [[1,0,1],[0,0,0],[1,0,1]]
输出：2
解释： 
海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。
示例 2：
输入：grid = [[1,0,0],[0,0,0],[0,0,0]]
输出：4
解释： 
海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。
  提示：
n == grid.length
n == grid[i].length
1 <= n <= 100
grid[i][j] 不是 0 就是 1",271,,44853,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",['https://leetcode.cn/problems/shortest-distance-from-all-buildings/'],95218
评论 (83),last-substring-in-lexicographical-order,困难,"给你一个字符串 s ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。
  示例 1：
输入：s = ""abab""
输出：""bab""
解释：我们可以找出 7 个子串 [""a"", ""ab"", ""aba"", ""abab"", ""b"", ""ba"", ""bab""]。按字典序排在最后的子串是 ""bab""。
示例 2：
输入：s = ""leetcode""
输出：""tcode""
  提示：
1 <= s.length <= 4 * 105
s 仅含有小写英文字符。",64,,6661,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],24781
评论 (205),product-price-at-a-given-date,Unknown,,-1,,-1,[],[],-1
评论 (56),single-row-keyboard,Unknown,,-1,,-1,[],[],-1
评论 (39),design-file-system,Unknown,,-1,,-1,[],[],-1
评论 (24),minimum-cost-to-connect-sticks,Unknown,,-1,,-1,[],[],-1
评论 (19),optimize-water-distribution-in-a-village,Unknown,,-1,,-1,[],[],-1
评论 (96),invalid-transactions,中等,"如果出现下述两种情况，交易 可能无效：
交易金额超过 $1000
或者，它和 另一个城市 中 同名 的另一笔交易相隔不超过 60 分钟（包含 60 分钟整）
给定字符串数组交易清单 transaction 。每个交易字符串 transactions[i] 由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。
返回 transactions，返回可能无效的交易列表。你可以按 任何顺序 返回答案。
  示例 1：
输入：transactions = [""alice,20,800,mtv"",""alice,50,100,beijing""]
输出：[""alice,20,800,mtv"",""alice,50,100,beijing""]
解释：第一笔交易是无效的，因为第二笔交易和它间隔不超过 60 分钟、名称相同且发生在不同的城市。同样，第二笔交易也是无效的。
示例 2：
输入：transactions = [""alice,20,800,mtv"",""alice,50,1200,mtv""]
输出：[""alice,50,1200,mtv""]
示例 3：
输入：transactions = [""alice,20,800,mtv"",""bob,50,1200,mtv""]
输出：[""bob,50,1200,mtv""]
  提示：
transactions.length <= 1000
每笔交易 transactions[i] 按 ""{name},{time},{amount},{city}"" 的格式进行记录
每个交易名称 {name} 和城市 {city} 都由小写英文字母组成，长度在 1 到 10 之间
每个交易时间 {time} 由一些数字组成，表示一个 0 到 1000 之间的整数
每笔交易金额 {amount} 由一些数字组成，表示一个 0 到 2000 之间的整数",28,,7546,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],23237
评论 (173),compare-strings-by-frequency-of-the-smallest-character,中等,"定义一个函数 f(s)，统计 s  中（按字典序比较）最小字母的出现频次 ，其中 s 是一个非空字符串。
例如，若 s = ""dcce""，那么 f(s) = 2，因为字典序最小字母是 ""c""，它出现了 2 次。
现在，给你两个字符串数组待查表 queries 和词汇表 words 。对于每次查询 queries[i] ，需统计 words 中满足 f(queries[i]) < f(W) 的 词的数目 ，W 表示词汇表 words 中的每个词。
请你返回一个整数数组 answer 作为答案，其中每个 answer[i] 是第 i 次查询的结果。
  示例 1：
输入：queries = [""cbd""], words = [""zaaaz""]
输出：[1]
解释：查询 f(""cbd"") = 1，而 f(""zaaaz"") = 3 所以 f(""cbd"") < f(""zaaaz"")。
示例 2：
输入：queries = [""bbb"",""cc""], words = [""a"",""aa"",""aaa"",""aaaa""]
输出：[1,2]
解释：第一个查询 f(""bbb"") < f(""aaaa"")，第二个查询 f(""aaa"") 和 f(""aaaa"") 都 > f(""cc"")。
  提示：
1 <= queries.length <= 2000
1 <= words.length <= 2000
1 <= queries[i].length, words[i].length <= 10
queries[i][j]、words[i][j] 都由小写英文字母组成",51,,14969,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],24189
评论 (152),remove-zero-sum-consecutive-nodes-from-linked-list,中等,"给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。
删除完毕后，请你返回最终结果链表的头节点。
  你可以返回任何满足题目要求的答案。
（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）
示例 1：
输入：head = [1,2,-3,3,1]
输出：[3,1]
提示：答案 [1,2,1] 也是正确的。
示例 2：
输入：head = [1,2,3,-3,4]
输出：[1,2,4]
示例 3：
输入：head = [1,2,3,-3,-2]
输出：[1]
  提示：
给你的链表中可能有 1 到 1000 个节点。
对于链表中的每个节点，节点的值：-1000 <= node.val <= 1000.",159,,16215,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/']",[],33762
评论 (55),dinner-plate-stacks,困难,"我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 capacity 都相同。
实现一个叫「餐盘」的类 DinnerPlates：
DinnerPlates(int capacity) - 给出栈的最大容量 capacity。
void push(int val) - 将给出的正整数 val 推入 从左往右第一个 没有满的栈。
int pop() - 返回 从右往左第一个 非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回 -1。
int popAtStack(int index) - 返回编号 index 的栈顶部的值，并将其从栈中删除；如果编号 index 的栈是空的，请返回 -1。
  示例：
输入： 
[""DinnerPlates"",""push"",""push"",""push"",""push"",""push"",""popAtStack"",""push"",""push"",""popAtStack"",""popAtStack"",""pop"",""pop"",""pop"",""pop"",""pop""]
[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]
输出：
[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]

解释：
DinnerPlates D = DinnerPlates(2);  // 初始化，栈最大容量 capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // 栈的现状为：    2  4
                                    1  3  5
                                    ﹈ ﹈ ﹈
D.popAtStack(0);   // 返回 2。栈的现状为：      4
                                          1  3  5
                                          ﹈ ﹈ ﹈
D.push(20);        // 栈的现状为：  20  4
                                   1  3  5
                                   ﹈ ﹈ ﹈
D.push(21);        // 栈的现状为：  20  4 21
                                   1  3  5
                                   ﹈ ﹈ ﹈
D.popAtStack(0);   // 返回 20。栈的现状为：       4 21
                                            1  3  5
                                            ﹈ ﹈ ﹈
D.popAtStack(2);   // 返回 21。栈的现状为：       4
                                            1  3  5
                                            ﹈ ﹈ ﹈ 
D.pop()            // 返回 5。栈的现状为：        4
                                            1  3 
                                            ﹈ ﹈  
D.pop()            // 返回 4。栈的现状为：    1  3 
                                           ﹈ ﹈   
D.pop()            // 返回 3。栈的现状为：    1 
                                           ﹈   
D.pop()            // 返回 1。现在没有栈。
D.pop()            // 返回 -1。仍然没有栈。
  提示：
1 <= capacity <= 20000
1 <= val <= 20000
0 <= index <= 100000
最多会对 push，pop，和 popAtStack 进行 200000 次调用。",36,,2979,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],11164
评论 (124),immediate-food-delivery-i,Unknown,,-1,,-1,[],[],-1
评论 (203),immediate-food-delivery-ii,Unknown,,-1,,-1,[],[],-1
评论 (143),prime-arrangements,简单,"请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。
让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。
由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。
  示例 1：
输入：n = 5
输出：12
解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。
示例 2：
输入：n = 100
输出：682289015
  提示：
1 <= n <= 100",44,,9308,['https://leetcode.cn/tag/math/'],[],18932
评论 (91),diet-plan-performance,Unknown,,-1,,-1,[],[],-1
评论 (127),can-make-palindrome-from-substring,中等,"给你一个字符串 s，请你对 s 的子串进行检测。
每次检测，待检子串都可以表示为 queries[i] = [left, right, k]。我们可以 重新排列 子串 s[left], ..., s[right]，并从中选择 最多 k 项替换成任何小写英文字母。 
如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。
返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。
注意：在替换时，子串中的每个字母都必须作为 独立的 项进行计数，也就是说，如果 s[left..right] = ""aaa"" 且 k = 2，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 s，可以认为每次检测都是独立的）
  示例：
输入：s = ""abcda"", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
输出：[true,false,false,true,true]
解释：
queries[0] : 子串 = ""d""，回文。
queries[1] : 子串 = ""bc""，不是回文。
queries[2] : 子串 = ""abcd""，只替换 1 个字符是变不成回文串的。
queries[3] : 子串 = ""abcd""，可以变成回文的 ""abba""。 也可以变成 ""baab""，先重新排序变成 ""bacd""，然后把 ""cd"" 替换为 ""ab""。
queries[4] : 子串 = ""abcda""，可以变成回文的 ""abcba""。
  提示：
1 <= s.length, queries.length <= 10^5
0 <= queries[i][0] <= queries[i][1] < s.length
0 <= queries[i][2] <= s.length
s 中只有小写英文字母",60,,6969,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/prefix-sum/']",[],25131
评论 (289),number-of-valid-words-for-each-puzzle,困难,"外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。
字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：
单词 word 中包含谜面 puzzle 的第一个字母。
单词 word 中的每一个字母都可以在谜面 puzzle 中找到。
例如，如果字谜的谜面是 ""abcdefg""，那么可以作为谜底的单词有 ""faced"", ""cabbage"", 和 ""baggage""；而 ""beefed""（不含字母 ""a""）以及 ""based""（其中的 ""s"" 没有出现在谜面中）都不能作为谜底。
返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。
  示例：
输入：
words = [""aaaa"",""asas"",""able"",""ability"",""actt"",""actor"",""access""], 
puzzles = [""aboveyz"",""abrodyz"",""abslute"",""absoryz"",""actresz"",""gaswxyz""]
输出：[1,1,3,2,4,0]
解释：
1 个单词可以作为 ""aboveyz"" 的谜底 : ""aaaa"" 
1 个单词可以作为 ""abrodyz"" 的谜底 : ""aaaa""
3 个单词可以作为 ""abslute"" 的谜底 : ""aaaa"", ""asas"", ""able""
2 个单词可以作为 ""absoryz"" 的谜底 : ""aaaa"", ""asas""
4 个单词可以作为 ""actresz"" 的谜底 : ""aaaa"", ""asas"", ""actt"", ""access""
没有单词可以作为 ""gaswxyz"" 的谜底，因为列表中的单词都不含字母 'g'。
  提示：
1 <= words.length <= 10^5
4 <= words[i].length <= 50
1 <= puzzles.length <= 10^4
puzzles[i].length == 7
words[i][j], puzzles[i][j] 都是小写英文字母。
每个 puzzles[i] 所包含的字符都不重复。",230,,19272,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],41542
评论 (268),reformat-department-table,简单,"SQL架构
部门表 Department：
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| revenue       | int     |
| month         | varchar |
+---------------+---------+
(id, month) 是表的联合主键。
这个表格有关于每个部门每月收入的信息。
月份（month）可以取下列值 [""Jan"",""Feb"",""Mar"",""Apr"",""May"",""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",""Nov"",""Dec""]。
  编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 每个月 的收入（revenue）列。
查询结果格式如下面的示例所示：
Department 表：
+------+---------+-------+
| id   | revenue | month |
+------+---------+-------+
| 1    | 8000    | Jan   |
| 2    | 9000    | Jan   |
| 3    | 10000   | Feb   |
| 1    | 7000    | Feb   |
| 1    | 6000    | Mar   |
+------+---------+-------+

查询得到的结果表：
+------+-------------+-------------+-------------+-----+-------------+
| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |
+------+-------------+-------------+-------------+-----+-------------+
| 1    | 8000        | 7000        | 6000        | ... | null        |
| 2    | 9000        | null        | null        | ... | null        |
| 3    | null        | 10000       | null        | ... | null        |
+------+-------------+-------------+-------------+-----+-------------+

注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。",173,,38479,['https://leetcode.cn/tag/database/'],[],59995
评论 (53),count-substrings-with-only-one-distinct-letter,Unknown,,-1,,-1,[],[],-1
评论 (14),before-and-after-puzzle,Unknown,,-1,,-1,[],[],-1
评论 (44),shortest-distance-to-target-color,Unknown,,-1,,-1,[],[],-1
评论 (8),maximum-number-of-ones,Unknown,,-1,,-1,[],[],-1
评论 (183),distance-between-bus-stops,简单,"环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。
环线上的公交车都可以按顺时针和逆时针的方向行驶。
返回乘客从出发点 start 到目的地 destination 之间的最短距离。
  示例 1：
输入：distance = [1,2,3,4], start = 0, destination = 1
输出：1
解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。
  示例 2：
输入：distance = [1,2,3,4], start = 0, destination = 2
输出：3
解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。
  示例 3：
输入：distance = [1,2,3,4], start = 0, destination = 3
输出：4
解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。
  提示：
1 <= n <= 10^4
distance.length == n
0 <= start, destination < n
0 <= distance[i] <= 10^4",50,,16010,['https://leetcode.cn/tag/array/'],[],27391
评论 (356),day-of-the-week,简单,"给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
输入为三个整数：day、month 和 year，分别表示日、月、年。
您返回的结果必须是这几个值中的一个 {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""}。
  示例 1：
输入：day = 31, month = 8, year = 2019
输出：""Saturday""
示例 2：
输入：day = 18, month = 7, year = 1999
输出：""Sunday""
示例 3：
输入：day = 15, month = 8, year = 1993
输出：""Sunday""
  提示：
给出的日期一定是在 1971 到 2100 年之间的有效日期。",113,,36039,['https://leetcode.cn/tag/math/'],[],57544
评论 (104),maximum-subarray-sum-with-one-deletion,中等,"给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。
注意，删除一个元素后，子数组 不能为空。
  示例 1：
输入：arr = [1,-2,0,3]
输出：4
解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
示例 2：
输入：arr = [1,-2,-2,3]
输出：3
解释：我们直接选出 [3]，这就是最大和。
示例 3：
输入：arr = [-1,-1,-1,-1]
输出：-1
解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。
  提示：
1 <= arr.length <= 105
-104 <= arr[i] <= 104",130,,9259,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],22706
评论 (23),make-array-strictly-increasing,困难,"给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。
每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 <= i < arr1.length 和 0 <= j < arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。
如果无法让 arr1 严格递增，请返回 -1。
  示例 1：
输入：arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
输出：1
解释：用 2 来替换 5，之后 arr1 = [1, 2, 3, 6, 7]。
示例 2：
输入：arr1 = [1,5,3,6,7], arr2 = [4,3,1]
输出：2
解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = [1, 3, 4, 6, 7]。
示例 3：
输入：arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
输出：-1
解释：无法使 arr1 严格递增。
  提示：
1 <= arr1.length, arr2.length <= 2000
0 <= arr1[i], arr2[i] <= 10^9
 ",80,,2324,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],5057
评论 (34),design-bounded-blocking-queue,Unknown,,-1,,-1,[],[],-1
评论 (482),maximum-number-of-balloons,简单,"给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 ""balloon""（气球）。
字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 ""balloon""。
  示例 1：
输入：text = ""nlaebolko""
输出：1
示例 2：
输入：text = ""loonbalxballpoon""
输出：2
示例 3：
输入：text = ""leetcode""
输出：0
  提示：
1 <= text.length <= 10^4
text 全部由小写英文字母组成",110,,53098,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],77287
评论 (412),reverse-substrings-between-each-pair-of-parentheses,中等,"给出一个字符串 s（仅含有小写英文字母和括号）。
请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。
注意，您的结果中 不应 包含任何括号。
  示例 1：
输入：s = ""(abcd)""
输出：""dcba""
示例 2：
输入：s = ""(u(love)i)""
输出：""iloveu""
解释：先反转子字符串 ""love"" ，然后反转整个字符串。
示例 3：
输入：s = ""(ed(et(oc))el)""
输出：""leetcode""
解释：先反转子字符串 ""oc"" ，接着反转 ""etco"" ，然后反转整个字符串。
示例 4：
输入：s = ""a(bcdefghijkl(mno)p)q""
输出：""apmnolkjihgfedcbq""
  提示：
0 <= s.length <= 2000
s 中只有小写英文字母和括号
题目测试用例确保所有括号都是成对出现的",229,,50762,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],78225
评论 (71),k-concatenation-maximum-sum,中等,"给定一个整数数组 arr 和一个整数 k ，通过重复 k 次来修改数组。
例如，如果 arr = [1, 2] ， k = 3 ，那么修改后的数组将是 [1, 2, 1, 2, 1, 2] 。
返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 0，在这种情况下它的总和也是 0。
由于 结果可能会很大，需要返回的 109 + 7 的 模 。
  示例 1：
输入：arr = [1,2], k = 3
输出：9
示例 2：
输入：arr = [1,-2,1], k = 5
输出：2
示例 3：
输入：arr = [-1,-2], k = 7
输出：0
  提示：
1 <= arr.length <= 105
1 <= k <= 105
-104 <= arr[i] <= 104",92,,6849,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],25617
评论 (59),critical-connections-in-a-network,困难,"力扣数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 connections 是无向的。从形式上讲，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。
「关键连接」 是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。
请你以任意顺序返回该集群内的所有 「关键连接」。
  示例 1：
输入：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
输出：[[1,3]]
解释：[[3,1]] 也是正确的。
示例 2:
输入：n = 2, connections = [[0,1]]
输出：[[0,1]]
  提示：
1 <= n <= 10^5
n-1 <= connections.length <= 10^5
connections[i][0] != connections[i][1]
不存在重复的连接",191,,6044,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/biconnected-component/']",[],11572
评论 (156),monthly-transactions-i,Unknown,,-1,,-1,[],[],-1
评论 (155),tournament-winners,Unknown,,-1,,-1,[],[],-1
评论 (239),fizz-buzz-multithreaded,中等,"编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：
如果这个数字可以被 3 整除，输出 ""fizz""。
如果这个数字可以被 5 整除，输出 ""buzz""。
如果这个数字可以同时被 3 和 5 整除，输出 ""fizzbuzz""。
例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。
假设有这么一个类：
class FizzBuzz {
  public FizzBuzz(int n) { ... }               // constructor
  public void fizz(printFizz) { ... }          // only output ""fizz""
  public void buzz(printBuzz) { ... }          // only output ""buzz""
  public void fizzbuzz(printFizzBuzz) { ... }  // only output ""fizzbuzz""
  public void number(printNumber) { ... }      // only output the numbers
}
请你实现一个有四个线程的多线程版  FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用：
线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。
线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。
线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。
线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。
  提示：
本题已经提供了打印字符串的相关方法，如 printFizz() 等，具体方法名请参考答题模板中的注释部分。
 ",77,,17160,['https://leetcode.cn/tag/concurrency/'],[],26716
评论 (30),how-many-apples-can-you-put-into-the-basket,Unknown,,-1,,-1,[],[],-1
评论 (28),minimum-knight-moves,Unknown,,-1,,-1,[],[],-1
评论 (42),find-smallest-common-element-in-all-rows,Unknown,,-1,,-1,[],[],-1
评论 (11),minimum-time-to-build-blocks,Unknown,,-1,,-1,[],[],-1
评论 (219),minimum-absolute-difference,简单,"给你个整数数组 arr，其中每个元素都 不相同。
请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。
  示例 1：
输入：arr = [4,2,1,3]
输出：[[1,2],[2,3],[3,4]]
示例 2：
输入：arr = [1,3,6,10,15]
输出：[[1,3]]
示例 3：
输入：arr = [3,8,-10,23,19,-4,-14,27]
输出：[[-14,-10],[19,23],[23,27]]
  提示：
2 <= arr.length <= 10^5
-10^6 <= arr[i] <= 10^6",61,,21698,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],31807
评论 (82),ugly-number-iii,中等,"给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。
丑数是可以被 a 或 b 或 c 整除的 正整数 。
  示例 1：
输入：n = 3, a = 2, b = 3, c = 5
输出：4
解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。
示例 2：
输入：n = 4, a = 2, b = 3, c = 4
输出：6
解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。
示例 3：
输入：n = 5, a = 2, b = 11, c = 13
输出：10
解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。
示例 4：
输入：n = 1000000000, a = 2, b = 217983653, c = 336916467
输出：1999999984
  提示：
1 <= n, a, b, c <= 10^9
1 <= a * b * c <= 10^18
本题结果在 [1, 2 * 10^9] 的范围内",108,,7833,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/number-theory/']",[],29931
评论 (299),smallest-string-with-swaps,中等,"给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。
你可以 任意多次交换 在 pairs 中任意一对索引处的字符。
返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。
  示例 1:
输入：s = ""dcab"", pairs = [[0,3],[1,2]]
输出：""bacd""
解释： 
交换 s[0] 和 s[3], s = ""bcad""
交换 s[1] 和 s[2], s = ""bacd""
示例 2：
输入：s = ""dcab"", pairs = [[0,3],[1,2],[0,2]]
输出：""abcd""
解释：
交换 s[0] 和 s[3], s = ""bcad""
交换 s[0] 和 s[2], s = ""acbd""
交换 s[1] 和 s[2], s = ""abcd""
示例 3：
输入：s = ""cba"", pairs = [[0,1],[1,2]]
输出：""abc""
解释：
交换 s[0] 和 s[1], s = ""bca""
交换 s[1] 和 s[2], s = ""bac""
交换 s[0] 和 s[1], s = ""abc""
  提示：
1 <= s.length <= 10^5
0 <= pairs.length <= 10^5
0 <= pairs[i][0], pairs[i][1] < s.length
s 中只含有小写英文字母",273,,29126,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],57491
评论 (271),sort-items-by-groups-respecting-dependencies,困难,"有 n 个项目，每个项目或者不属于任何小组，或者属于 m 个小组之一。group[i] 表示第 i 个项目所属的小组，如果第 i 个项目不属于任何小组，则 group[i] 等于 -1。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。
请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：
同一小组的项目，排序后在列表中彼此相邻。
项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。
如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。
  示例 1：
输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
输出：[6,3,4,1,5,2,0,7]
示例 2：
输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
输出：[]
解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。
  提示：
1 <= m <= n <= 3 * 104
group.length == beforeItems.length == n
-1 <= group[i] <= m - 1
0 <= beforeItems[i].length <= n - 1
0 <= beforeItems[i][j] <= n - 1
i != beforeItems[i][j]
beforeItems[i] 不含重复元素",193,,12851,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']",[],20828
评论 (161),last-person-to-fit-in-the-bus,Unknown,,-1,,-1,[],[],-1
评论 (157),monthly-transactions-ii,Unknown,,-1,,-1,[],[],-1
评论 (96),design-skiplist,困难,"不使用任何库函数，设计一个 跳表 。
跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。
例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作：

Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons
跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。
了解更多 : https://en.wikipedia.org/wiki/Skip_list
在本题中，你的设计应该要包含这些函数：
bool search(int target) : 返回target是否存在于跳表中。
void add(int num): 插入一个元素到跳表。
bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。
注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。
  示例 1:
输入
[""Skiplist"", ""add"", ""add"", ""add"", ""search"", ""add"", ""search"", ""erase"", ""erase"", ""search""]
[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]
输出
[null, null, null, null, false, null, true, false, true, false]

解释
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // 返回 false
skiplist.add(4);
skiplist.search(1);   // 返回 true
skiplist.erase(0);    // 返回 false，0 不在跳表中
skiplist.erase(1);    // 返回 true
skiplist.search(1);   // 返回 false，1 已被擦除
  提示:
0 <= num, target <= 2 * 104
调用search, add,  erase操作次数不大于 5 * 104 ",118,,10833,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/linked-list/']",[],17365
评论 (541),unique-number-of-occurrences,简单,"给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。
如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。
  示例 1：
输入：arr = [1,2,2,1,1,3]
输出：true
解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。
示例 2：
输入：arr = [1,2]
输出：false
示例 3：
输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]
输出：true
  提示：
1 <= arr.length <= 1000
-1000 <= arr[i] <= 1000",135,,64966,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],89091
评论 (506),get-equal-substrings-within-budget,中等,"给你两个长度相同的字符串，s 和 t。
将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。
用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。
如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。
如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。
  示例 1：
输入：s = ""abcd"", t = ""bcdf"", maxCost = 3
输出：3
解释：s 中的 ""abc"" 可以变为 ""bcd""。开销为 3，所以最大长度为 3。
示例 2：
输入：s = ""abcd"", t = ""cdef"", maxCost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。
示例 3：
输入：s = ""abcd"", t = ""acde"", maxCost = 0
输出：1
解释：a -> a, cost = 0，字符串未发生变化，所以最大长度为 1。
  提示：
1 <= s.length, t.length <= 10^5
0 <= maxCost <= 10^6
s 和 t 都只含小写英文字母。",168,,56885,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",[],113934
评论 (135),remove-all-adjacent-duplicates-in-string-ii,中等,"给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。
你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。
在执行完所有删除操作后，返回最终得到的字符串。
本题答案保证唯一。
  示例 1：
输入：s = ""abcd"", k = 2
输出：""abcd""
解释：没有要删除的内容。
示例 2：
输入：s = ""deeedbbcccbdaa"", k = 3
输出：""aa""
解释： 
先删除 ""eee"" 和 ""ccc""，得到 ""ddbbbdaa""
再删除 ""bbb""，得到 ""dddaa""
最后删除 ""ddd""，得到 ""aa""
示例 3：
输入：s = ""pbbcggttciiippooaais"", k = 2
输出：""ps""
  提示：
1 <= s.length <= 10^5
2 <= k <= 10^4
s 中只含有小写英文字母。",139,,15063,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],29274
评论 (61),minimum-moves-to-reach-target-with-rotations,困难,"你还记得那条风靡全球的贪吃蛇吗？
我们在一个 n*n 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（(0, 0) 和 (0, 1)）开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（(n-1, n-2) 和 (n-1, n-1)）。
每次移动，蛇可以这样走：
如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。
如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。
如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。
如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。
返回蛇抵达目的地所需的最少移动次数。
如果无法到达目的地，请返回 -1。
  示例 1：
输入：grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
输出：11
解释：
一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。
示例 2：
输入：grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
输出：9
  提示：
2 <= n <= 100
0 <= grid[i][j] <= 1
蛇保证从空单元格开始出发。",42,,3009,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],6585
评论 (152),queries-quality-and-percentage,Unknown,,-1,,-1,[],[],-1
评论 (203),team-scores-in-football-tournament,Unknown,,-1,,-1,[],[],-1
评论 (76),intersection-of-three-sorted-arrays,Unknown,,-1,,-1,[],[],-1
评论 (38),two-sum-bsts,Unknown,,-1,,-1,[],[],-1
评论 (19),stepping-numbers,Unknown,,-1,,-1,[],[],-1
评论 (26),valid-palindrome-iii,Unknown,,-1,,-1,[],[],-1
评论 (294),minimum-cost-to-move-chips-to-the-same-position,简单,"有 n 个筹码。第 i 个芯片的位置是 position[i] 。
我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 i 个芯片的位置从 position[i] 改变为:
position[i] + 2 或 position[i] - 2 ，此时 cost = 0
position[i] + 1 或 position[i] - 1 ，此时 cost = 1
返回将所有筹码移动到同一位置上所需要的 最小代价 。
  示例 1：
输入：position = [1,2,3]
输出：1
解释：第一步:将位置3的芯片移动到位置1，成本为0。
第二步:将位置2的芯片移动到位置1，成本= 1。
总成本是1。
示例 2：
输入：position = [2,2,2,3,3]
输出：2
解释：我们可以把位置3的两个芯片移到位置2。每一步的成本为1。总成本= 2。
示例 3:
输入：position = [1,1000000000]
输出：1
  提示：
1 <= chips.length <= 100
1 <= chips[i] <= 10^9",118,,26083,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],37275
评论 (288),longest-arithmetic-subsequence-of-given-difference,中等,"给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。
子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。
  示例 1：
输入：arr = [1,2,3,4], difference = 1
输出：4
解释：最长的等差子序列是 [1,2,3,4]。
示例 2：
输入：arr = [1,3,5,7], difference = 1
输出：1
解释：最长的等差子序列是任意单个元素。
示例 3：
输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2
输出：4
解释：最长的等差子序列是 [7,5,3,1]。
  提示：
1 <= arr.length <= 105
-104 <= arr[i], difference <= 104",215,,39788,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/dynamic-programming/']",[],77015
评论 (339),path-with-maximum-gold,中等,"你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。
为了使收益最大化，矿工需要按以下规则来开采黄金：
每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。
  示例 1：
输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。
示例 2：
输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
输出：28
解释：
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
一种收集最多黄金的路线是：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7。
  提示：
1 <= grid.length, grid[i].length <= 15
0 <= grid[i][j] <= 100
最多 25 个单元格中有黄金。",209,,36057,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/matrix/']",[],51759
评论 (261),count-vowels-permutation,困难,"给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：
字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）
每个元音 'a' 后面都只能跟着 'e'
每个元音 'e' 后面只能跟着 'a' 或者是 'i'
每个元音 'i' 后面 不能 再跟着另一个 'i'
每个元音 'o' 后面只能跟着 'i' 或者是 'u'
每个元音 'u' 后面只能跟着 'a'
由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。
  示例 1：
输入：n = 1
输出：5
解释：所有可能的字符串分别是：""a"", ""e"", ""i"" , ""o"" 和 ""u""。
示例 2：
输入：n = 2
输出：10
解释：所有可能的字符串分别是：""ae"", ""ea"", ""ei"", ""ia"", ""ie"", ""io"", ""iu"", ""oi"", ""ou"" 和 ""ua""。
示例 3：
输入：n = 5
输出：68
  提示：
1 <= n <= 2 * 10^4",143,,25202,['https://leetcode.cn/tag/dynamic-programming/'],[],41524
评论 (705),split-a-string-in-balanced-strings,简单,"在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。
给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。
注意：分割得到的每个字符串都必须是平衡字符串，且分割得到的平衡字符串是原平衡字符串的连续子串。
返回可以通过分割得到的平衡字符串的 最大数量 。
  示例 1：
输入：s = ""RLRRLLRLRL""
输出：4
解释：s 可以分割为 ""RL""、""RRLL""、""RL""、""RL"" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
示例 2：
输入：s = ""RLLLLRRRLR""
输出：3
解释：s 可以分割为 ""RL""、""LLLRRR""、""LR"" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
示例 3：
输入：s = ""LLLLRRRR""
输出：1
解释：s 只能保持原样 ""LLLLRRRR"".
示例 4：
输入：s = ""RLRRRLLRLL""
输出：2
解释：s 可以分割为 ""RL""、""RRRLLRLL"" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
  提示：
1 <= s.length <= 1000
s[i] = 'L' 或 'R'
s 是一个 平衡 字符串",184,,83362,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],98727
评论 (97),queens-that-can-attack-the-king,中等,"在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。
给定一个由整数坐标组成的数组 queens ，表示黑皇后的位置；以及一对坐标 king ，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。
  示例 1：
输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
输出：[[0,1],[1,0],[3,3]]
解释： 
[0,1] 的皇后可以攻击到国王，因为他们在同一行上。 
[1,0] 的皇后可以攻击到国王，因为他们在同一列上。 
[3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。 
[0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。 
[4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。 
[2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。
示例 2：
输入：queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
输出：[[2,2],[3,4],[4,4]]
示例 3：
输入：queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
输出：[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]
  提示：
1 <= queens.length <= 63
queens[i].length == 2
0 <= queens[i][j] < 8
king.length == 2
0 <= king[0], king[1] < 8
一个棋盘格上最多只能放置一枚棋子。",47,,7116,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],10426
评论 (55),dice-roll-simulation,困难,"有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。
不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。
现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。
假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。
  示例 1：
输入：n = 2, rollMax = [1,1,2,2,2,3]
输出：34
解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。
示例 2：
输入：n = 2, rollMax = [1,1,1,1,1,1]
输出：30
示例 3：
输入：n = 3, rollMax = [1,1,1,2,2,3]
输出：181
  提示：
1 <= n <= 5000
rollMax.length == 6
1 <= rollMax[i] <= 15",92,,3796,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],7895
评论 (60),maximum-equal-frequency,困难,"给你一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回该前缀的长度：
从前缀中 恰好删除一个 元素后，剩下每个数字的出现次数都相同。
如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。
  示例 1：
输入：nums = [2,2,1,1,5,3,3,5]
输出：7
解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4] = 5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。
示例 2：
输入：nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
输出：13
  提示：
2 <= nums.length <= 105
1 <= nums[i] <= 105",61,,5341,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],16114
评论 (136),report-contiguous-dates,Unknown,,-1,,-1,[],[],-1
评论 (213),the-dining-philosophers,中等,"5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）
所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。
假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。
设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。
问题描述和图片来自维基百科 wikipedia.org
  哲学家从 0 到 4 按 顺时针 编号。请实现函数 void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)：
philosopher 哲学家的编号。
pickLeftFork 和 pickRightFork 表示拿起左边或右边的叉子。
eat 表示吃面。
putLeftFork 和 putRightFork 表示放下左边或右边的叉子。
由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。
给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。
  示例：
输入：n = 1
输出：[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]
解释:
n 表示每个哲学家需要进餐的次数。
输出数组描述了叉子的控制和进餐的调用，它的格式如下：
output[i] = [a, b, c] (3个整数)
- a 哲学家编号。
- b 指定叉子：{1 : 左边, 2 : 右边}.
- c 指定行为：{1 : 拿起, 2 : 放下, 3 : 吃面}。
如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。
  提示：
1 <= n <= 60",110,,14729,['https://leetcode.cn/tag/concurrency/'],[],24879
评论 (146),airplane-seat-assignment-probability,中等,"有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。
剩下的乘客将会：
如果他们自己的座位还空着，就坐到自己的座位上，
当他们自己的座位被占用时，随机选择其他座位
第 n 位乘客坐在自己的座位上的概率是多少？
  示例 1：
输入：n = 1
输出：1.00000
解释：第一个人只会坐在自己的位置上。
示例 2：
输入: n = 2
输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
  提示：
1 <= n <= 10^5",102,,11823,"['https://leetcode.cn/tag/brainteaser/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/probability-and-statistics/']",[],17735
评论 (45),missing-number-in-arithmetic-progression,Unknown,,-1,,-1,[],[],-1
评论 (36),meeting-scheduler,Unknown,,-1,,-1,[],[],-1
评论 (36),toss-strange-coins,Unknown,,-1,,-1,[],[],-1
评论 (58),divide-chocolate,Unknown,,-1,,-1,[],[],-1
评论 (309),check-if-it-is-a-straight-line,简单,"给定一个数组 coordinates ，其中 coordinates[i] = [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。
  示例 1：
输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
输出：true
示例 2：
输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
输出：false
  提示：
2 <= coordinates.length <= 1000
coordinates[i].length == 2
-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4
coordinates 中不含重复的点",113,,39428,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],85058
评论 (82),remove-sub-folders-from-the-filesystem,中等,"你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。
如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。
文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：'/' 后跟一个或者多个小写英文字母。
例如，""/leetcode"" 和 ""/leetcode/problems"" 都是有效的路径，而空字符串和 ""/"" 不是。
  示例 1：
输入：folder = [""/a"",""/a/b"",""/c/d"",""/c/d/e"",""/c/f""]
输出：[""/a"",""/c/d"",""/c/f""]
解释：""/a/b/"" 是 ""/a"" 的子文件夹，而 ""/c/d/e"" 是 ""/c/d"" 的子文件夹。
示例 2：
输入：folder = [""/a"",""/a/b/c"",""/a/b/d""]
输出：[""/a""]
解释：文件夹 ""/a/b/c"" 和 ""/a/b/d/"" 都会被删除，因为它们都是 ""/a"" 的子文件夹。
示例 3：
输入: folder = [""/a/b/c"",""/a/b/ca"",""/a/b/d""]
输出: [""/a/b/c"",""/a/b/ca"",""/a/b/d""]
  提示：
1 <= folder.length <= 4 * 104
2 <= folder[i].length <= 100
folder[i] 只包含小写字母和 '/'
folder[i] 总是以字符 '/' 起始
每个文件夹名都是 唯一 的",60,,10157,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],20311
评论 (69),replace-the-substring-for-balanced-string,中等,"有一个只含有 'Q', 'W', 'E', 'R' 四种字符，且长度为 n 的字符串。
假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。
  给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。
你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。
请返回待替换子串的最小可能长度。
如果原字符串自身就是一个平衡字符串，则返回 0。
  示例 1：
输入：s = ""QWER""
输出：0
解释：s 已经是平衡的了。
示例 2：
输入：s = ""QQWE""
输出：1
解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 ""RQWE"" (或 ""QRWE"") 是平衡的。
示例 3：
输入：s = ""QQQW""
输出：2
解释：我们可以把前面的 ""QQ"" 替换成 ""ER""。 
示例 4：
输入：s = ""QQQQ""
输出：3
解释：我们可以替换后 3 个 'Q'，使 s = ""QWER""。
  提示：
1 <= s.length <= 10^5
s.length 是 4 的倍数
s 中只含有 'Q', 'W', 'E', 'R' 四种字符",84,,7213,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],20529
评论 (84),maximum-profit-in-job-scheduling,困难,"你打算利用空闲时间来做兼职工作赚些零花钱。
这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。
给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。
注意，时间上出现重叠的 2 份工作不能同时进行。
如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。
  示例 1：
输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
输出：120
解释：
我们选出第 1 份和第 4 份工作， 
时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。
示例 2：
输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
输出：150
解释：
我们选择第 1，4，5 份工作。 
共获得报酬 150 = 20 + 70 + 60。
示例 3：
输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
输出：6
  提示：
1 <= startTime.length == endTime.length == profit.length <= 5 * 10^4
1 <= startTime[i] < endTime[i] <= 10^9
1 <= profit[i] <= 10^4",154,,8634,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],18077
评论 (29),web-crawler,Unknown,,-1,,-1,[],[],-1
评论 (136),find-positive-integer-solution-for-a-given-equation,中等,"给你一个函数  f(x, y) 和一个目标结果 z，函数公式未知，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。满足条件的结果数对可以按任意顺序返回。
尽管函数的具体式子未知，但它是单调递增函数，也就是说：
f(x, y) < f(x + 1, y)
f(x, y) < f(x, y + 1)
函数接口定义如下：
interface CustomFunction {
public:
  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.
  int f(int x, int y);
};
你的解决方案将按如下规则进行评判：
判题程序有一个由 CustomFunction 的 9 种实现组成的列表，以及一种为特定的 z 生成所有有效数对的答案的方法。
判题程序接受两个输入：function_id（决定使用哪种实现测试你的代码）以及目标结果 z 。
判题程序将会调用你实现的 findSolution 并将你的结果与答案进行比较。
如果你的结果与答案相符，那么解决方案将被视作正确答案，即 Accepted 。
  示例 1：
输入：function_id = 1, z = 5
输出：[[1,4],[2,3],[3,2],[4,1]]
解释：function_id = 1 暗含的函数式子为 f(x, y) = x + y
以下 x 和 y 满足 f(x, y) 等于 5：
x=1, y=4 -> f(1, 4) = 1 + 4 = 5
x=2, y=3 -> f(2, 3) = 2 + 3 = 5
x=3, y=2 -> f(3, 2) = 3 + 2 = 5
x=4, y=1 -> f(4, 1) = 4 + 1 = 5
示例 2：
输入：function_id = 2, z = 5
输出：[[1,5],[5,1]]
解释：function_id = 2 暗含的函数式子为 f(x, y) = x * y
以下 x 和 y 满足 f(x, y) 等于 5：
x=1, y=5 -> f(1, 5) = 1 * 5 = 5
x=5, y=1 -> f(5, 1) = 5 * 1 = 5
  提示：
1 <= function_id <= 9
1 <= z <= 100
题目保证 f(x, y) == z 的解处于 1 <= x, y <= 1000 的范围内。
在 1 <= x, y <= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。",55,,11231,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/interactive/']",[],15747
评论 (43),circular-permutation-in-binary-representation,中等,"给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,...,2^n-1) 的排列 p，并且满足：
p[0] = start
p[i] 和 p[i+1] 的二进制表示形式只有一位不同
p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同
  示例 1：
输入：n = 2, start = 3
输出：[3,2,0,1]
解释：这个排列的二进制表示是 (11,10,00,01)
     所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2]
示例 2：
输出：n = 3, start = 2
输出：[2,6,7,5,4,0,1,3]
解释：这个排列的二进制表示是 (010,110,111,101,100,000,001,011)
  提示：
1 <= n <= 16
0 <= start < 2^n",41,,3738,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/backtracking/']",[],5625
评论 (276),maximum-length-of-a-concatenated-string-with-unique-characters,中等,"给定一个字符串数组 arr，字符串 s 是将 arr 的含有 不同字母 的 子序列 字符串 连接 所得的字符串。
请返回所有可行解 s 中最长长度。
子序列 是一种可以从另一个数组派生而来的数组，通过删除某些元素或不删除元素而不改变其余元素的顺序。
  示例 1：
输入：arr = [""un"",""iq"",""ue""]
输出：4
解释：所有可能的串联组合是：
- """"
- ""un""
- ""iq""
- ""ue""
- ""uniq"" (""un"" + ""iq"")
- ""ique"" (""iq"" + ""ue"")
最大长度为 4。
示例 2：
输入：arr = [""cha"",""r"",""act"",""ers""]
输出：6
解释：可能的解答有 ""chaers"" 和 ""acters""。
示例 3：
输入：arr = [""abcdefghijklmnopqrstuvwxyz""]
输出：26
  提示：
1 <= arr.length <= 16
1 <= arr[i].length <= 26
arr[i] 中只含有小写英文字母",201,,37289,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],76167
评论 (30),tiling-a-rectangle-with-the-fewest-squares,困难,"你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。
房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。
假设正方形瓷砖的规格不限，边长都是整数。
请你帮设计师计算一下，最少需要用到多少块方形瓷砖？
  示例 1：
输入：n = 2, m = 3
输出：3
解释：3 块地砖就可以铺满卧室。
     2 块 1x1 地砖
     1 块 2x2 地砖
示例 2：
输入：n = 5, m = 8
输出：5
示例 3：
输入：n = 11, m = 13
输出：6
  提示：
1 <= n <= 13
1 <= m <= 13",83,,3044,"['https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/']",[],6088
评论 (164),number-of-comments-per-post,Unknown,,-1,,-1,[],[],-1
评论 (18),web-crawler-multithreaded,Unknown,,-1,,-1,[],[],-1
评论 (42),array-transformation,Unknown,,-1,,-1,[],[],-1
评论 (26),design-a-leaderboard,Unknown,,-1,,-1,[],[],-1
评论 (41),tree-diameter,Unknown,,-1,,-1,[],[],-1
评论 (35),palindrome-removal,Unknown,,-1,,-1,[],[],-1
评论 (92),minimum-swaps-to-make-strings-equal,中等,"有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 ""x"" 和 ""y""，你需要通过「交换字符」的方式使这两个字符串相同。
每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。
交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。
最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。
  示例 1：
输入：s1 = ""xx"", s2 = ""yy""
输出：1
解释：
交换 s1[0] 和 s2[1]，得到 s1 = ""yx""，s2 = ""yx""。
示例 2：
输入：s1 = ""xy"", s2 = ""yx""
输出：2
解释：
交换 s1[0] 和 s2[0]，得到 s1 = ""yy""，s2 = ""xx"" 。
交换 s1[0] 和 s2[1]，得到 s1 = ""xy""，s2 = ""xy"" 。
注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 ""yx""，因为我们只能交换属于两个不同字符串的字符。
示例 3：
输入：s1 = ""xx"", s2 = ""xy""
输出：-1
示例 4：
输入：s1 = ""xxyyxyxyxx"", s2 = ""xyyxyxxxyx""
输出：4
  提示：
1 <= s1.length, s2.length <= 1000
s1, s2 只包含 'x' 或 'y'。",60,,10981,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],17613
评论 (357),count-number-of-nice-subarrays,中等,"给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。
请返回这个数组中 「优美子数组」 的数目。
  示例 1：
输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
示例 2：
输入：nums = [2,4,6], k = 1
输出：0
解释：数列中不包含任何奇数，所以不存在优美子数组。
示例 3：
输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
输出：16
  提示：
1 <= nums.length <= 50000
1 <= nums[i] <= 10^5
1 <= k <= nums.length",218,,41791,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sliding-window/']",[],73342
评论 (202),minimum-remove-to-make-valid-parentheses,中等,"给你一个由 '('、')' 和小写字母组成的字符串 s。
你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。
请返回任意一个合法字符串。
有效「括号字符串」应当符合以下 任意一条 要求：
空字符串或只包含小写字母的字符串
可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」
  示例 1：
输入：s = ""lee(t(c)o)de)""
输出：""lee(t(c)o)de""
解释：""lee(t(co)de)"" , ""lee(t(c)ode)"" 也是一个可行答案。
示例 2：
输入：s = ""a)b(c)d""
输出：""ab(c)d""
示例 3：
输入：s = ""))((""
输出：""""
解释：空字符串也是有效的
  提示：
1 <= s.length <= 105
s[i] 可能是 '('、')' 或英文小写字母",181,,32513,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],55471
评论 (35),check-if-it-is-a-good-array,困难,"给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。
假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。
  示例 1：
输入：nums = [12,5,7,23]
输出：true
解释：挑选数字 5 和 7。
5*3 + 7*(-2) = 1
示例 2：
输入：nums = [29,6,10]
输出：true
解释：挑选数字 29, 6 和 10。
29*1 + 6*(-3) + 10*(-1) = 1
示例 3：
输入：nums = [3,6]
输出：false
  提示：
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9",29,,3498,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/number-theory/']",[],6005
评论 (178),average-selling-price,Unknown,,-1,,-1,[],[],-1
评论 (222),cells-with-odd-values-in-a-matrix,简单,"给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。
另有一个二维索引数组 indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。
对 indices[i] 所指向的每个位置，应同时执行下述增量操作：
ri 行上的所有单元格，加 1 。
ci 列上的所有单元格，加 1 。
给你 m、n 和 indices 。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 奇数值单元格 的数目。
  示例 1：
输入：m = 2, n = 3, indices = [[0,1],[1,1]]
输出：6
解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。
第一次增量操作后得到 [[1,2,1],[0,1,0]]。
最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。
示例 2：
输入：m = 2, n = 2, indices = [[1,1],[0,0]]
输出：0
解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。
  提示：
1 <= m, n <= 50
1 <= indices.length <= 100
0 <= ri < m
0 <= ci < n
  进阶：你可以设计一个时间复杂度为 O(n + m + indices.length) 且仅用 O(n + m) 额外空间的算法来解决此问题吗？",69,,20052,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],26861
评论 (52),reconstruct-a-2-row-binary-matrix,中等,"给你一个 2 行 n 列的二进制数组：
矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 0 就是 1。
第 0 行的元素之和为 upper。
第 1 行的元素之和为 lower。
第 i 列（从 0 开始编号）的元素之和为 colsum[i]，colsum 是一个长度为 n 的整数数组。
你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。
如果有多个不同的答案，那么任意一个都可以通过本题。
如果不存在符合要求的答案，就请返回一个空的二维数组。
  示例 1：
输入：upper = 2, lower = 1, colsum = [1,1,1]
输出：[[1,1,0],[0,0,1]]
解释：[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。
示例 2：
输入：upper = 2, lower = 3, colsum = [2,2,1,1]
输出：[]
示例 3：
输入：upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]
输出：[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]
  提示：
1 <= colsum.length <= 10^5
0 <= upper, lower <= colsum.length
0 <= colsum[i] <= 2",25,,5980,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],15019
评论 (216),number-of-closed-islands,中等,"二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。
请返回 封闭岛屿 的数目。
  示例 1：
输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：
灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
示例 2：
输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
输出：1
示例 3：
输入：grid = [[1,1,1,1,1,1,1],
             [1,0,0,0,0,0,1],
             [1,0,1,1,1,0,1],
             [1,0,1,0,1,0,1],
             [1,0,1,1,1,0,1],
             [1,0,0,0,0,0,1],
             [1,1,1,1,1,1,1]]
输出：2
  提示：
1 <= grid.length, grid[0].length <= 100
0 <= grid[i][j] <=1",138,,26808,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],43414
评论 (49),maximum-score-words-formed-by-letters,困难,"你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。
请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。
单词拼写游戏的规则概述如下：
玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。
可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。
单词表 words 中每个单词只能计分（使用）一次。
根据字母得分情况表score，字母 'a', 'b', 'c', ... , 'z' 对应的得分分别为 score[0], score[1], ..., score[25]。
本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。
  示例 1：
输入：words = [""dog"",""cat"",""dad"",""good""], letters = [""a"",""a"",""c"",""d"",""d"",""d"",""g"",""o"",""o""], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
输出：23
解释：
字母得分为  a=1, c=9, d=5, g=3, o=2
使用给定的字母表 letters，我们可以拼写单词 ""dad"" (5+1+5)和 ""good"" (3+2+2+5)，得分为 23 。
而单词 ""dad"" 和 ""dog"" 只能得到 21 分。
示例 2：
输入：words = [""xxxz"",""ax"",""bx"",""cx""], letters = [""z"",""a"",""b"",""c"",""x"",""x"",""x""], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
输出：27
解释：
字母得分为  a=4, b=4, c=4, x=5, z=10
使用给定的字母表 letters，我们可以组成单词 ""ax"" (4+5)， ""bx"" (4+5) 和 ""cx"" (4+5) ，总得分为 27 。
单词 ""xxxz"" 的得分仅为 25 。
示例 3：
输入：words = [""leetcode""], letters = [""l"",""e"",""t"",""c"",""o"",""d""], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
输出：0
解释：
字母 ""e"" 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。
  提示：
1 <= words.length <= 14
1 <= words[i].length <= 15
1 <= letters.length <= 100
letters[i].length == 1
score.length == 26
0 <= score[i] <= 10
words[i] 和 letters[i] 只包含小写的英文字母。",44,,3758,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",[],5357
评论 (17),encode-number,Unknown,,-1,,-1,[],[],-1
评论 (24),smallest-common-region,Unknown,,-1,,-1,[],[],-1
评论 (22),synonymous-sentences,Unknown,,-1,,-1,[],[],-1
评论 (36),handshakes-that-dont-cross,Unknown,,-1,,-1,[],[],-1
评论 (183),shift-2d-grid,简单,"给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。
每次「迁移」操作将会引发下述活动：
位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。
位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。
位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。
请你返回 k 次迁移操作后最终得到的 二维网格。
  示例 1：
输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[9,1,2],[3,4,5],[6,7,8]]
示例 2：
输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
示例 3：
输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
输出：[[1,2,3],[4,5,6],[7,8,9]]
  提示：
m == grid.length
n == grid[i].length
1 <= m <= 50
1 <= n <= 50
-1000 <= grid[i][j] <= 1000
0 <= k <= 100",52,,15415,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],25461
评论 (98),find-elements-in-a-contaminated-binary-tree,中等,"给出一个满足下述规则的二叉树：
root.val == 0
如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1
如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2
现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。
请你先还原二叉树，然后实现 FindElements 类：
FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。
bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。
  示例 1：
输入：
[""FindElements"",""find"",""find""]
[[[-1,null,-1]],[1],[2]]
输出：
[null,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True 
示例 2：
输入：
[""FindElements"",""find"",""find"",""find""]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
输出：
[null,true,true,false]
解释：
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False
示例 3：
输入：
[""FindElements"",""find"",""find"",""find"",""find""]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
输出：
[null,true,false,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True
  提示：
TreeNode.val == -1
二叉树的高度不超过 20
节点的总数在 [1, 10^4] 之间
调用 find() 的总次数在 [1, 10^4] 之间
0 <= target <= 10^6",30,,9420,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-tree/']",[],12856
评论 (136),greatest-sum-divisible-by-three,中等,"给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。
  示例 1：
输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
示例 2：
输入：nums = [4]
输出：0
解释：4 不能被 3 整除，所以无法选出数字，返回 0。
示例 3：
输入：nums = [1,2,3,4,4]
输出：12
解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。
  提示：
1 <= nums.length <= 4 * 10^4
1 <= nums[i] <= 10^4",177,,16828,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],31815
评论 (61),minimum-moves-to-move-a-box-to-their-target-location,困难,"「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。
游戏地图用大小为 m x n 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。
现在你将作为玩家参与游戏，按规则将箱子 'B' 移动到目标位置 'T' ：
玩家用字符 'S' 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。
地板用字符 '.' 表示，意味着可以自由行走。
墙用字符 '#' 表示，意味着障碍物，不能通行。 
箱子仅有一个，用字符 'B' 表示。相应地，网格上有一个目标位置 'T'。
玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。
玩家无法越过箱子。
返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。
  示例 1：
输入：grid = [[""#"",""#"",""#"",""#"",""#"",""#""],
             [""#"",""T"",""#"",""#"",""#"",""#""],
             [""#"",""."",""."",""B"",""."",""#""],
             [""#"",""."",""#"",""#"",""."",""#""],
             [""#"",""."",""."",""."",""S"",""#""],
             [""#"",""#"",""#"",""#"",""#"",""#""]]
输出：3
解释：我们只需要返回推箱子的次数。
示例 2：
输入：grid = [[""#"",""#"",""#"",""#"",""#"",""#""],
             [""#"",""T"",""#"",""#"",""#"",""#""],
             [""#"",""."",""."",""B"",""."",""#""],
             [""#"",""#"",""#"",""#"",""."",""#""],
             [""#"",""."",""."",""."",""S"",""#""],
             [""#"",""#"",""#"",""#"",""#"",""#""]]
输出：-1
示例 3：
输入：grid = [[""#"",""#"",""#"",""#"",""#"",""#""],
             [""#"",""T"",""."",""."",""#"",""#""],
             [""#"",""."",""#"",""B"",""."",""#""],
             [""#"",""."",""."",""."",""."",""#""],
             [""#"",""."",""."",""."",""S"",""#""],
             [""#"",""#"",""#"",""#"",""#"",""#""]]
输出：5
解释：向下、向左、向左、向上再向上。
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 20
grid 仅包含字符 '.', '#',  'S' , 'T', 以及 'B'。
grid 中 'S', 'B' 和 'T' 各只能出现一个。",84,,4077,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],9505
评论 (183),page-recommendations,Unknown,,-1,,-1,[],[],-1
评论 (43),print-immutable-linked-list-in-reverse,Unknown,,-1,,-1,[],[],-1
评论 (241),minimum-time-visiting-all-points,简单,"平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。
你需要按照下面的规则在平面上移动：
每一秒内，你可以：
沿水平方向移动一个单位长度，或者
沿竖直方向移动一个单位长度，或者
跨过对角线移动 sqrt(2) 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。
必须按照数组中出现的顺序来访问这些点。
在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。
  示例 1：
输入：points = [[1,1],[3,4],[-1,0]]
输出：7
解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
从 [1,1] 到 [3,4] 需要 3 秒 
从 [3,4] 到 [-1,0] 需要 4 秒
一共需要 7 秒
示例 2：
输入：points = [[3,2],[-2,2]]
输出：5
  提示：
points.length == n
1 <= n <= 100
points[i].length == 2
-1000 <= points[i][0], points[i][1] <= 1000",83,,32142,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],38928
评论 (84),count-servers-that-communicate,中等,"这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。
如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。
请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。
  示例 1：
输入：grid = [[1,0],[0,1]]
输出：0
解释：没有一台服务器能与其他服务器进行通信。
示例 2：
输入：grid = [[1,0],[1,1]]
输出：3
解释：所有这些服务器都至少可以与一台别的服务器进行通信。
示例 3：
输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]
输出：4
解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。
  提示：
m == grid.length
n == grid[i].length
1 <= m <= 250
1 <= n <= 250
grid[i][j] == 0 or 1",48,,10948,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/matrix/']",[],17927
评论 (115),search-suggestions-system,中等,"给你一个产品数组 products 和一个字符串 searchWord ，products  数组中每个产品都是一个字符串。
请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。
请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。
  示例 1：
输入：products = [""mobile"",""mouse"",""moneypot"",""monitor"",""mousepad""], searchWord = ""mouse""
输出：[
[""mobile"",""moneypot"",""monitor""],
[""mobile"",""moneypot"",""monitor""],
[""mouse"",""mousepad""],
[""mouse"",""mousepad""],
[""mouse"",""mousepad""]
]
解释：按字典序排序后的产品列表是 [""mobile"",""moneypot"",""monitor"",""mouse"",""mousepad""]
输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 [""mobile"",""moneypot"",""monitor""]
输入 mou， mous 和 mouse 后系统都返回 [""mouse"",""mousepad""]
示例 2：
输入：products = [""havana""], searchWord = ""havana""
输出：[[""havana""],[""havana""],[""havana""],[""havana""],[""havana""],[""havana""]]
示例 3：
输入：products = [""bags"",""baggage"",""banner"",""box"",""cloths""], searchWord = ""bags""
输出：[[""baggage"",""bags"",""banner""],[""baggage"",""bags"",""banner""],[""baggage"",""bags""],[""bags""]]
示例 4：
输入：products = [""havana""], searchWord = ""tatiana""
输出：[[],[],[],[],[],[],[]]
  提示：
1 <= products.length <= 1000
1 <= Σ products[i].length <= 2 * 10^4
products[i] 中所有的字符都是小写英文字母。
1 <= searchWord.length <= 1000
searchWord 中所有字符都是小写英文字母。",116,,10624,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],18069
评论 (289),number-of-ways-to-stay-in-the-same-place-after-some-steps,困难,"有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。
每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。
给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。
由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。
  示例 1：
输入：steps = 3, arrLen = 2
输出：4
解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动
示例  2：
输入：steps = 2, arrLen = 4
输出：2
解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。
向右，向左
不动，不动
示例 3：
输入：steps = 4, arrLen = 2
输出：8
  提示：
1 <= steps <= 500
1 <= arrLen <= 106",200,,31071,['https://leetcode.cn/tag/dynamic-programming/'],[],63311
评论 (169),all-people-report-to-the-given-manager,Unknown,,-1,,-1,[],[],-1
评论 (35),hexspeak,Unknown,,-1,,-1,[],[],-1
评论 (19),remove-interval,Unknown,,-1,,-1,[],[],-1
评论 (26),delete-tree-nodes,Unknown,,-1,,-1,[],[],-1
评论 (10),number-of-ships-in-a-rectangle,Unknown,,-1,,-1,[],[],-1
评论 (152),find-winner-on-a-tic-tac-toe-game,简单,"A 和 B 在一个 3 x 3 的网格上玩井字棋。
井字棋游戏的规则如下：
玩家轮流将棋子放在空方格 ("" "") 上。
第一个玩家 A 总是用 ""X"" 作为棋子，而第二个玩家 B 总是用 ""O"" 作为棋子。
""X"" 和 ""O"" 只能放在空方格中，而不能放在已经被占用的方格上。
只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
如果所有方块都放满棋子（不为空），游戏也会结束。
游戏结束后，棋子无法再进行任何移动。
给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。
如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 ""Draw""；如果仍会有行动（游戏未结束），则返回 ""Pending""。
你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。
  示例 1：
输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
输出：""A""
解释：""A"" 获胜，他总是先走。
""X  ""    ""X  ""    ""X  ""    ""X  ""    ""X  ""
""   "" -> ""   "" -> "" X "" -> "" X "" -> "" X ""
""   ""    ""O  ""    ""O  ""    ""OO ""    ""OOX""
示例 2：
输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
输出：""B""
解释：""B"" 获胜。
""X  ""    ""X  ""    ""XX ""    ""XXO""    ""XXO""    ""XXO""
""   "" -> "" O "" -> "" O "" -> "" O "" -> ""XO "" -> ""XO "" 
""   ""    ""   ""    ""   ""    ""   ""    ""   ""    ""O  ""
示例 3：
输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
输出：""Draw""
输出：由于没有办法再行动，游戏以平局结束。
""XXO""
""OOX""
""XOX""
示例 4：
输入：moves = [[0,0],[1,1]]
输出：""Pending""
解释：游戏还没有结束。
""X  ""
"" O ""
""   ""
  提示：
1 <= moves.length <= 9
moves[i].length == 2
0 <= moves[i][j] <= 2
moves 里没有重复的元素。
moves 遵循井字棋的规则。",59,,9794,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],17899
评论 (88),number-of-burgers-with-no-waste-of-ingredients,中等,"圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。
给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：
巨无霸汉堡：4 片番茄和 1 片奶酪
小皇堡：2 片番茄和 1 片奶酪
请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。
如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。
  示例 1：
输入：tomatoSlices = 16, cheeseSlices = 7
输出：[1,6]
解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。
示例 2：
输入：tomatoSlices = 17, cheeseSlices = 4
输出：[]
解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。
示例 3：
输入：tomatoSlices = 4, cheeseSlices = 17
输出：[]
解释：制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。
示例 4：
输入：tomatoSlices = 0, cheeseSlices = 0
输出：[0,0]
示例 5：
输入：tomatoSlices = 2, cheeseSlices = 1
输出：[0,1]
  提示：
0 <= tomatoSlices <= 10^7
0 <= cheeseSlices <= 10^7",17,,7446,['https://leetcode.cn/tag/math/'],[],14738
评论 (177),count-square-submatrices-with-all-ones,中等,"给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。
  示例 1：
输入：matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
输出：15
解释： 
边长为 1 的正方形有 10 个。
边长为 2 的正方形有 4 个。
边长为 3 的正方形有 1 个。
正方形的总数 = 10 + 4 + 1 = 15.
示例 2：
输入：matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
输出：7
解释：
边长为 1 的正方形有 6 个。 
边长为 2 的正方形有 1 个。
正方形的总数 = 6 + 1 = 7.
  提示：
1 <= arr.length <= 300
1 <= arr[0].length <= 300
0 <= arr[i][j] <= 1",235,,24011,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],32759
评论 (46),palindrome-partitioning-iii,困难,"给你一个由小写字母组成的字符串 s，和一个整数 k。
请你按下面的要求分割字符串：
首先，你可以将 s 中的部分字符修改为其他的小写英文字母。
接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。
请返回以这种方式分割字符串所需修改的最少字符数。
  示例 1：
输入：s = ""abc"", k = 2
输出：1
解释：你可以把字符串分割成 ""ab"" 和 ""c""，并修改 ""ab"" 中的 1 个字符，将它变成回文串。
示例 2：
输入：s = ""aabbc"", k = 3
输出：0
解释：你可以把字符串分割成 ""aa""、""bb"" 和 ""c""，它们都是回文串。
示例 3：
输入：s = ""leetcode"", k = 8
输出：0
  提示：
1 <= k <= s.length <= 100
s 中只含有小写英文字母。",102,,-1,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],-1
评论 (29),traffic-light-controlled-intersection,Unknown,,-1,,-1,[],[],-1
评论 (134),students-and-examinations,Unknown,,-1,,-1,[],[],-1
评论 (313),subtract-the-product-and-sum-of-digits-of-an-integer,简单,"给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。
  示例 1：
输入：n = 234
输出：15 
解释：
各位数之积 = 2 * 3 * 4 = 24 
各位数之和 = 2 + 3 + 4 = 9 
结果 = 24 - 9 = 15
示例 2：
输入：n = 4421
输出：21
解释： 
各位数之积 = 4 * 4 * 2 * 1 = 32 
各位数之和 = 4 + 4 + 2 + 1 = 11 
结果 = 32 - 11 = 21
  提示：
1 <= n <= 10^5",84,,56126,['https://leetcode.cn/tag/math/'],[],67356
评论 (191),group-the-people-given-the-group-size-they-belong-to,中等,"有 n 个人被分成数量未知的组。每个人都被标记为一个从 0 到 n - 1 的唯一ID 。
给定一个整数数组 groupSizes ，其中 groupSizes[i] 是第 i 个人所在的组的大小。例如，如果 groupSizes[1] = 3 ，则第 1 个人必须位于大小为 3 的组中。
返回一个组列表，使每个人 i 都在一个大小为 groupSizes[i] 的组中。
每个人应该 恰好只 出现在 一个组 中，并且每个人必须在一个组中。如果有多个答案，返回其中 任何 一个。可以 保证 给定输入 至少有一个 有效的解。
  示例 1：
输入：groupSizes = [3,3,3,3,3,1,3]
输出：[[5],[0,1,2],[3,4,6]]
解释：
第一组是 [5]，大小为 1，groupSizes[5] = 1。
第二组是 [0,1,2]，大小为 3，groupSizes[0] = groupSizes[1] = groupSizes[2] = 3。
第三组是 [3,4,6]，大小为 3，groupSizes[3] = groupSizes[4] = groupSizes[6] = 3。 
其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。
示例 2：
输入：groupSizes = [2,1,3,3,3,2]
输出：[[1],[0,5],[2,3,4]]
  提示：
groupSizes.length == n
1 <= n <= 500
1 <= groupSizes[i] <= n",60,,14271,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],17567
评论 (83),find-the-smallest-divisor-given-a-threshold,中等,"给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。
请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。
每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。
题目保证一定有解。
  示例 1：
输入：nums = [1,2,5,9], threshold = 6
输出：5
解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。
如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。
示例 2：
输入：nums = [2,3,5,7,11], threshold = 11
输出：3
示例 3：
输入：nums = [19], threshold = 5
输出：4
  提示：
1 <= nums.length <= 5 * 10^4
1 <= nums[i] <= 10^6
nums.length <= threshold <= 10^6",73,,9639,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],21482
评论 (61),minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix,困难,"给你一个 m x n 的二进制矩阵 mat。每一步，你可以选择一个单元格并将它反转（反转表示 0 变 1 ，1 变 0 ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。相邻的两个单元格共享同一条边。
请你返回将矩阵 mat 转化为全零矩阵的最少反转次数，如果无法转化为全零矩阵，请返回 -1 。
二进制矩阵 的每一个格子要么是 0 要么是 1 。
全零矩阵 是所有格子都为 0 的矩阵。
  示例 1：
输入：mat = [[0,0],[0,1]]
输出：3
解释：一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。
示例 2：
输入：mat = [[0]]
输出：0
解释：给出的矩阵是全零矩阵，所以你不需要改变它。
示例 3：
输入：mat = [[1,0,0],[1,0,0]]
输出：-1
解释：该矩阵无法转变成全零矩阵
  提示：
m == mat.length
n == mat[0].length
1 <= m <= 3
1 <= n <= 3
mat[i][j] 是 0 或 1 。",57,,3131,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],4648
评论 (147),find-the-start-and-end-number-of-continuous-ranges,Unknown,,-1,,-1,[],[],-1
评论 (74),iterator-for-combination,中等,"请你设计一个迭代器类 CombinationIterator ，包括以下内容：
CombinationIterator(string characters, int combinationLength) 一个构造函数，输入参数包括：用一个 有序且字符唯一 的字符串 characters（该字符串只包含小写英文字母）和一个数字 combinationLength 。
函数 next() ，按 字典序 返回长度为 combinationLength 的下一个字母组合。
函数 hasNext() ，只有存在长度为 combinationLength 的下一个字母组合时，才返回 true
  示例 1：
输入:
[""CombinationIterator"", ""next"", ""hasNext"", ""next"", ""hasNext"", ""next"", ""hasNext""]
[[""abc"", 2], [], [], [], [], [], []]
输出：
[null, ""ab"", true, ""ac"", true, ""bc"", false]
解释：
CombinationIterator iterator = new CombinationIterator(""abc"", 2); // 创建迭代器 iterator
iterator.next(); // 返回 ""ab""
iterator.hasNext(); // 返回 true
iterator.next(); // 返回 ""ac""
iterator.hasNext(); // 返回 true
iterator.next(); // 返回 ""bc""
iterator.hasNext(); // 返回 false
  提示：
1 <= combinationLength <= characters.length <= 15
 characters 中每个字符都 不同
每组测试数据最多对 next 和 hasNext 调用 104次
题目保证每次调用函数 next 时都存在下一个字母组合。",55,,5711,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/iterator/']",[],8781
评论 (153),element-appearing-more-than-25-in-sorted-array,简单,"给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。
请你找到并返回这个整数
  示例：
输入：arr = [1,2,2,6,6,6,6,7,10]
输出：6
  提示：
1 <= arr.length <= 10^4
0 <= arr[i] <= 10^5",59,,18731,['https://leetcode.cn/tag/array/'],[],31203
评论 (112),remove-covered-intervals,中等,"给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。
只有当 c <= a 且 b <= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。
在完成所有删除操作后，请你返回列表中剩余区间的数目。
  示例：
输入：intervals = [[1,4],[3,6],[2,8]]
输出：2
解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。
  提示：
1 <= intervals.length <= 1000
0 <= intervals[i][0] < intervals[i][1] <= 10^5
对于所有的 i != j：intervals[i] != intervals[j]",73,,19367,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],34379
评论 (102),minimum-falling-path-sum-ii,困难,"给你一个 n x n 整数矩阵 arr ，请你返回 非零偏移下降路径 数字和的最小值。
非零偏移下降路径 定义为：从 arr 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。
  示例 1：
输入：arr = [[1,2,3],[4,5,6],[7,8,9]]
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
示例 2：
输入：grid = [[7]]
输出：7
  提示：
n == grid.length == grid[i].length
1 <= n <= 200
-99 <= grid[i][j] <= 99",69,,10086,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],16645
评论 (389),convert-binary-number-in-a-linked-list-to-integer,简单,"给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。
请你返回该链表所表示数字的 十进制值 。
  示例 1：
输入：head = [1,0,1]
输出：5
解释：二进制数 (101) 转化为十进制数 (5)
示例 2：
输入：head = [0]
输出：0
示例 3：
输入：head = [1]
输出：1
示例 4：
输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
输出：18880
示例 5：
输入：head = [0,0]
输出：0
  提示：
链表不为空。
链表的结点总数不超过 30。
每个结点的值不是 0 就是 1。",116,,65040,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/math/']",[],80484
评论 (101),sequential-digits,中等,"我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。
请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。
  示例 1：
输出：low = 100, high = 300
输出：[123,234]
示例 2：
输出：low = 1000, high = 13000
输出：[1234,2345,3456,4567,5678,6789,12345]
  提示：
10 <= low <= high <= 10^9",40,,8698,['https://leetcode.cn/tag/enumeration/'],[],16463
评论 (72),maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold,中等,"给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。
请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。
  示例 1：
输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
输出：2
解释：总和小于或等于 4 的正方形的最大边长为 2，如图所示。
示例 2：
输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
输出：0
  提示：
m == mat.length
n == mat[i].length
1 <= m, n <= 300
0 <= mat[i][j] <= 104
0 <= threshold <= 105 ",92,,8089,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/prefix-sum/']",[],16666
评论 (95),shortest-path-in-a-grid-with-obstacles-elimination,困难,"给你一个 m * n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。
如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1 。
  示例 1：
输入： grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
输出：6
解释：
不消除任何障碍的最短路径是 10。
消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).
示例 2：
输入：grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
输出：-1
解释：我们至少需要消除两个障碍才能找到这样的路径。
  提示：
grid.length == m
grid[0].length == n
1 <= m, n <= 40
1 <= k <= m*n
grid[i][j] 是 0 或 1
grid[0][0] == grid[m-1][n-1] == 0",182,,16738,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],44816
评论 (181),weather-type-in-each-country,Unknown,,-1,,-1,[],[],-1
评论 (341),find-numbers-with-even-number-of-digits,简单,"给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。
  示例 1：
输入：nums = [12,345,2,6,7896]
输出：2
解释：
12 是 2 位数字（位数为偶数） 
345 是 3 位数字（位数为奇数）  
2 是 1 位数字（位数为奇数） 
6 是 1 位数字 位数为奇数） 
7896 是 4 位数字（位数为偶数）  
因此只有 12 和 7896 是位数为偶数的数字
示例 2：
输入：nums = [555,901,482,1771]
输出：1 
解释： 
只有 1771 是位数为偶数的数字。
  提示：
1 <= nums.length <= 500
1 <= nums[i] <= 10^5",72,,52302,['https://leetcode.cn/tag/array/'],[],64881
评论 (92),divide-array-in-sets-of-k-consecutive-numbers,中等,"给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。
如果可以，请返回 true；否则，返回 false。
  示例 1：
输入：nums = [1,2,3,3,4,4,5,6], k = 4
输出：true
解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。
示例 2：
输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
输出：true
解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。
示例 3：
输入：nums = [3,3,2,2,1,1], k = 3
输出：true
示例 4：
输入：nums = [1,2,3,4], k = 3
输出：false
解释：数组不能分成几个大小为 3 的子数组。
  提示：
1 <= k <= nums.length <= 105
1 <= nums[i] <= 109
  注意：此题目与 846 重复：https://leetcode-cn.com/problems/hand-of-straights/",77,,10348,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],21388
评论 (74),maximum-number-of-occurrences-of-a-substring,中等,"给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：
子串中不同字母的数目必须小于等于 maxLetters 。
子串的长度必须大于等于 minSize 且小于等于 maxSize 。
  示例 1：
输入：s = ""aababcaab"", maxLetters = 2, minSize = 3, maxSize = 4
输出：2
解释：子串 ""aab"" 在原字符串中出现了 2 次。
它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。
示例 2：
输入：s = ""aaaa"", maxLetters = 1, minSize = 3, maxSize = 3
输出：2
解释：子串 ""aaa"" 在原字符串中出现了 2 次，且它们有重叠部分。
示例 3：
输入：s = ""aabcabcab"", maxLetters = 2, minSize = 2, maxSize = 3
输出：3
示例 4：
输入：s = ""abcde"", maxLetters = 2, minSize = 3, maxSize = 3
输出：0
  提示：
1 <= s.length <= 10^5
1 <= maxLetters <= 26
1 <= minSize <= maxSize <= min(26, s.length)
s 只包含小写英文字母。",65,,7958,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],17077
评论 (54),maximum-candies-you-can-get-from-boxes,困难,"给你 n 个盒子，每个盒子的格式为 [status, candies, keys, containedBoxes] ，其中：
状态字 status[i]：整数，如果 box[i] 是开的，那么是 1 ，否则是 0 。
糖果数 candies[i]: 整数，表示 box[i] 中糖果的数目。
钥匙 keys[i]：数组，表示你打开 box[i] 后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。
内含的盒子 containedBoxes[i]：整数，表示放在 box[i] 里的盒子所对应的下标。
给你一个 initialBoxes 数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。
请你按照上述规则，返回可以获得糖果的 最大数目 。
  示例 1：
输入：status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
输出：16
解释：
一开始你有盒子 0 。你将获得它里面的 7 个糖果和盒子 1 和 2。
盒子 1 目前状态是关闭的，而且你还没有对应它的钥匙。所以你将会打开盒子 2 ，并得到里面的 4 个糖果和盒子 1 的钥匙。
在盒子 1 中，你会获得 5 个糖果和盒子 3 ，但是你没法获得盒子 3 的钥匙所以盒子 3 会保持关闭状态。
你总共可以获得的糖果数目 = 7 + 4 + 5 = 16 个。
示例 2：
输入：status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
输出：6
解释：
你一开始拥有盒子 0 。打开它你可以找到盒子 1,2,3,4,5 和它们对应的钥匙。
打开这些盒子，你将获得所有盒子的糖果，所以总糖果数为 6 个。
示例 3：
输入：status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]
输出：1
示例 4：
输入：status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []
输出：0
示例 5：
输入：status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]
输出：7
  提示：
1 <= status.length <= 1000
status.length == candies.length == keys.length == containedBoxes.length == n
status[i] 要么是 0 要么是 1 。
1 <= candies[i] <= 1000
0 <= keys[i].length <= status.length
0 <= keys[i][j] < status.length
keys[i] 中的值都是互不相同的。
0 <= containedBoxes[i].length <= status.length
0 <= containedBoxes[i][j] < status.length
containedBoxes[i] 中的值都是互不相同的。
每个盒子最多被一个盒子包含。
0 <= initialBoxes.length <= status.length
0 <= initialBoxes[i] < status.length",29,,2992,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/']",[],5039
评论 (212),replace-elements-with-greatest-element-on-right-side,简单,"给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。
完成所有替换操作后，请你返回这个数组。
  示例 1：
输入：arr = [17,18,5,4,6,1]
输出：[18,6,6,6,1,-1]
解释：
- 下标 0 的元素 --> 右侧最大元素是下标 1 的元素 (18)
- 下标 1 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 2 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 3 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 4 的元素 --> 右侧最大元素是下标 5 的元素 (1)
- 下标 5 的元素 --> 右侧没有其他元素，替换为 -1
示例 2：
输入：arr = [400]
输出：[-1]
解释：下标 0 的元素右侧没有其他元素。
  提示：
1 <= arr.length <= 104
1 <= arr[i] <= 105",79,,34499,['https://leetcode.cn/tag/array/'],[],43788
评论 (291),sum-of-mutated-array-closest-to-target,中等,"给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。
如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。
请注意，答案不一定是 arr 中的数字。
  示例 1：
输入：arr = [4,9,3], target = 10
输出：3
解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。
示例 2：
输入：arr = [2,3,5], target = 10
输出：5
示例 3：
输入：arr = [60864,25176,27249,21296,20204], target = 56803
输出：11361
  提示：
1 <= arr.length <= 10^4
1 <= arr[i], target <= 10^5",167,,26732,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],57527
评论 (75),number-of-paths-with-max-score,困难,"给你一个正方形字符数组 board ，你从数组最右下方的字符 'S' 出发。
你的目标是到达数组最左上角的字符 'E' ，数组剩余的部分为数字字符 1, 2, ..., 9 或者障碍 'X'。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。
一条路径的 「得分」 定义为：路径上所有数字的和。
请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 10^9 + 7 取余。
如果没有任何路径可以到达终点，请返回 [0, 0] 。
  示例 1：
输入：board = [""E23"",""2X2"",""12S""]
输出：[7,1]
示例 2：
输入：board = [""E12"",""1X1"",""21S""]
输出：[4,2]
示例 3：
输入：board = [""E11"",""XXX"",""11S""]
输出：[0,0]
  提示：
2 <= board.length == board[i].length <= 100",56,,4809,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],12847
评论 (202),deepest-leaves-sum,中等,"给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。
  示例 1：
输入：root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
输出：15
示例 2：
输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
输出：19
  提示：
树中节点数目在范围 [1, 104] 之间。
1 <= Node.val <= 100",81,,24360,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],29543
评论 (127),find-the-team-size,Unknown,,-1,,-1,[],[],-1
评论 (222),find-n-unique-integers-sum-up-to-zero,简单,"给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。
  示例 1：
输入：n = 5
输出：[-7,-1,1,3,4]
解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。
示例 2：
输入：n = 3
输出：[-1,0,1]
示例 3：
输入：n = 1
输出：[0]
  提示：
1 <= n <= 1000",62,,24285,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],33889
评论 (385),all-elements-in-two-binary-search-trees,中等,"给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.
  示例 1：
输入：root1 = [2,1,4], root2 = [1,0,3]
输出：[0,1,1,2,3,4]
示例 2：
输入：root1 = [1,null,8], root2 = [8,1]
输出：[1,1,8,8]
  提示：
每棵树的节点数在 [0, 5000] 范围内
-105 <= Node.val <= 105",157,,46466,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/sorting/']",[],59439
评论 (230),jump-game-iii,中等,"这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。
请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。
注意，不管是什么情况下，你都无法跳到数组之外。
  示例 1：
输入：arr = [4,2,3,0,3,1,2], start = 5
输出：true
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 
示例 2：
输入：arr = [4,2,3,0,3,1,2], start = 0
输出：true 
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 0 -> 下标 4 -> 下标 1 -> 下标 3
示例 3：
输入：arr = [3,0,2,1,2], start = 2
输出：false
解释：无法到达值为 0 的下标 1 处。 
  提示：
1 <= arr.length <= 5 * 10^4
0 <= arr[i] < arr.length
0 <= start < arr.length",114,,23631,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/']",[],40641
评论 (38),verbal-arithmetic-puzzle,困难,"给你一个方程，左边用 words 表示，右边用 result 表示。
你需要根据以下规则检查方程是否可解：
每个字符都会被解码成一位数字（0 - 9）。
每对不同的字符必须映射到不同的数字。
每个 words[i] 和 result 都会被解码成一个没有前导零的数字。
左侧数字之和（words）等于右侧数字（result）。 
如果方程可解，返回 True，否则返回 False。
  示例 1：
输入：words = [""SEND"",""MORE""], result = ""MONEY""
输出：true
解释：映射 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'
所以 ""SEND"" + ""MORE"" = ""MONEY"" ,  9567 + 1085 = 10652
示例 2：
输入：words = [""SIX"",""SEVEN"",""SEVEN""], result = ""TWENTY""
输出：true
解释：映射 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4
所以 ""SIX"" + ""SEVEN"" + ""SEVEN"" = ""TWENTY"" ,  650 + 68782 + 68782 = 138214
示例 3：
输入：words = [""THIS"",""IS"",""TOO""], result = ""FUNNY""
输出：true
示例 4：
输入：words = [""LEET"",""CODE""], result = ""POINT""
输出：false
  提示：
2 <= words.length <= 5
1 <= words[i].length, results.length <= 7
words[i], result 只含有大写英文字母
表达式中使用的不同字符数最大为 10",57,,2030,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],6119
评论 (142),running-total-for-different-genders,Unknown,,-1,,-1,[],[],-1
评论 (250),decrypt-string-from-alphabet-to-integer-mapping,简单,"给你一个字符串 s，它由数字（'0' - '9'）和 '#' 组成。我们希望按下述规则将 s 映射为一些小写英文字符：
字符（'a' - 'i'）分别用（'1' - '9'）表示。
字符（'j' - 'z'）分别用（'10#' - '26#'）表示。 
返回映射之后形成的新字符串。
题目数据保证映射始终唯一。
  示例 1：
输入：s = ""10#11#12""
输出：""jkab""
解释：""j"" -> ""10#"" , ""k"" -> ""11#"" , ""a"" -> ""1"" , ""b"" -> ""2"".
示例 2：
输入：s = ""1326#""
输出：""acz""
  提示：
1 <= s.length <= 1000
s[i] 只包含数字（'0'-'9'）和 '#' 字符。
s 是映射始终存在的有效字符串。",58,,21221,['https://leetcode.cn/tag/string/'],[],27792
评论 (380),xor-queries-of-a-subarray,中等,"有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。
对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。
并返回一个包含给定查询 queries 所有结果的数组。
  示例 1：
输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
输出：[2,7,14,8] 
解释：
数组中元素的二进制表示形式是：
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 
查询的 XOR 值为：
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8
示例 2：
输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
输出：[8,0,4,4]
  提示：
1 <= arr.length <= 3 * 10^4
1 <= arr[i] <= 10^9
1 <= queries.length <= 3 * 10^4
queries[i].length == 2
0 <= queries[i][0] <= queries[i][1] < arr.length",145,,39236,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],54778
评论 (80),get-watched-videos-by-your-friends,中等,"有 n 个人，每个人都有一个  0 到 n-1 的唯一 id 。
给你数组 watchedVideos  和 friends ，其中 watchedVideos[i]  和 friends[i] 分别表示 id = i 的人观看过的视频列表和他的好友列表。
Level 1 的视频包含所有你好友观看过的视频，level 2 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 k 的视频包含所有从你出发，最短距离为 k 的好友观看过的视频。
给定你的 id  和一个 level 值，请你找出所有指定 level 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按字母顺序从小到大排列。
  示例 1：
输入：watchedVideos = [[""A"",""B""],[""C""],[""B"",""C""],[""D""]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1
输出：[""B"",""C""] 
解释：
你的 id 为 0（绿色），你的朋友包括（黄色）：
id 为 1 -> watchedVideos = [""C""] 
id 为 2 -> watchedVideos = [""B"",""C""] 
你朋友观看过视频的频率为：
B -> 1 
C -> 2
示例 2：
输入：watchedVideos = [[""A"",""B""],[""C""],[""B"",""C""],[""D""]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2
输出：[""D""]
解释：
你的 id 为 0（绿色），你朋友的朋友只有一个人，他的 id 为 3（黄色）。
  提示：
n == watchedVideos.length == friends.length
2 <= n <= 100
1 <= watchedVideos[i].length <= 100
1 <= watchedVideos[i][j].length <= 8
0 <= friends[i].length < n
0 <= friends[i][j] < n
0 <= id < n
1 <= level < n
如果 friends[i] 包含 j ，那么 friends[j] 包含 i",38,,6383,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],16445
评论 (124),minimum-insertion-steps-to-make-a-string-palindrome,困难,"给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。
请你返回让 s 成为回文串的 最少操作次数 。
「回文串」是正读和反读都相同的字符串。
  示例 1：
输入：s = ""zzazz""
输出：0
解释：字符串 ""zzazz"" 已经是回文串了，所以不需要做任何插入操作。
示例 2：
输入：s = ""mbadm""
输出：2
解释：字符串可变为 ""mbdadbm"" 或者 ""mdbabdm"" 。
示例 3：
输入：s = ""leetcode""
输出：5
解释：插入 5 个字符后字符串变为 ""leetcodocteel"" 。
  提示：
1 <= s.length <= 500
s 中所有字符都是小写字母。",143,,15382,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],22688
评论 (291),decompress-run-length-encoded-list,简单,"给你一个以行程长度编码压缩的整数列表 nums 。
考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。
请你返回解压后的列表。
  示例 1：
输入：nums = [1,2,3,4]
输出：[2,4,4,4]
解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。
第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。
最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。
示例 2：
输入：nums = [1,1,2,3]
输出：[1,3,3]
  提示：
2 <= nums.length <= 100
nums.length % 2 == 0
1 <= nums[i] <= 100",52,,38249,['https://leetcode.cn/tag/array/'],[],45965
评论 (219),matrix-block-sum,中等,"给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： 
i - k <= r <= i + k,
j - k <= c <= j + k 且
(r, c) 在矩阵内。
  示例 1：
输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[12,21,16],[27,45,33],[24,39,28]]
示例 2：
输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
输出：[[45,45,45],[45,45,45],[45,45,45]]
  提示：
m == mat.length
n == mat[i].length
1 <= m, n, k <= 100
1 <= mat[i][j] <= 100",137,,18336,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/prefix-sum/']",[],24282
评论 (181),sum-of-nodes-with-even-valued-grandparent,中等,"给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：
该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）
如果不存在祖父节点值为偶数的节点，那么返回 0 。
  示例：
输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
输出：18
解释：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。
  提示：
树中节点的数目在 1 到 10^4 之间。
每个节点的值在 1 到 100 之间。",69,,14922,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],18353
评论 (41),distinct-echo-substrings,困难,"给你一个字符串 text ，请你返回满足下述条件的 不同 非空子字符串的数目：
可以写成某个字符串与其自身相连接的形式（即，可以写为 a + a，其中 a 是某个字符串）。
例如，abcabc 就是 abc 和它自身连接形成的。
  示例 1：
输入：text = ""abcabcabc""
输出：3
解释：3 个子字符串分别为 ""abcabc""，""bcabca"" 和 ""cabcab"" 。
示例 2：
输入：text = ""leetcodeleetcode""
输出：2
解释：2 个子字符串为 ""ee"" 和 ""leetcodeleetcode"" 。
  提示：
1 <= text.length <= 2000
text 只包含小写英文字母。",39,,3490,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],7687
评论 (117),convert-integer-to-the-sum-of-two-no-zero-integers,简单,"「无零整数」是十进制表示中 不含任何 0 的正整数。
给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足：
A 和 B 都是无零整数
A + B = n
题目数据保证至少有一个有效的解决方案。
如果存在多个有效解决方案，你可以返回其中任意一个。
  示例 1：
输入：n = 2
输出：[1,1]
解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。
示例 2：
输入：n = 11
输出：[2,9]
示例 3：
输入：n = 10000
输出：[1,9999]
示例 4：
输入：n = 69
输出：[1,68]
示例 5：
输入：n = 1010
输出：[11,999]
  提示：
2 <= n <= 10^4",28,,11907,['https://leetcode.cn/tag/math/'],[],19247
评论 (99),minimum-flips-to-make-a-or-b-equal-to-c,中等,"给你三个正整数 a、b 和 c。
你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算   a OR b == c  成立的最小翻转次数。
「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。
  示例 1：
输入：a = 2, b = 6, c = 5
输出：3
解释：翻转后 a = 1 , b = 4 , c = 5 使得 a OR b == c
示例 2：
输入：a = 4, b = 2, c = 7
输出：1
示例 3：
输入：a = 1, b = 2, c = 3
输出：0
  提示：
1 <= a <= 10^9
1 <= b <= 10^9
1 <= c <= 10^9",39,,7392,['https://leetcode.cn/tag/bit-manipulation/'],[],11198
评论 (407),number-of-operations-to-make-network-connected,中等,"用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。
网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。
给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 
  示例 1：
输入：n = 4, connections = [[0,1],[0,2],[1,2]]
输出：1
解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。
示例 2：
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
输出：2
示例 3：
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
输出：-1
解释：线缆数量不足。
示例 4：
输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
输出：0
  提示：
1 <= n <= 10^5
1 <= connections.length <= min(n*(n-1)/2, 10^5)
connections[i].length == 2
0 <= connections[i][0], connections[i][1] < n
connections[i][0] != connections[i][1]
没有重复的连接。
两台计算机不会通过多条线缆连接。",183,,36896,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']",[],59552
评论 (36),minimum-distance-to-type-a-word-using-two-fingers,困难,"二指输入法定制键盘在 X-Y 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处。
例如字母 A 位于坐标 (0,0)，字母 B 位于坐标 (0,1)，字母 P 位于坐标 (2,3) 且字母 Z 位于坐标 (4,1)。
给你一个待输入字符串 word，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。
坐标 (x1,y1) 和 (x2,y2) 之间的 距离 是 |x1 - x2| + |y1 - y2|。 
注意，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。
  示例 1：
输入：word = ""CAKE""
输出：3
解释： 
使用两根手指输入 ""CAKE"" 的最佳方案之一是： 
手指 1 在字母 'C' 上 -> 移动距离 = 0 
手指 1 在字母 'A' 上 -> 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2 
手指 2 在字母 'K' 上 -> 移动距离 = 0 
手指 2 在字母 'E' 上 -> 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1 
总距离 = 3
示例 2：
输入：word = ""HAPPY""
输出：6
解释： 
使用两根手指输入 ""HAPPY"" 的最佳方案之一是：
手指 1 在字母 'H' 上 -> 移动距离 = 0
手指 1 在字母 'A' 上 -> 移动距离 = 从字母 'H' 到字母 'A' 的距离 = 2
手指 2 在字母 'P' 上 -> 移动距离 = 0
手指 2 在字母 'P' 上 -> 移动距离 = 从字母 'P' 到字母 'P' 的距离 = 0
手指 1 在字母 'Y' 上 -> 移动距离 = 从字母 'A' 到字母 'Y' 的距离 = 4
总距离 = 6
  提示：
2 <= word.length <= 300
每个 word[i] 都是一个大写英文字母。",70,,2851,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],4808
评论 (187),restaurant-growth,Unknown,,-1,,-1,[],[],-1
评论 (104),ads-performance,Unknown,,-1,,-1,[],[],-1
评论 (361),maximum-69-number,简单,"给你一个仅由数字 6 和 9 组成的正整数 num。
你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。
请返回你可以得到的最大数字。
  示例 1：
输入：num = 9669
输出：9969
解释：
改变第一位数字可以得到 6669 。
改变第二位数字可以得到 9969 。
改变第三位数字可以得到 9699 。
改变第四位数字可以得到 9666 。
其中最大的数字是 9969 。
示例 2：
输入：num = 9996
输出：9999
解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。
示例 3：
输入：num = 9999
输出：9999
解释：无需改变就已经是最大的数字了。
  提示：
1 <= num <= 10^4
num 每一位上的数字都是 6 或者 9 。",61,,29088,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/']",[],38651
评论 (86),print-words-vertically,中等,"给你一个字符串 s。请你按照单词在 s 中的出现顺序将它们全部竖直返回。
单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。
每个单词只能放在一列上，每一列中也只能有一个单词。
  示例 1：
输入：s = ""HOW ARE YOU""
输出：[""HAY"",""ORO"",""WEU""]
解释：每个单词都应该竖直打印。 
 ""HAY""
 ""ORO""
 ""WEU""
示例 2：
输入：s = ""TO BE OR NOT TO BE""
输出：[""TBONTB"",""OEROOE"",""   T""]
解释：题目允许使用空格补位，但不允许输出末尾出现空格。
""TBONTB""
""OEROOE""
""   T""
示例 3：
输入：s = ""CONTEST IS COMING""
输出：[""CIC"",""OSO"",""N M"",""T I"",""E N"",""S G"",""T""]
  提示：
1 <= s.length <= 200
s 仅含大写英文字母。
题目数据保证两个单词之间只有一个空格。",35,,7066,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],11997
评论 (132),delete-leaves-with-a-given-value,中等,"给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。
注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。
也就是说，你需要重复此过程直到不能继续删除。
  示例 1：
输入：root = [1,2,3,2,null,2,4], target = 2
输出：[1,null,3,null,4]
解释：
上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。
有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。
示例 2：
输入：root = [1,3,3,3,2], target = 3
输出：[1,3,null,null,2]
示例 3：
输入：root = [1,2,null,2,null,2], target = 2
输出：[1]
解释：每一步都删除一个绿色的叶子节点（值为 2）。
示例 4：
输入：root = [1,1,1], target = 1
输出：[]
示例 5：
输入：root = [1,2,3], target = 1
输出：[1,2,3]
  提示：
1 <= target <= 1000
每一棵树最多有 3000 个节点。
每一个节点值的范围是 [1, 1000] 。",83,,12954,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],17729
评论 (63),minimum-number-of-taps-to-open-to-water-a-garden,困难,"在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。
花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。
给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i -  ranges[i], i + ranges[i]] 。
请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。
  示例 1：
输入：n = 5, ranges = [3,4,1,1,0,0]
输出：1
解释：
点 0 处的水龙头可以灌溉区间 [-3,3]
点 1 处的水龙头可以灌溉区间 [-3,5]
点 2 处的水龙头可以灌溉区间 [1,3]
点 3 处的水龙头可以灌溉区间 [2,4]
点 4 处的水龙头可以灌溉区间 [4,4]
点 5 处的水龙头可以灌溉区间 [5,5]
只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。
示例 2：
输入：n = 3, ranges = [0,0,0,0]
输出：-1
解释：即使打开所有水龙头，你也无法灌溉整个花园。
  提示：
1 <= n <= 104
ranges.length == n + 1
0 <= ranges[i] <= 100",103,,6812,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],14307
评论 (122),list-the-products-ordered-in-a-period,Unknown,,-1,,-1,[],[],-1
评论 (72),break-a-palindrome,中等,"给你一个由小写英文字母组成的回文字符串 palindrome ，请你将其中 一个 字符用任意小写英文字母替换，使得结果字符串的 字典序最小 ，且 不是 回文串。
请你返回结果字符串。如果无法做到，则返回一个 空串 。
如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符严格小于 b 中的对应字符。例如，""abcc” 字典序比 ""abcd"" 小，因为不同的第一个位置是在第四个字符，显然 'c' 比 'd' 小。
  示例 1：
输入：palindrome = ""abccba""
输出：""aaccba""
解释：存在多种方法可以使 ""abccba"" 不是回文，例如 ""zbccba"", ""aaccba"", 和 ""abacba"" 。
在所有方法中，""aaccba"" 的字典序最小。
示例 2：
输入：palindrome = ""a""
输出：""""
解释：不存在替换一个字符使 ""a"" 变成非回文的方法，所以返回空字符串。
  提示：
1 <= palindrome.length <= 1000
palindrome 只包含小写英文字母。",39,,6865,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],14638
评论 (103),sort-the-matrix-diagonally,中等,"矩阵对角线 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 mat 有 6 行 3 列，从 mat[2][0] 开始的 矩阵对角线 将会经过 mat[2][0]、mat[3][1] 和 mat[4][2] 。
给你一个 m * n 的整数矩阵 mat ，请你将同一条 矩阵对角线 上的元素按升序排序后，返回排好序的矩阵。
  示例 1：
输入：mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
输出：[[1,1,1,1],[1,2,2,2],[1,2,3,3]]
示例 2：
输入：mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
输出：[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
  提示：
m == mat.length
n == mat[i].length
1 <= m, n <= 100
1 <= mat[i][j] <= 100",67,,8359,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/sorting/']",[],10855
评论 (26),reverse-subarray-to-maximize-array-value,困难,"给你一个整数数组 nums 。「数组值」定义为所有满足 0 <= i < nums.length-1 的 |nums[i]-nums[i+1]| 的和。
你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作 一次 。
请你找到可行的最大 数组值 。
  示例 1：
输入：nums = [2,3,1,5,4]
输出：10
解释：通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。
示例 2：
输入：nums = [2,4,9,24,2,1,10]
输出：68
  提示：
1 <= nums.length <= 3*10^4
-10^5 <= nums[i] <= 10^5",60,,1471,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],3687
评论 (113),rank-transform-of-an-array,简单,"给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。
序号代表了一个元素有多大。序号编号的规则如下：
序号从 1 开始编号。
一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。
每个数字的序号都应该尽可能地小。
  示例 1：
输入：arr = [40,10,20,30]
输出：[4,1,2,3]
解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。
示例 2：
输入：arr = [100,100,100]
输出：[1,1,1]
解释：所有元素有相同的序号。
示例 3：
输入：arr = [37,12,28,9,100,56,80,5,12]
输出：[5,3,4,2,8,6,7,1,3]
  提示：
0 <= arr.length <= 105
-109 <= arr[i] <= 109",61,,15077,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],28426
评论 (528),remove-palindromic-subsequences,简单,"给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。
返回删除给定字符串中所有字符（字符串为空）的最小删除次数。
「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。
「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。
  示例 1：
输入：s = ""ababa""
输出：1
解释：字符串本身就是回文序列，只需要删除一次。
示例 2：
输入：s = ""abb""
输出：2
解释：""abb"" -> ""bb"" -> """". 
先删除回文子序列 ""a""，然后再删除 ""bb""。
示例 3：
输入：s = ""baabb""
输出：2
解释：""baabb"" -> ""b"" -> """". 
先删除回文子序列 ""baab""，然后再删除 ""b""。
  提示：
1 <= s.length <= 1000
s 仅包含字母 'a'  和 'b'",169,,31846,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],40851
评论 (73),filter-restaurants-by-vegan-friendly-price-and-distance,中等,"给你一个餐馆信息数组 restaurants，其中  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]。你必须使用以下三个过滤器来过滤这些餐馆信息。
其中素食者友好过滤器 veganFriendly 的值可以为 true 或者 false，如果为 true 就意味着你应该只包括 veganFriendlyi 为 true 的餐馆，为 false 则意味着可以包括任何餐馆。此外，我们还有最大价格 maxPrice 和最大距离 maxDistance 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。
过滤后返回餐馆的 id，按照 rating 从高到低排序。如果 rating 相同，那么按 id 从高到低排序。简单起见， veganFriendlyi 和 veganFriendly 为 true 时取值为 1，为 false 时，取值为 0 。
  示例 1：
输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10
输出：[3,1,5] 
解释： 
这些餐馆为：
餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]
餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]
餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]
餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]
餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] 
在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance = 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。 
示例 2：
输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10
输出：[4,3,2,1,5]
解释：餐馆与示例 1 相同，但在 veganFriendly = 0 的过滤条件下，应该考虑所有餐馆。
示例 3：
输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3
输出：[4,5]
  提示：
1 <= restaurants.length <= 10^4
restaurants[i].length == 5
1 <= idi, ratingi, pricei, distancei <= 10^5
1 <= maxPrice, maxDistance <= 10^5
veganFriendlyi 和 veganFriendly 的值为 0 或 1 。
所有 idi 各不相同。",15,,6602,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],11912
评论 (83),find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance,中等,"有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。
返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。
注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。
  示例 1：
输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
输出：3
解释：城市分布图如上。
每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：
城市 0 -> [城市 1, 城市 2] 
城市 1 -> [城市 0, 城市 2, 城市 3] 
城市 2 -> [城市 0, 城市 1, 城市 3] 
城市 3 -> [城市 1, 城市 2] 
城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。
示例 2：
输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
输出：0
解释：城市分布图如上。 
每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：
城市 0 -> [城市 1] 
城市 1 -> [城市 0, 城市 4] 
城市 2 -> [城市 3, 城市 4] 
城市 3 -> [城市 2, 城市 4]
城市 4 -> [城市 1, 城市 2, 城市 3] 
城市 0 在阈值距离 2 以内只有 1 个邻居城市。
  提示：
2 <= n <= 100
1 <= edges.length <= n * (n - 1) / 2
edges[i].length == 3
0 <= fromi < toi < n
1 <= weighti, distanceThreshold <= 10^4
所有 (fromi, toi) 都是不同的。",77,,7828,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/shortest-path/']",[],15321
评论 (53),minimum-difficulty-of-a-job-schedule,困难,"你需要制定一份 d 天的工作计划表。工作之间存在依赖，要想执行第 i 项工作，你必须完成全部 j 项工作（ 0 <= j < i）。
你每天 至少 需要完成一项任务。工作计划的总难度是这 d 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。
给你一个整数数组 jobDifficulty 和一个整数 d，分别代表工作难度和需要计划的天数。第 i 项工作的难度是 jobDifficulty[i]。
返回整个工作计划的 最小难度 。如果无法制定工作计划，则返回 -1 。
  示例 1：
输入：jobDifficulty = [6,5,4,3,2,1], d = 2
输出：7
解释：第一天，您可以完成前 5 项工作，总难度 = 6.
第二天，您可以完成最后一项工作，总难度 = 1.
计划表的难度 = 6 + 1 = 7 
示例 2：
输入：jobDifficulty = [9,9,9], d = 4
输出：-1
解释：就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。
示例 3：
输入：jobDifficulty = [1,1,1], d = 3
输出：3
解释：工作计划为每天一项工作，总难度为 3 。
示例 4：
输入：jobDifficulty = [7,1,7,1,7,1], d = 3
输出：15
示例 5：
输入：jobDifficulty = [11,111,22,222,33,333,44,444], d = 6
输出：843
  提示：
1 <= jobDifficulty.length <= 300
0 <= jobDifficulty[i] <= 1000
1 <= d <= 10",74,,4324,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],7283
评论 (109),number-of-transactions-per-visit,Unknown,,-1,,-1,[],[],-1
评论 (507),the-k-weakest-rows-in-a-matrix,简单,"给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。
  示例 1：
输入：mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
输出：[2,0,3]
解释：
每行中的军人数目：
行 0 -> 2 
行 1 -> 4 
行 2 -> 1 
行 3 -> 2 
行 4 -> 5 
从最弱到最强对这些行排序后得到 [2,0,3,1,4]
示例 2：
输入：mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
输出：[0,2]
解释： 
每行中的军人数目：
行 0 -> 1 
行 1 -> 4 
行 2 -> 1 
行 3 -> 1 
从最弱到最强对这些行排序后得到 [0,2,3,1]
  提示：
m == mat.length
n == mat[i].length
2 <= n, m <= 100
1 <= k <= m
matrix[i][j] 不是 0 就是 1",165,,47970,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],69436
评论 (121),reduce-array-size-to-the-half,中等,"给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。
返回 至少 能删除数组中的一半整数的整数集合的最小大小。
  示例 1：
输入：arr = [3,3,3,3,5,5,5,2,2,7]
输出：2
解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。
大小为 2 的可行集合有 {3,5},{3,2},{5,2}。
选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。
示例 2：
输入：arr = [7,7,7,7,7,7]
输出：1
解释：我们只能选择集合 {7}，结果数组为空。
  提示：
1 <= arr.length <= 105
arr.length 为偶数
1 <= arr[i] <= 105",35,,10691,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],16643
评论 (101),maximum-product-of-splitted-binary-tree,中等,"给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。
由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。
  示例 1：
输入：root = [1,2,3,4,5,6]
输出：110
解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）
示例 2：
输入：root = [1,null,2,3,4,null,null,5,6]
输出：90
解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）
示例 3：
输入：root = [2,3,9,10,7,8,6,5,4,11,1]
输出：1025
示例 4：
输入：root = [1,1]
输出：1
  提示：
每棵树最多有 50000 个节点，且至少有 2 个节点。
每个节点的值在 [1, 10000] 之间。",72,,10153,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],24962
评论 (49),jump-game-v,困难,"给你一个整数数组 arr 和一个整数 d 。每一步你可以从下标 i 跳到：
i + x ，其中 i + x < arr.length 且 0 < x <= d 。
i - x ，其中 i - x >= 0 且 0 < x <= d 。
除此以外，你从下标 i 跳到下标 j 需要满足：arr[i] > arr[j] 且 arr[i] > arr[k] ，其中下标 k 是所有 i 到 j 之间的数字（更正式的，min(i, j) < k < max(i, j)）。
你可以选择数组的任意下标开始跳跃。请你返回你 最多 可以访问多少个下标。
请注意，任何时刻你都不能跳到数组的外面。
  示例 1：
输入：arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
输出：4
解释：你可以从下标 10 出发，然后如上图依次经过 10 --> 8 --> 6 --> 7 。
注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 > 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 > 9 。
类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。
示例 2：
输入：arr = [3,3,3,3,3], d = 3
输出：1
解释：你可以从任意下标处开始且你永远无法跳到任何其他坐标。
示例 3：
输入：arr = [7,6,5,4,3,2,1], d = 1
输出：7
解释：从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。
示例 4：
输入：arr = [7,1,7,1,7,1], d = 2
输出：2
示例 5：
输入：arr = [66], d = 1
输出：1
  提示：
1 <= arr.length <= 1000
1 <= arr[i] <= 10^5
1 <= d <= arr.length",86,,5418,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],9316
评论 (142),movie-rating,Unknown,,-1,,-1,[],[],-1
评论 (559),number-of-steps-to-reduce-a-number-to-zero,简单,"给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。
  示例 1：
输入：num = 14
输出：6
解释：
步骤 1) 14 是偶数，除以 2 得到 7 。
步骤 2） 7 是奇数，减 1 得到 6 。
步骤 3） 6 是偶数，除以 2 得到 3 。
步骤 4） 3 是奇数，减 1 得到 2 。
步骤 5） 2 是偶数，除以 2 得到 1 。
步骤 6） 1 是奇数，减 1 得到 0 。
示例 2：
输入：num = 8
输出：4
解释：
步骤 1） 8 是偶数，除以 2 得到 4 。
步骤 2） 4 是偶数，除以 2 得到 2 。
步骤 3） 2 是偶数，除以 2 得到 1 。
步骤 4） 1 是奇数，减 1 得到 0 。
示例 3：
输入：num = 123
输出：12
  提示：
0 <= num <= 10^6",113,,68259,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/']",[],82721
评论 (141),number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold,中等,"给你一个整数数组 arr 和两个整数 k 和 threshold 。
请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。
  示例 1：
输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
输出：3
解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。
示例 2：
输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
输出：6
解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。
  提示：
1 <= arr.length <= 105
1 <= arr[i] <= 104
1 <= k <= arr.length
0 <= threshold <= 104",38,,14672,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/']",[],26393
评论 (86),angle-between-hands-of-a-clock,中等,"给你两个数 hour 和 minutes 。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60 单位制）。
  示例 1：
输入：hour = 12, minutes = 30
输出：165
示例 2：
输入：hour = 3, minutes = 30
输出；75
示例 3：
输入：hour = 3, minutes = 15
输出：7.5
示例 4：
输入：hour = 4, minutes = 50
输出：155
示例 5：
输入：hour = 12, minutes = 0
输出：0
  提示：
1 <= hour <= 12
0 <= minutes <= 59
与标准答案误差在 10^-5 以内的结果都被视为正确结果。",39,,7692,['https://leetcode.cn/tag/math/'],[],12806
评论 (355),jump-game-iv,困难,"给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。
每一步，你可以从下标 i 跳到下标 i + 1 、i - 1 或者 j ：
i + 1 需满足：i + 1 < arr.length
i - 1 需满足：i - 1 >= 0
j 需满足：arr[i] == arr[j] 且 i != j
请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。
注意：任何时候你都不能跳到数组外面。
  示例 1：
输入：arr = [100,-23,-23,404,100,23,23,23,3,404]
输出：3
解释：那你需要跳跃 3 次，下标依次为 0 --> 4 --> 3 --> 9 。下标 9 为数组的最后一个元素的下标。
示例 2：
输入：arr = [7]
输出：0
解释：一开始就在最后一个元素处，所以你不需要跳跃。
示例 3：
输入：arr = [7,6,9,6,9,6,9,7]
输出：1
解释：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。
  提示：
1 <= arr.length <= 5 * 104
-108 <= arr[i] <= 108",196,,25302,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],54213
评论 (175),check-if-n-and-its-double-exist,简单,"给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。
更正式地，检查是否存在两个下标 i 和 j 满足：
i != j
0 <= i, j < arr.length
arr[i] == 2 * arr[j]
  示例 1：
输入：arr = [10,2,5,3]
输出：true
解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。
示例 2：
输入：arr = [7,1,14,11]
输出：true
解释：N = 14 是 M = 7 的两倍，即 14 = 2 * 7 。
示例 3：
输入：arr = [3,1,7,11]
输出：false
解释：在该情况下不存在 N 和 M 满足 N = 2 * M 。
  提示：
2 <= arr.length <= 500
-10^3 <= arr[i] <= 10^3",55,,22208,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],51751
评论 (93),minimum-number-of-steps-to-make-two-strings-anagram,中等,"给你两个长度相等的字符串 s 和 t。每一个步骤中，你可以选择将 t 中的 任一字符 替换为 另一个字符。
返回使 t 成为 s 的字母异位词的最小步骤数。
字母异位词 指字母相同，但排列不同（也可能相同）的字符串。
  示例 1：
输出：s = ""bab"", t = ""aba""
输出：1
提示：用 'b' 替换 t 中的第一个 'a'，t = ""bba"" 是 s 的一个字母异位词。
示例 2：
输出：s = ""leetcode"", t = ""practice""
输出：5
提示：用合适的字符替换 t 中的 'p', 'r', 'a', 'i' 和 'c'，使 t 变成 s 的字母异位词。
示例 3：
输出：s = ""anagram"", t = ""mangaar""
输出：0
提示：""anagram"" 和 ""mangaar"" 本身就是一组字母异位词。 
示例 4：
输出：s = ""xxyyzz"", t = ""xxyyzz""
输出：0
示例 5：
输出：s = ""friend"", t = ""family""
输出：4
  提示：
1 <= s.length <= 50000
s.length == t.length
s 和 t 只包含小写英文字母",36,,9426,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],12562
评论 (93),tweet-counts-per-frequency,中等,"一家社交媒体公司正试图通过分析特定时间段内出现的推文数量来监控其网站上的活动。这些时间段可以根据特定的频率（ 每分钟 、每小时 或 每一天 ）划分为更小的 时间段 。
  例如，周期 [10,10000] （以 秒 为单位）将被划分为以下频率的 时间块 :
每 分钟 (60秒 块)： [10,69], [70,129], [130,189], ..., [9970,10000]
每 小时 (3600秒 块)：[10,3609], [3610,7209], [7210,10000]
每 天 (86400秒 块)： [10,10000]
注意，最后一个块可能比指定频率的块大小更短，并且总是以时间段的结束时间结束(在上面的示例中为 10000 )。
设计和实现一个API来帮助公司进行分析。
实现 TweetCounts 类:
TweetCounts() 初始化 TweetCounts 对象。
存储记录时间的 tweetName (以秒为单位)。
List<integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) 返回一个整数列表，表示给定时间 [startTime, endTime] （单位秒）和频率频率中，每个 时间块 中带有 tweetName 的 tweet 的数量。
freq 是 “minute” 、 “hour” 或 “day” 中的一个，分别表示 每分钟 、 每小时 或 每一天 的频率。
  示例：
输入：
[""TweetCounts"",""recordTweet"",""recordTweet"",""recordTweet"",""getTweetCountsPerFrequency"",""getTweetCountsPerFrequency"",""recordTweet"",""getTweetCountsPerFrequency""]
[[],[""tweet3"",0],[""tweet3"",60],[""tweet3"",10],[""minute"",""tweet3"",0,59],[""minute"",""tweet3"",0,60],[""tweet3"",120],[""hour"",""tweet3"",0,210]]

输出：
[null,null,null,null,[2],[2,1],null,[4]]

解释：
TweetCounts tweetCounts = new TweetCounts();
tweetCounts.recordTweet(""tweet3"", 0);
tweetCounts.recordTweet(""tweet3"", 60);
tweetCounts.recordTweet(""tweet3"", 10);                             // ""tweet3"" 发布推文的时间分别是 0, 10 和 60 。
tweetCounts.getTweetCountsPerFrequency(""minute"", ""tweet3"", 0, 59); // 返回 [2]。统计频率是每分钟（60 秒），因此只有一个有效时间间隔 [0,60> - > 2 条推文。
tweetCounts.getTweetCountsPerFrequency(""minute"", ""tweet3"", 0, 60); // 返回 [2,1]。统计频率是每分钟（60 秒），因此有两个有效时间间隔 1) [0,60> - > 2 条推文，和 2) [60,61> - > 1 条推文。 
tweetCounts.recordTweet(""tweet3"", 120);                            // ""tweet3"" 发布推文的时间分别是 0, 10, 60 和 120 。
tweetCounts.getTweetCountsPerFrequency(""hour"", ""tweet3"", 0, 210);  // 返回 [4]。统计频率是每小时（3600 秒），因此只有一个有效时间间隔 [0,211> - > 4 条推文。
  提示：
0 <= time, startTime, endTime <= 109
0 <= endTime - startTime <= 104
recordTweet 和 getTweetCountsPerFrequency，最多有 104 次操作。",25,,4118,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/sorting/']",[],12727
评论 (53),maximum-students-taking-exam,困难,"给你一个 m * n 的矩阵 seats 表示教室中的座位分布。如果座位是坏的（不可用），就用 '#' 表示；否则，用 '.' 表示。
学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。
学生必须坐在状况良好的座位上。
  示例 1：
输入：seats = [[""#"",""."",""#"",""#"",""."",""#""],
              [""."",""#"",""#"",""#"",""#"","".""],
              [""#"",""."",""#"",""#"",""."",""#""]]
输出：4
解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 
示例 2：
输入：seats = [[""."",""#""],
              [""#"",""#""],
              [""#"","".""],
              [""#"",""#""],
              [""."",""#""]]
输出：3
解释：让所有学生坐在可用的座位上。
示例 3：
输入：seats = [[""#"",""."",""."",""."",""#""],
              [""."",""#"",""."",""#"","".""],
              [""."",""."",""#"",""."","".""],
              [""."",""#"",""."",""#"","".""],
              [""#"",""."",""."",""."",""#""]]
输出：10
解释：让学生坐在第 1、3 和 5 列的可用座位上。
  提示：
seats 只包含字符 '.' 和'#'
m == seats.length
n == seats[i].length
1 <= m <= 8
1 <= n <= 8",134,,4029,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/', 'https://leetcode.cn/tag/matrix/']",[],7693
评论 (92),students-with-invalid-departments,Unknown,,-1,,-1,[],[],-1
评论 (342),count-negative-numbers-in-a-sorted-matrix,简单,"给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 grid 中 负数 的数目。
  示例 1：
输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
输出：8
解释：矩阵中共有 8 个负数。
示例 2：
输入：grid = [[3,2],[1,0]]
输出：0
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 100
-100 <= grid[i][j] <= 100
  进阶：你可以设计一个时间复杂度为 O(n + m) 的解决方案吗？",96,,38286,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/']",[],50856
评论 (73),product-of-the-last-k-numbers,中等,"请你实现一个「数字乘积类」ProductOfNumbers，要求支持下述两种方法：
1. add(int num)
将数字 num 添加到当前数字列表的最后面。
2. getProduct(int k)
返回当前数字列表中，最后 k 个数字的乘积。
你可以假设当前列表中始终 至少 包含 k 个数字。
题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。
  示例：
输入：
[""ProductOfNumbers"",""add"",""add"",""add"",""add"",""add"",""getProduct"",""getProduct"",""getProduct"",""add"",""getProduct""]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

输出：
[null,null,null,null,null,null,20,40,0,null,32]

解释：
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20
productOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 
  提示：
add 和 getProduct 两种操作加起来总共不会超过 40000 次。
0 <= num <= 100
1 <= k <= 40000",73,,8351,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/data-stream/']",[],18231
评论 (112),maximum-number-of-events-that-can-be-attended,中等,"给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。
你可以在满足 startDayi <= d <= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。
请你返回你可以参加的 最大 会议数目。
  示例 1：
输入：events = [[1,2],[2,3],[3,4]]
输出：3
解释：你可以参加所有的三个会议。
安排会议的一种方案如上图。
第 1 天参加第一个会议。
第 2 天参加第二个会议。
第 3 天参加第三个会议。
示例 2：
输入：events= [[1,2],[2,3],[3,4],[1,2]]
输出：4
  提示：
1 <= events.length <= 105
events[i].length == 2
1 <= startDayi <= endDayi <= 105",210,,14371,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],49381
评论 (61),construct-target-array-with-multiple-sums,困难,"给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作：
令 x 为你数组里所有元素的和
选择满足 0 <= i < target.size 的任意下标 i ，并让 A 数组里下标为 i 处的值为 x 。
你可以重复该过程任意次
如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。
  示例 1：
输入：target = [9,3,5]
输出：true
解释：从 [1, 1, 1] 开始
[1, 1, 1], 和为 3 ，选择下标 1
[1, 3, 1], 和为 5， 选择下标 2
[1, 3, 5], 和为 9， 选择下标 0
[9, 3, 5] 完成
示例 2：
输入：target = [1,1,1,2]
输出：false
解释：不可能从 [1,1,1,1] 出发构造目标数组。
示例 3：
输入：target = [8,5]
输出：true
  提示：
N == target.length
1 <= target.length <= 5 * 10^4
1 <= target[i] <= 10^9",68,,3298,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],11716
评论 (125),activity-participants,Unknown,,-1,,-1,[],[],-1
评论 (364),sort-integers-by-the-number-of-1-bits,简单,"给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。
如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。
请你返回排序后的数组。
  示例 1：
输入：arr = [0,1,2,3,4,5,6,7,8]
输出：[0,1,2,4,8,3,5,6,7]
解释：[0] 是唯一一个有 0 个 1 的数。
[1,2,4,8] 都有 1 个 1 。
[3,5,6] 有 2 个 1 。
[7] 有 3 个 1 。
按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]
示例 2：
输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]
输出：[1,2,4,8,16,32,64,128,256,512,1024]
解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。
示例 3：
输入：arr = [10000,10000]
输出：[10000,10000]
示例 4：
输入：arr = [2,3,5,7,11,13,17,19]
输出：[2,3,5,17,7,11,13,19]
示例 5：
输入：arr = [10,100,1000,10000]
输出：[10,100,10000,1000]
  提示：
1 <= arr.length <= 500
0 <= arr[i] <= 10^4",130,,51361,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],70291
评论 (56),apply-discount-every-n-orders,中等,"超市里正在举行打折活动，每隔 n 个顾客会得到 discount 的折扣。
超市里有一些商品，第 i 种商品为 products[i] 且每件单品的价格为 prices[i] 。
结账系统会统计顾客的数目，每隔 n 个顾客结账时，该顾客的账单都会打折，折扣为 discount （也就是如果原本账单为 x ，那么实际金额会变成 x - (discount * x) / 100 ），然后系统会重新开始计数。
顾客会购买一些商品， product[i] 是顾客购买的第 i 种商品， amount[i] 是对应的购买该种商品的数目。
请你实现 Cashier 类：
Cashier(int n, int discount, int[] products, int[] prices) 初始化实例对象，参数分别为打折频率 n ，折扣大小 discount ，超市里的商品列表 products 和它们的价格 prices 。
double getBill(int[] product, int[] amount) 返回账单的实际金额（如果有打折，请返回打折后的结果）。返回结果与标准答案误差在 10^-5 以内都视为正确结果。
  示例 1：
输入
[""Cashier"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill""]
[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]
输出
[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]
解释
Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);
cashier.getBill([1,2],[1,2]);                        // 返回 500.0, 账单金额为 = 1 * 100 + 2 * 200 = 500.
cashier.getBill([3,7],[10,10]);                      // 返回 4000.0
cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // 返回 800.0 ，账单原本为 1600.0 ，但由于该顾客是第三位顾客，他将得到 50% 的折扣，所以实际金额为 1600 - 1600 * (50 / 100) = 800 。
cashier.getBill([4],[10]);                           // 返回 4000.0
cashier.getBill([7,3],[10,10]);                      // 返回 4000.0
cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // 返回 7350.0 ，账单原本为 14700.0 ，但由于系统计数再次达到三，该顾客将得到 50% 的折扣，实际金额为 7350.0 。
cashier.getBill([2,3,5],[5,3,2]);                    // 返回 2500.0
  提示：
1 <= n <= 10^4
0 <= discount <= 100
1 <= products.length <= 200
1 <= products[i] <= 200
products 列表中 不会 有重复的元素。
prices.length == products.length
1 <= prices[i] <= 1000
1 <= product.length <= products.length
product[i] 在 products 出现过。
amount.length == product.length
1 <= amount[i] <= 1000
最多有 1000 次对 getBill 函数的调用。
返回结果与标准答案误差在 10^-5 以内都视为正确结果。",15,,5261,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],9842
评论 (84),number-of-substrings-containing-all-three-characters,中等,"给你一个字符串 s ，它只包含三种字符 a, b 和 c 。
请你返回 a，b 和 c 都 至少 出现过一次的子字符串数目。
  示例 1：
输入：s = ""abcabc""
输出：10
解释：包含 a，b 和 c 各至少一次的子字符串为 ""abc"", ""abca"", ""abcab"", ""abcabc"", ""bca"", ""bcab"", ""bcabc"", ""cab"", ""cabc"" 和 ""abc"" (相同字符串算多次)。
示例 2：
输入：s = ""aaacb""
输出：3
解释：包含 a，b 和 c 各至少一次的子字符串为 ""aaacb"", ""aacb"" 和 ""acb"" 。
示例 3：
输入：s = ""abc""
输出：1
  提示：
3 <= s.length <= 5 x 10^4
s 只包含字符 a，b 和 c 。",73,,7736,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],15106
评论 (41),count-all-valid-pickup-and-delivery-options,困难,"给你 n 笔订单，每笔订单都需要快递服务。
请你统计所有有效的 收件/配送 序列的数目，确保第 i 个物品的配送服务 delivery(i) 总是在其收件服务 pickup(i) 之后。
由于答案可能很大，请返回答案对 10^9 + 7 取余的结果。
  示例 1：
输入：n = 1
输出：1
解释：只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。
示例 2：
输入：n = 2
输出：6
解释：所有可能的序列包括：
(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。
(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。
示例 3：
输入：n = 3
输出：90
  提示：
1 <= n <= 500",43,,3491,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/combinatorics/']",[],6242
评论 (118),number-of-days-between-two-dates,简单,"请你编写一个程序来计算两个日期之间隔了多少天。
日期以字符串形式给出，格式为 YYYY-MM-DD，如示例所示。
  示例 1：
输入：date1 = ""2019-06-29"", date2 = ""2019-06-30""
输出：1
示例 2：
输入：date1 = ""2020-01-15"", date2 = ""2019-12-31""
输出：15
  提示：
给定的日期是 1971 年到 2100 年之间的有效日期。",47,,11028,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],21956
评论 (130),validate-binary-tree-nodes,中等,"二叉树上有 n 个节点，按从 0 到 n - 1 编号，其中节点 i 的两个子节点分别是 leftChild[i] 和 rightChild[i]。
只有 所有 节点能够形成且 只 形成 一颗 有效的二叉树时，返回 true；否则返回 false。
如果节点 i 没有左子节点，那么 leftChild[i] 就等于 -1。右子节点也符合该规则。
注意：节点没有值，本问题中仅仅使用节点编号。
  示例 1：
输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
输出：true
示例 2：
输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
输出：false
示例 3：
输入：n = 2, leftChild = [1,0], rightChild = [-1,-1]
输出：false
示例 4：
输入：n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]
输出：false
  提示：
1 <= n <= 10^4
leftChild.length == rightChild.length == n
-1 <= leftChild[i], rightChild[i] <= n - 1",85,,9234,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/binary-tree/']",[],23218
评论 (60),closest-divisors,中等,"给你一个整数 num，请你找出同时满足下面全部要求的两个整数：
两数乘积等于  num + 1 或 num + 2
以绝对差进行度量，两数大小最接近
你可以按任意顺序返回这两个整数。
  示例 1：
输入：num = 8
输出：[3,3]
解释：对于 num + 1 = 9，最接近的两个因数是 3 & 3；对于 num + 2 = 10, 最接近的两个因数是 2 & 5，因此返回 3 & 3 。
示例 2：
输入：num = 123
输出：[5,25]
示例 3：
输入：num = 999
输出：[40,25]
  提示：
1 <= num <= 10^9",27,,6391,['https://leetcode.cn/tag/math/'],[],11971
评论 (82),largest-multiple-of-three,困难,"给你一个整数数组 digits，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。
由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。
如果无法得到答案，请返回一个空字符串。
  示例 1：
输入：digits = [8,1,9]
输出：""981""
示例 2：
输入：digits = [8,6,7,1,0]
输出：""8760""
示例 3：
输入：digits = [1]
输出：""""
示例 4：
输入：digits = [0,0,0,0,0,0]
输出：""0""
  提示：
1 <= digits.length <= 10^4
0 <= digits[i] <= 9
返回的结果不应包含不必要的前导零。",67,,6238,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],17037
评论 (142),number-of-trusted-contacts-of-a-customer,Unknown,,-1,,-1,[],[],-1
评论 (501),how-many-numbers-are-smaller-than-the-current-number,简单,"给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。
换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。
以数组形式返回答案。
  示例 1：
输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。
示例 2：
输入：nums = [6,5,4,8]
输出：[2,1,0,3]
示例 3：
输入：nums = [7,7,7,7]
输出：[0,0,0,0]
  提示：
2 <= nums.length <= 500
0 <= nums[i] <= 100",203,,93813,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],113832
评论 (81),rank-teams-by-votes,中等,"现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。
排名规则如下：
参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。
如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。
给你一个字符串数组 votes 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。
请你返回能表示按排名系统 排序后 的所有团队排名的字符串。
  示例 1：
输入：votes = [""ABC"",""ACB"",""ABC"",""ACB"",""ACB""]
输出：""ACB""
解释：A 队获得五票「排位第一」，没有其他队获得「排位第一」，所以 A 队排名第一。
B 队获得两票「排位第二」，三票「排位第三」。
C 队获得三票「排位第二」，两票「排位第三」。
由于 C 队「排位第二」的票数较多，所以 C 队排第二，B 队排第三。
示例 2：
输入：votes = [""WXYZ"",""XYZW""]
输出：""XWYZ""
解释：X 队在并列僵局打破后成为排名第一的团队。X 队和 W 队的「排位第一」票数一样，但是 X 队有一票「排位第二」，而 W 没有获得「排位第二」。 
示例 3：
输入：votes = [""ZMNAGUEDSJYLBOPHRQICWFXTVK""]
输出：""ZMNAGUEDSJYLBOPHRQICWFXTVK""
解释：只有一个投票者，所以排名完全按照他的意愿。
示例 4：
输入：votes = [""BCA"",""CAB"",""CBA"",""ABC"",""ACB"",""BAC""]
输出：""ABC""
解释： 
A 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。
B 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。
C 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。
完全并列，所以我们需要按照字母升序排名。
示例 5：
输入：votes = [""M"",""M"",""M"",""M""]
输出：""M""
解释：只有 M 队参赛，所以它排名第一。
  提示：
1 <= votes.length <= 1000
1 <= votes[i].length <= 26
votes[i].length == votes[j].length for 0 <= i, j < votes.length
votes[i][j] 是英文 大写 字母
votes[i] 中的所有字母都是唯一的
votes[0] 中出现的所有字母 同样也 出现在 votes[j] 中，其中 1 <= j < votes.length",71,,8250,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],15123
评论 (236),linked-list-in-binary-tree,中等,"给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。
如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。
一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。
  示例 1：
输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
输出：true
解释：树中蓝色的节点构成了与链表对应的子路径。
示例 2：
输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
输出：true
示例 3：
输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
输出：false
解释：二叉树中不存在一一对应链表的路径。
  提示：
二叉树和链表中的每个节点的值都满足 1 <= node.val <= 100 。
链表包含的节点数目在 1 到 100 之间。
二叉树包含的节点数目在 1 到 2500 之间。",132,,18768,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/binary-tree/']",[],43741
评论 (55),minimum-cost-to-make-at-least-one-valid-path-in-a-grid,困难,"给你一个 m x n 的网格图 grid 。 grid 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况：
1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1]
2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1]
3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j]
4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j]
注意网格图中可能会有 无效数字 ，因为它们可能指向 grid 以外的区域。
一开始，你会从最左上角的格子 (0,0) 出发。我们定义一条 有效路径 为从格子 (0,0) 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 (m - 1, n - 1) 结束的路径。有效路径 不需要是最短路径 。
你可以花费 cost = 1 的代价修改一个格子中的数字，但每个格子中的数字 只能修改一次 。
请你返回让网格图至少有一条有效路径的最小代价。
  示例 1：
输入：grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
输出：3
解释：你将从点 (0, 0) 出发。
到达 (3, 3) 的路径为： (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) 花费代价 cost = 1 使方向向下 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) 花费代价 cost = 1 使方向向下 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) 花费代价 cost = 1 使方向向下 --> (3, 3)
总花费为 cost = 3.
示例 2：
输入：grid = [[1,1,3],[3,2,2],[1,1,4]]
输出：0
解释：不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。
示例 3：
输入：grid = [[1,2],[4,3]]
输出：1
示例 4：
输入：grid = [[2,2,2],[2,2,2]]
输出：3
示例 5：
输入：grid = [[4]]
输出：0
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 100",92,,5004,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/shortest-path/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],9001
评论 (101),get-the-second-most-recent-activity,Unknown,,-1,,-1,[],[],-1
评论 (404),increasing-decreasing-string,简单,"给你一个字符串 s ，请你根据下面的算法重新构造字符串：
从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
重复步骤 2 ，直到你没法从 s 中选择字符。
从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
重复步骤 5 ，直到你没法从 s 中选择字符。
重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。
在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。
请你返回将 s 中字符重新排序后的 结果字符串 。
  示例 1：
输入：s = ""aaaabbbbcccc""
输出：""abccbaabccba""
解释：第一轮的步骤 1，2，3 后，结果字符串为 result = ""abc""
第一轮的步骤 4，5，6 后，结果字符串为 result = ""abccba""
第一轮结束，现在 s = ""aabbcc"" ，我们再次回到步骤 1
第二轮的步骤 1，2，3 后，结果字符串为 result = ""abccbaabc""
第二轮的步骤 4，5，6 后，结果字符串为 result = ""abccbaabccba""
示例 2：
输入：s = ""rat""
输出：""art""
解释：单词 ""rat"" 在上述算法重排序以后变成 ""art""
示例 3：
输入：s = ""leetcode""
输出：""cdelotee""
示例 4：
输入：s = ""ggggggg""
输出：""ggggggg""
示例 5：
输入：s = ""spo""
输出：""ops""
  提示：
1 <= s.length <= 500
s 只包含小写英文字母。",103,,50208,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],63596
评论 (286),find-the-longest-substring-containing-vowels-in-even-counts,中等,"给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。
  示例 1：
输入：s = ""eleetminicoworoep""
输出：13
解释：最长子字符串是 ""leetminicowor"" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
示例 2：
输入：s = ""leetcodeisgreat""
输出：5
解释：最长子字符串是 ""leetc"" ，其中包含 2 个 e 。
示例 3：
输入：s = ""bcbcbc""
输出：6
解释：这个示例中，字符串 ""bcbcbc"" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
  提示：
1 <= s.length <= 5 x 10^5
s 只包含小写英文字母。",393,,22878,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/prefix-sum/']",[],39349
评论 (123),longest-zigzag-path-in-a-binary-tree,中等,"给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：
选择二叉树中 任意 节点和一个方向（左或者右）。
如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
改变前进方向：左变右或者右变左。
重复第二步和第三步，直到你在树中无法继续移动。
交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。
请你返回给定树中最长 交错路径 的长度。
  示例 1：
输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
输出：3
解释：蓝色节点为树中最长交错路径（右 -> 左 -> 右）。
示例 2：
输入：root = [1,1,1,null,1,null,null,1,1,null,1]
输出：4
解释：蓝色节点为树中最长交错路径（左 -> 右 -> 左 -> 右）。
示例 3：
输入：root = [1]
输出：0
  提示：
每棵树最多有 50000 个节点。
每个节点的值在 [1, 100] 之间。",77,,10286,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",[],19523
评论 (170),maximum-sum-bst-in-binary-tree,困难,"给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。
二叉搜索树的定义如下：
任意节点的左子树中的键值都 小于 此节点的键值。
任意节点的右子树中的键值都 大于 此节点的键值。
任意节点的左子树和右子树都是二叉搜索树。
  示例 1：
输入：root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
输出：20
解释：键值为 3 的子树是和最大的二叉搜索树。
示例 2：
输入：root = [4,3,null,1,2]
输出：2
解释：键值为 2 的单节点子树是和最大的二叉搜索树。
示例 3：
输入：root = [-4,-2,-5]
输出：0
解释：所有节点键值都为负数，和最大的二叉搜索树为空。
示例 4：
输入：root = [2,1,3]
输出：6
示例 5：
输入：root = [5,4,8,3,null,6,3]
输出：7
  提示：
每棵树有 1 到 40000 个节点。
每个节点的键值在 [-4 * 10^4 , 4 * 10^4] 之间。",98,,14132,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",[],33696
评论 (156),generate-a-string-with-characters-that-have-odd-counts,简单,"给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。
返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。
  示例 1：
输入：n = 4
输出：""pppz""
解释：""pppz"" 是一个满足题目要求的字符串，因为 'p' 出现 3 次，且 'z' 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：""ohhh"" 和 ""love""。
示例 2：
输入：n = 2
输出：""xy""
解释：""xy"" 是一个满足题目要求的字符串，因为 'x' 和 'y' 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：""ag"" 和 ""ur""。
示例 3：
输入：n = 7
输出：""holasss""
  提示：
1 <= n <= 500",21,,18876,['https://leetcode.cn/tag/string/'],[],25362
评论 (93),number-of-times-binary-string-is-prefix-aligned,中等,"给你一个长度为 n 、下标从 1 开始的二进制字符串，所有位最开始都是 0 。我们会按步翻转该二进制字符串的所有位（即，将 0 变为 1）。
给你一个下标从 1 开始的整数数组 flips ，其中 flips[i] 表示对应下标 i 的位将会在第 i 步翻转。
二进制字符串 前缀一致 需满足：在第 i 步之后，在 闭 区间 [1, i] 内的所有位都是 1 ，而其他位都是 0 。
返回二进制字符串在翻转过程中 前缀一致 的次数。
  示例 1：
输入：flips = [3,2,4,1,5]
输出：2
解释：二进制字符串最开始是 ""00000"" 。
执行第 1 步：字符串变为 ""00100"" ，不属于前缀一致的情况。
执行第 2 步：字符串变为 ""01100"" ，不属于前缀一致的情况。
执行第 3 步：字符串变为 ""01110"" ，不属于前缀一致的情况。
执行第 4 步：字符串变为 ""11110"" ，属于前缀一致的情况。
执行第 5 步：字符串变为 ""11111"" ，属于前缀一致的情况。
在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。
示例 2：
输入：flips = [4,1,2,3]
输出：1
解释：二进制字符串最开始是 ""0000"" 。
执行第 1 步：字符串变为 ""0001"" ，不属于前缀一致的情况。
执行第 2 步：字符串变为 ""1001"" ，不属于前缀一致的情况。
执行第 3 步：字符串变为 ""1101"" ，不属于前缀一致的情况。
执行第 4 步：字符串变为 ""1111"" ，属于前缀一致的情况。
在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。
  提示：
n == flips.length
1 <= n <= 5 * 104
flips 是范围 [1, n] 中所有整数构成的一个排列",50,,9535,['https://leetcode.cn/tag/array/'],[],16299
评论 (106),time-needed-to-inform-all-employees,中等,"公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。
在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。
公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。
第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。
返回通知所有员工这一紧急消息所需要的 分钟数 。
  示例 1：
输入：n = 1, headID = 0, manager = [-1], informTime = [0]
输出：0
解释：公司总负责人是该公司的唯一一名员工。
示例 2：
输入：n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
输出：1
解释：id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。
上图显示了公司员工的树结构。
  提示：
1 <= n <= 10^5
0 <= headID < n
manager.length == n
0 <= manager[i] < n
manager[headID] == -1
informTime.length == n
0 <= informTime[i] <= 1000
如果员工 i 没有下属，informTime[i] == 0 。
题目 保证 所有员工都可以收到通知。",94,,10764,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/']",[],20284
评论 (110),frog-position-after-t-seconds,困难,"给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：
在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。
青蛙无法跳回已经访问过的顶点。
如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。
如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。
无向树的边用数组 edges 描述，其中 edges[i] = [fromi, toi] 意味着存在一条直接连通 fromi 和 toi 两个顶点的边。
返回青蛙在 t 秒后位于目标顶点 target 上的概率。
  示例 1：
输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
输出：0.16666666666666666 
解释：上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 1 秒 有 1/3 的概率跳到顶点 2 ，然后第 2 秒 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 
示例 2：
输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
输出：0.3333333333333333
解释：上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 1 秒 后跳到顶点 7 。 
    提示：
1 <= n <= 100
edges.length == n - 1
edges[i].length == 2
1 <= ai, bi <= n
1 <= t <= 50
1 <= target <= n",41,,4911,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/']",[],14881
评论 (73),replace-employee-id-with-the-unique-identifier,Unknown,,-1,,-1,[],[],-1
评论 (125),find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree,中等,"给你两棵二叉树，原始树 original 和克隆树 cloned，以及一个位于原始树 original 中的目标节点 target。
其中，克隆树 cloned 是原始树 original 的一个 副本 。
请找出在树 cloned 中，与 target 相同 的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。
  注意：你 不能 对两棵二叉树，以及 target 节点进行更改。只能 返回对克隆树 cloned 中已有的节点的引用。
  示例 1:
输入: tree = [7,4,3,null,null,6,19], target = 3
输出: 3
解释: 上图画出了树 original 和 cloned。target 节点在树 original 中，用绿色标记。答案是树 cloned 中的黄颜色的节点（其他示例类似）。
示例 2:
输入: tree = [7], target =  7
输出: 7
示例 3:
输入: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
输出: 4
  提示：
树中节点的数量范围为 [1, 104] 。
同一棵树中，没有值相同的节点。
target 节点是树 original 中的一个节点，并且不会是 null 。
  进阶：如果树中允许出现值相同的节点，将如何解答？",41,,12342,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],14709
评论 (422),lucky-numbers-in-a-matrix,简单,"给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。
幸运数 是指矩阵中满足同时下列两个条件的元素：
在同一行的所有元素中最小
在同一列的所有元素中最大
  示例 1：
输入：matrix = [[3,7,8],[9,11,13],[15,16,17]]
输出：[15]
解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。
示例 2：
输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
输出：[12]
解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。
示例 3：
输入：matrix = [[7,8],[1,2]]
输出：[7]
解释：7是唯一的幸运数字，因为它是行中的最小值，列中的最大值。
  提示：
m == mat.length
n == mat[i].length
1 <= n, m <= 50
1 <= matrix[i][j] <= 10^5
矩阵中的所有元素都是不同的",119,,52388,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],68123
评论 (91),design-a-stack-with-increment-operation,中等,"请你设计一个支持下述操作的栈。
实现自定义栈类 CustomStack ：
CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。
void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。
int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。
void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。
  示例：
输入：
[""CustomStack"",""push"",""push"",""pop"",""push"",""push"",""push"",""increment"",""increment"",""pop"",""pop"",""pop"",""pop""]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
输出：
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
解释：
CustomStack customStack = new CustomStack(3); // 栈是空的 []
customStack.push(1);                          // 栈变为 [1]
customStack.push(2);                          // 栈变为 [1, 2]
customStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]
customStack.push(2);                          // 栈变为 [1, 2]
customStack.push(3);                          // 栈变为 [1, 2, 3]
customStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4
customStack.increment(5, 100);                // 栈变为 [101, 102, 103]
customStack.increment(2, 100);                // 栈变为 [201, 202, 103]
customStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]
customStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]
customStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []
customStack.pop();                            // 返回 -1 --> 栈为空，返回 -1
  提示：
1 <= maxSize <= 1000
1 <= x <= 1000
1 <= k <= 1000
0 <= val <= 100
每种方法 increment，push 以及 pop 分别最多调用 1000 次",75,,14705,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/']",[],20141
评论 (131),balance-a-binary-search-tree,中等,"给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。
如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。
  示例 1：
输入：root = [1,null,2,null,3,null,4,null,null]
输出：[2,1,3,null,null,null,4]
解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。
示例 2：
输入: root = [2,1,3]
输出: [2,1,3]
  提示：
树节点的数目在 [1, 104] 范围内。
1 <= Node.val <= 105",115,,14968,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/binary-tree/']",[],21154
评论 (107),maximum-performance-of-a-team,困难,"公司有编号为 1 到 n 的 n 个工程师，给你两个数组 speed 和 efficiency ，其中 speed[i] 和 efficiency[i] 分别代表第 i 位工程师的速度和效率。请你返回由最多 k 个工程师组成的 最大团队表现值 ，由于答案可能很大，请你返回结果对 10^9 + 7 取余后的结果。
团队表现值 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。
  示例 1：
输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
输出：60
解释：
我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。
示例 2：
输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
输出：68
解释：
此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。
示例 3：
输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
输出：72
  提示：
1 <= n <= 10^5
speed.length == n
efficiency.length == n
1 <= speed[i] <= 10^5
1 <= efficiency[i] <= 10^8
1 <= k <= n",104,,5270,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],15852
评论 (120),total-sales-amount-by-year,Unknown,,-1,,-1,[],[],-1
评论 (178),find-the-distance-value-between-two-arrays,简单,"给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。
「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| <= d 。
  示例 1：
输入：arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
输出：2
解释：
对于 arr1[0]=4 我们有：
|4-10|=6 > d=2 
|4-9|=5 > d=2 
|4-1|=3 > d=2 
|4-8|=4 > d=2 
所以 arr1[0]=4 符合距离要求

对于 arr1[1]=5 我们有：
|5-10|=5 > d=2 
|5-9|=4 > d=2 
|5-1|=4 > d=2 
|5-8|=3 > d=2
所以 arr1[1]=5 也符合距离要求

对于 arr1[2]=8 我们有：
|8-10|=2 <= d=2
|8-9|=1 <= d=2
|8-1|=7 > d=2
|8-8|=0 <= d=2
存在距离小于等于 2 的情况，不符合距离要求 

故而只有 arr1[0]=4 和 arr1[1]=5 两个符合距离要求，距离值为 2
示例 2：
输入：arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
输出：2
示例 3：
输入：arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
输出：1
  提示：
1 <= arr1.length, arr2.length <= 500
-10^3 <= arr1[i], arr2[j] <= 10^3
0 <= d <= 100",52,,22968,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],34499
评论 (82),cinema-seat-allocation,中等,"如上图所示，电影院的观影厅中有 n 行座位，行编号从 1 到 n ，且每一行内总共有 10 个座位，列编号从 1 到 10 。
给你数组 reservedSeats ，包含所有已经被预约了的座位。比如说，researvedSeats[i]=[3,8] ，它表示第 3 行第 8 个座位被预约了。
请你返回 最多能安排多少个 4 人家庭 。4 人家庭要占据 同一行内连续 的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。
  示例 1：
输入：n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]
输出：4
解释：上图所示是最优的安排方案，总共可以安排 4 个家庭。蓝色的叉表示被预约的座位，橙色的连续座位表示一个 4 人家庭。
示例 2：
输入：n = 2, reservedSeats = [[2,1],[1,8],[2,6]]
输出：2
示例 3：
输入：n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]
输出：4
  提示：
1 <= n <= 10^9
1 <= reservedSeats.length <= min(10*n, 10^4)
reservedSeats[i].length == 2
1 <= reservedSeats[i][0] <= n
1 <= reservedSeats[i][1] <= 10
所有 reservedSeats[i] 都是互不相同的。",50,,7306,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],22460
评论 (113),sort-integers-by-the-power-value,中等,"我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：
如果 x 是偶数，那么 x = x / 2
如果 x 是奇数，那么 x = 3 * x + 1
比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）。
给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。
请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。
注意，题目保证对于任意整数 x （lo <= x <= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。
  示例 1：
输入：lo = 12, hi = 15, k = 2
输出：13
解释：12 的权重为 9（12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）
13 的权重为 9
14 的权重为 17
15 的权重为 17
区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k = 2 ，答案是第二个整数也就是 13 。
注意，12 和 13 有相同的权重，所以我们按照它们本身升序排序。14 和 15 同理。
示例 2：
输入：lo = 7, hi = 11, k = 4
输出：7
解释：区间内整数 [7, 8, 9, 10, 11] 对应的权重为 [16, 3, 19, 6, 14] 。
按权重排序后得到的结果为 [8, 10, 11, 7, 9] 。
排序后数组中第 4 个数字为 7 。
  提示：
1 <= lo <= hi <= 1000
1 <= k <= hi - lo + 1",45,,11433,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],16461
评论 (58),pizza-with-3n-slices,困难,"给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：
你挑选 任意 一块披萨。
Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。
Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。
重复上述过程直到没有披萨剩下。
每一块披萨的大小按顺时针方向由循环数组 slices 表示。
请你返回你可以获得的披萨大小总和的最大值。
  示例 1：
输入：slices = [1,2,3,4,5,6]
输出：10
解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。
示例 2：
输入：slices = [8,9,8,6,1,1]
输出：16
解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。
  提示：
1 <= slices.length <= 500
slices.length % 3 == 0
1 <= slices[i] <= 1000",102,,5496,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],9912
评论 (233),create-target-array-in-the-given-order,简单,"给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：
目标数组 target 最初为空。
按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。
重复上一步，直到在 nums 和 index 中都没有要读取的元素。
请你返回目标数组。
题目保证数字插入位置总是存在。
  示例 1：
输入：nums = [0,1,2,3,4], index = [0,1,2,2,1]
输出：[0,4,1,3,2]
解释：
nums       index     target
0            0        [0]
1            1        [0,1]
2            2        [0,1,2]
3            2        [0,1,3,2]
4            1        [0,4,1,3,2]
示例 2：
输入：nums = [1,2,3,4,0], index = [0,1,2,3,0]
输出：[0,1,2,3,4]
解释：
nums       index     target
1            0        [1]
2            1        [1,2]
3            2        [1,2,3]
4            3        [1,2,3,4]
0            0        [0,1,2,3,4]
示例 3：
输入：nums = [1], index = [0]
输出：[1]
  提示：
1 <= nums.length, index.length <= 100
nums.length == index.length
0 <= nums[i] <= 100
0 <= index[i] <= i",53,,31317,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],37703
评论 (102),four-divisors,中等,"给你一个整数数组 nums，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回 0 。
  示例 1：
输入：nums = [21,4,7]
输出：32
解释：
21 有 4 个因数：1, 3, 7, 21
4 有 3 个因数：1, 2, 4
7 有 2 个因数：1, 7
答案仅为 21 的所有因数的和。
示例 2:
输入: nums = [21,21]
输出: 64
示例 3:
输入: nums = [1,2,3,4,5]
输出: 0
  提示：
1 <= nums.length <= 104
1 <= nums[i] <= 105",23,,7612,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],20498
评论 (161),check-if-there-is-a-valid-path-in-a-grid,中等,"给你一个 m x n 的网格 grid。网格里的每个单元都代表一条街道。grid[i][j] 的街道可以是：
1 表示连接左单元格和右单元格的街道。
2 表示连接上单元格和下单元格的街道。
3 表示连接左单元格和下单元格的街道。
4 表示连接右单元格和下单元格的街道。
5 表示连接左单元格和上单元格的街道。
6 表示连接右单元格和上单元格的街道。
你最开始从左上角的单元格 (0,0) 开始出发，网格中的「有效路径」是指从左上方的单元格 (0,0) 开始、一直到右下方的 (m-1,n-1) 结束的路径。该路径必须只沿着街道走。
注意：你 不能 变更街道。
如果网格中存在有效的路径，则返回 true，否则返回 false 。
  示例 1：
输入：grid = [[2,4,3],[6,5,2]]
输出：true
解释：如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。
示例 2：
输入：grid = [[1,2,1],[1,2,1]]
输出：false
解释：如图所示，单元格 (0, 0) 上的街道没有与任何其他单元格上的街道相连，你只会停在 (0, 0) 处。
示例 3：
输入：grid = [[1,1,2]]
输出：false
解释：你会停在 (0, 1)，而且无法到达 (0, 2) 。
示例 4：
输入：grid = [[1,1,1,1,1,1,3]]
输出：true
示例 5：
输入：grid = [[2],[2],[2],[2],[2],[2],[6]]
输出：true
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 300
1 <= grid[i][j] <= 6",56,,7484,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],18396
评论 (148),longest-happy-prefix,困难,"「快乐前缀」 是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。
给你一个字符串 s，请你返回它的 最长快乐前缀。如果不存在满足题意的前缀，则返回一个空字符串 """" 。
  示例 1：
输入：s = ""level""
输出：""l""
解释：不包括 s 自己，一共有 4 个前缀（""l"", ""le"", ""lev"", ""leve""）和 4 个后缀（""l"", ""el"", ""vel"", ""evel""）。最长的既是前缀也是后缀的字符串是 ""l"" 。
示例 2：
输入：s = ""ababab""
输出：""abab""
解释：""abab"" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。
  提示：
1 <= s.length <= 105
s 只含有小写英文字母",93,,10743,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],25069
评论 (154),capital-gainloss,中等,"SQL架构
Stocks 表：
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| stock_name    | varchar |
| operation     | enum    |
| operation_day | int     |
| price         | int     |
+---------------+---------+
(stock_name, day) 是这张表的主键
operation 列使用的是一种枚举类型，包括：('Sell','Buy')
此表的每一行代表了名为 stock_name 的某支股票在 operation_day 这一天的操作价格。
保证股票的每次'Sell'操作前，都有相应的'Buy'操作。
  编写一个SQL查询来报告每支股票的资本损益。
股票的资本损益是一次或多次买卖股票后的全部收益或损失。
以任意顺序返回结果即可。
SQL查询结果的格式如下例所示：
Stocks 表:
+---------------+-----------+---------------+--------+
| stock_name    | operation | operation_day | price  |
+---------------+-----------+---------------+--------+
| Leetcode      | Buy       | 1             | 1000   |
| Corona Masks  | Buy       | 2             | 10     |
| Leetcode      | Sell      | 5             | 9000   |
| Handbags      | Buy       | 17            | 30000  |
| Corona Masks  | Sell      | 3             | 1010   |
| Corona Masks  | Buy       | 4             | 1000   |
| Corona Masks  | Sell      | 5             | 500    |
| Corona Masks  | Buy       | 6             | 1000   |
| Handbags      | Sell      | 29            | 7000   |
| Corona Masks  | Sell      | 10            | 10000  |
+---------------+-----------+---------------+--------+

Result 表:
+---------------+-------------------+
| stock_name    | capital_gain_loss |
+---------------+-------------------+
| Corona Masks  | 9500              |
| Leetcode      | 8000              |
| Handbags      | -23000            |
+---------------+-------------------+
Leetcode 股票在第一天以1000美元的价格买入，在第五天以9000美元的价格卖出。资本收益=9000-1000=8000美元。
Handbags 股票在第17天以30000美元的价格买入，在第29天以7000美元的价格卖出。资本损失=7000-30000=-23000美元。
Corona Masks 股票在第1天以10美元的价格买入，在第3天以1010美元的价格卖出。在第4天以1000美元的价格再次购买，在第5天以500美元的价格出售。最后，它在第6天以1000美元的价格被买走，在第10天以10000美元的价格被卖掉。资本损益是每次（’Buy'->'Sell'）操作资本收益或损失的和=（1010-10）+（500-1000）+（10000-1000）=1000-500+9000=9500美元。",30,,9560,['https://leetcode.cn/tag/database/'],[],11284
评论 (158),find-lucky-integer-in-an-array,简单,"在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。
给你一个整数数组 arr，请你从中找出并返回一个幸运数。
如果数组中存在多个幸运数，只需返回 最大 的那个。
如果数组中不含幸运数，则返回 -1 。
  示例 1：
输入：arr = [2,2,3,4]
输出：2
解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。
示例 2：
输入：arr = [1,2,2,3,3,3]
输出：3
解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。
示例 3：
输入：arr = [2,2,2,3,3]
输出：-1
解释：数组中不存在幸运数。
示例 4：
输入：arr = [5]
输出：-1
示例 5：
输入：arr = [7,7,7,7,7,7,7]
输出：7
  提示：
1 <= arr.length <= 500
1 <= arr[i] <= 500",34,,20503,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],30988
评论 (132),count-number-of-teams,中等," n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。
每 3 个士兵可以组成一个作战单位，分组规则如下：
从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k]
作战单位需满足： rating[i] < rating[j] < rating[k] 或者 rating[i] > rating[j] > rating[k] ，其中  0 <= i < j < k < n
请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。
  示例 1：
输入：rating = [2,5,3,4,1]
输出：3
解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。
示例 2：
输入：rating = [2,1,3]
输出：0
解释：根据题目条件，我们无法组建作战单位。
示例 3：
输入：rating = [1,2,3,4]
输出：4
  提示：
n == rating.length
3 <= n <= 1000
1 <= rating[i] <= 10^5
rating 中的元素都是唯一的",101,,16366,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],22532
评论 (164),design-underground-system,中等,"地铁系统跟踪不同车站之间的乘客出行时间，并使用这一数据来计算从一站到另一站的平均时间。
实现 UndergroundSystem 类：
void checkIn(int id, string stationName, int t)
通行卡 ID 等于 id 的乘客，在时间 t ，从 stationName 站进入
乘客一次只能从一个站进入
void checkOut(int id, string stationName, int t)
通行卡 ID 等于 id 的乘客，在时间 t ，从 stationName 站离开
double getAverageTime(string startStation, string endStation)
返回从 startStation 站到 endStation 站的平均时间
平均时间会根据截至目前所有从 startStation 站 直接 到达 endStation 站的行程进行计算，也就是从 startStation 站进入并从 endStation 离开的行程
从 startStation 到 endStation 的行程时间与从 endStation 到 startStation 的行程时间可能不同
在调用 getAverageTime 之前，至少有一名乘客从 startStation 站到达 endStation 站
你可以假设对 checkIn 和 checkOut 方法的所有调用都是符合逻辑的。如果一名乘客在时间 t1 进站、时间 t2 出站，那么 t1 < t2 。所有时间都按时间顺序发生。
  示例 1：
输入
[""UndergroundSystem"",""checkIn"",""checkIn"",""checkIn"",""checkOut"",""checkOut"",""checkOut"",""getAverageTime"",""getAverageTime"",""checkIn"",""getAverageTime"",""checkOut"",""getAverageTime""]
[[],[45,""Leyton"",3],[32,""Paradise"",8],[27,""Leyton"",10],[45,""Waterloo"",15],[27,""Waterloo"",20],[32,""Cambridge"",22],[""Paradise"",""Cambridge""],[""Leyton"",""Waterloo""],[10,""Leyton"",24],[""Leyton"",""Waterloo""],[10,""Waterloo"",38],[""Leyton"",""Waterloo""]]

输出
[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]

解释
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(45, ""Leyton"", 3);
undergroundSystem.checkIn(32, ""Paradise"", 8);
undergroundSystem.checkIn(27, ""Leyton"", 10);
undergroundSystem.checkOut(45, ""Waterloo"", 15);  // 乘客 45 ""Leyton"" -> ""Waterloo"" ，用时 15-3 = 12
undergroundSystem.checkOut(27, ""Waterloo"", 20);  // 乘客 27 ""Leyton"" -> ""Waterloo"" ，用时 20-10 = 10
undergroundSystem.checkOut(32, ""Cambridge"", 22); // 乘客 32 ""Paradise"" -> ""Cambridge"" ，用时 22-8 = 14
undergroundSystem.getAverageTime(""Paradise"", ""Cambridge""); // 返回 14.00000 。只有一个 ""Paradise"" -> ""Cambridge"" 的行程，(14) / 1 = 14
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // 返回 11.00000 。有两个 ""Leyton"" -> ""Waterloo"" 的行程，(10 + 12) / 2 = 11
undergroundSystem.checkIn(10, ""Leyton"", 24);
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // 返回 11.00000
undergroundSystem.checkOut(10, ""Waterloo"", 38);  // 乘客 10 ""Leyton"" -> ""Waterloo"" ，用时 38-24 = 14
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // 返回 12.00000 。有三个 ""Leyton"" -> ""Waterloo"" 的行程，(10 + 12 + 14) / 3 = 12
示例 2：
输入
[""UndergroundSystem"",""checkIn"",""checkOut"",""getAverageTime"",""checkIn"",""checkOut"",""getAverageTime"",""checkIn"",""checkOut"",""getAverageTime""]
[[],[10,""Leyton"",3],[10,""Paradise"",8],[""Leyton"",""Paradise""],[5,""Leyton"",10],[5,""Paradise"",16],[""Leyton"",""Paradise""],[2,""Leyton"",21],[2,""Paradise"",30],[""Leyton"",""Paradise""]]

输出
[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]

解释
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(10, ""Leyton"", 3);
undergroundSystem.checkOut(10, ""Paradise"", 8); // 乘客 10 ""Leyton"" -> ""Paradise"" ，用时 8-3 = 5
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // 返回 5.00000 ，(5) / 1 = 5
undergroundSystem.checkIn(5, ""Leyton"", 10);
undergroundSystem.checkOut(5, ""Paradise"", 16); // 乘客 5 ""Leyton"" -> ""Paradise"" ，用时 16-10 = 6
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // 返回 5.50000 ，(5 + 6) / 2 = 5.5
undergroundSystem.checkIn(2, ""Leyton"", 21);
undergroundSystem.checkOut(2, ""Paradise"", 30); // 乘客 2 ""Leyton"" -> ""Paradise"" ，用时 30-21 = 9
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // 返回 6.66667 ，(5 + 6 + 9) / 3 = 6.66667
  提示：
1 <= id, t <= 106
1 <= stationName.length, startStation.length, endStation.length <= 10 次
所有字符串由大小写英文字母与数字组成
总共最多调用 checkIn、checkOut 和 getAverageTime 方法 2 * 104
与标准答案误差在 10-5 以内的结果都被视为正确结果",56,,15555,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],38042
评论 (21),find-all-good-strings,困难,"给你两个长度为 n 的字符串 s1 和 s2 ，以及一个字符串 evil 。请你返回 好字符串 的数目。
好字符串 的定义为：它的长度为 n ，字典序大于等于 s1 ，字典序小于等于 s2 ，且不包含 evil 为子字符串。
由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。
  示例 1：
输入：n = 2, s1 = ""aa"", s2 = ""da"", evil = ""b""
输出：51 
解释：总共有 25 个以 'a' 开头的好字符串：""aa""，""ac""，""ad""，...，""az""。还有 25 个以 'c' 开头的好字符串：""ca""，""cc""，""cd""，...，""cz""。最后，还有一个以 'd' 开头的好字符串：""da""。
示例 2：
输入：n = 8, s1 = ""leetcode"", s2 = ""leetgoes"", evil = ""leet""
输出：0 
解释：所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 ""leet"" 开头。所以没有好字符串。
示例 3：
输入：n = 2, s1 = ""gx"", s2 = ""gz"", evil = ""x""
输出：2
  提示：
s1.length == n
s2.length == n
s1 <= s2
1 <= n <= 500
1 <= evil.length <= 50
所有字符串都只包含小写英文字母。",67,,1266,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/string-matching/']",[],3128
评论 (129),customers-who-bought-products-a-and-b-but-not-c,Unknown,,-1,,-1,[],[],-1
评论 (122),count-largest-group,简单,"给你一个整数 n 。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。
请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。
  示例 1：
输入：n = 13
输出：4
解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：
[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。
示例 2：
输入：n = 2
输出：2
解释：总共有 2 个大小为 1 的组 [1]，[2]。
示例 3：
输入：n = 15
输出：6
示例 4：
输入：n = 24
输出：5
  提示：
1 <= n <= 10^4",28,,11203,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/']",[],16746
评论 (59),construct-k-palindrome-strings,中等,"给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。
如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。
  示例 1：
输入：s = ""annabelle"", k = 2
输出：true
解释：可以用 s 中所有字符构造 2 个回文字符串。
一些可行的构造方案包括：""anna"" + ""elble""，""anbna"" + ""elle""，""anellena"" + ""b""
示例 2：
输入：s = ""leetcode"", k = 3
输出：false
解释：无法用 s 中所有字符构造 3 个回文串。
示例 3：
输入：s = ""true"", k = 4
输出：true
解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。
示例 4：
输入：s = ""yzyzyzyzyzyzyzy"", k = 2
输出：true
解释：你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。
示例 5：
输入：s = ""cr"", k = 7
输出：false
解释：我们没有足够的字符去构造 7 个回文串。
  提示：
1 <= s.length <= 10^5
s 中所有字符都是小写英文字母。
1 <= k <= 10^5",39,,7550,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],12368
评论 (79),circle-and-rectangle-overlapping,中等,"给你一个以 (radius, x_center, y_center) 表示的圆和一个与坐标轴平行的矩形 (x1, y1, x2, y2)，其中 (x1, y1) 是矩形左下角的坐标，(x2, y2) 是右上角的坐标。
如果圆和矩形有重叠的部分，请你返回 True ，否则返回 False 。
换句话说，请你检测是否 存在 点 (xi, yi) ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。
  示例 1：
输入：radius = 1, x_center = 0, y_center = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1
输出：true
解释：圆和矩形有公共点 (1,0) 
示例 2：
输入：radius = 1, x_center = 0, y_center = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1
输出：true
示例 3：
输入：radius = 1, x_center = 1, y_center = 1, x1 = -3, y1 = -3, x2 = 3, y2 = 3
输出：true
示例 4：
输入：radius = 1, x_center = 1, y_center = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1
输出：false
  提示：
1 <= radius <= 2000
-10^4 <= x_center, y_center, x1, y1, x2, y2 <= 10^4
x1 < x2
y1 < y2",38,,4669,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/math/']",[],11056
评论 (164),reducing-dishes,困难,"一个厨师收集了他 n 道菜的满意程度 satisfaction ，这个厨师做出每道菜的时间都是 1 单位时间。
一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 time[i]*satisfaction[i] 。
请你返回做完所有菜 「喜爱时间」总和的最大值为多少。
你可以按 任意 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。
  示例 1：
输入：satisfaction = [-1,-8,0,5,-9]
输出：14
解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。
示例 2：
输入：satisfaction = [4,3,2]
输出：20
解释：按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)
示例 3：
输入：satisfaction = [-1,-4,-5]
输出：0
解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。
  提示：
n == satisfaction.length
1 <= n <= 500
-1000 <= satisfaction[i] <= 1000",94,,11816,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],15566
评论 (201),minimum-subsequence-in-non-increasing-order,简单,"给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。
如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。
与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。
注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。
  示例 1：
输入：nums = [4,3,10,9,8]
输出：[10,9] 
解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 
示例 2：
输入：nums = [4,4,7,6,7]
输出：[7,7,6] 
解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  
示例 3：
输入：nums = [6]
输出：[6]
  提示：
1 <= nums.length <= 500
1 <= nums[i] <= 100",48,,24285,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],35254
评论 (125),number-of-steps-to-reduce-a-number-in-binary-representation-to-one,中等,"给你一个以二进制形式表示的数字 s 。请你返回按下述规则将其减少到 1 所需要的步骤数：
如果当前数字为偶数，则将其除以 2 。
如果当前数字为奇数，则将其加上 1 。
题目保证你总是可以按上述规则将测试用例变为 1 。
  示例 1：
输入：s = ""1101""
输出：6
解释：""1101"" 表示十进制数 13 。
Step 1) 13 是奇数，加 1 得到 14 
Step 2) 14 是偶数，除 2 得到 7
Step 3) 7  是奇数，加 1 得到 8
Step 4) 8  是偶数，除 2 得到 4  
Step 5) 4  是偶数，除 2 得到 2 
Step 6) 2  是偶数，除 2 得到 1  
示例 2：
输入：s = ""10""
输出：1
解释：""10"" 表示十进制数 2 。
Step 1) 2 是偶数，除 2 得到 1 
示例 3：
输入：s = ""1""
输出：0
  提示：
1 <= s.length <= 500
s 由字符 '0' 或 '1' 组成。
s[0] == '1'",36,,8293,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/string/']",[],16598
评论 (332),longest-happy-string,中等,"如果字符串中不含有任何 'aaa'，'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。
给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：
s 是一个尽可能长的快乐字符串。
s 中 最多 有a 个字母 'a'、b 个字母 'b'、c 个字母 'c' 。
s 中只含有 'a'、'b' 、'c' 三种字母。
如果不存在这样的字符串 s ，请返回一个空字符串 """"。
  示例 1：
输入：a = 1, b = 1, c = 7
输出：""ccaccbcc""
解释：""ccbccacc"" 也是一种正确答案。
示例 2：
输入：a = 2, b = 2, c = 1
输出：""aabbc""
示例 3：
输入：a = 7, b = 1, c = 0
输出：""aabaa""
解释：这是该测试用例的唯一正确答案。
  提示：
0 <= a, b, c <= 100
a + b + c > 0",196,,27335,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],42708
评论 (91),stone-game-iii,困难,"Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。
Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。
每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。
假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 ""Alice"" ，Bob 赢了就返回 ""Bob""，平局（分数相同）返回 ""Tie"" 。
  示例 1：
输入：values = [1,2,3,7]
输出：""Bob""
解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。
示例 2：
输入：values = [1,2,3,-9]
输出：""Alice""
解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。
如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。
如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。
注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。
示例 3：
输入：values = [1,2,3,6]
输出：""Tie""
解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。
示例 4：
输入：values = [1,2,3,-1,-2,-3,7]
输出：""Alice""
示例 5：
输入：values = [-1,-2,-3]
输出：""Tie""
  提示：
1 <= values.length <= 50000
-1000 <= values[i] <= 1000",94,,6163,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",[],10552
评论 (120),top-travellers,简单,"SQL架构
表：Users
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| name          | varchar |
+---------------+---------+
id 是该表单主键。
name 是用户名字。
  表：Rides
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| user_id       | int     |
| distance      | int     |
+---------------+---------+
id 是该表单主键。
user_id 是本次行程的用户的 id, 而该用户此次行程距离为 distance 。
  写一段 SQL , 报告每个用户的旅行距离。
返回的结果表单，以 travelled_distance 降序排列 ，如果有两个或者更多的用户旅行了相同的距离, 那么再以 name 升序排列 。
查询结果格式如下例所示。
Users 表：
+------+-----------+
| id   | name      |
+------+-----------+
| 1    | Alice     |
| 2    | Bob       |
| 3    | Alex      |
| 4    | Donald    |
| 7    | Lee       |
| 13   | Jonathan  |
| 19   | Elvis     |
+------+-----------+

Rides 表：
+------+----------+----------+
| id   | user_id  | distance |
+------+----------+----------+
| 1    | 1        | 120      |
| 2    | 2        | 317      |
| 3    | 3        | 222      |
| 4    | 7        | 100      |
| 5    | 13       | 312      |
| 6    | 19       | 50       |
| 7    | 7        | 120      |
| 8    | 19       | 400      |
| 9    | 7        | 230      |
+------+----------+----------+

Result 表：
+----------+--------------------+
| name     | travelled_distance |
+----------+--------------------+
| Elvis    | 450                |
| Lee      | 450                |
| Bob      | 317                |
| Jonathan | 312                |
| Alex     | 222                |
| Alice    | 120                |
| Donald   | 0                  |
+----------+--------------------+
Elvis 和 Lee 旅行了 450 英里，Elvis 是排名靠前的旅行者，因为他的名字在字母表上的排序比 Lee 更小。
Bob, Jonathan, Alex 和 Alice 只有一次行程，我们只按此次行程的全部距离对他们排序。
Donald 没有任何行程, 他的旅行距离为 0。",23,,12313,['https://leetcode.cn/tag/database/'],[],18253
评论 (127),string-matching-in-an-array,简单,"给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。
如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。
  示例 1：
输入：words = [""mass"",""as"",""hero"",""superhero""]
输出：[""as"",""hero""]
解释：""as"" 是 ""mass"" 的子字符串，""hero"" 是 ""superhero"" 的子字符串。
[""hero"",""as""] 也是有效的答案。
示例 2：
输入：words = [""leetcode"",""et"",""code""]
输出：[""et"",""code""]
解释：""et"" 和 ""code"" 都是 ""leetcode"" 的子字符串。
示例 3：
输入：words = [""blue"",""green"",""bu""]
输出：[]
  提示：
1 <= words.length <= 100
1 <= words[i].length <= 30
words[i] 仅包含小写英文字母。
题目数据 保证 每个 words[i] 都是独一无二的。",25,,16081,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/']",[],26013
评论 (100),queries-on-a-permutation-with-key,中等,"给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：
一开始，排列 P=[1,2,3,...,m]。
对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 queries[i] 的查询结果。
请你以数组形式返回待查数组  queries 的查询结果。
  示例 1：
输入：queries = [3,1,2,1], m = 5
输出：[2,1,2,1] 
解释：待查数组 queries 处理如下：
对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。
对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 
对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。
对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 
因此，返回的结果数组为 [2,1,2,1] 。  
示例 2：
输入：queries = [4,1,2,2], m = 4
输出：[3,1,2,0]
示例 3：
输入：queries = [7,5,5,8,3], m = 8
输出：[6,5,0,7,5]
  提示：
1 <= m <= 10^3
1 <= queries.length <= m
1 <= queries[i] <= m",38,,9373,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],11564
评论 (130),html-entity-parser,中等,"「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。
HTML 里这些特殊字符和它们对应的字符实体包括：
双引号：字符实体为 &quot; ，对应的字符是 "" 。
单引号：字符实体为 &apos; ，对应的字符是 ' 。
与符号：字符实体为 &amp; ，对应对的字符是 & 。
大于号：字符实体为 &gt; ，对应的字符是 > 。
小于号：字符实体为 &lt; ，对应的字符是 < 。
斜线号：字符实体为 &frasl; ，对应的字符是 / 。
给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。
  示例 1：
输入：text = ""&amp; is an HTML entity but &ambassador; is not.""
输出：""& is an HTML entity but &ambassador; is not.""
解释：解析器把字符实体 &amp; 用 & 替换
示例 2：
输入：text = ""and I quote: &quot;...&quot;""
输出：""and I quote: \""...\""""
示例 3：
输入：text = ""Stay home! Practice on Leetcode :)""
输出：""Stay home! Practice on Leetcode :)""
示例 4：
输入：text = ""x &gt; y &amp;&amp; x &lt; y is always false""
输出：""x > y && x < y is always false""
示例 5：
输入：text = ""leetcode.com&frasl;problemset&frasl;all""
输出：""leetcode.com/problemset/all""
  提示：
1 <= text.length <= 10^5
字符串可能包含 256 个ASCII 字符中的任意字符。",18,,8240,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],17298
评论 (127),number-of-ways-to-paint-n-3-grid,困难,"你有一个 n x 3 的网格图 grid ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。
给你网格图的行数 n 。
请你返回给 grid 涂色的方案数。由于答案可能会非常大，请你返回答案对 10^9 + 7 取余的结果。
  示例 1：
输入：n = 1
输出：12
解释：总共有 12 种可行的方法：
示例 2：
输入：n = 2
输出：54
示例 3：
输入：n = 3
输出：246
示例 4：
输入：n = 7
输出：106494
示例 5：
输入：n = 5000
输出：30228214
  提示：
n == grid.length
grid[i].length == 3
1 <= n <= 5000",105,,8721,['https://leetcode.cn/tag/dynamic-programming/'],[],15651
评论 (140),find-the-quiet-students-in-all-exams,Unknown,,-1,,-1,[],[],-1
评论 (148),minimum-value-to-get-positive-step-by-step-sum,简单,"给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。
你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。
请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。
  示例 1：
输入：nums = [-3,2,-3,4,2]
输出：5
解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。
                累加求和
                startValue = 4 | startValue = 5 | nums
                  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
                  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
                  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
                  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
                  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
示例 2：
输入：nums = [1,2]
输出：1
解释：最小的 startValue 需要是正数。
示例 3：
输入：nums = [1,-2,-3]
输出：5
  提示：
1 <= nums.length <= 100
-100 <= nums[i] <= 100",35,,13976,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],20089
评论 (357),find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k,中等,"给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。
斐波那契数字定义为：
F1 = 1
F2 = 1
Fn = Fn-1 + Fn-2 ， 其中 n > 2 。
数据保证对于给定的 k ，一定能找到可行解。
  示例 1：
输入：k = 7
输出：2 
解释：斐波那契数字为：1，1，2，3，5，8，13，……
对于 k = 7 ，我们可以得到 2 + 5 = 7 。
示例 2：
输入：k = 10
输出：2 
解释：对于 k = 10 ，我们可以得到 2 + 8 = 10 。
示例 3：
输入：k = 19
输出：3 
解释：对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。
  提示：
1 <= k <= 10^9",142,,28469,['https://leetcode.cn/tag/greedy/'],[],40330
评论 (92),the-k-th-lexicographical-string-of-all-happy-strings-of-length-n,中等,"一个 「开心字符串」定义为：
仅包含小写字母 ['a', 'b', 'c'].
对所有在 1 到 s.length - 1 之间的 i ，满足 s[i] != s[i + 1] （字符串的下标从 1 开始）。
比方说，字符串 ""abc""，""ac""，""b"" 和 ""abcbabcbcb"" 都是开心字符串，但是 ""aa""，""baa"" 和 ""ababbc"" 都不是开心字符串。
给你两个整数 n 和 k ，你需要将长度为 n 的所有开心字符串按字典序排序。
请你返回排序后的第 k 个开心字符串，如果长度为 n 的开心字符串少于 k 个，那么请你返回 空字符串 。
  示例 1：
输入：n = 1, k = 3
输出：""c""
解释：列表 [""a"", ""b"", ""c""] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 ""c"" 。
示例 2：
输入：n = 1, k = 4
输出：""""
解释：长度为 1 的开心字符串只有 3 个。
示例 3：
输入：n = 3, k = 9
输出：""cab""
解释：长度为 3 的开心字符串总共有 12 个 [""aba"", ""abc"", ""aca"", ""acb"", ""bab"", ""bac"", ""bca"", ""bcb"", ""cab"", ""cac"", ""cba"", ""cbc""] 。第 9 个字符串为 ""cab""
示例 4：
输入：n = 2, k = 7
输出：""""
示例 5：
输入：n = 10, k = 100
输出：""abacbabacb""
  提示：
1 <= n <= 10
1 <= k <= 100
 ",35,,7608,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],11098
评论 (37),restore-the-array,困难,"某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。
给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。
按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。
由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。
  示例 1：
输入：s = ""1000"", k = 10000
输出：1
解释：唯一一种可能的数组方案是 [1000]
示例 2：
输入：s = ""1000"", k = 10
输出：0
解释：不存在任何数组方案满足所有整数都 >= 1 且 <= 10 同时输出结果为 s 。
示例 3：
输入：s = ""1317"", k = 2000
输出：8
解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]
示例 4：
输入：s = ""2020"", k = 30
输出：1
解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 > 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。
示例 5：
输入：s = ""1234567890"", k = 90
输出：34
  提示：
1 <= s.length <= 10^5.
s 只包含数字且不包含前导 0 。
1 <= k <= 10^9.",45,,3224,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],7757
评论 (125),reformat-the-string,简单,"给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。
请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。
请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。
  示例 1：
输入：s = ""a0b1c2""
输出：""0a1b2c""
解释：""0a1b2c"" 中任意两个相邻字符的类型都不同。 ""a0b1c2"", ""0a1b2c"", ""0c2a1b"" 也是满足题目要求的答案。
示例 2：
输入：s = ""leetcode""
输出：""""
解释：""leetcode"" 中只有字母，所以无法满足重新格式化的条件。
示例 3：
输入：s = ""1229857369""
输出：""""
解释：""1229857369"" 中只有数字，所以无法满足重新格式化的条件。
示例 4：
输入：s = ""covid2019""
输出：""c2o0v1i9d""
示例 5：
输入：s = ""ab123""
输出：""1a2b3""
  提示：
1 <= s.length <= 500
s 仅由小写英文字母和/或数字组成。",21,,14910,['https://leetcode.cn/tag/string/'],[],28633
评论 (391),display-table-of-food-orders-in-a-restaurant,中等,"给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。
请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。
注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。
  示例 1：
输入：orders = [[""David"",""3"",""Ceviche""],[""Corina"",""10"",""Beef Burrito""],[""David"",""3"",""Fried Chicken""],[""Carla"",""5"",""Water""],[""Carla"",""5"",""Ceviche""],[""Rous"",""3"",""Ceviche""]]
输出：[[""Table"",""Beef Burrito"",""Ceviche"",""Fried Chicken"",""Water""],[""3"",""0"",""2"",""1"",""0""],[""5"",""0"",""1"",""0"",""1""],[""10"",""1"",""0"",""0"",""0""]] 
解释：
点菜展示表如下所示：
Table,Beef Burrito,Ceviche,Fried Chicken,Water
3    ,0           ,2      ,1            ,0
5    ,0           ,1      ,0            ,1
10   ,1           ,0      ,0            ,0
对于餐桌 3：David 点了 ""Ceviche"" 和 ""Fried Chicken""，而 Rous 点了 ""Ceviche""
而餐桌 5：Carla 点了 ""Water"" 和 ""Ceviche""
餐桌 10：Corina 点了 ""Beef Burrito"" 
示例 2：
输入：orders = [[""James"",""12"",""Fried Chicken""],[""Ratesh"",""12"",""Fried Chicken""],[""Amadeus"",""12"",""Fried Chicken""],[""Adam"",""1"",""Canadian Waffles""],[""Brianna"",""1"",""Canadian Waffles""]]
输出：[[""Table"",""Canadian Waffles"",""Fried Chicken""],[""1"",""2"",""0""],[""12"",""0"",""3""]] 
解释：
对于餐桌 1：Adam 和 Brianna 都点了 ""Canadian Waffles""
而餐桌 12：James, Ratesh 和 Amadeus 都点了 ""Fried Chicken""
示例 3：
输入：orders = [[""Laura"",""2"",""Bean Burrito""],[""Jhon"",""2"",""Beef Burrito""],[""Melissa"",""2"",""Soda""]]
输出：[[""Table"",""Bean Burrito"",""Beef Burrito"",""Soda""],[""2"",""1"",""1"",""1""]]
  提示：
1 <= orders.length <= 5 * 10^4
orders[i].length == 3
1 <= customerNamei.length, foodItemi.length <= 20
customerNamei 和 foodItemi 由大小写英文字母及空格字符 ' ' 组成。
tableNumberi 是 1 到 500 范围内的整数。",82,,27225,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/sorting/']",[],37234
评论 (133),minimum-number-of-frogs-croaking,中等,"给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 ""croak"" ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 croakOfFrogs 中会混合多个 “croak” 。
请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。
要想发出蛙鸣 ""croak""，青蛙必须 依序 输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。如果字符串 croakOfFrogs 不是由若干有效的 ""croak"" 字符混合而成，请返回 -1 。
  示例 1：
输入：croakOfFrogs = ""croakcroak""
输出：1 
解释：一只青蛙 “呱呱” 两次
示例 2：
输入：croakOfFrogs = ""crcoakroak""
输出：2 
解释：最少需要两只青蛙，“呱呱” 声用黑体标注
第一只青蛙 ""crcoakroak""
第二只青蛙 ""crcoakroak""
示例 3：
输入：croakOfFrogs = ""croakcrook""
输出：-1
解释：给出的字符串不是 ""croak"" 的有效组合。
  提示：
1 <= croakOfFrogs.length <= 105
字符串中的字符只有 'c', 'r', 'o', 'a' 或者 'k'",76,,9074,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],21256
评论 (37),build-array-where-you-can-find-the-maximum-exactly-k-comparisons,困难,"给你三个整数 n、m 和 k 。下图描述的算法用于找出正整数数组中最大的元素。
请你生成一个具有下述属性的数组 arr ：
arr 中有 n 个整数。
1 <= arr[i] <= m 其中 (0 <= i < n) 。
将上面提到的算法应用于 arr ，search_cost 的值等于 k 。
返回上述条件下生成数组 arr 的 方法数 ，由于答案可能会很大，所以 必须 对 10^9 + 7 取余。
  示例 1：
输入：n = 2, m = 3, k = 1
输出：6
解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]
示例 2：
输入：n = 5, m = 2, k = 3
输出：0
解释：没有数组可以满足上述条件
示例 3：
输入：n = 9, m = 1, k = 1
输出：1
解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]
示例 4：
输入：n = 50, m = 100, k = 25
输出：34549172
解释：不要忘了对 1000000007 取余
示例 5：
输入：n = 37, m = 17, k = 7
输出：418930126
  提示：
1 <= n <= 50
1 <= m <= 100
0 <= k <= n",69,,2852,['https://leetcode.cn/tag/dynamic-programming/'],[],4647
评论 (77),npv-queries,Unknown,,-1,,-1,[],[],-1
评论 (118),maximum-score-after-splitting-a-string,简单,"给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。
「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。
  示例 1：
输入：s = ""011101""
输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = ""0"" 且 右子字符串 = ""11101""，得分 = 1 + 4 = 5 
左子字符串 = ""01"" 且 右子字符串 = ""1101""，得分 = 1 + 3 = 4 
左子字符串 = ""011"" 且 右子字符串 = ""101""，得分 = 1 + 2 = 3 
左子字符串 = ""0111"" 且 右子字符串 = ""01""，得分 = 1 + 1 = 2 
左子字符串 = ""01110"" 且 右子字符串 = ""1""，得分 = 2 + 1 = 3
示例 2：
输入：s = ""00111""
输出：5
解释：当 左子字符串 = ""00"" 且 右子字符串 = ""111"" 时，我们得到最大得分 = 2 + 3 = 5
示例 3：
输入：s = ""1111""
输出：3
  提示：
2 <= s.length <= 500
字符串 s 仅由字符 '0' 和 '1' 组成。",33,,12517,['https://leetcode.cn/tag/string/'],[],23098
评论 (461),maximum-points-you-can-obtain-from-cards,中等,"几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。
每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。
你的点数就是你拿到手中的所有卡牌的点数之和。
给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。
  示例 1：
输入：cardPoints = [1,2,3,4,5,6,1], k = 3
输出：12
解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。
示例 2：
输入：cardPoints = [2,2,2], k = 2
输出：4
解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。
示例 3：
输入：cardPoints = [9,7,7,9,7,7,9], k = 7
输出：55
解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。
示例 4：
输入：cardPoints = [1,1000,1], k = 1
输出：1
解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 
示例 5：
输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3
输出：202
  提示：
1 <= cardPoints.length <= 10^5
1 <= cardPoints[i] <= 10^4
1 <= k <= cardPoints.length",231,,40649,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",[],73234
评论 (142),diagonal-traverse-ii,中等,"给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。
  示例 1：
输入：nums = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,4,2,7,5,3,8,6,9]
示例 2：
输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
示例 3：
输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
输出：[1,4,2,5,3,8,6,9,7,10,11]
示例 4：
输入：nums = [[1,2,3,4,5,6]]
输出：[1,2,3,4,5,6]
  提示：
1 <= nums.length <= 10^5
1 <= nums[i].length <= 10^5
1 <= nums[i][j] <= 10^9
nums 中最多有 10^5 个数字。",63,,8288,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],20164
评论 (60),constrained-subsequence-sum,困难,"给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i < j 且 j - i <= k 。
数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。
  示例 1：
输入：nums = [10,2,-10,5,20], k = 2
输出：37
解释：子序列为 [10, 2, 5, 20] 。
示例 2：
输入：nums = [-1,-2,-3], k = 1
输出：-1
解释：子序列必须是非空的，所以我们选择最大的数字。
示例 3：
输入：nums = [10,-2,-10,-5,20], k = 2
输出：23
解释：子序列为 [10, -2, -5, 20] 。
  提示：
1 <= k <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4",98,,4295,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/monotonic-queue/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],9388
评论 (30),counting-elements,Unknown,,-1,,-1,[],[],-1
评论 (50),perform-string-shifts,Unknown,,-1,,-1,[],[],-1
评论 (19),leftmost-column-with-at-least-a-one,Unknown,,-1,,-1,[],[],-1
评论 (23),first-unique-number,Unknown,,-1,,-1,[],[],-1
评论 (17),check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (546),kids-with-the-greatest-number-of-candies,简单,"给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。
对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。
  示例 1：
输入：candies = [2,3,5,1,3], extraCandies = 3
输出：[true,true,true,false,true] 
解释：
孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
示例 2：
输入：candies = [4,2,1,1,2], extraCandies = 1
输出：[true,false,false,false,false] 
解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。
示例 3：
输入：candies = [12,1,12], extraCandies = 10
输出：[true,false,true]
  提示：
2 <= candies.length <= 100
1 <= candies[i] <= 100
1 <= extraCandies <= 50",129,,82969,['https://leetcode.cn/tag/array/'],[],98142
评论 (65),max-difference-you-can-get-from-changing-an-integer,中等,"给你一个整数 num 。你可以对它进行如下步骤恰好 两次 ：
选择一个数字 x (0 <= x <= 9).
选择另一个数字 y (0 <= y <= 9) 。数字 y 可以等于 x 。
将 num 中所有出现 x 的数位都用 y 替换。
得到的新的整数 不能 有前导 0 ，得到的新整数也 不能 是 0 。
令两次对 num 的操作得到的结果分别为 a 和 b 。
请你返回 a 和 b 的 最大差值 。
  示例 1：
输入：num = 555
输出：888
解释：第一次选择 x = 5 且 y = 9 ，并把得到的新数字保存在 a 中。
第二次选择 x = 5 且 y = 1 ，并把得到的新数字保存在 b 中。
现在，我们有 a = 999 和 b = 111 ，最大差值为 888
示例 2：
输入：num = 9
输出：8
解释：第一次选择 x = 9 且 y = 9 ，并把得到的新数字保存在 a 中。
第二次选择 x = 9 且 y = 1 ，并把得到的新数字保存在 b 中。
现在，我们有 a = 9 和 b = 1 ，最大差值为 8
示例 3：
输入：num = 123456
输出：820000
示例 4：
输入：num = 10000
输出：80000
示例 5：
输入：num = 9288
输出：8700
  提示：
1 <= num <= 10^8",19,,5198,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/']",[],13115
评论 (82),check-if-a-string-can-break-another-string,中等,"给你两个字符串 s1 和 s2 ，它们长度相等，请你检查是否存在一个 s1  的排列可以打破 s2 的一个排列，或者是否存在一个 s2 的排列可以打破 s1 的一个排列。
字符串 x 可以打破字符串 y （两者长度都为 n ）需满足对于所有 i（在 0 到 n - 1 之间）都有 x[i] >= y[i]（字典序意义下的顺序）。
  示例 1：
输入：s1 = ""abc"", s2 = ""xya""
输出：true
解释：""ayx"" 是 s2=""xya"" 的一个排列，""abc"" 是字符串 s1=""abc"" 的一个排列，且 ""ayx"" 可以打破 ""abc"" 。
示例 2：
输入：s1 = ""abe"", s2 = ""acd""
输出：false 
解释：s1=""abe"" 的所有排列包括：""abe""，""aeb""，""bae""，""bea""，""eab"" 和 ""eba"" ，s2=""acd"" 的所有排列包括：""acd""，""adc""，""cad""，""cda""，""dac"" 和 ""dca""。然而没有任何 s1 的排列可以打破 s2 的排列。也没有 s2 的排列能打破 s1 的排列。
示例 3：
输入：s1 = ""leetcodee"", s2 = ""interview""
输出：true
  提示：
s1.length == n
s2.length == n
1 <= n <= 10^5
所有字符串都只包含小写英文字母。",24,,6911,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],10779
评论 (64),number-of-ways-to-wear-different-hats-to-each-other,困难,"总共有 n 个人和 40 种不同的帽子，帽子编号从 1 到 40 。
给你一个整数列表的列表 hats ，其中 hats[i] 是第 i 个人所有喜欢帽子的列表。
请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。
由于答案可能很大，请返回它对 10^9 + 7 取余后的结果。
  示例 1：
输入：hats = [[3,4],[4,5],[5]]
输出：1
解释：给定条件下只有一种方法选择帽子。
第一个人选择帽子 3，第二个人选择帽子 4，最后一个人选择帽子 5。
示例 2：
输入：hats = [[3,5,1],[3,5]]
输出：4
解释：总共有 4 种安排帽子的方法：
(3,5)，(5,3)，(1,3) 和 (1,5)
示例 3：
输入：hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
输出：24
解释：每个人都可以从编号为 1 到 4 的帽子中选。
(1,2,3,4) 4 个帽子的排列方案数为 24 。
示例 4：
输入：hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
输出：111
  提示：
n == hats.length
1 <= n <= 10
1 <= hats[i].length <= 40
1 <= hats[i][j] <= 40
hats[i] 包含一个数字互不相同的整数列表。",81,,3124,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],6408
评论 (95),create-a-session-bar-chart,Unknown,,-1,,-1,[],[],-1
评论 (422),destination-city,简单,"给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。
题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。
  示例 1：
输入：paths = [[""London"",""New York""],[""New York"",""Lima""],[""Lima"",""Sao Paulo""]]
输出：""Sao Paulo"" 
解释：从 ""London"" 出发，最后抵达终点站 ""Sao Paulo"" 。本次旅行的路线是 ""London"" -> ""New York"" -> ""Lima"" -> ""Sao Paulo"" 。
示例 2：
输入：paths = [[""B"",""C""],[""D"",""B""],[""C"",""A""]]
输出：""A""
解释：所有可能的线路是：
""D"" -> ""B"" -> ""C"" -> ""A"". 
""B"" -> ""C"" -> ""A"". 
""C"" -> ""A"". 
""A"". 
显然，旅行终点站是 ""A"" 。
示例 3：
输入：paths = [[""A"",""Z""]]
输出：""Z""
  提示：
1 <= paths.length <= 100
paths[i].length == 2
1 <= cityAi.length, cityBi.length <= 10
cityAi != cityBi
所有字符串均由大小写英文字母和空格字符组成。",116,,48698,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],59364
评论 (118),check-if-all-1s-are-at-least-length-k-places-away,简单,"给你一个由若干 0 和 1 组成的数组 nums 以及整数 k。如果所有 1 都至少相隔 k 个元素，则返回 True ；否则，返回 False 。
  示例 1：
输入：nums = [1,0,0,0,1,0,0,1], k = 2
输出：true
解释：每个 1 都至少相隔 2 个元素。
示例 2：
输入：nums = [1,0,0,1,0,1], k = 2
输出：false
解释：第二个 1 和第三个 1 之间只隔了 1 个元素。
示例 3：
输入：nums = [1,1,1,1,1], k = 0
输出：true
示例 4：
输入：nums = [0,1,0,1], k = 1
输出：true
  提示：
1 <= nums.length <= 10^5
0 <= k <= nums.length
nums[i] 的值为 0 或 1",21,,12780,['https://leetcode.cn/tag/array/'],[],22153
评论 (379),longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit,中等,"给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。
如果不存在满足条件的子数组，则返回 0 。
  示例 1：
输入：nums = [8,2,4,7], limit = 4
输出：2 
解释：所有子数组如下：
[8] 最大绝对差 |8-8| = 0 <= 4.
[8,2] 最大绝对差 |8-2| = 6 > 4. 
[8,2,4] 最大绝对差 |8-2| = 6 > 4.
[8,2,4,7] 最大绝对差 |8-2| = 6 > 4.
[2] 最大绝对差 |2-2| = 0 <= 4.
[2,4] 最大绝对差 |2-4| = 2 <= 4.
[2,4,7] 最大绝对差 |2-7| = 5 > 4.
[4] 最大绝对差 |4-4| = 0 <= 4.
[4,7] 最大绝对差 |4-7| = 3 <= 4.
[7] 最大绝对差 |7-7| = 0 <= 4. 
因此，满足题意的最长子数组的长度为 2 。
示例 2：
输入：nums = [10,1,2,4,7,2], limit = 5
输出：4 
解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。
示例 3：
输入：nums = [4,2,2,2,4,4,2,2], limit = 0
输出：3
  提示：
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9
0 <= limit <= 10^9",244,,37990,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/monotonic-queue/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],77801
评论 (82),find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows,困难,"给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。
你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和。
  示例 1：
输入：mat = [[1,3,11],[2,4,6]], k = 5
输出：7
解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：
[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  
示例 2：
输入：mat = [[1,3,11],[2,4,6]], k = 9
输出：17
示例 3：
输入：mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
输出：9
解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 
示例 4：
输入：mat = [[1,1,10],[2,2,9]], k = 7
输出：12
  提示：
m == mat.length
n == mat.length[i]
1 <= m, n <= 40
1 <= k <= min(200, n ^ m)
1 <= mat[i][j] <= 5000
mat[i] 是一个非递减数组",92,,6183,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],11086
评论 (91),evaluate-boolean-expression,Unknown,,-1,,-1,[],[],-1
评论 (214),build-an-array-with-stack-operations,简单,"给你一个目标数组 target 和一个整数 n。每次迭代，需要从  list = {1,2,3..., n} 中依序读取一个数字。
请使用下述操作来构建目标数组 target ：
Push：从 list 中读取一个新元素， 并将其推入数组中。
Pop：删除数组中的最后一个元素。
如果目标数组构建完成，就停止读取更多元素。
题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。
请返回构建目标数组所用的操作序列。
题目数据保证答案是唯一的。
  示例 1：
输入：target = [1,3], n = 3
输出：[""Push"",""Push"",""Pop"",""Push""]
解释： 
读取 1 并自动推入数组 -> [1]
读取 2 并自动推入数组，然后删除它 -> [1]
读取 3 并自动推入数组 -> [1,3]
示例 2：
输入：target = [1,2,3], n = 3
输出：[""Push"",""Push"",""Push""]
示例 3：
输入：target = [1,2], n = 4
输出：[""Push"",""Push""]
解释：只需要读取前 2 个数字就可以停止。
  提示：
1 <= target.length <= 100
1 <= target[i] <= 100
1 <= n <= 100
target 是严格递增的",41,,21230,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],32653
评论 (237),count-triplets-that-can-form-two-arrays-of-equal-xor,中等,"给你一个整数数组 arr 。
现需要从数组中取三个下标 i、j 和 k ，其中 (0 <= i < j <= k < arr.length) 。
a 和 b 定义如下：
a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
注意：^ 表示 按位异或 操作。
请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。
  示例 1：
输入：arr = [2,3,1,6,7]
输出：4
解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)
示例 2：
输入：arr = [1,1,1,1,1]
输出：10
示例 3：
输入：arr = [2,3]
输出：0
示例 4：
输入：arr = [1,3,5,7,9]
输出：3
示例 5：
输入：arr = [7,11,12,9,5,2,7,17,22]
输出：8
  提示：
1 <= arr.length <= 300
1 <= arr[i] <= 10^8",204,,36514,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/prefix-sum/']",[],46131
评论 (160),minimum-time-to-collect-all-apples-in-a-tree,中等,"给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 节点 0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。
无向树的边由 edges 给出，其中 edges[i] = [fromi, toi] ，表示有一条边连接 from 和 toi 。除此以外，还有一个布尔数组 hasApple ，其中 hasApple[i] = true 代表节点 i 有一个苹果，否则，节点 i 没有苹果。
  示例 1：
输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
输出：8 
解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。
示例 2：
输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
输出：6
解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。
示例 3：
输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
输出：0
  提示：
1 <= n <= 10^5
edges.length == n-1
edges[i].length == 2
0 <= fromi, toi <= n-1
fromi < toi
hasApple.length == n",65,,6481,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/hash-table/']",[],15504
评论 (42),number-of-ways-of-cutting-a-pizza,困难,"给你一个 rows x cols 大小的矩形披萨和一个整数 k ，矩形包含两种字符： 'A' （表示苹果）和 '.' （表示空白格子）。你需要切披萨 k-1 次，得到 k 块披萨并送给别人。
切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。
请你返回确保每一块披萨包含 至少 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。
  示例 1：
输入：pizza = [""A.."",""AAA"",""...""], k = 3
输出：3 
解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。
示例 2：
输入：pizza = [""A.."",""AA."",""...""], k = 3
输出：1
示例 3：
输入：pizza = [""A.."",""A.."",""...""], k = 1
输出：1
  提示：
1 <= rows, cols <= 50
rows == pizza.length
cols == pizza[i].length
1 <= k <= 10
pizza 只包含字符 'A' 和 '.' 。",56,,3159,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],5905
评论 (113),apples-oranges,Unknown,,-1,,-1,[],[],-1
评论 (474),consecutive-characters,简单,"给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。
请你返回字符串 s 的 能量。
  示例 1：
输入：s = ""leetcode""
输出：2
解释：子字符串 ""ee"" 长度为 2 ，只包含字符 'e' 。
示例 2：
输入：s = ""abbcccddddeeeeedcba""
输出：5
解释：子字符串 ""eeeee"" 长度为 5 ，只包含字符 'e' 。
  提示：
1 <= s.length <= 500
s 只包含小写英文字母。",98,,53676,['https://leetcode.cn/tag/string/'],[],87997
评论 (332),simplified-fractions,中等,"给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。
  示例 1：
输入：n = 2
输出：[""1/2""]
解释：""1/2"" 是唯一一个分母小于等于 2 的最简分数。
示例 2：
输入：n = 3
输出：[""1/2"",""1/3"",""2/3""]
示例 3：
输入：n = 4
输出：[""1/2"",""1/3"",""1/4"",""2/3"",""3/4""]
解释：""2/4"" 不是最简分数，因为它可以化简为 ""1/2"" 。
示例 4：
输入：n = 1
输出：[]
  提示：
1 <= n <= 100",84,,39703,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/number-theory/']",[],58592
评论 (148),count-good-nodes-in-binary-tree,中等,"给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。
「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。
  示例 1：
输入：root = [3,1,4,3,null,1,5]
输出：4
解释：图中蓝色节点为好节点。
根节点 (3) 永远是个好节点。
节点 4 -> (3,4) 是路径中的最大值。
节点 5 -> (3,4,5) 是路径中的最大值。
节点 3 -> (3,1,3) 是路径中的最大值。
示例 2：
输入：root = [3,3,null,4,2]
输出：3
解释：节点 2 -> (3, 3, 2) 不是好节点，因为 ""3"" 比它大。
示例 3：
输入：root = [1]
输出：1
解释：根节点是好节点。
  提示：
二叉树中节点数目范围是 [1, 10^5] 。
每个节点权值的范围是 [-10^4, 10^4] 。",54,,14134,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],19692
评论 (185),form-largest-integer-with-digits-that-add-up-to-target,困难,"给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：
给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。
总成本必须恰好等于 target 。
添加的数位中没有数字 0 。
由于答案可能会很大，请你以字符串形式返回。
如果按照上述要求无法得到任何整数，请你返回 ""0"" 。
  示例 1：
输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
输出：""7772""
解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 ""7772"" 的代价为 2*3+ 3*1 = 9 。 ""977"" 也是满足要求的数字，但 ""7772"" 是较大的数字。
 数字     成本
  1  ->   4
  2  ->   3
  3  ->   2
  4  ->   5
  5  ->   6
  6  ->   7
  7  ->   2
  8  ->   5
  9  ->   5
示例 2：
输入：cost = [7,6,5,5,5,6,8,7,8], target = 12
输出：""85""
解释：添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。""85"" 的成本为 7 + 5 = 12 。
示例 3：
输入：cost = [2,4,6,2,4,6,4,4,4], target = 5
输出：""0""
解释：总成本是 target 的条件下，无法生成任何整数。
示例 4：
输入：cost = [6,10,15,40,40,40,40,40,40], target = 47
输出：""32211""
  提示：
cost.length == 9
1 <= cost[i] <= 5000
1 <= target <= 5000",145,,17609,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],28150
评论 (153),number-of-students-doing-homework-at-a-given-time,简单,"给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。
已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。
请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。
  示例 1：
输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
输出：1
解释：一共有 3 名学生。
第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。
第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。
第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。
示例 2：
输入：startTime = [4], endTime = [4], queryTime = 4
输出：1
解释：在查询时间只有一名学生在做作业。
示例 3：
输入：startTime = [4], endTime = [4], queryTime = 5
输出：0
示例 4：
输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7
输出：0
示例 5：
输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5
输出：5
  提示：
startTime.length == endTime.length
1 <= startTime.length <= 100
1 <= startTime[i] <= endTime[i] <= 1000
1 <= queryTime <= 1000",24,,26643,['https://leetcode.cn/tag/array/'],[],33134
评论 (147),rearrange-words-in-a-sentence,中等,"「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子 text :
句子的首字母大写
text 中的每个单词都用单个空格分隔。
请你重新排列 text 中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。
请同样按上述格式返回新的句子。
  示例 1：
输入：text = ""Leetcode is cool""
输出：""Is cool leetcode""
解释：句子中共有 3 个单词，长度为 8 的 ""Leetcode"" ，长度为 2 的 ""is"" 以及长度为 4 的 ""cool"" 。
输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。
示例 2：
输入：text = ""Keep calm and code on""
输出：""On and keep calm code""
解释：输出的排序情况如下：
""On"" 2 个字母。
""and"" 3 个字母。
""keep"" 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。
""calm"" 4 个字母。
""code"" 4 个字母。
示例 3：
输入：text = ""To be or not to be""
输出：""To be or to be not""
  提示：
text 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。
1 <= text.length <= 10^5",29,,11624,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],21874
评论 (83),people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list,中等,"给你一个数组 favoriteCompanies ，其中 favoriteCompanies[i] 是第 i 名用户收藏的公司清单（下标从 0 开始）。
请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标。下标需要按升序排列。
  示例 1：
输入：favoriteCompanies = [[""leetcode"",""google"",""facebook""],[""google"",""microsoft""],[""google"",""facebook""],[""google""],[""amazon""]]
输出：[0,1,4] 
解释：
favoriteCompanies[2]=[""google"",""facebook""] 是 favoriteCompanies[0]=[""leetcode"",""google"",""facebook""] 的子集。
favoriteCompanies[3]=[""google""] 是 favoriteCompanies[0]=[""leetcode"",""google"",""facebook""] 和 favoriteCompanies[1]=[""google"",""microsoft""] 的子集。
其余的收藏清单均不是其他任何人收藏的公司清单的子集，因此，答案为 [0,1,4] 。
示例 2：
输入：favoriteCompanies = [[""leetcode"",""google"",""facebook""],[""leetcode"",""amazon""],[""facebook"",""google""]]
输出：[0,1] 
解释：favoriteCompanies[2]=[""facebook"",""google""] 是 favoriteCompanies[0]=[""leetcode"",""google"",""facebook""] 的子集，因此，答案为 [0,1] 。
示例 3：
输入：favoriteCompanies = [[""leetcode""],[""google""],[""facebook""],[""amazon""]]
输出：[0,1,2,3]
  提示：
1 <= favoriteCompanies.length <= 100
1 <= favoriteCompanies[i].length <= 500
1 <= favoriteCompanies[i][j].length <= 20
favoriteCompanies[i] 中的所有字符串 各不相同 。
用户收藏的公司清单也 各不相同 ，也就是说，即便我们按字母顺序排序每个清单， favoriteCompanies[i] != favoriteCompanies[j] 仍然成立。
所有字符串仅包含小写英文字母。",27,,6777,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],13350
评论 (63),maximum-number-of-darts-inside-of-a-circular-dartboard,困难,"墙壁上挂着一个圆形的飞镖靶。现在请你蒙着眼睛向靶上投掷飞镖。
投掷到墙上的飞镖用二维平面上的点坐标数组表示。飞镖靶的半径为 r 。
请返回能够落在 任意 半径为 r 的圆形靶内或靶上的最大飞镖数。
  示例 1：
输入：points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2
输出：4
解释：如果圆形的飞镖靶的圆心为 (0,0) ，半径为 2 ，所有的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 4 。
示例 2：
输入：points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5
输出：5
解释：如果圆形的飞镖靶的圆心为 (0,4) ，半径为 5 ，则除了 (7,8) 之外的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 5 。
示例 3：
输入：points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1
输出：1
示例 4：
输入：points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2
输出：4
  提示：
1 <= points.length <= 100
points[i].length == 2
-10^4 <= points[i][0], points[i][1] <= 10^4
1 <= r <= 5000",29,,1877,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],5029
评论 (146),active-users,Unknown,,-1,,-1,[],[],-1
评论 (125),check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence,简单,"给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。
如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。如果 searchWord 不是任何单词的前缀，则返回 -1 。
字符串 s 的 前缀 是 s 的任何前导连续子字符串。
  示例 1：
输入：sentence = ""i love eating burger"", searchWord = ""burg""
输出：4
解释：""burg"" 是 ""burger"" 的前缀，而 ""burger"" 是句子中第 4 个单词。
示例 2：
输入：sentence = ""this problem is an easy problem"", searchWord = ""pro""
输出：2
解释：""pro"" 是 ""problem"" 的前缀，而 ""problem"" 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。
示例 3：
输入：sentence = ""i am tired"", searchWord = ""you""
输出：-1
解释：""you"" 不是句子中任何单词的前缀。
  提示：
1 <= sentence.length <= 100
1 <= searchWord.length <= 10
sentence 由小写英文字母和空格组成。
searchWord 由小写英文字母组成。",25,,14237,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/']",[],22716
评论 (152),maximum-number-of-vowels-in-a-substring-of-given-length,中等,"给你字符串 s 和整数 k 。
请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。
英文中的 元音字母 为（a, e, i, o, u）。
  示例 1：
输入：s = ""abciiidef"", k = 3
输出：3
解释：子字符串 ""iii"" 包含 3 个元音字母。
示例 2：
输入：s = ""aeiou"", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。
示例 3：
输入：s = ""leetcode"", k = 3
输出：2
解释：""lee""、""eet"" 和 ""ode"" 都包含 2 个元音字母。
示例 4：
输入：s = ""rhythms"", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。
示例 5：
输入：s = ""tryhard"", k = 4
输出：1
  提示：
1 <= s.length <= 10^5
s 由小写英文字母组成
1 <= k <= s.length",46,,19104,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],36023
评论 (122),pseudo-palindromic-paths-in-a-binary-tree,中等,"给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。
请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。
  示例 1：
输入：root = [2,3,1,3,1,null,1]
输出：2 
解释：上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。
     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。
示例 2：
输入：root = [2,1,1,1,3,null,null,null,null,null,1]
输出：1 
解释：上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。
     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。
示例 3：
输入：root = [9]
输出：1
  提示：
给定二叉树的节点数目在范围 [1, 105] 内
1 <= Node.val <= 9",46,,9163,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],14654
评论 (76),max-dot-product-of-two-subsequences,困难,"给你两个数组 nums1 和 nums2 。
请你返回 nums1 和 nums2 中两个长度相同的 非空 子序列的最大点积。
数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，[2,3,5] 是 [1,2,3,4,5] 的一个子序列而 [1,5,3] 不是。
  示例 1：
输入：nums1 = [2,1,-2,5], nums2 = [3,0,-6]
输出：18
解释：从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。
它们的点积为 (2*3 + (-2)*(-6)) = 18 。
示例 2：
输入：nums1 = [3,-2], nums2 = [2,-6,7]
输出：21
解释：从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。
它们的点积为 (3*7) = 21 。
示例 3：
输入：nums1 = [-1,-1], nums2 = [1,1]
输出：-1
解释：从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。
它们的点积为 -1 。
  提示：
1 <= nums1.length, nums2.length <= 500
-1000 <= nums1[i], nums2[i] <= 100
  点积：
定义 a = [a1, a2,…, an] 和 b = [b1, b2,…, bn] 的点积为：



这里的 Σ 指示总和符号。",69,,6275,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],13971
评论 (101),rectangles-area,Unknown,,-1,,-1,[],[],-1
评论 (193),make-two-arrays-equal-by-reversing-sub-arrays,简单,"给你两个长度相同的整数数组 target 和 arr 。每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。
如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。
  示例 1：
输入：target = [1,2,3,4], arr = [2,4,1,3]
输出：true
解释：你可以按照如下步骤使 arr 变成 target：
1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]
2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]
3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]
上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。
示例 2：
输入：target = [7], arr = [7]
输出：true
解释：arr 不需要做任何翻转已经与 target 相等。
示例 3：
输入：target = [3,7,9], arr = [3,7,11]
输出：false
解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。
  提示：
target.length == arr.length
1 <= target.length <= 1000
1 <= target[i] <= 1000
1 <= arr[i] <= 1000",35,,18180,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],24561
评论 (76),check-if-a-string-contains-all-binary-codes-of-size-k,中等,"给你一个二进制字符串 s 和一个整数 k 。如果所有长度为 k 的二进制字符串都是 s 的子串，请返回 true ，否则请返回 false 。
  示例 1：
输入：s = ""00110110"", k = 2
输出：true
解释：长度为 2 的二进制串包括 ""00""，""01""，""10"" 和 ""11""。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。
示例 2：
输入：s = ""0110"", k = 1
输出：true
解释：长度为 1 的二进制串包括 ""0"" 和 ""1""，显然它们都是 s 的子串。
示例 3：
输入：s = ""0110"", k = 2
输出：false
解释：长度为 2 的二进制串 ""00"" 没有出现在 s 中。
  提示：
1 <= s.length <= 5 * 105
s[i] 不是'0' 就是 '1'
1 <= k <= 20",42,,7156,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],14045
评论 (103),course-schedule-iv,中等,"你总共需要上 numCourses 门课，课程编号依次为 0 到 numCourses-1 。你会得到一个数组 prerequisite ，其中 prerequisites[i] = [ai, bi] 表示如果你想选 bi 课程，你 必须 先选 ai 课程。
有的课会有直接的先修课程，比如如果想上课程 1 ，你必须先上课程 0 ，那么会以 [0,1] 数对的形式给出先修课程数对。
先决条件也可以是 间接 的。如果课程 a 是课程 b 的先决条件，课程 b 是课程 c 的先决条件，那么课程 a 就是课程 c 的先决条件。
你也得到一个数组 queries ，其中 queries[j] = [uj, vj]。对于第 j 个查询，您应该回答课程 uj 是否是课程 vj 的先决条件。
返回一个布尔数组 answer ，其中 answer[j] 是第 j 个查询的答案。
  示例 1：
输入：numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
输出：[false,true]
解释：课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。
示例 2：
输入：numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
输出：[false,false]
解释：没有先修课程对，所以每门课程之间是独立的。
示例 3：
输入：numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
输出：[true,true]
  提示：
2 <= numCourses <= 100
0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)
prerequisites[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
每一对 [ai, bi] 都 不同
先修课程图中没有环。
0 <= ui, vi <= n - 1
ui != vi",82,,9011,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']",[],20137
评论 (57),cherry-pickup-ii,困难,"给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。
你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。
请你按照如下规则，返回两个机器人能收集的最多樱桃数目：
从格子 (i,j) 出发，机器人可以移动到格子 (i+1, j-1)，(i+1, j) 或者 (i+1, j+1) 。
当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。
当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。
两个机器人在任意时刻都不能移动到 grid 外面。
两个机器人最后都要到达 grid 最底下一行。
  示例 1：
输入：grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
输出：24
解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。
机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。
机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。
樱桃总数为： 12 + 12 = 24 。
示例 2：
输入：grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
输出：28
解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。
机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。
机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。
樱桃总数为： 17 + 11 = 28 。
示例 3：
输入：grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
输出：22
示例 4：
输入：grid = [[1,1],[1,1]]
输出：4
  提示：
rows == grid.length
cols == grid[i].length
2 <= rows, cols <= 70
0 <= grid[i][j] <= 100 ",60,,3369,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],5526
评论 (205),maximum-product-of-two-elements-in-an-array,简单,"给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。
请你计算并返回该式的最大值。
  示例 1：
输入：nums = [3,4,5,2]
输出：12 
解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 
示例 2：
输入：nums = [1,5,4,5]
输出：16
解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。
示例 3：
输入：nums = [3,7]
输出：12
  提示：
2 <= nums.length <= 500
1 <= nums[i] <= 10^3",33,,33321,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],43638
评论 (84),maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts,中等,"矩形蛋糕的高度为 h 且宽度为 w，给你两个整数数组 horizontalCuts 和 verticalCuts，其中：
 horizontalCuts[i] 是从矩形蛋糕顶部到第  i 个水平切口的距离
verticalCuts[j] 是从矩形蛋糕的左侧到第 j 个竖直切口的距离
请你按数组 horizontalCuts 和 verticalCuts 中提供的水平和竖直位置切割后，请你找出 面积最大 的那份蛋糕，并返回其 面积 。由于答案可能是一个很大的数字，因此需要将结果 对 109 + 7 取余 后返回。
  示例 1：
输入：h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]
输出：4 
解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。
示例 2：
输入：h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]
输出：6
解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。
示例 3：
输入：h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]
输出：9
  提示：
2 <= h, w <= 109
1 <= horizontalCuts.length <= min(h - 1, 105)
1 <= verticalCuts.length <= min(w - 1, 105)
1 <= horizontalCuts[i] < h
1 <= verticalCuts[i] < w
题目数据保证 horizontalCuts 中的所有元素各不相同
题目数据保证 verticalCuts 中的所有元素各不相同",27,,7373,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],23127
评论 (115),reorder-routes-to-make-all-paths-lead-to-the-city-zero,中等,"n 座城市，从 0 到 n-1 编号，其间共有 n-1 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。
路线用 connections 表示，其中 connections[i] = [a, b] 表示从城市 a 到 b 的一条有向路线。
今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。
请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。
题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。
  示例 1：
输入：n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
输出：3
解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。
示例 2：
输入：n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
输出：2
解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。
示例 3：
输入：n = 3, connections = [[1,0],[2,0]]
输出：0
  提示：
2 <= n <= 5 * 10^4
connections.length == n-1
connections[i].length == 2
0 <= connections[i][0], connections[i][1] <= n-1
connections[i][0] != connections[i][1]",76,,8034,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/']",[],16342
评论 (59),probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,困难,"桌面上有 2n 个颜色不完全相同的球，球上的颜色共有 k 种。给你一个大小为 k 的整数数组 balls ，其中 balls[i] 是颜色为 i 的球的数量。
所有的球都已经 随机打乱顺序 ，前 n 个球放入第一个盒子，后 n 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。
注意：这两个盒子是不同的。例如，两个球颜色分别为 a 和 b，盒子分别为 [] 和 ()，那么 [a] (b) 和 [b] (a) 这两种分配方式是不同的（请认真阅读示例的解释部分）。
请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在 10^-5 以内，则被视为正确答案
  示例 1：
输入：balls = [1,1]
输出：1.00000
解释：球平均分配的方式只有两种：
- 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子
- 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子
这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。
示例 2：
输入：balls = [2,1,1]
输出：0.66667
解释：球的列表为 [1, 1, 2, 3]
随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ：
[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]
然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。
这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。
概率 = 8/12 = 0.66667
示例 3：
输入：balls = [1,2,1,2]
输出：0.60000
解释：球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。
概率 = 108 / 180 = 0.6 。
  提示：
1 <= balls.length <= 8
1 <= balls[i] <= 6
sum(balls) 是偶数",46,,1922,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/combinatorics/', 'https://leetcode.cn/tag/probability-and-statistics/']",[],3058
评论 (103),calculate-salaries,Unknown,,-1,,-1,[],[],-1
评论 (49),find-all-the-lonely-nodes,Unknown,,-1,,-1,[],[],-1
评论 (305),shuffle-the-array,简单,"给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。
请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。
  示例 1：
输入：nums = [2,5,1,3,4,7], n = 3
输出：[2,3,5,4,1,7] 
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
示例 2：
输入：nums = [1,2,3,4,4,3,2,1], n = 4
输出：[1,4,2,3,3,2,4,1]
示例 3：
输入：nums = [1,1,2,2], n = 2
输出：[1,2,1,2]
  提示：
1 <= n <= 500
nums.length == 2n
1 <= nums[i] <= 10^3",86,,59951,['https://leetcode.cn/tag/array/'],[],71512
评论 (81),the-k-strongest-values-in-an-array,中等,"给你一个整数数组 arr 和一个整数 k 。
设 m 为数组的中位数，只要满足下述两个前提之一，就可以判定 arr[i] 的值比 arr[j] 的值更强：
 |arr[i] - m| > |arr[j] - m|
 |arr[i] - m| == |arr[j] - m|，且 arr[i] > arr[j]
请返回由数组中最强的 k 个值组成的列表。答案可以以 任意顺序 返回。
中位数 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 n ，那么中位数就是该有序列表（下标从 0 开始）中位于 ((n - 1) / 2) 的元素。
例如 arr = [6, -3, 7, 2, 11]，n = 5：数组排序后得到 arr = [-3, 2, 6, 7, 11] ，数组的中间位置为 m = ((5 - 1) / 2) = 2 ，中位数 arr[m] 的值为 6 。
例如 arr = [-7, 22, 17, 3]，n = 4：数组排序后得到 arr = [-7, 3, 17, 22] ，数组的中间位置为 m = ((4 - 1) / 2) = 1 ，中位数 arr[m] 的值为 3 。
  示例 1：
输入：arr = [1,2,3,4,5], k = 2
输出：[5,1]
解释：中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。
注意，尽管 |5 - 3| == |1 - 3| ，但是 5 比 1 更强，因为 5 > 1 。
示例 2：
输入：arr = [1,1,3,5,5], k = 2
输出：[5,5]
解释：中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。
示例 3：
输入：arr = [6,7,11,7,6,8], k = 5
输出：[11,8,6,6,7]
解释：中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。
[11,8,6,6,7] 的任何排列都是正确答案。
示例 4：
输入：arr = [6,-3,7,2,11], k = 3
输出：[-3,11,2]
示例 5：
输入：arr = [-7,22,17,3], k = 2
输出：[22,17]
  提示：
1 <= arr.length <= 10^5
-10^5 <= arr[i] <= 10^5
1 <= k <= arr.length",23,,8315,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],15124
评论 (96),design-browser-history,中等,"你有一个只支持单个标签页的 浏览器 ，最开始你浏览的网页是 homepage ，你可以访问其他的网站 url ，也可以在浏览历史中后退 steps 步或前进 steps 步。
请你实现 BrowserHistory 类：
BrowserHistory(string homepage) ，用 homepage 初始化浏览器类。
void visit(string url) 从当前页跳转访问 url 对应的页面  。执行此操作会把浏览历史前进的记录全部删除。
string back(int steps) 在浏览历史中后退 steps 步。如果你只能在浏览历史中后退至多 x 步且 steps > x ，那么你只后退 x 步。请返回后退 至多 steps 步以后的 url 。
string forward(int steps) 在浏览历史中前进 steps 步。如果你只能在浏览历史中前进至多 x 步且 steps > x ，那么你只前进 x 步。请返回前进 至多 steps步以后的 url 。
  示例：
输入：
[""BrowserHistory"",""visit"",""visit"",""visit"",""back"",""back"",""forward"",""visit"",""forward"",""back"",""back""]
[[""leetcode.com""],[""google.com""],[""facebook.com""],[""youtube.com""],[1],[1],[1],[""linkedin.com""],[2],[2],[7]]
输出：
[null,null,null,null,""facebook.com"",""google.com"",""facebook.com"",null,""linkedin.com"",""google.com"",""leetcode.com""]

解释：
BrowserHistory browserHistory = new BrowserHistory(""leetcode.com"");
browserHistory.visit(""google.com"");       // 你原本在浏览 ""leetcode.com"" 。访问 ""google.com""
browserHistory.visit(""facebook.com"");     // 你原本在浏览 ""google.com"" 。访问 ""facebook.com""
browserHistory.visit(""youtube.com"");      // 你原本在浏览 ""facebook.com"" 。访问 ""youtube.com""
browserHistory.back(1);                   // 你原本在浏览 ""youtube.com"" ，后退到 ""facebook.com"" 并返回 ""facebook.com""
browserHistory.back(1);                   // 你原本在浏览 ""facebook.com"" ，后退到 ""google.com"" 并返回 ""google.com""
browserHistory.forward(1);                // 你原本在浏览 ""google.com"" ，前进到 ""facebook.com"" 并返回 ""facebook.com""
browserHistory.visit(""linkedin.com"");     // 你原本在浏览 ""facebook.com"" 。 访问 ""linkedin.com""
browserHistory.forward(2);                // 你原本在浏览 ""linkedin.com"" ，你无法前进任何步数。
browserHistory.back(2);                   // 你原本在浏览 ""linkedin.com"" ，后退两步依次先到 ""facebook.com"" ，然后到 ""google.com"" ，并返回 ""google.com""
browserHistory.back(7);                   // 你原本在浏览 ""google.com""， 你只能后退一步到 ""leetcode.com"" ，并返回 ""leetcode.com""
  提示：
1 <= homepage.length <= 20
1 <= url.length <= 20
1 <= steps <= 100
homepage 和 url 都只包含 '.' 或者小写英文字母。
最多调用 5000 次 visit， back 和 forward 函数。",51,,11676,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/data-stream/', 'https://leetcode.cn/tag/doubly-linked-list/']",[],18933
评论 (226),paint-house-iii,困难,"在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不可以被重新涂色。
我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区  [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）
给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：
houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。
cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。
请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。
  示例 1：
输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：9
解释：房子涂色方案为 [1,2,2,1,1]
此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。
涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。
示例 2：
输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：11
解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]
此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。
给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。
示例 3：
输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
输出：5
示例 4：
输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
输出：-1
解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。
  提示：
m == houses.length == cost.length
n == cost[i].length
1 <= m <= 100
1 <= n <= 20
1 <= target <= m
0 <= houses[i] <= n
1 <= cost[i][j] <= 10^4",170,,16255,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],24271
评论 (29),delete-n-nodes-after-m-nodes-of-a-linked-list,Unknown,,-1,,-1,[],[],-1
评论 (164),final-prices-with-a-special-discount-in-a-shop,简单,"给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。
商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。
请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。
  示例 1：
输入：prices = [8,4,6,2,3]
输出：[4,2,4,2,3]
解释：
商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。
商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。
商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。
商品 3 和 4 都没有折扣。
示例 2：
输入：prices = [1,2,3,4,5]
输出：[1,2,3,4,5]
解释：在这个例子中，所有商品都没有折扣。
示例 3：
输入：prices = [10,1,1,6]
输出：[9,0,1,6]
  提示：
1 <= prices.length <= 500
1 <= prices[i] <= 10^3",64,,20393,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/monotonic-stack/']",[],28591
评论 (80),subrectangle-queries,中等,"请你实现一个类 SubrectangleQueries ，它的构造函数的参数是一个 rows x cols 的矩形（这里用整数矩阵表示），并支持以下两种操作：
1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)
用 newValue 更新以 (row1,col1) 为左上角且以 (row2,col2) 为右下角的子矩形。
2. getValue(int row, int col)
返回矩形中坐标 (row,col) 的当前值。
  示例 1：
输入：
[""SubrectangleQueries"",""getValue"",""updateSubrectangle"",""getValue"",""getValue"",""updateSubrectangle"",""getValue"",""getValue""]
[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
输出：
[null,1,null,5,5,null,10,5]
解释：
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  
// 初始的 (4x3) 矩形如下：
// 1 2 1
// 4 3 4
// 3 2 1
// 1 1 1
subrectangleQueries.getValue(0, 2); // 返回 1
subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
// 此次更新后矩形变为：
// 5 5 5
// 5 5 5
// 5 5 5
// 5 5 5 
subrectangleQueries.getValue(0, 2); // 返回 5
subrectangleQueries.getValue(3, 1); // 返回 5
subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
// 此次更新后矩形变为：
// 5   5   5
// 5   5   5
// 5   5   5
// 10  10  10 
subrectangleQueries.getValue(3, 1); // 返回 10
subrectangleQueries.getValue(0, 2); // 返回 5
示例 2：
输入：
[""SubrectangleQueries"",""getValue"",""updateSubrectangle"",""getValue"",""getValue"",""updateSubrectangle"",""getValue""]
[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
输出：
[null,1,null,100,100,null,20]
解释：
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
subrectangleQueries.getValue(0, 0); // 返回 1
subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
subrectangleQueries.getValue(0, 0); // 返回 100
subrectangleQueries.getValue(2, 2); // 返回 100
subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
subrectangleQueries.getValue(2, 2); // 返回 20
  提示：
最多有 500 次updateSubrectangle 和 getValue 操作。
1 <= rows, cols <= 100
rows == rectangle.length
cols == rectangle[i].length
0 <= row1 <= row2 < rows
0 <= col1 <= col2 < cols
1 <= newValue, rectangle[i][j] <= 10^9
0 <= row < rows
0 <= col < cols",32,,13973,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],16167
评论 (104),find-two-non-overlapping-sub-arrays-each-with-target-sum,中等,"给你一个整数数组 arr 和一个整数值 target 。
请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。
请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。
  示例 1：
输入：arr = [3,2,2,4,3], target = 3
输出：2
解释：只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。
示例 2：
输入：arr = [7,3,4,7], target = 7
输出：2
解释：尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。
示例 3：
输入：arr = [4,3,2,6,2,3,4], target = 6
输出：-1
解释：我们只有一个和为 6 的子数组。
示例 4：
输入：arr = [5,5,4,4,5], target = 3
输出：-1
解释：我们无法找到和为 3 的子数组。
示例 5：
输入：arr = [3,1,1,1,5,1,2,1], target = 3
输出：3
解释：注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。
  提示：
1 <= arr.length <= 10^5
1 <= arr[i] <= 1000
1 <= target <= 10^8",104,,6502,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/']",[],21792
评论 (48),allocate-mailboxes,困难,"给你一个房屋数组houses 和一个整数 k ，其中 houses[i] 是第 i 栋房子在一条街上的位置，现需要在这条街上安排 k 个邮筒。
请你返回每栋房子与离它最近的邮筒之间的距离的 最小 总和。
答案保证在 32 位有符号整数范围以内。
  示例 1：
输入：houses = [1,4,8,10,20], k = 3
输出：5
解释：将邮筒分别安放在位置 3， 9 和 20 处。
每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。
示例 2：
输入：houses = [2,3,5,12,18], k = 2
输出：9
解释：将邮筒分别安放在位置 3 和 14 处。
每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。
示例 3：
输入：houses = [7,4,6,1], k = 1
输出：8
示例 4：
输入：houses = [3,6,14,10], k = 4
输出：0
  提示：
n == houses.length
1 <= n <= 100
1 <= houses[i] <= 10^4
1 <= k <= n
数组 houses 中的整数互不相同。",85,,3683,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],6099
评论 (67),sales-by-day-of-the-week,Unknown,,-1,,-1,[],[],-1
评论 (562),running-sum-of-1d-array,简单,"给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。
请返回 nums 的动态和。
  示例 1：
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
示例 2：
输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
示例 3：
输入：nums = [3,1,2,10,1]
输出：[3,4,6,16,17]
  提示：
1 <= nums.length <= 1000
-10^6 <= nums[i] <= 10^6",141,,143319,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],165349
评论 (92),least-number-of-unique-integers-after-k-removals,中等,"给你一个整数数组 arr 和一个整数 k 。现需要从数组中恰好移除 k 个元素，请找出移除后数组中不同整数的最少数目。
  示例 1：
输入：arr = [5,5,4], k = 1
输出：1
解释：移除 1 个 4 ，数组中只剩下 5 一种整数。
示例 2：
输入：arr = [4,3,1,1,3,3,2], k = 3
输出：2
解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。
  提示：
1 <= arr.length <= 10^5
1 <= arr[i] <= 10^9
0 <= k <= arr.length",44,,11776,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],22516
评论 (349),minimum-number-of-days-to-make-m-bouquets,中等,"给你一个整数数组 bloomDay，以及两个整数 m 和 k 。
现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。
花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。
请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。
  示例 1：
输入：bloomDay = [1,10,3,10,2], m = 3, k = 1
输出：3
解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
现在需要制作 3 束花，每束只需要 1 朵。
1 天后：[x, _, _, _, _]   // 只能制作 1 束花
2 天后：[x, _, _, _, x]   // 只能制作 2 束花
3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
示例 2：
输入：bloomDay = [1,10,3,10,2], m = 3, k = 2
输出：-1
解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。
示例 3：
输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
输出：12
解释：要制作 2 束花，每束需要 3 朵。
花园在 7 天后和 12 天后的情况如下：
7 天后：[x, x, x, x, _, x, x]
可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。
12 天后：[x, x, x, x, x, x, x]
显然，我们可以用不同的方式制作两束花。
示例 4：
输入：bloomDay = [1000000000,1000000000], m = 1, k = 1
输出：1000000000
解释：需要等 1000000000 天才能采到花来制作花束
示例 5：
输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
输出：9
  提示：
bloomDay.length == n
1 <= n <= 10^5
1 <= bloomDay[i] <= 10^9
1 <= m <= 10^6
1 <= k <= n",245,,34840,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],58944
评论 (84),kth-ancestor-of-a-tree-node,困难,"给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。
树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。
实现 TreeAncestor 类：
TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。
getKthAncestor(int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。
  示例 1：
输入：
[""TreeAncestor"",""getKthAncestor"",""getKthAncestor"",""getKthAncestor""]
[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]

输出：
[null,1,0,-1]

解释：
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);

treeAncestor.getKthAncestor(3, 1);  // 返回 1 ，它是 3 的父节点
treeAncestor.getKthAncestor(5, 2);  // 返回 0 ，它是 5 的祖父节点
treeAncestor.getKthAncestor(6, 3);  // 返回 -1 因为不存在满足要求的祖先节点
  提示：
1 <= k <= n <= 5 * 104
parent[0] == -1 表示编号为 0 的节点是根节点。
对于所有的 0 < i < n ，0 <= parent[i] < n 总成立
0 <= node < n
至多查询 5 * 104 次",96,,4230,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],13180
评论 (94),group-sold-products-by-the-date,简单,"SQL架构
表 Activities：
+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| sell_date   | date    |
| product     | varchar |
+-------------+---------+
此表没有主键，它可能包含重复项。
此表的每一行都包含产品名称和在市场上销售的日期。
  编写一个 SQL 查询来查找每个日期、销售的不同产品的数量及其名称。
每个日期的销售产品名称应按词典序排列。
返回按 sell_date 排序的结果表。
查询结果格式如下例所示。
  示例 1:
输入：
Activities 表：
+------------+-------------+
| sell_date  | product     |
+------------+-------------+
| 2020-05-30 | Headphone   |
| 2020-06-01 | Pencil      |
| 2020-06-02 | Mask        |
| 2020-05-30 | Basketball  |
| 2020-06-01 | Bible       |
| 2020-06-02 | Mask        |
| 2020-05-30 | T-Shirt     |
+------------+-------------+
输出：
+------------+----------+------------------------------+
| sell_date  | num_sold | products                     |
+------------+----------+------------------------------+
| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |
| 2020-06-01 | 2        | Bible,Pencil                 |
| 2020-06-02 | 1        | Mask                         |
+------------+----------+------------------------------+
解释：
对于2020-05-30，出售的物品是 (Headphone, Basketball, T-shirt)，按词典序排列，并用逗号 ',' 分隔。
对于2020-06-01，出售的物品是 (Pencil, Bible)，按词典序排列，并用逗号分隔。
对于2020-06-02，出售的物品是 (Mask)，只需返回该物品名。",51,,13651,['https://leetcode.cn/tag/database/'],[],20061
评论 (15),clone-binary-tree-with-random-pointer,Unknown,,-1,,-1,[],[],-1
评论 (390),xor-operation-in-an-array,简单,"给你两个整数，n 和 start 。
数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。
请返回 nums 中所有元素按位异或（XOR）后得到的结果。
  示例 1：
输入：n = 5, start = 0
输出：8
解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
     ""^"" 为按位异或 XOR 运算符。
示例 2：
输入：n = 4, start = 3
输出：8
解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.
示例 3：
输入：n = 1, start = 7
输出：7
示例 4：
输入：n = 10, start = 5
输出：2
  提示：
1 <= n <= 1000
0 <= start <= 1000
n == nums.length",106,,75080,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/']",[],87548
评论 (62),making-file-names-unique,中等,"给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。
由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。
返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。
  示例 1：
输入：names = [""pes"",""fifa"",""gta"",""pes(2019)""]
输出：[""pes"",""fifa"",""gta"",""pes(2019)""]
解释：文件系统将会这样创建文件名：
""pes"" --> 之前未分配，仍为 ""pes""
""fifa"" --> 之前未分配，仍为 ""fifa""
""gta"" --> 之前未分配，仍为 ""gta""
""pes(2019)"" --> 之前未分配，仍为 ""pes(2019)""
示例 2：
输入：names = [""gta"",""gta(1)"",""gta"",""avalon""]
输出：[""gta"",""gta(1)"",""gta(2)"",""avalon""]
解释：文件系统将会这样创建文件名：
""gta"" --> 之前未分配，仍为 ""gta""
""gta(1)"" --> 之前未分配，仍为 ""gta(1)""
""gta"" --> 文件名被占用，系统为该名称添加后缀 (k)，由于 ""gta(1)"" 也被占用，所以 k = 2 。实际创建的文件名为 ""gta(2)"" 。
""avalon"" --> 之前未分配，仍为 ""avalon""
示例 3：
输入：names = [""onepiece"",""onepiece(1)"",""onepiece(2)"",""onepiece(3)"",""onepiece""]
输出：[""onepiece"",""onepiece(1)"",""onepiece(2)"",""onepiece(3)"",""onepiece(4)""]
解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 ""onepiece(4)""。
示例 4：
输入：names = [""wano"",""wano"",""wano"",""wano""]
输出：[""wano"",""wano(1)"",""wano(2)"",""wano(3)""]
解释：每次创建文件夹 ""wano"" 时，只需增加后缀中 k 的值即可。
示例 5：
输入：names = [""kaido"",""kaido(1)"",""kaido"",""kaido(1)""]
输出：[""kaido"",""kaido(1)"",""kaido(2)"",""kaido(1)(1)""]
解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。
  提示：
1 <= names.length <= 5 * 10^4
1 <= names[i].length <= 20
names[i] 由小写英文字母、数字和/或圆括号组成。",38,,8879,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],27753
评论 (89),avoid-flood-in-the-city,中等,"你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨前是空的，那么它就会装满水。如果第 n 个湖泊下雨前是 满的 ，这个湖泊会发生 洪水 。你的目标是避免任意一个湖泊发生洪水。
给你一个整数数组 rains ，其中：
rains[i] > 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。
rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。
请返回一个数组 ans ，满足：
ans.length == rains.length
如果 rains[i] > 0 ，那么ans[i] == -1 。
如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。
如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。
请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。
  示例 1：
输入：rains = [1,2,3,4]
输出：[-1,-1,-1,-1]
解释：第一天后，装满水的湖泊包括 [1]
第二天后，装满水的湖泊包括 [1,2]
第三天后，装满水的湖泊包括 [1,2,3]
第四天后，装满水的湖泊包括 [1,2,3,4]
没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。
示例 2：
输入：rains = [1,2,0,0,2,1]
输出：[-1,-1,2,1,-1,-1]
解释：第一天后，装满水的湖泊包括 [1]
第二天后，装满水的湖泊包括 [1,2]
第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]
第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。
第五天后，装满水的湖泊包括 [2]。
第六天后，装满水的湖泊包括 [1,2]。
可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。
示例 3：
输入：rains = [1,2,0,1,2]
输出：[]
解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。
但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。
  提示：
1 <= rains.length <= 105
0 <= rains[i] <= 109",94,,9429,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],37405
评论 (223),find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree,困难,"给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [fromi, toi, weighti] 表示在 fromi 和 toi 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。
请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。
请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。
  示例 1：
输入：n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
输出：[[0,1],[2,3,4,5]]
解释：上图描述了给定图。
下图是所有的最小生成树。

注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。
边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。
示例 2 ：
输入：n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
输出：[[],[0,1,2,3]]
解释：可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。
  提示：
2 <= n <= 100
1 <= edges.length <= min(200, n * (n - 1) / 2)
edges[i].length == 3
0 <= fromi < toi < n
1 <= weighti <= 1000
所有 (fromi, toi) 数对都是互不相同的。",123,,12267,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/minimum-spanning-tree/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/strongly-connected-component/']",[],17953
评论 (32),clone-n-ary-tree,Unknown,,-1,,-1,[],[],-1
评论 (252),average-salary-excluding-the-minimum-and-maximum-salary,简单,"给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。
请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。
  示例 1：
输入：salary = [4000,3000,1000,2000]
输出：2500.00000
解释：最低工资和最高工资分别是 1000 和 4000 。
去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500
示例 2：
输入：salary = [1000,2000,3000]
输出：2000.00000
解释：最低工资和最高工资分别是 1000 和 3000 。
去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000
示例 3：
输入：salary = [6000,5000,4000,3000,2000,1000]
输出：3500.00000
示例 4：
输入：salary = [8000,9000,2000,3000,6000,1000]
输出：4750.00000
  提示：
3 <= salary.length <= 100
10^3 <= salary[i] <= 10^6
salary[i] 是唯一的。
与真实值误差在 10^-5 以内的结果都将视为正确答案。",36,,33388,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],51694
评论 (79),the-kth-factor-of-n,中等,"给你两个正整数 n 和 k 。
如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。
考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。
  示例 1：
输入：n = 12, k = 3
输出：3
解释：因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。
示例 2：
输入：n = 7, k = 2
输出：7
解释：因子列表包括 [1, 7] ，第 2 个因子是 7 。
示例 3：
输入：n = 4, k = 4
输出：-1
解释：因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。
  提示：
1 <= k <= n <= 1000",23,,10280,['https://leetcode.cn/tag/math/'],[],16321
评论 (109),longest-subarray-of-1s-after-deleting-one-element,中等,"给你一个二进制数组 nums ，你需要从中删掉一个元素。
请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。
如果不存在这样的子数组，请返回 0 。
  提示 1：
输入：nums = [1,1,0,1]
输出：3
解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。
示例 2：
输入：nums = [0,1,1,1,0,1,1,0,1]
输出：5
解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。
示例 3：
输入：nums = [1,1,1]
输出：2
解释：你必须要删除一个元素。
  提示：
1 <= nums.length <= 105
nums[i] 要么是 0 要么是 1 。",58,,11629,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/']",[],19876
评论 (62),parallel-courses-ii,困难,"给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 dependencies 中， dependencies[i] = [xi, yi]  表示一个先修课的关系，也就是课程 xi 必须在课程 yi 之前上。同时你还有一个整数 k 。
在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。
请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。
  示例 1：
输入：n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2
输出：3 
解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。
示例 2：
输入：n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2
输出：4 
解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。
示例 3：
输入：n = 11, dependencies = [], k = 2
输出：6
  提示：
1 <= n <= 15
1 <= k <= n
0 <= dependencies.length <= n * (n-1) / 2
dependencies[i].length == 2
1 <= xi, yi <= n
xi != yi
所有先修关系都是不同的，也就是说 dependencies[i] != dependencies[j] 。
题目输入的图是个有向无环图。",87,,3038,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],7927
评论 (96),friendly-movies-streamed-last-month,Unknown,,-1,,-1,[],[],-1
评论 (106),path-crossing,简单,"给你一个字符串 path，其中 path[i] 的值可以是 'N'、'S'、'E' 或者 'W'，分别表示向北、向南、向东、向西移动一个单位。
你从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。
如果路径在任何位置上与自身相交，也就是走到之前已经走过的位置，请返回 true ；否则，返回 false 。
  示例 1：
输入：path = ""NES""
输出：false 
解释：该路径没有在任何位置相交。
示例 2：
输入：path = ""NESWW""
输出：true
解释：该路径经过原点两次。
  提示：
1 <= path.length <= 104
path[i] 为 'N'、'S'、'E' 或 'W'",36,,13174,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],24661
评论 (107),check-if-array-pairs-are-divisible-by-k,中等,"给你一个整数数组 arr 和一个整数 k ，其中数组长度是偶数，值为 n 。
现在需要把数组恰好分成 n / 2 对，以使每对数字的和都能够被 k 整除。
如果存在这样的分法，请返回 True ；否则，返回 False 。
  示例 1：
输入：arr = [1,2,3,4,5,10,6,7,8,9], k = 5
输出：true
解释：划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。
示例 2：
输入：arr = [1,2,3,4,5,6], k = 7
输出：true
解释：划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。
示例 3：
输入：arr = [1,2,3,4,5,6], k = 10
输出：false
解释：无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。
  提示：
arr.length == n
1 <= n <= 105
n 为偶数
-109 <= arr[i] <= 109
1 <= k <= 105",65,,10077,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],25263
评论 (94),number-of-subsequences-that-satisfy-the-given-sum-condition,中等,"给你一个整数数组 nums 和一个整数 target 。
请你统计并返回 nums 中能满足其最小元素与最大元素的 和 小于或等于 target 的 非空 子序列的数目。
由于答案可能很大，请将结果对 109 + 7 取余后返回。
  示例 1：
输入：nums = [3,5,6,7], target = 9
输出：4
解释：有 4 个子序列满足该条件。
[3] -> 最小元素 + 最大元素 <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)
示例 2：
输入：nums = [3,3,6,8], target = 10
输出：6
解释：有 6 个子序列满足该条件。（nums 中可以有重复数字）
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
示例 3：
输入：nums = [2,3,3,4,6,7], target = 12
输出：61
解释：共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）
有效序列总数为（63 - 2 = 61）
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 106
1 <= target <= 106",87,,6879,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],19435
评论 (56),max-value-of-equation,困难,"给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 points[i] = [xi, yi] ，并且在 1 <= i < j <= points.length 的前提下， xi < xj 总成立。
请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| <= k 且 1 <= i < j <= points.length。
题目测试数据保证至少存在一对能够满足 |xi - xj| <= k 的点。
  示例 1：
输入：points = [[1,3],[2,0],[5,10],[6,-10]], k = 1
输出：4
解释：前两个点满足 |xi - xj| <= 1 ，代入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。
没有其他满足条件的点，所以返回 4 和 1 中最大的那个。
示例 2：
输入：points = [[0,0],[3,0],[9,2]], k = 3
输出：3
解释：只有前两个点满足 |xi - xj| <= 3 ，代入方程后得到值 0 + 0 + |0 - 3| = 3 。
  提示：
2 <= points.length <= 10^5
points[i].length == 2
-10^8 <= points[i][0], points[i][1] <= 10^8
0 <= k <= 2 * 10^8
对于所有的1 <= i < j <= points.length ，points[i][0] < points[j][0] 都成立。也就是说，xi 是严格递增的。",55,,3575,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/monotonic-queue/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],9192
评论 (21),design-a-file-sharing-system,Unknown,,-1,,-1,[],[],-1
评论 (132),countries-you-can-safely-invest-in,Unknown,,-1,,-1,[],[],-1
评论 (184),can-make-arithmetic-progression-from-sequence,简单,"给你一个数字数组 arr 。
如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。
如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。
  示例 1：
输入：arr = [3,5,1]
输出：true
解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。
示例 2：
输入：arr = [1,2,4]
输出：false
解释：无法通过重新排序得到等差数列。
  提示：
2 <= arr.length <= 1000
-10^6 <= arr[i] <= 10^6",24,,34181,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],48273
评论 (140),last-moment-before-all-ants-fall-out-of-a-plank,中等,"有一块木板，长度为 n 个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。
当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。
而当蚂蚁在某一时刻 t 到达木板的一端时，它立即从木板上掉下来。
给你一个整数 n 和两个整数数组 left 以及 right 。两个数组分别标识向左或者向右移动的蚂蚁在 t = 0 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。
  示例 1：
  输入：n = 4, left = [4,3], right = [0,1]
输出：4
解释：如上图所示：
-下标 0 处的蚂蚁命名为 A 并向右移动。
-下标 1 处的蚂蚁命名为 B 并向右移动。
-下标 3 处的蚂蚁命名为 C 并向左移动。
-下标 4 处的蚂蚁命名为 D 并向左移动。
请注意，蚂蚁在木板上的最后时刻是 t = 4 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = 4.0000000001 时，木板上没有蚂蚁）。
示例 2：
输入：n = 7, left = [], right = [0,1,2,3,4,5,6,7]
输出：7
解释：所有蚂蚁都向右移动，下标为 0 的蚂蚁需要 7 秒才能从木板上掉落。
示例 3：
输入：n = 7, left = [0,1,2,3,4,5,6,7], right = []
输出：7
解释：所有蚂蚁都向左移动，下标为 7 的蚂蚁需要 7 秒才能从木板上掉落。
  提示：
1 <= n <= 10^4
0 <= left.length <= n + 1
0 <= left[i] <= n
0 <= right.length <= n + 1
0 <= right[i] <= n
1 <= left.length + right.length <= n + 1
left 和 right 中的所有值都是唯一的，并且每个值 只能出现在二者之一 中。",48,,9721,"['https://leetcode.cn/tag/brainteaser/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],18607
评论 (122),count-submatrices-with-all-ones,中等,"给你一个 m x n 的二进制矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。
  示例 1：
输入：mat = [[1,0,1],[1,1,0],[1,1,0]]
输出：13
解释：
有 6 个 1x1 的矩形。
有 2 个 1x2 的矩形。
有 3 个 2x1 的矩形。
有 1 个 2x2 的矩形。
有 1 个 3x1 的矩形。
矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。
示例 2：
输入：mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
输出：24
解释：
有 8 个 1x1 的子矩形。
有 5 个 1x2 的子矩形。
有 2 个 1x3 的子矩形。
有 4 个 2x1 的子矩形。
有 2 个 2x2 的子矩形。
有 2 个 3x1 的子矩形。
有 1 个 3x2 的子矩形。
矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。
  提示：
1 <= m, n <= 150
mat[i][j] 仅包含 0 或 1",136,,9184,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/monotonic-stack/']",[],15066
评论 (88),minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits,困难,"给你一个字符串 num 和一个整数 k 。其中，num 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 数位 。
你可以交换这个整数相邻数位的数字 最多 k 次。
请你返回你能得到的最小整数，并以字符串形式返回。
  示例 1：
输入：num = ""4321"", k = 4
输出：""1342""
解释：4321 通过 4 次交换相邻数位得到最小整数的步骤如上图所示。
示例 2：
输入：num = ""100"", k = 1
输出：""010""
解释：输出可以包含前导 0 ，但输入保证不会有前导 0 。
示例 3：
输入：num = ""36789"", k = 1000
输出：""36789""
解释：不需要做任何交换。
示例 4：
输入：num = ""22"", k = 22
输出：""22""
示例 5：
输入：num = ""9438957234785635408"", k = 23
输出：""0345989723478563548""
  提示：
1 <= num.length <= 30000
num 只包含 数字 且不含有 前导 0 。
1 <= k <= 10^9",69,,3729,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/string/']",[],10044
评论 (18),find-root-of-n-ary-tree,Unknown,,-1,,-1,[],[],-1
评论 (82),reformat-date,简单,"给你一个字符串 date ，它的格式为 Day Month Year ，其中：
Day 是集合 {""1st"", ""2nd"", ""3rd"", ""4th"", ..., ""30th"", ""31st""} 中的一个元素。
Month 是集合 {""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"", ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""} 中的一个元素。
Year 的范围在 [1900, 2100] 之间。
请你将字符串转变为 YYYY-MM-DD 的格式，其中：
YYYY 表示 4 位的年份。
MM 表示 2 位的月份。
DD 表示 2 位的天数。
  示例 1：
输入：date = ""20th Oct 2052""
输出：""2052-10-20""
示例 2：
输入：date = ""6th Jun 1933""
输出：""1933-06-06""
示例 3：
输入：date = ""26th May 1960""
输出：""1960-05-26""
  提示：
给定日期保证是合法的，所以不需要处理异常输入。",15,,12109,['https://leetcode.cn/tag/string/'],[],20564
评论 (51),range-sum-of-sorted-subarray-sums,中等,"给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) / 2 个数字的数组。
请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。
  示例 1：
输入：nums = [1,2,3,4], n = 4, left = 1, right = 5
输出：13 
解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。
示例 2：
输入：nums = [1,2,3,4], n = 4, left = 3, right = 4
输出：6
解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。
示例 3：
输入：nums = [1,2,3,4], n = 4, left = 1, right = 10
输出：50
  提示：
1 <= nums.length <= 10^3
nums.length == n
1 <= nums[i] <= 100
1 <= left <= right <= n * (n + 1) / 2",45,,7937,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],14131
评论 (58),minimum-difference-between-largest-and-smallest-value-in-three-moves,中等,"给你一个数组 nums ，每次操作你可以选择 nums 中的任意一个元素并将它改成任意值。
请你返回三次操作后， nums 中最大值与最小值的差的最小值。
  示例 1：
输入：nums = [5,3,2,4]
输出：0
解释：将数组 [5,3,2,4] 变成 [2,2,2,2].
最大值与最小值的差为 2-2 = 0 。
示例 2：
输入：nums = [1,5,0,10,14]
输出：1
解释：将数组 [1,5,0,10,14] 变成 [1,1,0,1,1] 。
最大值与最小值的差为 1-0 = 1 。
示例 3：
输入：nums = [6,6,0,1,1,4,6]
输出：2
示例 4：
输入：nums = [1,5,6,14,15]
输出：1
  提示：
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9",43,,6363,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],11515
评论 (59),stone-game-iv,困难,"Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。
一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。
如果石子堆里没有石子了，则无法操作的玩家输掉游戏。
给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。
  示例 1：
输入：n = 1
输出：true
解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。
示例 2：
输入：n = 2
输出：false
解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。
示例 3：
输入：n = 4
输出：true
解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -> 0）。
示例 4：
输入：n = 7
输出：false
解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。
如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 3 -> 2 -> 1 -> 0）。
如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 6 -> 2 -> 1 -> 0）。
示例 5：
输入：n = 17
输出：false
解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。
  提示：
1 <= n <= 10^5",44,,6402,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",[],10799
评论 (150),customer-order-frequency,Unknown,,-1,,-1,[],[],-1
评论 (316),number-of-good-pairs,简单,"给你一个整数数组 nums 。
如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 。
返回好数对的数目。
  示例 1：
输入：nums = [1,2,3,1,1,3]
输出：4
解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始
示例 2：
输入：nums = [1,1,1,1]
输出：6
解释：数组中的每组数字都是好数对
示例 3：
输入：nums = [1,2,3]
输出：0
  提示：
1 <= nums.length <= 100
1 <= nums[i] <= 100",87,,64949,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/counting/']",[],76587
评论 (86),number-of-substrings-with-only-1s,中等,"给你一个二进制字符串 s（仅由 '0' 和 '1' 组成的字符串）。
返回所有字符都为 1 的子字符串的数目。
由于答案可能很大，请你将它对 10^9 + 7 取模后返回。
  示例 1：
输入：s = ""0110111""
输出：9
解释：共有 9 个子字符串仅由 '1' 组成
""1"" -> 5 次
""11"" -> 3 次
""111"" -> 1 次
示例 2：
输入：s = ""101""
输出：2
解释：子字符串 ""1"" 在 s 中共出现 2 次
示例 3：
输入：s = ""111111""
输出：21
解释：每个子字符串都仅由 '1' 组成
示例 4：
输入：s = ""000""
输出：0
  提示：
s[i] == '0' 或 s[i] == '1'
1 <= s.length <= 10^5",22,,12363,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],31995
评论 (149),path-with-maximum-probability,中等,"给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。
指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。
如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。
  示例 1：
输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
输出：0.25000
解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25
示例 2：
输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
输出：0.30000
示例 3：
输入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
输出：0.00000
解释：节点 0 和 节点 2 之间不存在路径
  提示：
2 <= n <= 10^4
0 <= start, end < n
start != end
0 <= a, b < n
a != b
0 <= succProb.length == edges.length <= 2*10^4
0 <= succProb[i] <= 1
每两个节点之间最多有一条边",104,,12464,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/shortest-path/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],33885
评论,best-position-for-a-service-centre,困难,"一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 到所有客户的欧几里得距离的总和最小 。
给你一个数组 positions ，其中 positions[i] = [xi, yi] 表示第 i 个客户在二维地图上的位置，返回到所有客户的 欧几里得距离的最小总和 。
换句话说，请你为服务中心选址，该位置的坐标 [xcentre, ycentre] 需要使下面的公式取到最小值：
与真实值误差在 10-5之内的答案将被视作正确答案。
  示例 1：
输入：positions = [[0,1],[1,0],[1,2],[2,1]]
输出：4.00000
解释：如图所示，你可以选 [xcentre, ycentre] = [1, 1] 作为新中心的位置，这样一来到每个客户的距离就都是 1，所有距离之和为 4 ，这也是可以找到的最小值。
示例 2：
输入：positions = [[1,1],[3,3]]
输出：2.82843
解释：欧几里得距离可能的最小总和为 sqrt(2) + sqrt(2) = 2.82843
  提示：
1 <= positions.length <= 50
positions[i].length == 2
0 <= xi, yi <= 100",45,,3707,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/randomized/']",[],10622
评论,move-sub-tree-of-n-ary-tree,Unknown,,-1,,-1,[],[],-1
评论,find-users-with-valid-e-mails,Unknown,,-1,,-1,[],[],-1
评论 (602),water-bottles,简单,"小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。
如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。
请你计算 最多 能喝到多少瓶酒。
  示例 1：
输入：numBottles = 9, numExchange = 3
输出：13
解释：你可以用 3 个空酒瓶兑换 1 瓶酒。
所以最多能喝到 9 + 3 + 1 = 13 瓶酒。
示例 2：
输入：numBottles = 15, numExchange = 4
输出：19
解释：你可以用 4 个空酒瓶兑换 1 瓶酒。
所以最多能喝到 15 + 3 + 1 = 19 瓶酒。
示例 3：
输入：numBottles = 5, numExchange = 5
输出：6
示例 4：
输入：numBottles = 2, numExchange = 3
输出：2
  提示：
1 <= numBottles <= 100
2 <= numExchange <= 100",138,,56260,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],80118
评论 (107),number-of-nodes-in-the-sub-tree-with-the-same-label,中等,"给你一棵树（即，一个连通的无环无向图），这棵树由编号从 0  到 n - 1 的 n 个节点组成，且恰好有 n - 1 条 edges 。树的根节点为节点 0 ，树上的每一个节点都有一个标签，也就是字符串 labels 中的一个小写字符（编号为 i 的 节点的标签就是 labels[i] ）
边数组 edges 以 edges[i] = [ai, bi] 的形式给出，该格式表示节点 ai 和 bi 之间存在一条边。
返回一个大小为 n 的数组，其中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数。
树 T 中的子树是由 T 中的某个节点及其所有后代节点组成的树。
  示例 1：
输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = ""abaedcd""
输出：[2,1,1,1,1,1,1]
解释：节点 0 的标签为 'a' ，以 'a' 为根节点的子树中，节点 2 的标签也是 'a' ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。
节点 1 的标签为 'b' ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。
示例 2：
输入：n = 4, edges = [[0,1],[1,2],[0,3]], labels = ""bbbb""
输出：[4,2,1,1]
解释：节点 2 的子树中只有节点 2 ，所以答案为 1 。
节点 3 的子树中只有节点 3 ，所以答案为 1 。
节点 1 的子树中包含节点 1 和 2 ，标签都是 'b' ，因此答案为 2 。
节点 0 的子树中包含节点 0、1、2 和 3，标签都是 'b'，因此答案为 4 。
示例 3：
输入：n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = ""aabab""
输出：[3,2,1,1,1]
  提示：
1 <= n <= 10^5
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
labels.length == n
labels 仅由小写英文字母组成",57,,6202,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],19991
评论 (47),maximum-number-of-non-overlapping-substrings,困难,"给你一个只包含小写字母的字符串 s ，你需要找到 s 中最多数目的非空子字符串，满足如下条件：
这些字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[x..y] ，要么 j < x 要么 i > y 。
如果一个子字符串包含字符 char ，那么 s 中所有 char 字符都应该在这个子字符串中。
请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。
请注意，你可以以 任意 顺序返回最优解的子字符串。
  示例 1：
输入：s = ""adefaddaccc""
输出：[""e"",""f"",""ccc""]
解释：下面为所有满足第二个条件的子字符串：
[
  ""adefaddaccc""
  ""adefadda"",
  ""ef"",
  ""e"",
  ""f"",
  ""ccc"",
]
如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 ""adefadda"" ，剩下子字符串中我们只可以选择 ""ccc"" ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 ""ef"" 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 [""e"",""f"",""ccc""] ，答案为 3 。不存在别的相同数目子字符串解。
示例 2：
输入：s = ""abbaccd""
输出：[""d"",""bb"",""cc""]
解释：注意到解 [""d"",""abba"",""cc""] 答案也为 3 ，但它不是最优解，因为它的总长度更长。
  提示：
1 <= s.length <= 10^5
s 只包含小写英文字母。",72,,2800,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],8205
评论 (49),find-a-value-of-a-mysterious-function-closest-to-target,困难,"Winston 构造了一个如上所示的函数 func 。他有一个整数数组 arr 和一个整数 target ，他想找到让 |func(arr, l, r) - target| 最小的 l 和 r 。
请你返回 |func(arr, l, r) - target| 的最小值。
请注意， func 的输入参数 l 和 r 需要满足 0 <= l, r < arr.length 。
  示例 1：
输入：arr = [9,12,3,7,15], target = 5
输出：2
解释：所有可能的 [l,r] 数对包括 [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]]， Winston 得到的相应结果为 [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0] 。最接近 5 的值是 7 和 3，所以最小差值为 2 。
示例 2：
输入：arr = [1000000,1000000,1000000], target = 1
输出：999999
解释：Winston 输入函数的所有可能 [l,r] 数对得到的函数值都为 1000000 ，所以最小差值为 999999 。
示例 3：
输入：arr = [1,2,4,8,16], target = 0
输出：0
  提示：
1 <= arr.length <= 10^5
1 <= arr[i] <= 10^6
0 <= target <= 10^7",46,,3021,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],7553
评论 (22),diameter-of-n-ary-tree,Unknown,,-1,,-1,[],[],-1
评论 (185),count-odd-numbers-in-an-interval-range,简单,"给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。
  示例 1：
输入：low = 3, high = 7
输出：3
解释：3 到 7 之间奇数数字为 [3,5,7] 。
示例 2：
输入：low = 8, high = 10
输出：1
解释：8 到 10 之间奇数数字为 [9] 。
  提示：
0 <= low <= high <= 10^9",50,,26112,['https://leetcode.cn/tag/math/'],[],51185
评论 (94),number-of-sub-arrays-with-odd-sum,中等,"给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。
由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。
  示例 1：
输入：arr = [1,3,5]
输出：4
解释：所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。
所有子数组的和为 [1,4,9,3,8,5].
奇数和包括 [1,9,3,5] ，所以答案为 4 。
示例 2 ：
输入：arr = [2,4,6]
输出：0
解释：所有子数组为 [[2],[2,4],[2,4,6],[4],[4,6],[6]] 。
所有子数组和为 [2,6,12,4,10,6] 。
所有子数组和都是偶数，所以答案为 0 。
示例 3：
输入：arr = [1,2,3,4,5,6,7]
输出：16
示例 4：
输入：arr = [100,100,99,99]
输出：4
示例 5：
输入：arr = [7]
输出：1
  提示：
1 <= arr.length <= 10^5
1 <= arr[i] <= 100",48,,6883,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/prefix-sum/']",[],15577
评论 (65),number-of-good-ways-to-split-a-string,中等,"给你一个字符串 s ，一个分割被称为 「好分割」 当它满足：将 s 分割成 2 个字符串 p 和 q ，它们连接起来等于 s 且 p 和 q 中不同字符的数目相同。
请你返回 s 中好分割的数目。
  示例 1：
输入：s = ""aacaba""
输出：2
解释：总共有 5 种分割字符串 ""aacaba"" 的方法，其中 2 种是好分割。
(""a"", ""acaba"") 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。
(""aa"", ""caba"") 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。
(""aac"", ""aba"") 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。
(""aaca"", ""ba"") 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。
(""aacab"", ""a"") 左边字符串和右边字符串分别包含 3 个和 1 个不同的字符。
示例 2：
输入：s = ""abcd""
输出：1
解释：好分割为将字符串分割成 (""ab"", ""cd"") 。
示例 3：
输入：s = ""aaaaa""
输出：4
解释：所有分割都是好分割。
示例 4：
输入：s = ""acbadbaada""
输出：2
  提示：
s 只包含小写英文字母。
1 <= s.length <= 10^5",36,,6670,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],10127
评论 (42),minimum-number-of-increments-on-subarrays-to-form-a-target-array,困难,"给你一个整数数组 target 和一个数组 initial ，initial 数组与 target  数组有同样的维度，且一开始全部为 0 。
请你返回从 initial 得到  target 的最少操作次数，每次操作需遵循以下规则：
在 initial 中选择 任意 子数组，并将子数组中每个元素增加 1 。
答案保证在 32 位有符号整数以内。
  示例 1：
输入：target = [1,2,3,2,1]
输出：3
解释：我们需要至少 3 次操作从 intial 数组得到 target 数组。
[0,0,0,0,0] 将下标为 0 到 4 的元素（包含二者）加 1 。
[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。
[1,2,2,2,1] 将下表为 2 的元素增加 1 。
[1,2,3,2,1] 得到了目标数组。
示例 2：
输入：target = [3,1,1,2]
输出：4
解释：(initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target) 。
示例 3：
输入：target = [3,1,5,4,2]
输出：7
解释：(initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] 
                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target)。
示例 4：
输入：target = [1,1,1,1]
输出：1
  提示：
1 <= target.length <= 10^5
1 <= target[i] <= 10^5",55,,3915,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/monotonic-stack/']",[],6163
评论 (117),patients-with-a-condition,简单,"SQL架构
患者信息表： Patients
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| patient_id   | int     |
| patient_name | varchar |
| conditions   | varchar |
+--------------+---------+
patient_id （患者 ID）是该表的主键。
'conditions' （疾病）包含 0 个或以上的疾病代码，以空格分隔。
这个表包含医院中患者的信息。
  写一条 SQL 语句，查询患有 I 类糖尿病的患者 ID （patient_id）、患者姓名（patient_name）以及其患有的所有疾病代码（conditions）。I 类糖尿病的代码总是包含前缀 DIAB1 。
按 任意顺序 返回结果表。
查询结果格式如下示例所示。
  示例 1:
输入：
Patients表：
+------------+--------------+--------------+
| patient_id | patient_name | conditions   |
+------------+--------------+--------------+
| 1          | Daniel       | YFEV COUGH   |
| 2          | Alice        |              |
| 3          | Bob          | DIAB100 MYOP |
| 4          | George       | ACNE DIAB100 |
| 5          | Alain        | DIAB201      |
+------------+--------------+--------------+
输出：
+------------+--------------+--------------+
| patient_id | patient_name | conditions   |
+------------+--------------+--------------+
| 3          | Bob          | DIAB100 MYOP |
| 4          | George       | ACNE DIAB100 | 
+------------+--------------+--------------+
解释：Bob 和 George 都患有代码以 DIAB1 开头的疾病。",38,,13651,['https://leetcode.cn/tag/database/'],[],27986
评论 (190),shuffle-string,简单,"给你一个字符串 s 和一个 长度相同 的整数数组 indices 。
请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置。
返回重新排列后的字符串。
  示例 1：
输入：s = ""codeleet"", indices = [4,5,6,7,0,2,1,3]
输出：""leetcode""
解释：如图所示，""codeleet"" 重新排列后变为 ""leetcode"" 。
示例 2：
输入：s = ""abc"", indices = [0,1,2]
输出：""abc""
解释：重新排列后，每个字符都还留在原来的位置上。
  提示：
s.length == indices.length == n
1 <= n <= 100
s 仅包含小写英文字母
0 <= indices[i] < n
indices 的所有的值都是 唯一 的",43,,33632,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],42785
评论 (80),minimum-suffix-flips,中等,"给你一个长度为 n 、下标从 0 开始的二进制字符串 target 。你自己有另一个长度为 n 的二进制字符串 s ，最初每一位上都是 0 。你想要让 s 和 target 相等。
在一步操作，你可以选择下标 i（0 <= i < n）并翻转在 闭区间 [i, n - 1] 内的所有位。翻转意味着 '0' 变为 '1' ，而 '1' 变为 '0' 。
返回使 s 与 target 相等需要的最少翻转次数。
  示例 1：
输入：target = ""10111""
输出：3
解释：最初，s = ""00000"" 。
选择下标 i = 2: ""00000"" -> ""00111""
选择下标 i = 0: ""00111"" -> ""11000""
选择下标 i = 1: ""11000"" -> ""10111""
要达成目标，需要至少 3 次翻转。
示例 2：
输入：target = ""101""
输出：3
解释：最初，s = ""000"" 。
选择下标 i = 0: ""000"" -> ""111""
选择下标 i = 1: ""111"" -> ""100""
选择下标 i = 2: ""100"" -> ""101""
要达成目标，需要至少 3 次翻转。
示例 3：
输入：target = ""00000""
输出：0
解释：由于 s 已经等于目标，所以不需要任何操作
  提示：
n == target.length
1 <= n <= 105
target[i] 为 '0' 或 '1'",42,,9971,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],14304
评论 (105),number-of-good-leaf-nodes-pairs,中等,"给你二叉树的根节点 root 和一个整数 distance 。
如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。
返回树中 好叶子节点对的数量 。
  示例 1：
  输入：root = [1,2,3,null,4], distance = 3
输出：1
解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。
示例 2：
输入：root = [1,2,3,4,5,6,7], distance = 3
输出：2
解释：好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。
示例 3：
输入：root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
输出：1
解释：唯一的好叶子节点对是 [2,5] 。
示例 4：
输入：root = [100], distance = 1
输出：0
示例 5：
输入：root = [1,1,1], distance = 2
输出：1
  提示：
tree 的节点数在 [1, 2^10] 范围内。
每个节点的值都在 [1, 100] 之间。
1 <= distance <= 10",107,,9881,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],17115
评论 (33),string-compression-ii,困难,"行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 ""aabccc"" ，将 ""aa"" 替换为 ""a2"" ，""ccc"" 替换为` ""c3"" 。因此压缩后的字符串变为 ""a2bc3"" 。
注意，本问题中，压缩时没有在单个字符后附加计数 '1' 。
给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。
请你返回删除最多 k 个字符后，s 行程长度编码的最小长度 。
  示例 1：
输入：s = ""aaabcccd"", k = 2
输出：4
解释：在不删除任何内容的情况下，压缩后的字符串是 ""a3bc3d"" ，长度为 6 。最优的方案是删除 'b' 和 'd'，这样一来，压缩后的字符串为 ""a3c3"" ，长度是 4 。
示例 2：
输入：s = ""aabbaa"", k = 2
输出：2
解释：如果删去两个 'b' 字符，那么压缩后的字符串是长度为 2 的 ""a4"" 。
示例 3：
输入：s = ""aaaaaaaaaaa"", k = 0
输出：3
解释：由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 ""a11"" ，长度为 3 。
  提示：
1 <= s.length <= 100
0 <= k <= s.length
s 仅包含小写英文字母",84,,2358,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],6555
评论 (130),the-most-recent-three-orders,Unknown,,-1,,-1,[],[],-1
评论 (11),find-the-index-of-the-large-integer,Unknown,,-1,,-1,[],[],-1
评论 (99),count-good-triplets,简单,"给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。
如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。
0 <= i < j < k < arr.length
|arr[i] - arr[j]| <= a
|arr[j] - arr[k]| <= b
|arr[i] - arr[k]| <= c
其中 |x| 表示 x 的绝对值。
返回 好三元组的数量 。
  示例 1：
输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
输出：4
解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。
示例 2：
输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1
输出：0
解释：不存在满足所有条件的三元组。
  提示：
3 <= arr.length <= 100
0 <= arr[i] <= 1000
0 <= a, b, c <= 1000",37,,20257,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/enumeration/']",[],25963
评论 (95),find-the-winner-of-an-array-game,中等,"给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。
每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。
返回赢得比赛的整数。
题目数据 保证 游戏存在赢家。
  示例 1：
输入：arr = [2,1,3,5,4,6,7], k = 2
输出：5
解释：一起看一下本场游戏每回合的情况：

因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。
示例 2：
输入：arr = [3,2,1], k = 10
输出：3
解释：3 将会在前 10 个回合中连续获胜。
示例 3：
输入：arr = [1,9,8,2,3,7,6,4,5], k = 7
输出：9
示例 4：
输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000
输出：99
  提示：
2 <= arr.length <= 10^5
1 <= arr[i] <= 10^6
arr 所含的整数 各不相同 。
1 <= k <= 10^9",38,,14610,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],31858
评论 (60),minimum-swaps-to-arrange-a-binary-grid,中等,"给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换。
一个符合要求的网格需要满足主对角线以上的格子全部都是 0 。
请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 。
主对角线指的是从 (1, 1) 到 (n, n) 的这些格子。
  示例 1：
输入：grid = [[0,0,1],[1,1,0],[1,0,0]]
输出：3
示例 2：
输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]
输出：-1
解释：所有行都是一样的，交换相邻行无法使网格符合要求。
示例 3：
输入：grid = [[1,0,0],[1,1,0],[1,1,1]]
输出：0
  提示：
n == grid.length
n == grid[i].length
1 <= n <= 200
grid[i][j] 要么是 0 要么是 1 。",44,,4521,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],10089
评论 (78),get-the-maximum-score,困难,"你有两个 有序 且数组内元素互不相同的数组 nums1 和 nums2 。
一条 合法路径 定义如下：
选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。
从左到右遍历当前数组。
如果你遇到了 nums1 和 nums2 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。
得分定义为合法路径中不同数字的和。
请你返回所有可能合法路径中的最大得分。
由于答案可能很大，请你将它对 10^9 + 7 取余后返回。
  示例 1：
输入：nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]
输出：30
解释：合法路径包括：
[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）
[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）
最大得分为上图中的绿色路径 [2,4,6,8,10] 。
示例 2：
输入：nums1 = [1,3,5,7,9], nums2 = [3,5,100]
输出：109
解释：最大得分由路径 [1,3,5,100] 得到。
示例 3：
输入：nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]
输出：40
解释：nums1 和 nums2 之间无相同数字。
最大得分由路径 [6,7,8,9,10] 得到。
示例 4：
输入：nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]
输出：61
  提示：
1 <= nums1.length <= 10^5
1 <= nums2.length <= 10^5
1 <= nums1[i], nums2[i] <= 10^7
nums1 和 nums2 都是严格递增的数组。",55,,5198,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/dynamic-programming/']",[],13818
评论 (2),guess-the-majority-in-a-hidden-array,Unknown,,-1,,-1,[],[],-1
评论 (191),kth-missing-positive-number,简单,"给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。
请你找到这个数组里第 k 个缺失的正整数。
  示例 1：
输入：arr = [2,3,4,7,11], k = 5
输出：9
解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。
示例 2：
输入：arr = [1,2,3,4], k = 2
输出：6
解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。
  提示：
1 <= arr.length <= 1000
1 <= arr[i] <= 1000
1 <= k <= 1000
对于所有 1 <= i < j <= arr.length 的 i 和 j 满足 arr[i] < arr[j] ",107,,26075,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],48316
评论 (71),can-convert-string-in-k-moves,中等,"给你两个字符串 s 和 t ，你的目标是在 k 次操作以内把字符串 s 转变成 t 。
在第 i 次操作时（1 <= i <= k），你可以选择进行如下操作：
选择字符串 s 中满足 1 <= j <= s.length 且之前未被选过的任意下标 j （下标从 1 开始），并将此位置的字符切换 i 次。
不进行任何操作。
切换 1 个字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以 'z' 切换后会变成 'a'）。第 i 次操作意味着该字符应切换 i 次
请记住任意一个下标 j 最多只能被操作 1 次。
如果在不超过 k 次操作内可以把字符串 s 转变成 t ，那么请你返回 true ，否则请你返回 false 。
  示例 1：
输入：s = ""input"", t = ""ouput"", k = 9
输出：true
解释：第 6 次操作时，我们将 'i' 切换 6 次得到 'o' 。第 7 次操作时，我们将 'n' 切换 7 次得到 'u' 。
示例 2：
输入：s = ""abc"", t = ""bcd"", k = 10
输出：false
解释：我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 'a' 切换成 'b' ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母。
示例 3：
输入：s = ""aab"", t = ""bbb"", k = 27
输出：true
解释：第 1 次操作时，我们将第一个 'a' 切换 1 次得到 'b' 。在第 27 次操作时，我们将第二个字母 'a' 切换 27 次得到 'b' 。
  提示：
1 <= s.length, t.length <= 10^5
0 <= k <= 10^9
s 和 t 只包含小写英文字母。",15,,5475,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],17029
评论 (98),minimum-insertions-to-balance-a-parentheses-string,中等,"给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足：
任何左括号 '(' 必须对应两个连续的右括号 '))' 。
左括号 '(' 必须在对应的连续两个右括号 '))' 之前。
比方说 ""())""， ""())(())))"" 和 ""(())())))"" 都是平衡的， "")()""， ""()))"" 和 ""(()))"" 都是不平衡的。
你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。
请你返回让 s 平衡的最少插入次数。
  示例 1：
输入：s = ""(()))""
输出：1
解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 ""(())))"" 。
示例 2：
输入：s = ""())""
输出：0
解释：字符串已经平衡了。
示例 3：
输入：s = ""))())(""
输出：3
解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。
示例 4：
输入：s = ""((((((""
输出：12
解释：添加 12 个 ')' 得到平衡字符串。
示例 5：
输入：s = "")))))))""
输出：5
解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 ""(((())))))))"" 。
  提示：
1 <= s.length <= 10^5
s 只包含 '(' 和 ')' 。",45,,11464,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],23782
评论 (53),find-longest-awesome-substring,困难,"给你一个字符串 s 。请返回 s 中最长的 超赞子字符串 的长度。
「超赞子字符串」需满足满足下述两个条件：
该字符串是 s 的一个非空子字符串
进行任意次数的字符交换后，该字符串可以变成一个回文字符串
  示例 1：
输入：s = ""3242415""
输出：5
解释：""24241"" 是最长的超赞子字符串，交换其中的字符后，可以得到回文 ""24142""
示例 2：
输入：s = ""12345678""
输出：1
示例 3：
输入：s = ""213123""
输出：6
解释：""213123"" 是最长的超赞子字符串，交换其中的字符后，可以得到回文 ""231132""
示例 4：
输入：s = ""00""
输出：2
  提示：
1 <= s.length <= 10^5
s 仅由数字组成",60,,3166,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],7808
评论 (79),fix-product-name-format,Unknown,,-1,,-1,[],[],-1
评论 (204),make-the-string-great,简单,"给你一个由大小写英文字母组成的字符串 s 。
一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0<= i <= s.length-2 ，要满足如下条件:
若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。
若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。
请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。
请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。
注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。
  示例 1：
输入：s = ""leEeetcode""
输出：""leetcode""
解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 ""leEeetcode"" 缩减为 ""leetcode"" 。
示例 2：
输入：s = ""abBAcC""
输出：""""
解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：
""abBAcC"" --> ""aAcC"" --> ""cC"" --> """"
""abBAcC"" --> ""abBA"" --> ""aA"" --> """"
示例 3：
输入：s = ""s""
输出：""s""
  提示：
1 <= s.length <= 100
s 只包含小写和大写英文字母",44,,23249,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],41975
评论 (88),find-kth-bit-in-nth-binary-string,中等,"给你两个正整数 n 和 k，二进制字符串  Sn 的形成规则如下：
S1 = ""0""
当 i > 1 时，Si = Si-1 + ""1"" + reverse(invert(Si-1))
其中 + 表示串联操作，reverse(x) 返回反转 x 后得到的字符串，而 invert(x) 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0）。
例如，符合上述描述的序列的前 4 个字符串依次是：
S1 = ""0""
S2 = ""011""
S3 = ""0111001""
S4 = ""011100110110001""
请你返回  Sn 的 第 k 位字符 ，题目数据保证 k 一定在 Sn 长度范围以内。
  示例 1：
输入：n = 3, k = 1
输出：""0""
解释：S3 为 ""0111001""，其第 1 位为 ""0"" 。
示例 2：
输入：n = 4, k = 11
输出：""1""
解释：S4 为 ""011100110110001""，其第 11 位为 ""1"" 。
示例 3：
输入：n = 1, k = 1
输出：""0""
示例 4：
输入：n = 2, k = 3
输出：""1""
  提示：
1 <= n <= 20
1 <= k <= 2n - 1",29,,8423,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/string/']",[],15128
评论 (105),maximum-number-of-non-overlapping-subarrays-with-sum-equals-target,中等,"给你一个数组 nums 和一个整数 target 。
请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 target 。
  示例 1：
输入：nums = [1,1,1,1,1], target = 2
输出：2
解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 。
示例 2：
输入：nums = [-1,3,5,1,4,2,-9], target = 6
输出：2
解释：总共有 3 个子数组和为 6 。
([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。
示例 3：
输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10
输出：3
示例 4：
输入：nums = [0,0,0], target = 0
输出：3
  提示：
1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
0 <= target <= 10^6",79,,6013,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']",[],14052
评论 (57),minimum-cost-to-cut-a-stick,困难,"有一根长度为 n 个单位的木棍，棍上从 0 到 n 标记了若干位置。例如，长度为 6 的棍子可以标记如下：
给你一个整数数组 cuts ，其中 cuts[i] 表示你需要将棍子切开的位置。
你可以按顺序完成切割，也可以根据需要更改切割的顺序。
每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。
返回切棍子的 最小总成本 。
  示例 1：
输入：n = 7, cuts = [1,3,4,5]
输出：16
解释：按 [1, 3, 4, 5] 的顺序切割的情况如下所示：

第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。
而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。
示例 2：
输入：n = 9, cuts = [5,6,1,4,2]
输出：22
解释：如果按给定的顺序切割，则总成本为 25 。总成本 <= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。
  提示：
2 <= n <= 10^6
1 <= cuts.length <= min(n - 1, 100)
1 <= cuts[i] <= n - 1
cuts 数组中的所有整数都 互不相同",68,,4778,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],8667
评论 (8),the-most-similar-path-in-a-graph,Unknown,,-1,,-1,[],[],-1
评论 (115),the-most-recent-orders-for-each-product,Unknown,,-1,,-1,[],[],-1
评论 (166),three-consecutive-odds,简单,"给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。
  示例 1：
输入：arr = [2,6,4,1]
输出：false
解释：不存在连续三个元素都是奇数的情况。
示例 2：
输入：arr = [1,2,34,3,4,5,7,23,12]
输出：true
解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。
  提示：
1 <= arr.length <= 1000
1 <= arr[i] <= 1000",17,,24379,['https://leetcode.cn/tag/array/'],[],37174
评论 (123),minimum-operations-to-make-array-equal,中等,"存在一个长度为 n 的数组 arr ，其中 arr[i] = (2 * i) + 1 （ 0 <= i < n ）。
一次操作中，你可以选出两个下标，记作 x 和 y （ 0 <= x, y < n ）并使 arr[x] 减去 1 、arr[y] 加上 1 （即 arr[x] -=1 且 arr[y] += 1 ）。最终的目标是使数组中的所有元素都 相等 。题目测试用例将会 保证 ：在执行若干步操作后，数组中的所有元素最终可以全部相等。
给你一个整数 n，即数组的长度。请你返回使数组 arr 中所有元素相等所需的 最小操作数 。
  示例 1：
输入：n = 3
输出：2
解释：arr = [1, 3, 5]
第一次操作选出 x = 2 和 y = 0，使数组变为 [2, 3, 4]
第二次操作继续选出 x = 2 和 y = 0，数组将会变成 [3, 3, 3]
示例 2：
输入：n = 6
输出：9
  提示：
1 <= n <= 10^4",30,,12751,['https://leetcode.cn/tag/math/'],[],15592
评论 (126),magnetic-force-between-two-balls,中等,"在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。
已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。
给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。
  示例 1：
输入：position = [1,2,3,4,7], m = 3
输出：3
解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。
示例 2：
输入：position = [5,4,3,2,1,1000000000], m = 2
输出：999999999
解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。
  提示：
n == position.length
2 <= n <= 10^5
1 <= position[i] <= 10^9
所有 position 中的整数 互不相同 。
2 <= m <= position.length",105,,12121,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],22802
评论 (158),minimum-number-of-days-to-eat-n-oranges,困难,"厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子：
吃掉一个橘子。
如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。
如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。
每天你只能从以上 3 种方案中选择一种方案。
请你返回吃掉所有 n 个橘子的最少天数。
  示例 1：
输入：n = 10
输出：4
解释：你总共有 10 个橘子。
第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。
第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）
第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。
第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。
你需要至少 4 天吃掉 10 个橘子。
示例 2：
输入：n = 6
输出：3
解释：你总共有 6 个橘子。
第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）
第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）
第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。
你至少需要 3 天吃掉 6 个橘子。
示例 3：
输入：n = 1
输出：1
示例 4：
输入：n = 56
输出：6
  提示：
1 <= n <= 2*10^9",113,,8913,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/dynamic-programming/']",[],28916
评论 (22),strings-differ-by-one-character,Unknown,,-1,,-1,[],[],-1
评论 (107),bank-account-summary,Unknown,,-1,,-1,[],[],-1
评论 (96),thousand-separator,简单,"给你一个整数 n，请你每隔三位添加点（即 ""."" 符号）作为千位分隔符，并将结果以字符串格式返回。
  示例 1：
输入：n = 987
输出：""987""
示例 2：
输入：n = 1234
输出：""1.234""
示例 3：
输入：n = 123456789
输出：""123.456.789""
示例 4：
输入：n = 0
输出：""0""
  提示：
0 <= n < 2^31",20,,14442,['https://leetcode.cn/tag/string/'],[],25395
评论 (116),minimum-number-of-vertices-to-reach-all-nodes,中等,"给你一个 有向无环图 ， n 个节点编号为 0 到 n-1 ，以及一个边数组 edges ，其中 edges[i] = [fromi, toi] 表示一条从点  fromi 到点 toi 的有向边。
找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。
你可以以任意顺序返回这些节点编号。
  示例 1：
输入：n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
输出：[0,3]
解释：从单个节点出发无法到达所有节点。从 0 出发我们可以到达 [0,1,2,5] 。从 3 出发我们可以到达 [3,4,2,5] 。所以我们输出 [0,3] 。
示例 2：
输入：n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]
输出：[0,2,3]
解释：注意到节点 0，3 和 2 无法从其他节点到达，所以我们必须将它们包含在结果点集中，这些点都能到达节点 1 和 4 。
  提示：
2 <= n <= 10^5
1 <= edges.length <= min(10^5, n * (n - 1) / 2)
edges[i].length == 2
0 <= fromi, toi < n
所有点对 (fromi, toi) 互不相同。",46,,12280,['https://leetcode.cn/tag/graph/'],[],15373
评论 (64),minimum-numbers-of-function-calls-to-make-target-array,中等,"给你一个与 nums 大小相同且初始值全为 0 的数组 arr ，请你调用以上函数得到整数数组 nums 。
请你返回将 arr 变成 nums 的最少函数调用次数。
答案保证在 32 位有符号整数以内。
  示例 1：
输入：nums = [1,5]
输出：5
解释：给第二个数加 1 ：[0, 0] 变成 [0, 1] （1 次操作）。
将所有数字乘以 2 ：[0, 1] -> [0, 2] -> [0, 4] （2 次操作）。
给两个数字都加 1 ：[0, 4] -> [1, 4] -> [1, 5] （2 次操作）。
总操作次数为：1 + 2 + 2 = 5 。
示例 2：
输入：nums = [2,2]
输出：3
解释：给两个数字都加 1 ：[0, 0] -> [0, 1] -> [1, 1] （2 次操作）。
将所有数字乘以 2 ： [1, 1] -> [2, 2] （1 次操作）。
总操作次数为： 2 + 1 = 3 。
示例 3：
输入：nums = [4,2,5]
输出：6
解释：（初始）[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5] （nums 数组）。
示例 4：
输入：nums = [3,2,2,4]
输出：7
示例 5：
输入：nums = [2,4,8,16]
输出：8
  提示：
1 <= nums.length <= 10^5
0 <= nums[i] <= 10^9",34,,5220,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],8336
评论 (59),detect-cycles-in-2d-grid,中等,"给你一个二维字符网格数组 grid ，大小为 m x n ，你需要检查 grid 中是否存在 相同值 形成的环。
一个环是一条开始和结束于同一个格子的长度 大于等于 4 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 相同的值 。
同时，你也不能回到上一次移动时所在的格子。比方说，环  (1, 1) -> (1, 2) -> (1, 1) 是不合法的，因为从 (1, 2) 移动到 (1, 1) 回到了上一次移动时的格子。
如果 grid 中有相同值形成的环，请你返回 true ，否则返回 false 。
  示例 1：
输入：grid = [[""a"",""a"",""a"",""a""],[""a"",""b"",""b"",""a""],[""a"",""b"",""b"",""a""],[""a"",""a"",""a"",""a""]]
输出：true
解释：如下图所示，有 2 个用不同颜色标出来的环：
示例 2：
输入：grid = [[""c"",""c"",""c"",""a""],[""c"",""d"",""c"",""c""],[""c"",""c"",""e"",""c""],[""f"",""c"",""c"",""c""]]
输出：true
解释：如下图所示，只有高亮所示的一个合法环：
示例 3：
输入：grid = [[""a"",""b"",""b""],[""b"",""z"",""b""],[""b"",""b"",""a""]]
输出：false
  提示：
m == grid.length
n == grid[i].length
1 <= m <= 500
1 <= n <= 500
grid 只包含小写英文字母。",40,,4943,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],12888
评论 (79),most-visited-sector-in-a-circular-track,简单,"给你一个整数 n 和一个整数数组 rounds 。有一条圆形赛道由 n 个扇区组成，扇区编号从 1 到 n 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 m 个阶段组成。其中，第 i 个阶段将会从扇区 rounds[i - 1] 开始，到扇区 rounds[i] 结束。举例来说，第 1 阶段从 rounds[0] 开始，到 rounds[1] 结束。
请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。
注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。
  示例 1：
输入：n = 4, rounds = [1,3,1,2]
输出：[1,2]
解释：本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示：
1 --> 2 --> 3（阶段 1 结束）--> 4 --> 1（阶段 2 结束）--> 2（阶段 3 结束，即本场马拉松结束）
其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。扇区 3 和 4 都只经过了一次。
示例 2：
输入：n = 2, rounds = [2,1,2,1,2,1,2,1,2]
输出：[2]
示例 3：
输入：n = 7, rounds = [1,3,5,7]
输出：[1,2,3,4,5,6,7]
  提示：
2 <= n <= 100
1 <= m <= 100
rounds.length == m + 1
1 <= rounds[i] <= n
rounds[i] != rounds[i + 1] ，其中 0 <= i < m",33,,9874,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],17224
评论 (121),maximum-number-of-coins-you-can-get,中等,"有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：
每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。
Alice 将会取走硬币数量最多的那一堆。
你将会取走硬币数量第二多的那一堆。
Bob 将会取走最后一堆。
重复这个过程，直到没有更多硬币。
给你一个整数数组 piles ，其中 piles[i] 是第 i 堆中硬币的数目。
返回你可以获得的最大硬币数目。
  示例 1：
输入：piles = [2,4,1,2,7,8]
输出：9
解释：选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 7 枚硬币的那堆，Bob 取走最后一堆。
选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 2 枚硬币的那堆，Bob 取走最后一堆。
你可以获得的最大硬币数目：7 + 2 = 9.
考虑另外一种情况，如果选出的是 (1, 2, 8) 和 (2, 4, 7) ，你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。
示例 2：
输入：piles = [2,4,5]
输出：4
示例 3：
输入：piles = [9,8,7,6,5,1,2,3,4]
输出：18
  提示：
3 <= piles.length <= 10^5
piles.length % 3 == 0
1 <= piles[i] <= 10^4",25,,14024,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/game-theory/', 'https://leetcode.cn/tag/sorting/']",[],18052
评论 (115),find-latest-group-of-size-m,中等,"给你一个数组 arr ，该数组表示一个从 1 到 n 的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。
在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 arr[i] 的位将会设为 1 。
给你一个整数 m ，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。
返回存在长度 恰好 为 m 的 一组 1  的最后步骤。如果不存在这样的步骤，请返回 -1 。
  示例 1：
输入：arr = [3,5,1,2,4], m = 1
输出：4
解释：
步骤 1：""00100""，由 1 构成的组：[""1""]
步骤 2：""00101""，由 1 构成的组：[""1"", ""1""]
步骤 3：""10101""，由 1 构成的组：[""1"", ""1"", ""1""]
步骤 4：""11101""，由 1 构成的组：[""111"", ""1""]
步骤 5：""11111""，由 1 构成的组：[""11111""]
存在长度为 1 的一组 1 的最后步骤是步骤 4 。
示例 2：
输入：arr = [3,1,5,4,2], m = 2
输出：-1
解释：
步骤 1：""00100""，由 1 构成的组：[""1""]
步骤 2：""10100""，由 1 构成的组：[""1"", ""1""]
步骤 3：""10101""，由 1 构成的组：[""1"", ""1"", ""1""]
步骤 4：""10111""，由 1 构成的组：[""1"", ""111""]
步骤 5：""11111""，由 1 构成的组：[""11111""]
不管是哪一步骤都无法形成长度为 2 的一组 1 。
示例 3：
输入：arr = [1], m = 1
输出：1
示例 4：
输入：arr = [2,1], m = 2
输出：2
  提示：
n == arr.length
1 <= n <= 10^5
1 <= arr[i] <= n
arr 中的所有整数 互不相同
1 <= m <= arr.length",57,,5071,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/simulation/']",[],15442
评论 (99),stone-game-v,困难,"几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。
游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。
只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。
返回 Alice 能够获得的最大分数 。
  示例 1：
输入：stoneValue = [6,2,3,4,5,5]
输出：18
解释：在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。
在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。
最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。
示例 2：
输入：stoneValue = [7,7,7,7,7,7,7]
输出：28
示例 3：
输入：stoneValue = [4]
输出：0
  提示：
1 <= stoneValue.length <= 500
1 <= stoneValue[i] <= 10^6",45,,4633,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",[],11849
评论 (13),put-boxes-into-the-warehouse-i,Unknown,,-1,,-1,[],[],-1
评论 (76),unique-orders-and-customers-per-month,Unknown,,-1,,-1,[],[],-1
评论 (81),detect-pattern-of-length-m-repeated-k-or-more-times,简单,"给你一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。
模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。
如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true ，否则返回  false 。
  示例 1：
输入：arr = [1,2,4,4,4,4], m = 1, k = 3
输出：true
解释：模式 (4) 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。
示例 2：
输入：arr = [1,2,1,2,1,1,1,3], m = 2, k = 2
输出：true
解释：模式 (1,2) 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 (2,1) ，同样重复 2 次。
示例 3：
输入：arr = [1,2,1,2,1,3], m = 2, k = 3
输出：false
解释：模式 (1,2) 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。
示例 4：
输入：arr = [1,2,3,1,2], m = 2, k = 2
输出：false
解释：模式 (1,2) 出现 2 次但并不连续，所以不能算作连续重复 2 次。
示例 5：
输入：arr = [2,2,2,2], m = 2, k = 3
输出：false
解释：长度为 2 的模式只有 (2,2) ，但是只连续重复 2 次。注意，不能计算重叠的重复次数。
  提示：
2 <= arr.length <= 100
1 <= arr[i] <= 100
1 <= m <= 100
2 <= k <= 100",45,,9671,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/enumeration/']",[],21847
评论 (168),maximum-length-of-subarray-with-positive-product,中等,"给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。
一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。
请你返回乘积为正数的最长子数组长度。
  示例  1：
输入：nums = [1,-2,-3,4]
输出：4
解释：数组本身乘积就是正数，值为 24 。
示例 2：
输入：nums = [0,1,-2,-3,-4]
输出：3
解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。
示例 3：
输入：nums = [-1,-2,-3,0,1]
输出：2
解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。
  提示：
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
 ",156,,26673,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],63295
评论 (54),minimum-number-of-days-to-disconnect-island,困难,"给你一个由若干 0 和 1 组成的二维网格 grid ，其中 0 表示水，而 1 表示陆地。岛屿由水平方向或竖直方向上相邻的 1 （陆地）连接形成。
如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。
一天内，可以将任何单个陆地单元（1）更改为水单元（0）。
返回使陆地分离的最少天数。
  示例 1：
输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
输出：2
解释：至少需要 2 天才能得到分离的陆地。
将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。
示例 2：
输入：grid = [[1,1]]
输出：2
解释：如果网格中都是水，也认为是分离的 ([[1,1]] -> [[0,0]])，0 岛屿。
示例 3：
输入：grid = [[1,0,1,0]]
输出：0
示例 4：
输入：grid = [[1,1,0,1,1],
             [1,1,1,1,1],
             [1,1,0,1,1],
             [1,1,0,1,1]]
输出：1
示例 5：
输入：grid = [[1,1,0,1,1],
             [1,1,1,1,1],
             [1,1,0,1,1],
             [1,1,1,1,1]]
输出：2
  提示：
1 <= grid.length, grid[i].length <= 30
grid[i][j] 为 0 或 1",37,,3110,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/strongly-connected-component/']",[],6836
评论 (44),number-of-ways-to-reorder-array-to-get-same-bst,困难,"给你一个数组 nums 表示 1 到 n 的一个排列。我们按照元素在 nums 中的顺序依次插入一个初始为空的二叉查找树（BST）。请你统计将 nums 重新排序后，统计满足如下条件的方案数：重排后得到的二叉查找树与 nums 原本数字顺序得到的二叉查找树相同。
比方说，给你 nums = [2,1,3]，我们得到一棵 2 为根，1 为左孩子，3 为右孩子的树。数组 [2,3,1] 也能得到相同的 BST，但 [3,2,1] 会得到一棵不同的 BST 。
请你返回重排 nums 后，与原数组 nums 得到相同二叉查找树的方案数。
由于答案可能会很大，请将结果对 10^9 + 7 取余数。
  示例 1：
输入：nums = [2,1,3]
输出：1
解释：我们将 nums 重排， [2,3,1] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。
示例 2：
输入：nums = [3,4,5,1,2]
输出：5
解释：下面 5 个数组会得到相同的 BST：
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]
示例 3：
输入：nums = [1,2,3]
输出：0
解释：没有别的排列顺序能得到相同的 BST 。
示例 4：
输入：nums = [3,1,2,5,4,6]
输出：19
示例  5：
输入：nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18]
输出：216212978
解释：得到相同 BST 的方案数是 3216212999。将它对 10^9 + 7 取余后得到 216212978。
  提示：
1 <= nums.length <= 1000
1 <= nums[i] <= nums.length
nums 中所有数 互不相同 。",42,,2433,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/combinatorics/']",[],5126
评论 (17),dot-product-of-two-sparse-vectors,Unknown,,-1,,-1,[],[],-1
评论 (82),warehouse-manager,Unknown,,-1,,-1,[],[],-1
评论 (216),matrix-diagonal-sum,简单,"给你一个正方形矩阵 mat，请你返回矩阵对角线元素的和。
请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。
  示例  1：
输入：mat = [[1,2,3],
            [4,5,6],
            [7,8,9]]
输出：25
解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25
请注意，元素 mat[1][1] = 5 只会被计算一次。
示例  2：
输入：mat = [[1,1,1,1],
            [1,1,1,1],
            [1,1,1,1],
            [1,1,1,1]]
输出：8
示例 3：
输入：mat = [[5]]
输出：5
  提示：
n == mat.length == mat[i].length
1 <= n <= 100
1 <= mat[i][j] <= 100",51,,26667,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],33101
评论 (55),number-of-ways-to-split-a-string,中等,"给你一个二进制串 s  （一个只包含 0 和 1 的字符串），我们可以将 s 分割成 3 个 非空 字符串 s1, s2, s3 （s1 + s2 + s3 = s）。
请你返回分割 s 的方案数，满足 s1，s2 和 s3 中字符 '1' 的数目相同。
由于答案可能很大，请将它对 10^9 + 7 取余后返回。
  示例 1：
输入：s = ""10101""
输出：4
解释：总共有 4 种方法将 s 分割成含有 '1' 数目相同的三个子字符串。
""1|010|1""
""1|01|01""
""10|10|1""
""10|1|01""
示例 2：
输入：s = ""1001""
输出：0
示例 3：
输入：s = ""0000""
输出：3
解释：总共有 3 种分割 s 的方法。
""0|0|00""
""0|00|0""
""00|0|0""
示例 4：
输入：s = ""100100010100110""
输出：12
  提示：
s[i] == '0' 或者 s[i] == '1'
3 <= s.length <= 10^5",9,,5343,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],17596
评论 (80),shortest-subarray-to-be-removed-to-make-array-sorted,中等,"给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。
一个子数组指的是原数组中连续的一个子序列。
请你返回满足题目要求的最短子数组的长度。
  示例 1：
输入：arr = [1,2,3,10,4,2,3,5]
输出：3
解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。
另一个正确的解为删除子数组 [3,10,4] 。
示例 2：
输入：arr = [5,4,3,2,1]
输出：4
解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。
示例 3：
输入：arr = [1,2,3]
输出：0
解释：数组已经是非递减的了，我们不需要删除任何元素。
示例 4：
输入：arr = [1]
输出：0
  提示：
1 <= arr.length <= 10^5
0 <= arr[i] <= 10^9",78,,7200,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/monotonic-stack/']",[],20533
评论 (50),count-all-possible-routes,困难,"给你一个 互不相同 的整数数组，其中 locations[i] 表示第 i 个城市的位置。同时给你 start，finish 和 fuel 分别表示出发城市、目的地城市和你初始拥有的汽油总量
每一步中，如果你在城市 i ，你可以选择任意一个城市 j ，满足  j != i 且 0 <= j < locations.length ，并移动到城市 j 。从城市 i 移动到 j 消耗的汽油量为 |locations[i] - locations[j]|，|x| 表示 x 的绝对值。
请注意， fuel 任何时刻都 不能 为负，且你 可以 经过任意城市超过一次（包括 start 和 finish ）。
请你返回从 start 到 finish 所有可能路径的数目。
由于答案可能很大， 请将它对 10^9 + 7 取余后返回。
  示例 1：
输入：locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
输出：4
解释：以下为所有可能路径，每一条都用了 5 单位的汽油：
1 -> 3
1 -> 2 -> 3
1 -> 4 -> 3
1 -> 4 -> 2 -> 3
示例 2：
输入：locations = [4,3,1], start = 1, finish = 0, fuel = 6
输出：5
解释：以下为所有可能的路径：
1 -> 0，使用汽油量为 fuel = 1
1 -> 2 -> 0，使用汽油量为 fuel = 5
1 -> 2 -> 1 -> 0，使用汽油量为 fuel = 5
1 -> 0 -> 1 -> 0，使用汽油量为 fuel = 3
1 -> 0 -> 1 -> 0 -> 1 -> 0，使用汽油量为 fuel = 5
示例 3：
输入：locations = [5,2,1], start = 0, finish = 2, fuel = 3
输出：0
解释：没有办法只用 3 单位的汽油从 0 到达 2 。因为最短路径需要 4 单位的汽油。
  提示：
2 <= locations.length <= 100
1 <= locations[i] <= 109
所有 locations 中的整数 互不相同 。
0 <= start, finish < locations.length
1 <= fuel <= 200",65,,7302,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],12309
评论 (381),replace-all-s-to-avoid-consecutive-repeating-characters,简单,"给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。
注意：你 不能 修改非 '?' 字符。
题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。
在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。
  示例 1：
输入：s = ""?zs""
输出：""azs""
解释：该示例共有 25 种解决方案，从 ""azs"" 到 ""yzs"" 都是符合题目要求的。只有 ""z"" 是无效的修改，因为字符串 ""zzs"" 中有连续重复的两个 'z' 。
示例 2：
输入：s = ""ubv?w""
输出：""ubvaw""
解释：该示例共有 24 种解决方案，只有替换成 ""v"" 和 ""w"" 不符合题目要求。因为 ""ubvvw"" 和 ""ubvww"" 都包含连续重复的字符。
  提示：
1 <= s.length <= 100
s 仅包含小写英文字母和 '?' 字符",105,,49244,['https://leetcode.cn/tag/string/'],[],95740
评论 (86),number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers,中等,"给你两个整数数组 nums1 和 nums2 ，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）：
类型 1：三元组 (i, j, k) ，如果 nums1[i]2 == nums2[j] * nums2[k] 其中 0 <= i < nums1.length 且 0 <= j < k < nums2.length
类型 2：三元组 (i, j, k) ，如果 nums2[i]2 == nums1[j] * nums1[k] 其中 0 <= i < nums2.length 且 0 <= j < k < nums1.length
  示例 1：
输入：nums1 = [7,4], nums2 = [5,2,8,9]
输出：1
解释：类型 1：(1,1,2), nums1[1]^2 = nums2[1] * nums2[2] (4^2 = 2 * 8)
示例 2：
输入：nums1 = [1,1], nums2 = [1,1,1]
输出：9
解释：所有三元组都符合题目要求，因为 1^2 = 1 * 1
类型 1：(0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2), nums1[i]^2 = nums2[j] * nums2[k]
类型 2：(0,0,1), (1,0,1), (2,0,1), nums2[i]^2 = nums1[j] * nums1[k]
示例 3：
输入：nums1 = [7,7,8,3], nums2 = [1,2,9,7]
输出：2
解释：有两个符合题目要求的三元组
类型 1：(3,0,2), nums1[3]^2 = nums2[0] * nums2[2]
类型 2：(3,0,1), nums2[3]^2 = nums1[0] * nums1[1]
示例 4：
输入：nums1 = [4,7,9,11,23], nums2 = [3,5,1024,12,18]
输出：0
解释：不存在符合题目要求的三元组
  提示：
1 <= nums1.length, nums2.length <= 1000
1 <= nums1[i], nums2[i] <= 10^5",14,,5764,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/']",[],17292
评论 (120),minimum-time-to-make-rope-colorful,中等,"Alice 把 n 个气球排列在一根绳子上。给你一个下标从 0 开始的字符串 colors ，其中 colors[i] 是第 i 个气球的颜色。
Alice 想要把绳子装扮成 彩色 ，且她不希望两个连续的气球涂着相同的颜色，所以她喊来 Bob 帮忙。Bob 可以从绳子上移除一些气球使绳子变成 彩色 。给你一个下标从 0 开始的整数数组 neededTime ，其中 neededTime[i] 是 Bob 从绳子上移除第 i 个气球需要的时间（以秒为单位）。
返回 Bob 使绳子变成 彩色 需要的 最少时间 。
  示例 1：
输入：colors = ""abaac"", neededTime = [1,2,3,4,5]
输出：3
解释：在上图中，'a' 是蓝色，'b' 是红色且 'c' 是绿色。
Bob 可以移除下标 2 的蓝色气球。这将花费 3 秒。
移除后，不存在两个连续的气球涂着相同的颜色。总时间 = 3 。
示例 2：
输入：colors = ""abc"", neededTime = [1,2,3]
输出：0
解释：绳子已经是彩色的，Bob 不需要从绳子上移除任何气球。
示例 3：
输入：colors = ""aabaa"", neededTime = [1,2,3,4,1]
输出：2
解释：Bob 会移除下标 0 和下标 4 处的气球。这两个气球各需要 1 秒来移除。
移除后，不存在两个连续的气球涂着相同的颜色。总时间 = 1 + 1 = 2 。
  提示：
n == colors.length == neededTime.length
1 <= n <= 105
1 <= neededTime[i] <= 104
colors 仅由小写英文字母组成",54,https://assets.leetcode.com/uploads/2021/12/13/ballon1.jpg,12685,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],21491
评论 (309),remove-max-number-of-edges-to-keep-graph-fully-traversable,困难,"Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：
类型 1：只能由 Alice 遍历。
类型 2：只能由 Bob 遍历。
类型 3：Alice 和 Bob 都可以遍历。
给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。
返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。
  示例 1：
输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
输出：2
解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。
示例 2：
输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
输出：0
解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。
示例 3：
输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
输出：-1
解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。
  提示：
1 <= n <= 10^5
1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)
edges[i].length == 3
1 <= edges[i][0] <= 3
1 <= edges[i][1] < edges[i][2] <= n
所有元组 (typei, ui, vi) 互不相同",131,,17041,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']",[],27542
评论 (6),put-boxes-into-the-warehouse-ii,Unknown,,-1,,-1,[],[],-1
评论 (133),customer-who-visited-but-did-not-make-any-transactions,简单,"SQL架构
表：Visits
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| visit_id    | int     |
| customer_id | int     |
+-------------+---------+
visit_id 是该表的主键。
该表包含有关光临过购物中心的顾客的信息。
  表：Transactions
+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| transaction_id | int     |
| visit_id       | int     |
| amount         | int     |
+----------------+---------+
transaction_id 是此表的主键。
此表包含 visit_id 期间进行的交易的信息。
  有一些顾客可能光顾了购物中心但没有进行交易。请你编写一个 SQL 查询，来查找这些顾客的 ID ，以及他们只光顾不交易的次数。
返回以 任何顺序 排序的结果表。
查询结果格式如下例所示。
  示例 1：
输入:
Visits
+----------+-------------+
| visit_id | customer_id |
+----------+-------------+
| 1        | 23          |
| 2        | 9           |
| 4        | 30          |
| 5        | 54          |
| 6        | 96          |
| 7        | 54          |
| 8        | 54          |
+----------+-------------+
Transactions
+----------------+----------+--------+
| transaction_id | visit_id | amount |
+----------------+----------+--------+
| 2              | 5        | 310    |
| 3              | 5        | 300    |
| 9              | 5        | 200    |
| 12             | 1        | 910    |
| 13             | 2        | 970    |
+----------------+----------+--------+
输出:
+-------------+----------------+
| customer_id | count_no_trans |
+-------------+----------------+
| 54          | 2              |
| 30          | 1              |
| 96          | 1              |
+-------------+----------------+
解释:
ID = 23 的顾客曾经逛过一次购物中心，并在 ID = 12 的访问期间进行了一笔交易。
ID = 9 的顾客曾经逛过一次购物中心，并在 ID = 13 的访问期间进行了一笔交易。
ID = 30 的顾客曾经去过购物中心，并且没有进行任何交易。
ID = 54 的顾客三度造访了购物中心。在 2 次访问中，他们没有进行任何交易，在 1 次访问中，他们进行了 3 次交易。
ID = 96 的顾客曾经去过购物中心，并且没有进行任何交易。
如我们所见，ID 为 30 和 96 的顾客一次没有进行任何交易就去了购物中心。顾客 54 也两次访问了购物中心并且没有进行任何交易。",26,,11129,['https://leetcode.cn/tag/database/'],[],13546
评论 (73),special-positions-in-a-binary-matrix,简单,"给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。
特殊位置 定义：如果 mat[i][j] == 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。
  示例 1：
输入：mat = [[1,0,0],
            [0,0,1],
            [1,0,0]]
输出：1
解释：(1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0
示例 2：
输入：mat = [[1,0,0],
            [0,1,0],
            [0,0,1]]
输出：3
解释：(0,0), (1,1) 和 (2,2) 都是特殊位置
示例 3：
输入：mat = [[0,0,0,1],
            [1,0,0,0],
            [0,1,1,0],
            [0,0,0,0]]
输出：2
示例 4：
输入：mat = [[0,0,0,0,0],
            [1,0,0,0,0],
            [0,1,0,0,0],
            [0,0,1,0,0],
            [0,0,0,1,1]]
输出：3
  提示：
rows == mat.length
cols == mat[i].length
1 <= rows, cols <= 100
mat[i][j] 是 0 或 1",23,,12004,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],17897
评论 (365),count-unhappy-friends,中等,"给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。
对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。
所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。
但是，这样的配对情况可能会使其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：
x 与 u 的亲近程度胜过 x 与 y，且
u 与 x 的亲近程度胜过 u 与 v
返回 不开心的朋友的数目 。
  示例 1：
输入：n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]
输出：2
解释：
朋友 1 不开心，因为：
- 1 与 0 配对，但 1 与 3 的亲近程度比 1 与 0 高，且
- 3 与 1 的亲近程度比 3 与 2 高。
朋友 3 不开心，因为：
- 3 与 2 配对，但 3 与 1 的亲近程度比 3 与 2 高，且
- 1 与 3 的亲近程度比 1 与 0 高。
朋友 0 和 2 都是开心的。
示例 2：
输入：n = 2, preferences = [[1], [0]], pairs = [[1, 0]]
输出：0
解释：朋友 0 和 1 都开心。
示例 3：
输入：n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]
输出：4
  提示：
2 <= n <= 500
n 是偶数
preferences.length == n
preferences[i].length == n - 1
0 <= preferences[i][j] <= n - 1
preferences[i] 不包含 i
preferences[i] 中的所有值都是独一无二的
pairs.length == n/2
pairs[i].length == 2
xi != yi
0 <= xi, yi <= n - 1
每位朋友都 恰好 被包含在一对中",83,,19407,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],28341
评论 (336),min-cost-to-connect-all-points,中等,"给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。
连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。
请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。
  示例 1：
输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
输出：20
解释：

我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。
注意到任意两个点之间只有唯一一条路径互相到达。
示例 2：
输入：points = [[3,12],[-2,5],[-4,1]]
输出：18
示例 3：
输入：points = [[0,0],[1,1],[1,0],[-1,1]]
输出：4
示例 4：
输入：points = [[-1000000,-1000000],[1000000,1000000]]
输出：4000000
示例 5：
输入：points = [[0,0]]
输出：0
  提示：
1 <= points.length <= 1000
-106 <= xi, yi <= 106
所有点 (xi, yi) 两两不同。",206,,35698,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/minimum-spanning-tree/']",[],53958
评论 (29),check-if-string-is-transformable-with-substring-sort-operations,困难,"给你两个字符串 s 和 t ，请你通过若干次以下操作将字符串 s 转化成字符串 t ：
选择 s 中一个 非空 子字符串并将它包含的字符就地 升序 排序。
比方说，对下划线所示的子字符串进行操作可以由 ""14234"" 得到 ""12344"" 。
如果可以将字符串 s 变成 t ，返回 true 。否则，返回 false 。
一个 子字符串 定义为一个字符串中连续的若干字符。
  示例 1：
输入：s = ""84532"", t = ""34852""
输出：true
解释：你可以按以下操作将 s 转变为 t ：
""84532"" （从下标 2 到下标 3）-> ""84352""
""84352"" （从下标 0 到下标 2） -> ""34852""
示例 2：
输入：s = ""34521"", t = ""23415""
输出：true
解释：你可以按以下操作将 s 转变为 t ：
""34521"" -> ""23451""
""23451"" -> ""23415""
示例 3：
输入：s = ""12345"", t = ""12435""
输出：false
示例 4：
输入：s = ""1"", t = ""2""
输出：false
  提示：
s.length == t.length
1 <= s.length <= 105
s 和 t 都只包含数字字符，即 '0' 到 '9' 。",51,,2682,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],6219
评论 (22),binary-search-tree-iterator-ii,Unknown,,-1,,-1,[],[],-1
评论 (87),bank-account-summary-ii,简单,"SQL架构
表: Users
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| account      | int     |
| name         | varchar |
+--------------+---------+
account 是该表的主键.
表中的每一行包含银行里中每一个用户的账号.
  表: Transactions
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| trans_id      | int     |
| account       | int     |
| amount        | int     |
| transacted_on | date    |
+---------------+---------+
trans_id 是该表主键.
该表的每一行包含了所有账户的交易改变情况.
如果用户收到了钱, 那么金额是正的; 如果用户转了钱, 那么金额是负的.
所有账户的起始余额为 0.
  写一个 SQL,  报告余额高于 10000 的所有用户的名字和余额. 账户的余额等于包含该账户的所有交易的总和.
返回结果表单没有顺序要求.
查询结果格式如下例所示.
  Users table:
+------------+--------------+
| account    | name         |
+------------+--------------+
| 900001     | Alice        |
| 900002     | Bob          |
| 900003     | Charlie      |
+------------+--------------+

Transactions table:
+------------+------------+------------+---------------+
| trans_id   | account    | amount     | transacted_on |
+------------+------------+------------+---------------+
| 1          | 900001     | 7000       |  2020-08-01   |
| 2          | 900001     | 7000       |  2020-09-01   |
| 3          | 900001     | -3000      |  2020-09-02   |
| 4          | 900002     | 1000       |  2020-09-12   |
| 5          | 900003     | 6000       |  2020-08-07   |
| 6          | 900003     | 6000       |  2020-09-07   |
| 7          | 900003     | -4000      |  2020-09-11   |
+------------+------------+------------+---------------+

Result table:
+------------+------------+
| name       | balance    |
+------------+------------+
| Alice      | 11000      |
+------------+------------+
Alice 的余额为(7000 + 7000 - 3000) = 11000.
Bob 的余额为1000.
Charlie 的余额为(6000 + 6000 - 4000) = 8000.",11,,8596,['https://leetcode.cn/tag/database/'],[],10203
评论 (451),sum-of-all-odd-length-subarrays,简单,"给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。
子数组 定义为原数组中的一个连续子序列。
请你返回 arr 中 所有奇数长度子数组的和 。
  示例 1：
输入：arr = [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
示例 2：
输入：arr = [1,2]
输出：3
解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
示例 3：
输入：arr = [10,11,12]
输出：66
  提示：
1 <= arr.length <= 100
1 <= arr[i] <= 1000",184,,52968,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/prefix-sum/']",[],63071
评论 (65),maximum-sum-obtained-of-any-permutation,中等,"有一个整数数组 nums ，和一个查询数组 requests ，其中 requests[i] = [starti, endi] 。第 i 个查询求 nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi] 的结果 ，starti 和 endi 数组索引都是 从 0 开始 的。
你可以任意排列 nums 中的数字，请你返回所有查询结果之和的最大值。
由于答案可能会很大，请你将它对 109 + 7 取余 后返回。
  示例 1：
输入：nums = [1,2,3,4,5], requests = [[1,3],[0,1]]
输出：19
解释：一个可行的 nums 排列为 [2,1,3,4,5]，并有如下结果：
requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8
requests[1] -> nums[0] + nums[1] = 2 + 1 = 3
总和为：8 + 3 = 11。
一个总和更大的排列为 [3,5,4,2,1]，并有如下结果：
requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11
requests[1] -> nums[0] + nums[1] = 3 + 5  = 8
总和为： 11 + 8 = 19，这个方案是所有排列中查询之和最大的结果。
示例 2：
输入：nums = [1,2,3,4,5,6], requests = [[0,1]]
输出：11
解释：一个总和最大的排列为 [6,5,4,3,2,1] ，查询和为 [11]。
示例 3：
输入：nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]
输出：47
解释：一个和最大的排列为 [4,10,5,3,2,1] ，查询结果分别为 [19,18,10]。
  提示：
n == nums.length
1 <= n <= 105
0 <= nums[i] <= 105
1 <= requests.length <= 105
requests[i].length == 2
0 <= starti <= endi < n",50,,4846,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sorting/']",[],15759
评论 (51),make-sum-divisible-by-p,中等,"给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。
请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。
子数组 定义为原数组中连续的一组元素。
  示例 1：
输入：nums = [3,1,4,2], p = 6
输出：1
解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。
示例 2：
输入：nums = [6,3,5,2], p = 9
输出：2
解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。
示例 3：
输入：nums = [1,2,3], p = 3
输出：0
解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。
示例  4：
输入：nums = [1,2,3], p = 7
输出：-1
解释：没有任何方案使得移除子数组后剩余元素的和被 7 整除。
示例 5：
输入：nums = [1000000000,1000000000,1000000000], p = 3
输出：0
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= p <= 109",56,,4737,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']",[],17114
评论 (23),strange-printer-ii,困难,"给你一个奇怪的打印机，它有如下两个特殊的打印规则：
每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。
一旦矩形根据上面的规则使用了一种颜色，那么 相同的颜色不能再被使用 。
给你一个初始没有颜色的 m x n 的矩形 targetGrid ，其中 targetGrid[row][col] 是位置 (row, col) 的颜色。
如果你能按照上述规则打印出矩形 targetGrid ，请你返回 true ，否则返回 false 。
  示例 1：
输入：targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
输出：true
示例 2：
输入：targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
输出：true
示例 3：
输入：targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
输出：false
解释：没有办法得到 targetGrid ，因为每一轮操作使用的颜色互不相同。
示例 4：
输入：targetGrid = [[1,1,1],[3,1,3]]
输出：false
  提示：
m == targetGrid.length
n == targetGrid[i].length
1 <= m, n <= 60
1 <= targetGrid[row][col] <= 60",27,,1580,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],2618
评论 (72),rearrange-spaces-between-words,简单,"给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。
请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。
返回 重新排列空格后的字符串 。
  示例 1：
输入：text = ""  this   is  a sentence ""
输出：""this   is   a   sentence""
解释：总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。
示例 2：
输入：text = "" practice   makes   perfect""
输出：""practice   makes   perfect ""
解释：总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。
示例 3：
输入：text = ""hello   world""
输出：""hello   world""
示例 4：
输入：text = ""  walks  udp package   into  bar a""
输出：""walks  udp  package  into  bar  a ""
示例 5：
输入：text = ""a""
输出：""a""
  提示：
1 <= text.length <= 100
text 由小写英文字母和 ' ' 组成
text 中至少包含一个单词",18,,9313,['https://leetcode.cn/tag/string/'],[],20971
评论 (97),split-a-string-into-the-max-number-of-unique-substrings,中等,"给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。
字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。
注意：子字符串 是字符串中的一个连续字符序列。
  示例 1：
输入：s = ""ababccc""
输出：5
解释：一种最大拆分方法为 ['a', 'b', 'ab', 'c', 'cc'] 。像 ['a', 'b', 'a', 'b', 'c', 'cc'] 这样拆分不满足题目要求，因为其中的 'a' 和 'b' 都出现了不止一次。
示例 2：
输入：s = ""aba""
输出：2
解释：一种最大拆分方法为 ['a', 'ba'] 。
示例 3：
输入：s = ""aa""
输出：1
解释：无法进一步拆分字符串。
  提示：
1 <= s.length <= 16
s 仅包含小写英文字母",49,,6913,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],12468
评论 (84),maximum-non-negative-product-in-a-matrix,中等,"给你一个大小为 rows x cols 的矩阵 grid 。最初，你位于左上角 (0, 0) ，每一步，你可以在矩阵中 向右 或 向下 移动。
在从左上角 (0, 0) 开始到右下角 (rows - 1, cols - 1) 结束的所有路径中，找出具有 最大非负积 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。
返回 最大非负积 对 109 + 7 取余 的结果。如果最大积为负数，则返回 -1 。
注意，取余是在得到最大积之后执行的。
  示例 1：
输入：grid = [[-1,-2,-3],
             [-2,-3,-3],
             [-3,-3,-2]]
输出：-1
解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1
示例 2：
输入：grid = [[1,-2,1],
             [1,-2,1],
             [3,-4,1]]
输出：8
解释：最大非负积对应的路径已经用粗体标出 (1 * 1 * -2 * -4 * 1 = 8)
示例 3：
输入：grid = [[1, 3],
             [0,-4]]
输出：0
解释：最大非负积对应的路径已经用粗体标出 (1 * 0 * -4 = 0)
示例 4：
输入：grid = [[ 1, 4,4,0],
             [-2, 0,0,1],
             [ 1,-1,1,1]]
输出：2
解释：最大非负积对应的路径已经用粗体标出 (1 * -2 * 1 * -1 * 1 * 1 = 2)
  提示：
1 <= rows, cols <= 15
-4 <= grid[i][j] <= 4",37,,4912,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],15269
评论 (31),minimum-cost-to-connect-two-groups-of-points,困难,"给你两组点，其中第一组中有 size1 个点，第二组中有 size2 个点，且 size1 >= size2 。
任意两点间的连接成本 cost 由大小为 size1 x size2 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。
返回连通两组点所需的最小成本。
  示例 1：
输入：cost = [[15, 96], [36, 2]]
输出：17
解释：连通两组点的最佳方法是：
1--A
2--B
总成本为 17 。
示例 2：
输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
输出：4
解释：连通两组点的最佳方法是：
1--A
2--B
2--C
3--A
最小成本为 4 。
请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。
示例 3：
输入：cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
输出：10
  提示：
size1 == cost.length
size2 == cost[i].length
1 <= size1, size2 <= 12
size1 >= size2
0 <= cost[i][j] <= 100",55,,2378,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/', 'https://leetcode.cn/tag/matrix/']",[],4841
评论 (89),the-most-frequently-ordered-products-for-each-customer,Unknown,,-1,,-1,[],[],-1
评论 (21),build-binary-expression-tree-from-infix-expression,Unknown,,-1,,-1,[],[],-1
评论 (91),crawler-log-folder,简单,"每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。
下面给出对变更操作的说明：
""../"" ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。
""./"" ：继续停留在当前文件夹。
""x/"" ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。
给你一个字符串列表 logs ，其中 logs[i] 是用户在 ith 步执行的操作。
文件系统启动时位于主文件夹，然后执行 logs 中的操作。
执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。
  示例 1：
输入：logs = [""d1/"",""d2/"",""../"",""d21/"",""./""]
输出：2
解释：执行 ""../"" 操作变更文件夹 2 次，即可回到主文件夹
示例 2：
输入：logs = [""d1/"",""d2/"",""./"",""d3/"",""../"",""d31/""]
输出：3
示例 3：
输入：logs = [""d1/"",""../"",""../"",""../""]
输出：0
  提示：
1 <= logs.length <= 103
2 <= logs[i].length <= 10
logs[i] 包含小写英文字母，数字，'.' 和 '/'
logs[i] 符合语句中描述的格式
文件夹名称由小写英文字母和数字组成",20,,13320,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],19759
评论 (81),maximum-profit-of-operating-a-centennial-wheel,中等,"你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。
给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。
你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。
返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。
  示例 1：
输入：customers = [8,3], boardingCost = 5, runningCost = 6
输出：3
解释：座舱上标注的数字是该座舱的当前游客数。
1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。
2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。
3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。
轮转 3 次得到最大利润，最大利润为 $37 。
示例 2：
输入：customers = [10,9,6], boardingCost = 6, runningCost = 4
输出：7
解释：
1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。
2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。
3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。
4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。
5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。
6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。
7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。
轮转 7 次得到最大利润，最大利润为$122 。
示例 3：
输入：customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92
输出：-1
解释：
1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。
2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。
3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。
4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。
5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。
利润永不为正，所以返回 -1 。
  提示：
n == customers.length
1 <= n <= 105
0 <= customers[i] <= 50
1 <= boardingCost, runningCost <= 100",9,,4420,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],10428
评论 (226),throne-inheritance,中等,"一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。
这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。
Successor(x, curOrder):
    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：
        如果 x 是国王，那么返回 null
        否则，返回 Successor(x 的父亲, curOrder)
    否则，返回 x 不在 curOrder 中最年长的孩子
比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。
一开始， curOrder 为 [""king""].
调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [""king"", ""Alice""] 。
调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [""king"", ""Alice"", ""Jack""] 。
调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [""king"", ""Alice"", ""Jack"", ""Bob""] 。
调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [""king"", ""Alice"", ""Jack"", ""Bob""] 。
通过以上的函数，我们总是能得到一个唯一的继承顺序。
请你实现 ThroneInheritance 类：
ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。
void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。
void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。
string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。
  示例：
输入：
[""ThroneInheritance"", ""birth"", ""birth"", ""birth"", ""birth"", ""birth"", ""birth"", ""getInheritanceOrder"", ""death"", ""getInheritanceOrder""]
[[""king""], [""king"", ""andy""], [""king"", ""bob""], [""king"", ""catherine""], [""andy"", ""matthew""], [""bob"", ""alex""], [""bob"", ""asha""], [null], [""bob""], [null]]
输出：
[null, null, null, null, null, null, null, [""king"", ""andy"", ""matthew"", ""bob"", ""alex"", ""asha"", ""catherine""], null, [""king"", ""andy"", ""matthew"", ""alex"", ""asha"", ""catherine""]]

解释：
ThroneInheritance t= new ThroneInheritance(""king""); // 继承顺序：king
t.birth(""king"", ""andy""); // 继承顺序：king > andy
t.birth(""king"", ""bob""); // 继承顺序：king > andy > bob
t.birth(""king"", ""catherine""); // 继承顺序：king > andy > bob > catherine
t.birth(""andy"", ""matthew""); // 继承顺序：king > andy > matthew > bob > catherine
t.birth(""bob"", ""alex""); // 继承顺序：king > andy > matthew > bob > alex > catherine
t.birth(""bob"", ""asha""); // 继承顺序：king > andy > matthew > bob > alex > asha > catherine
t.getInheritanceOrder(); // 返回 [""king"", ""andy"", ""matthew"", ""bob"", ""alex"", ""asha"", ""catherine""]
t.death(""bob""); // 继承顺序：king > andy > matthew > bob（已经去世）> alex > asha > catherine
t.getInheritanceOrder(); // 返回 [""king"", ""andy"", ""matthew"", ""alex"", ""asha"", ""catherine""]
  提示：
1 <= kingName.length, parentName.length, childName.length, name.length <= 15
kingName，parentName， childName 和 name 仅包含小写英文字母。
所有的参数 childName 和 kingName 互不相同。
所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。
每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。
最多调用 105 次birth 和 death 。
最多调用 10 次 getInheritanceOrder 。",66,,17892,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/']",[],26745
评论 (281),maximum-number-of-achievable-transfer-requests,困难,"我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。
给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。
一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。
请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。
  示例 1：
输入：n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
输出：5
解释：请求列表如下：
从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。
从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。
从楼 2 离开的员工为 z ，且他想要搬到楼 0 。
从楼 3 离开的员工为 c ，且他想要搬到楼 4 。
没有员工从楼 4 离开。
我们可以让 x 和 b 交换他们的楼，以满足他们的请求。
我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。
所以最多可以满足 5 个请求。
示例 2：
输入：n = 3, requests = [[0,0],[1,2],[2,1]]
输出：3
解释：请求列表如下：
从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。
从楼 1 离开的员工为 y ，且他想要搬到楼 2 。
从楼 2 离开的员工为 z ，且他想要搬到楼 1 。
我们可以满足所有的请求。
示例 3：
输入：n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
输出：4
  提示：
1 <= n <= 20
1 <= requests.length <= 16
requests[i].length == 2
0 <= fromi, toi < n",133,,20719,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/enumeration/']",[],33586
评论 (13),find-nearest-right-node-in-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (374),design-parking-system,简单,"请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。
请你实现 ParkingSystem 类：
ParkingSystem(int big, int medium, int small) 初始化 ParkingSystem 类，三个参数分别对应每种停车位的数目。
bool addCar(int carType) 检查是否有 carType 对应的停车位。 carType 有三种类型：大，中，小，分别用数字 1， 2 和 3 表示。一辆车只能停在  carType 对应尺寸的停车位中。如果没有空车位，请返回 false ，否则将该车停入车位并返回 true 。
  示例 1：
输入：
[""ParkingSystem"", ""addCar"", ""addCar"", ""addCar"", ""addCar""]
[[1, 1, 0], [1], [2], [3], [1]]
输出：
[null, true, true, false, false]

解释：
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位
parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位
parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位
parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了
  提示：
0 <= big, medium, small <= 1000
carType 取值为 1， 2 或 3
最多会调用 addCar 函数 1000 次",113,,64553,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/simulation/']",[],76406
评论 (66),alert-using-same-key-card-three-or-more-times-in-a-one-hour-period,中等,"力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。
给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。
使用时间的格式是 24小时制 ，形如 ""HH:MM"" ，比方说 ""23:51"" 和 ""09:49"" 。
请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。
请注意 ""10:00"" - ""11:00"" 视为一个小时时间范围内，而 ""23:51"" - ""00:10"" 不被视为一小时内，因为系统记录的是某一天内的使用情况。
  示例 1：
输入：keyName = [""daniel"",""daniel"",""daniel"",""luis"",""luis"",""luis"",""luis""], keyTime = [""10:00"",""10:40"",""11:00"",""09:00"",""11:00"",""13:00"",""15:00""]
输出：[""daniel""]
解释：""daniel"" 在一小时内使用了 3 次员工卡（""10:00""，""10:40""，""11:00""）。
示例 2：
输入：keyName = [""alice"",""alice"",""alice"",""bob"",""bob"",""bob"",""bob""], keyTime = [""12:01"",""12:00"",""18:00"",""21:00"",""21:20"",""21:30"",""23:00""]
输出：[""bob""]
解释：""bob"" 在一小时内使用了 3 次员工卡（""21:00""，""21:20""，""21:30""）。
示例 3：
输入：keyName = [""john"",""john"",""john""], keyTime = [""23:58"",""23:59"",""00:01""]
输出：[]
示例 4：
输入：keyName = [""leslie"",""leslie"",""leslie"",""clare"",""clare"",""clare"",""clare""], keyTime = [""13:00"",""13:20"",""14:00"",""18:00"",""18:51"",""19:30"",""19:49""]
输出：[""clare"",""leslie""]
  提示：
1 <= keyName.length, keyTime.length <= 105
keyName.length == keyTime.length
keyTime 格式为 ""HH:MM"" 。
保证 [keyName[i], keyTime[i]] 形成的二元对 互不相同 。
1 <= keyName[i].length <= 10
keyName[i] 只包含小写英文字母。",17,,4761,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],11358
评论 (48),find-valid-matrix-given-row-and-column-sums,中等,"给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。
请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。
请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。
  示例 1：
输入：rowSum = [3,8], colSum = [4,7]
输出：[[3,0],
      [1,7]]
解释：
第 0 行：3 + 0 = 3 == rowSum[0]
第 1 行：1 + 7 = 8 == rowSum[1]
第 0 列：3 + 1 = 4 == colSum[0]
第 1 列：0 + 7 = 7 == colSum[1]
行和列的和都满足题目要求，且所有矩阵元素都是非负的。
另一个可行的矩阵为：[[1,2],
                  [3,5]]
示例 2：
输入：rowSum = [5,7,10], colSum = [8,6,8]
输出：[[0,5,0],
      [6,1,0],
      [2,0,8]]
示例 3：
输入：rowSum = [14,9], colSum = [6,9,8]
输出：[[0,9,5],
      [6,0,3]]
示例 4：
输入：rowSum = [1,0], colSum = [1]
输出：[[1],
      [0]]
示例 5：
输入：rowSum = [0], colSum = [0]
输出：[[0]]
  提示：
1 <= rowSum.length, colSum.length <= 500
0 <= rowSum[i], colSum[i] <= 108
sum(rows) == sum(columns)",47,,4669,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],6228
评论 (256),find-servers-that-handled-most-number-of-requests,困难,"你有 k 个服务器，编号为 0 到 k-1 ，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 不能同时处理超过一个请求 。请求分配到服务器的规则如下：
第 i （序号从 0 开始）个请求到达。
如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。
如果第 (i % k) 个服务器空闲，那么对应服务器会处理该请求。
否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 i 个服务器在忙，那么会查看第 (i+1) 个服务器，第 (i+2) 个服务器等等。
给你一个 严格递增 的正整数数组 arrival ，表示第 i 个任务的到达时间，和另一个数组 load ，其中 load[i] 表示第 i 个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 最繁忙的服务器 。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。
请你返回包含所有 最繁忙服务器 序号的列表，你可以以任意顺序返回这个列表。
  示例 1：
输入：k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] 
输出：[1] 
解释：
所有服务器一开始都是空闲的。
前 3 个请求分别由前 3 台服务器依次处理。
请求 3 进来的时候，服务器 0 被占据，所以它被安排到下一台空闲的服务器，也就是服务器 1 。
请求 4 进来的时候，由于所有服务器都被占据，该请求被舍弃。
服务器 0 和 2 分别都处理了一个请求，服务器 1 处理了两个请求。所以服务器 1 是最忙的服务器。
示例 2：
输入：k = 3, arrival = [1,2,3,4], load = [1,2,1,2]
输出：[0]
解释：
前 3 个请求分别被前 3 个服务器处理。
请求 3 进来，由于服务器 0 空闲，它被服务器 0 处理。
服务器 0 处理了两个请求，服务器 1 和 2 分别处理了一个请求。所以服务器 0 是最忙的服务器。
示例 3：
输入：k = 3, arrival = [1,2,3], load = [10,12,11]
输出：[0,1,2]
解释：每个服务器分别处理了一个请求，所以它们都是最忙的服务器。
示例 4：
输入：k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]
输出：[1]
示例 5：
输入：k = 1, arrival = [1], load = [1]
输出：[0]
  提示：
1 <= k <= 105
1 <= arrival.length, load.length <= 105
arrival.length == load.length
1 <= arrival[i], load[i] <= 109
arrival 保证 严格递增 。",142,,19172,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],39833
评论 (89),sellers-with-no-sales,Unknown,,-1,,-1,[],[],-1
评论 (176),special-array-with-x-elements-greater-than-or-equal-x,简单,"给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。
注意： x 不必 是 nums 的中的元素。
如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。
  示例 1：
输入：nums = [3,5]
输出：2
解释：有 2 个元素（3 和 5）大于或等于 2 。
示例 2：
输入：nums = [0,0]
输出：-1
解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。
如果 x = 0，应该有 0 个元素 >= x，但实际有 2 个。
如果 x = 1，应该有 1 个元素 >= x，但实际有 0 个。
如果 x = 2，应该有 2 个元素 >= x，但实际有 0 个。
x 不能取更大的值，因为 nums 中只有两个元素。
示例 3：
输入：nums = [0,4,3,0,4]
输出：3
解释：有 3 个元素大于或等于 3 。
示例 4：
输入：nums = [3,6,7,7,0]
输出：-1
  提示：
1 <= nums.length <= 100
0 <= nums[i] <= 1000",61,,16324,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],26956
评论 (309),even-odd-tree,中等,"如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：
二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增
奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减
给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。
  示例 1：
输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
输出：true
解释：每一层的节点值分别是：
0 层：[1]
1 层：[10,4]
2 层：[3,7,9]
3 层：[12,8,6,2]
由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。
示例 2：
输入：root = [5,4,2,3,3,7]
输出：false
解释：每一层的节点值分别是：
0 层：[5]
1 层：[4,2]
2 层：[3,3,7]
2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。
示例 3：
输入：root = [5,9,1,3,5,7]
输出：false
解释：1 层上的节点值应为偶数。
示例 4：
输入：root = [1]
输出：true
示例 5：
输入：root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]
输出：true
  提示：
树中节点数在范围 [1, 105] 内
1 <= Node.val <= 106",73,,29517,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],50047
评论 (252),maximum-number-of-visible-points,困难,"给你一个点数组 points 和一个表示角度的整数 angle ，你的位置是 location ，其中 location = [posx, posy] 且 points[i] = [xi, yi] 都表示 X-Y 平面上的整数坐标。
最开始，你面向东方进行观测。你 不能 进行移动改变位置，但可以通过 自转 调整观测角度。换句话说，posx 和 posy 不能改变。你的视野范围的角度用 angle 表示， 这决定了你观测任意方向时可以多宽。设 d 为你逆时针自转旋转的度数，那么你的视野就是角度范围 [d - angle/2, d + angle/2] 所指示的那片区域。
Your browser does not support the video tag or this video format.
对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 位于你的视野中 ，那么你就可以看到它。
同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。
返回你能看到的点的最大数目。
  示例 1：
输入：points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
输出：3
解释：阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。
示例 2：
输入：points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]
输出：4
解释：在你的视野中，所有的点都清晰可见，包括你所在位置的那个点。
示例 3：
输入：points = [[1,0],[2,1]], angle = 13, location = [1,1]
输出：1
解释：如图所示，你只能看到两点之一。
  提示：
1 <= points.length <= 105
points[i].length == 2
location.length == 2
0 <= angle < 360
0 <= posx, posy, xi, yi <= 100",112,,16647,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/sliding-window/']",[],37565
评论 (45),minimum-one-bit-operations-to-make-integers-zero,困难,"给你一个整数 n，你需要重复执行多次下述操作将其转换为 0 ：
翻转 n 的二进制表示中最右侧位（第 0 位）。
如果第 (i-1) 位为 1 且从第 (i-2) 位到第 0 位都为 0，则翻转 n 的二进制表示中的第 i 位。
返回将 n 转换为 0 的最小操作次数。
  示例 1：
输入：n = 3
输出：2
解释：3 的二进制表示为 ""11""
""11"" -> ""01"" ，执行的是第 2 种操作，因为第 0 位为 1 。
""01"" -> ""00"" ，执行的是第 1 种操作。
示例 2：
输入：n = 6
输出：4
解释：6 的二进制表示为 ""110"".
""110"" -> ""010"" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。
""010"" -> ""011"" ，执行的是第 1 种操作。
""011"" -> ""001"" ，执行的是第 2 种操作，因为第 0 位为 1 。
""001"" -> ""000"" ，执行的是第 1 种操作。
  提示：
0 <= n <= 109",43,,2507,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/dynamic-programming/']",[],4059
评论 (9),check-if-two-expression-trees-are-equivalent,Unknown,,-1,,-1,[],[],-1
评论 (59),find-the-missing-ids,Unknown,,-1,,-1,[],[],-1
评论 (503),maximum-nesting-depth-of-the-parentheses,简单,"如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：
字符串是一个空字符串 """"，或者是一个不为 ""("" 或 "")"" 的单字符。
字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：
depth("""") = 0
depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 ""("" 或者 "")""
depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
depth(""("" + A + "")"") = 1 + depth(A)，其中 A 是一个 有效括号字符串
例如：""""、""()()""、""()(()())"" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 "")("" 、""(()"" 都不是 有效括号字符串 。
给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。
  示例 1：
输入：s = ""(1+(2*3)+((8)/4))+1""
输出：3
解释：数字 8 在嵌套的 3 层括号中。
示例 2：
输入：s = ""(1)+((2))+(((3)))""
输出：3
  提示：
1 <= s.length <= 100
s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成
题目数据保证括号表达式 s 是 有效的括号表达式",98,,50740,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],60226
评论 (47),maximal-network-rank,中等,"n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。
两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。
整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。
给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。
  示例 1：
输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
输出：4
解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。
示例 2：
输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
输出：5
解释：共有 5 条道路与城市 1 或 2 相连。
示例 3：
输入：n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]
输出：5
解释：2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。
  提示：
2 <= n <= 100
0 <= roads.length <= n * (n - 1) / 2
roads[i].length == 2
0 <= ai, bi <= n-1
ai != bi
每对城市之间 最多只有一条 道路相连",23,,7522,['https://leetcode.cn/tag/graph/'],[],13824
评论 (135),split-two-strings-to-make-palindrome,中等,"给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。
当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = ""abc"" 那么 """" + ""abc"" ， ""a"" + ""bc"" ， ""ab"" + ""c"" 和 ""abc"" + """" 都是合法分割。
如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。
注意， x + y 表示连接字符串 x 和 y 。
  示例 1：
输入：a = ""x"", b = ""y""
输出：true
解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：
aprefix = """", asuffix = ""x""
bprefix = """", bsuffix = ""y""
那么 aprefix + bsuffix = """" + ""y"" = ""y"" 是回文串。
示例 2：
输入：a = ""abdef"", b = ""fecab""
输出：true
示例 3：
输入：a = ""ulacfd"", b = ""jizalu""
输出：true
解释：在下标为 3 处分割：
aprefix = ""ula"", asuffix = ""cfd""
bprefix = ""jiz"", bsuffix = ""alu""
那么 aprefix + bsuffix = ""ula"" + ""alu"" = ""ulaalu"" 是回文串。
  提示：
1 <= a.length, b.length <= 105
a.length == b.length
a 和 b 都只包含小写英文字母",43,,5715,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],20501
评论 (33),count-subtrees-with-max-distance-between-cities,困难,"给你 n 个城市，编号为从 1 到 n 。同时给你一个大小为 n-1 的数组 edges ，其中 edges[i] = [ui, vi] 表示城市 ui 和 vi 之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 树 。
一棵 子树 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。
对于 d 从 1 到 n-1 ，请你找到城市间 最大距离 恰好为 d 的所有子树数目。
请你返回一个大小为 n-1 的数组，其中第 d 个元素（下标从 1 开始）是城市间 最大距离 恰好等于 d 的子树数目。
请注意，两个城市间距离定义为它们之间需要经过的边的数目。
  示例 1：
输入：n = 4, edges = [[1,2],[2,3],[2,4]]
输出：[3,4,0]
解释：
子树 {1,2}, {2,3} 和 {2,4} 最大距离都是 1 。
子树 {1,2,3}, {1,2,4}, {2,3,4} 和 {1,2,3,4} 最大距离都为 2 。
不存在城市间最大距离为 3 的子树。
示例 2：
输入：n = 2, edges = [[1,2]]
输出：[1]
示例 3：
输入：n = 3, edges = [[1,2],[2,3]]
输出：[2,1]
  提示：
2 <= n <= 15
edges.length == n-1
edges[i].length == 2
1 <= ui, vi <= n
题目保证 (ui, vi) 所表示的边互不相同。",41,,2092,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/', 'https://leetcode.cn/tag/enumeration/']",[],3312
评论 (11),maximum-font-to-fit-a-sentence-in-a-screen,Unknown,,-1,,-1,[],[],-1
评论 (79),mean-of-array-after-removing-some-elements,简单,"给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。
与 标准答案 误差在 10-5 的结果都被视为正确结果。
  示例 1：
输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]
输出：2.00000
解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。
示例 2：
输入：arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]
输出：4.00000
示例 3：
输入：arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
输出：4.77778
示例 4：
输入：arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]
输出：5.27778
示例 5：
输入：arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]
输出：5.29167
  提示：
20 <= arr.length <= 1000
arr.length 是 20 的 倍数 
0 <= arr[i] <= 105",22,,9745,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],14627
评论 (43),coordinate-with-maximum-network-quality,中等,"给你一个数组 towers 和一个整数 radius ，数组中包含一些网络信号塔，其中 towers[i] = [xi, yi, qi] 表示第 i 个网络信号塔的坐标是 (xi, yi) 且信号强度参数为 qi 。所有坐标都是在  X-Y 坐标系内的 整数 坐标。两个坐标之间的距离用 欧几里得距离 计算。
整数 radius 表示一个塔 能到达 的 最远距离 。如果一个坐标跟塔的距离在 radius 以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 radius 以外的距离该塔是 不能到达的 。
如果第 i 个塔能到达 (x, y) ，那么该塔在此处的信号为 ⌊qi / (1 + d)⌋ ，其中 d 是塔跟此坐标的距离。一个坐标的 网络信号 是所有 能到达 该坐标的塔的信号强度之和。
请你返回 网络信号 最大的整数坐标点。如果有多个坐标网络信号一样大，请你返回字典序最小的一个坐标。
注意：
坐标 (x1, y1) 字典序比另一个坐标 (x2, y2) 小：要么 x1 < x2 ，要么 x1 == x2 且 y1 < y2 。
⌊val⌋ 表示小于等于 val 的最大整数（向下取整函数）。
  示例 1：
输入：towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2
输出：[2,1]
解释：
坐标 (2, 1) 信号强度之和为 13
- 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7
- 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2
- 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4
没有别的坐标有更大的信号强度。
示例 2：
输入：towers = [[23,11,21]], radius = 9
输出：[23,11]
示例 3：
输入：towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2
输出：[1,2]
示例 4：
输入：towers = [[2,1,9],[0,1,9]], radius = 2
输出：[0,1]
解释：坐标 (0, 1) 和坐标 (2, 1) 都是强度最大的位置，但是 (0, 1) 字典序更小。
  提示：
1 <= towers.length <= 50
towers[i].length == 3
0 <= xi, yi, qi <= 50
1 <= radius <= 50",8,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/untitled-diagram.png,3005,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/enumeration/']",[],8104
评论 (38),number-of-sets-of-k-non-overlapping-line-segments,中等,"给你一维空间的 n 个点，其中第 i 个点（编号从 0 到 n-1）位于 x = i 处，请你找到 恰好 k 个不重叠 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 整数坐标 。这 k 个线段不需要全部覆盖全部 n 个点，且它们的端点 可以 重合。
请你返回 k 个不重叠线段的方案数。由于答案可能很大，请将结果对 109 + 7 取余 后返回。
  示例 1：
输入：n = 4, k = 2
输出：5
解释：
如图所示，两个线段分别用红色和蓝色标出。
上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。
示例 2：
输入：n = 3, k = 1
输出：3
解释：总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。
示例 3：
输入：n = 30, k = 7
输出：796297179
解释：画 7 条线段的总方案数为 3796297200 种。将这个数对 109 + 7 取余得到 796297179 。
示例 4：
输入：n = 5, k = 3
输出：7
示例 5：
输入：n = 3, k = 2
输出：1
  提示：
2 <= n <= 1000
1 <= k <= n-1",45,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/ex1.png,2175,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],4765
评论 (67),fancy-sequence,困难,"请你实现三个 API append，addAll 和 multAll 来实现奇妙序列。
请实现 Fancy 类 ：
Fancy() 初始化一个空序列对象。
void append(val) 将整数 val 添加在序列末尾。
void addAll(inc) 将所有序列中的现有数值都增加 inc 。
void multAll(m) 将序列中的所有现有数值都乘以整数 m 。
int getIndex(idx) 得到下标为 idx 处的数值（下标从 0 开始），并将结果对 109 + 7 取余。如果下标大于等于序列的长度，请返回 -1 。
  示例：
输入：
[""Fancy"", ""append"", ""addAll"", ""append"", ""multAll"", ""getIndex"", ""addAll"", ""append"", ""multAll"", ""getIndex"", ""getIndex"", ""getIndex""]
[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]
输出：
[null, null, null, null, null, 10, null, null, null, 26, 34, 20]

解释：
Fancy fancy = new Fancy();
fancy.append(2);   // 奇妙序列：[2]
fancy.addAll(3);   // 奇妙序列：[2+3] -> [5]
fancy.append(7);   // 奇妙序列：[5, 7]
fancy.multAll(2);  // 奇妙序列：[5*2, 7*2] -> [10, 14]
fancy.getIndex(0); // 返回 10
fancy.addAll(3);   // 奇妙序列：[10+3, 14+3] -> [13, 17]
fancy.append(10);  // 奇妙序列：[13, 17, 10]
fancy.multAll(2);  // 奇妙序列：[13*2, 17*2, 10*2] -> [26, 34, 20]
fancy.getIndex(0); // 返回 26
fancy.getIndex(1); // 返回 34
fancy.getIndex(2); // 返回 20
  提示：
1 <= val, inc, m <= 100
0 <= idx <= 105
总共最多会有 105 次对 append，addAll，multAll 和 getIndex 的调用。",54,,3479,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/math/']",[],21554
评论 (72),all-valid-triplets-that-can-represent-a-country,Unknown,,-1,,-1,[],[],-1
评论 (155),largest-substring-between-two-equal-characters,简单,"给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。
子字符串 是字符串中的一个连续字符序列。
  示例 1：
输入：s = ""aa""
输出：0
解释：最优的子字符串是两个 'a' 之间的空子字符串。
示例 2：
输入：s = ""abca""
输出：2
解释：最优的子字符串是 ""bc"" 。
示例 3：
输入：s = ""cbzxy""
输出：-1
解释：s 中不存在出现出现两次的字符，所以返回 -1 。
示例 4：
输入：s = ""cabbac""
输出：4
解释：最优的子字符串是 ""abba"" ，其他的非最优解包括 ""bb"" 和 """" 。
  提示：
1 <= s.length <= 300
s 只含小写英文字母",17,,15420,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],24922
评论 (45),lexicographically-smallest-string-after-applying-operations,中等,"给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。
你可以在 s 上按任意顺序多次执行下面两个操作之一：
累加：将  a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。例如，s = ""3456"" 且 a = 5，则执行此操作后 s 变成 ""3951""。
轮转：将 s 向右轮转 b 位。例如，s = ""3456"" 且 b = 1，则执行此操作后 s 变成 ""6345""。
请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。
如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符出现在字母表中的时间早于 b 中的对应字符。例如，""0158” 字典序比 ""0190"" 小，因为不同的第一个位置是在第三个字符，显然 '5' 出现在 '9' 之前。
  示例 1：
输入：s = ""5525"", a = 9, b = 2
输出：""2050""
解释：执行操作如下：
初态：""5525""
轮转：""2555""
累加：""2454""
累加：""2353""
轮转：""5323""
累加：""5222""
累加：""5121""
轮转：""2151""
累加：""2050""
无法获得字典序小于 ""2050"" 的字符串。
示例 2：
输入：s = ""74"", a = 5, b = 1
输出：""24""
解释：执行操作如下：
初态：""74""
轮转：""47""
累加：""42""
轮转：""24""
无法获得字典序小于 ""24"" 的字符串。
示例 3：
输入：s = ""0011"", a = 4, b = 2
输出：""0011""
解释：无法获得字典序小于 ""0011"" 的字符串。
示例 4：
输入：s = ""43987654"", a = 7, b = 3
输出：""00553311""
  提示：
2 <= s.length <= 100
s.length 是偶数
s 仅由数字 0 到 9 组成
1 <= a <= 9
1 <= b <= s.length - 1",24,,3385,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/string/']",[],6133
评论 (43),best-team-with-no-conflicts,中等,"假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。
然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。
给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。
  示例 1：
输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5]
输出：34
解释：你可以选中所有球员。
示例 2：
输入：scores = [4,5,6,5], ages = [2,1,2,1]
输出：16
解释：最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。
示例 3：
输入：scores = [1,2,3,5], ages = [8,9,10,1]
输出：6
解释：最佳的选择是前 3 名球员。
  提示：
1 <= scores.length, ages.length <= 1000
scores.length == ages.length
1 <= scores[i] <= 106
1 <= ages[i] <= 1000",55,,4747,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],11832
评论 (36),graph-connectivity-with-threshold,困难,"有 n 座城市，编号从 1 到 n 。编号为 x 和 y 的两座城市直接连通的前提是： x 和 y 的公因数中，至少有一个 严格大于 某个阈值 threshold 。更正式地说，如果存在整数 z ，且满足以下所有条件，则编号 x 和 y 的城市之间有一条道路：
x % z == 0
y % z == 0
z > threshold
给你两个整数 n 和 threshold ，以及一个待查询数组，请你判断每个查询 queries[i] = [ai, bi] 指向的城市 ai 和 bi 是否连通（即，它们之间是否存在一条路径）。
返回数组 answer ，其中answer.length == queries.length 。如果第 i 个查询中指向的城市 ai 和 bi 连通，则 answer[i] 为 true ；如果不连通，则 answer[i] 为 false 。
  示例 1：
  输入：n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
输出：[false,false,true]
解释：每个数的因数如下：
1:   1
2:   1, 2
3:   1, 3
4:   1, 2, 4
5:   1, 5
6:   1, 2, 3, 6
所有大于阈值的的因数已经加粗标识，只有城市 3 和 6 共享公约数 3 ，因此结果是： 
[1,4]   1 与 4 不连通
[2,5]   2 与 5 不连通
[3,6]   3 与 6 连通，存在路径 3--6
示例 2：
  输入：n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
输出：[true,true,true,true,true]
解释：每个数的因数与上一个例子相同。但是，由于阈值为 0 ，所有的因数都大于阈值。因为所有的数字共享公因数 1 ，所以所有的城市都互相连通。
示例 3：
  输入：n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
输出：[false,false,false,false,false]
解释：只有城市 2 和 4 共享的公约数 2 严格大于阈值 1 ，所以只有这两座城市是连通的。
注意，同一对节点 [x, y] 可以有多个查询，并且查询 [x，y] 等同于查询 [y，x] 。
  提示：
2 <= n <= 104
0 <= threshold <= n
1 <= queries.length <= 105
queries[i].length == 2
1 <= ai, bi <= cities
ai != bi",36,,3033,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],7625
评论 (30),design-an-expression-tree-with-evaluate-function,Unknown,,-1,,-1,[],[],-1
评论 (336),slowest-key,简单,"LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。
给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。
测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。
注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。
请返回单次按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。
  示例 1：
输入：releaseTimes = [9,29,49,50], keysPressed = ""cbcd""
输出：""c""
解释：按键顺序和持续时间如下：
按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）
按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）
按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）
按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）
按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20
'c' 按字母顺序排列比 'b' 大，所以答案是 'c'
示例 2：
输入：releaseTimes = [12,23,36,46,62], keysPressed = ""spuda""
输出：""a""
解释：按键顺序和持续时间如下：
按下 's' ，持续时间 12
按下 'p' ，持续时间 23 - 12 = 11
按下 'u' ，持续时间 36 - 23 = 13
按下 'd' ，持续时间 46 - 36 = 10
按下 'a' ，持续时间 62 - 46 = 16
按键持续时间最长的键是 'a' ，持续时间 16
  提示：
releaseTimes.length == n
keysPressed.length == n
2 <= n <= 1000
1 <= releaseTimes[i] <= 109
releaseTimes[i] < releaseTimes[i+1]
keysPressed 仅由小写英文字母组成",63,,34222,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],61106
评论 (111),arithmetic-subarrays,中等,"如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 等差数列 。更正式地，数列 s 是等差数列，只需要满足：对于每个有效的 i ， s[i+1] - s[i] == s[1] - s[0] 都成立。
例如，下面这些都是 等差数列 ：
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
下面的数列 不是等差数列 ：
1, 1, 2, 5, 7
给你一个由 n 个整数组成的数组 nums，和两个由 m 个整数组成的数组 l 和 r，后两个数组表示 m 组范围查询，其中第 i 个查询对应范围 [l[i], r[i]] 。所有数组的下标都是 从 0 开始 的。
返回 boolean 元素构成的答案列表 answer 。如果子数组 nums[l[i]], nums[l[i]+1], ... , nums[r[i]] 可以 重新排列 形成 等差数列 ，answer[i] 的值就是 true；否则answer[i] 的值就是 false 。
  示例 1：
输入：nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
输出：[true,false,true]
解释：
第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。
第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。
第 2 个查询，对应子数组 [5,9,3,7] 。可以重新排列为等差数列 [3,5,7,9] 。
示例 2：
输入：nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
输出：[false,true,false,false,true,true]
  提示：
n == nums.length
m == l.length
m == r.length
2 <= n <= 500
1 <= m <= 500
0 <= l[i] < r[i] < n
-105 <= nums[i] <= 105",18,,9564,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],12573
评论 (317),path-with-minimum-effort,中等,"你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。
一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。
请你返回从左上角走到右下角的最小 体力消耗值 。
  示例 1：
输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。
示例 2：
输入：heights = [[1,2,3],[3,8,4],[5,3,5]]
输出：1
解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。
示例 3：
输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
输出：0
解释：上图所示路径不需要消耗任何体力。
  提示：
rows == heights.length
columns == heights[i].length
1 <= rows, columns <= 100
1 <= heights[i][j] <= 106",287,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png,32051,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],64124
评论 (29),rank-transform-of-a-matrix,困难,"给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。
每个元素的 秩 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：
秩是从 1 开始的一个整数。
如果两个元素 p 和 q 在 同一行 或者 同一列 ，那么：
如果 p < q ，那么 rank(p) < rank(q)
如果 p == q ，那么 rank(p) == rank(q)
如果 p > q ，那么 rank(p) > rank(q)
秩 需要越 小 越好。
题目保证按照上面规则 answer 数组是唯一的。
  示例 1：
输入：matrix = [[1,2],[3,4]]
输出：[[1,2],[2,3]]
解释：
matrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。
matrix[0][1] 的秩为 2 ，因为 matrix[0][1] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。
matrix[1][0] 的秩为 2 ，因为 matrix[1][0] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。
matrix[1][1] 的秩为 3 ，因为 matrix[1][1] > matrix[0][1]， matrix[1][1] > matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。
示例 2：
输入：matrix = [[7,7],[7,7]]
输出：[[1,1],[1,1]]
示例 3：
输入：matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
输出：[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
示例 4：
输入：matrix = [[7,3,6],[1,4,5],[9,8,2]]
输出：[[5,1,4],[1,2,3],[6,3,1]]
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 500
-109 <= matrix[row][col] <= 109",53,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg,1779,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],5349
评论 (79),percentage-of-users-attended-a-contest,Unknown,,-1,,-1,[],[],-1
评论 (24),add-two-polynomials-represented-as-linked-lists,Unknown,,-1,,-1,[],[],-1
评论 (77),hopper-company-queries-i,Unknown,,-1,,-1,[],[],-1
评论 (108),sort-array-by-increasing-frequency,简单,"给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 
请你返回排序后的数组。
  示例 1：
输入：nums = [1,1,2,2,2,3]
输出：[3,1,1,2,2,2]
解释：'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。
示例 2：
输入：nums = [2,3,1,3,2]
输出：[1,3,3,2,2]
解释：'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序。
示例 3：
输入：nums = [-1,1,-6,4,5,-6,1,4,1]
输出：[5,-1,4,4,-6,-6,1,1,1]
  提示：
1 <= nums.length <= 100
-100 <= nums[i] <= 100",43,,12752,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],18314
评论 (71),widest-vertical-area-between-two-points-containing-no-points,中等,"给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直面积 的宽度。
垂直面积 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 最宽垂直面积 为宽度最大的一个垂直面积。
请注意，垂直区域 边上 的点 不在 区域内。
  示例 1：
输入：points = [[8,7],[9,9],[7,4],[9,7]]
输出：1
解释：红色区域和蓝色区域都是最优区域。
示例 2：
输入：points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
输出：3
  提示：
n == points.length
2 <= n <= 105
points[i].length == 2
0 <= xi, yi <= 109",13,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/points3.png,6919,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],8543
评论 (50),count-substrings-that-differ-by-one-character,中等,"给你两个字符串 s 和 t ，请你找出 s 中的非空子串的数目，这些子串满足替换 一个不同字符 以后，是 t 串的子串。换言之，请你找到 s 和 t 串中 恰好 只有一个字符不同的子字符串对的数目。
比方说， ""computer"" 和 ""computation"" 加粗部分只有一个字符不同： 'e'/'a' ，所以这一对子字符串会给答案加 1 。
请你返回满足上述条件的不同子字符串对数目。
一个 子字符串 是一个字符串中连续的字符。
  示例 1：
输入：s = ""aba"", t = ""baba""
输出：6
解释：以下为只相差 1 个字符的 s 和 t 串的子字符串对：
(""aba"", ""baba"")
(""aba"", ""baba"")
(""aba"", ""baba"")
(""aba"", ""baba"")
(""aba"", ""baba"")
(""aba"", ""baba"")
加粗部分分别表示 s 和 t 串选出来的子字符串。
示例 2：
输入：s = ""ab"", t = ""bb""
输出：3
解释：以下为只相差 1 个字符的 s 和 t 串的子字符串对：
(""ab"", ""bb"")
(""ab"", ""bb"")
(""ab"", ""bb"")
加粗部分分别表示 s 和 t 串选出来的子字符串。
示例 3：
输入：s = ""a"", t = ""a""
输出：0
示例 4：
输入：s = ""abe"", t = ""bbc""
输出：10
  提示：
1 <= s.length, t.length <= 100
s 和 t 都只包含小写英文字母。",42,,3637,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],5061
评论 (24),number-of-ways-to-form-a-target-string-given-a-dictionary,困难,"给你一个字符串列表 words 和一个目标字符串 target 。words 中所有字符串都 长度相同  。
你的目标是使用给定的 words 字符串列表按照下述规则构造 target ：
从左到右依次构造 target 的每一个字符。
为了得到 target 第 i 个字符（下标从 0 开始），当 target[i] = words[j][k] 时，你可以使用 words 列表中第 j 个字符串的第 k 个字符。
一旦你使用了 words 中第 j 个字符串的第 k 个字符，你不能再使用 words 字符串列表中任意单词的第 x 个字符（x <= k）。也就是说，所有单词下标小于等于 k 的字符都不能再被使用。
请你重复此过程直到得到目标字符串 target 。
请注意， 在构造目标字符串的过程中，你可以按照上述规定使用 words 列表中 同一个字符串 的 多个字符 。
请你返回使用 words 构造 target 的方案数。由于答案可能会很大，请对 109 + 7 取余 后返回。
（译者注：此题目求的是有多少个不同的 k 序列，详情请见示例。）
  示例 1：
输入：words = [""acca"",""bbbb"",""caca""], target = ""aba""
输出：6
解释：总共有 6 种方法构造目标串。
""aba"" -> 下标为 0 (""acca"")，下标为 1 (""bbbb"")，下标为 3 (""caca"")
""aba"" -> 下标为 0 (""acca"")，下标为 2 (""bbbb"")，下标为 3 (""caca"")
""aba"" -> 下标为 0 (""acca"")，下标为 1 (""bbbb"")，下标为 3 (""acca"")
""aba"" -> 下标为 0 (""acca"")，下标为 2 (""bbbb"")，下标为 3 (""acca"")
""aba"" -> 下标为 1 (""caca"")，下标为 2 (""bbbb"")，下标为 3 (""acca"")
""aba"" -> 下标为 1 (""caca"")，下标为 2 (""bbbb"")，下标为 3 (""caca"")
示例 2：
输入：words = [""abba"",""baab""], target = ""bab""
输出：4
解释：总共有 4 种不同形成 target 的方法。
""bab"" -> 下标为 0 (""baab"")，下标为 1 (""baab"")，下标为 2 (""abba"")
""bab"" -> 下标为 0 (""baab"")，下标为 1 (""baab"")，下标为 3 (""baab"")
""bab"" -> 下标为 0 (""baab"")，下标为 2 (""baab"")，下标为 3 (""baab"")
""bab"" -> 下标为 1 (""abba"")，下标为 2 (""baab"")，下标为 3 (""baab"")
示例 3：
输入：words = [""abcd""], target = ""abcd""
输出：1
示例 4：
输入：words = [""abab"",""baba"",""abba"",""baab""], target = ""abba""
输出：16
  提示：
1 <= words.length <= 1000
1 <= words[i].length <= 1000
words 中所有单词长度相同。
1 <= target.length <= 1000
words[i] 和 target 都仅包含小写英文字母。",18,,1621,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],3893
评论 (151),check-array-formation-through-concatenation,简单,"给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。
如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。
  示例 1：
输入：arr = [15,88], pieces = [[88],[15]]
输出：true
解释：依次连接 [15] 和 [88]
示例 2：
输入：arr = [49,18,16], pieces = [[16,18,49]]
输出：false
解释：即便数字相符，也不能重新排列 pieces[0]
示例 3：
输入：arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
输出：true
解释：依次连接 [91]、[4,64] 和 [78]
  提示：
1 <= pieces.length <= arr.length <= 100
sum(pieces[i].length) == arr.length
1 <= pieces[i].length <= arr.length
1 <= arr[i], pieces[i][j] <= 100
arr 中的整数 互不相同
pieces 中的整数 互不相同（也就是说，如果将 pieces 扁平化成一维数组，数组中的所有整数互不相同）",40,,14623,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],22596
评论 (155),count-sorted-vowel-strings,中等,"给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。
字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。
  示例 1：
输入：n = 1
输出：5
解释：仅由元音组成的 5 个字典序字符串为 [""a"",""e"",""i"",""o"",""u""]
示例 2：
输入：n = 2
输出：15
解释：仅由元音组成的 15 个字典序字符串为
[""aa"",""ae"",""ai"",""ao"",""au"",""ee"",""ei"",""eo"",""eu"",""ii"",""io"",""iu"",""oo"",""ou"",""uu""]
注意，""ea"" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后
示例 3：
输入：n = 33
输出：66045
  提示：
1 <= n <= 50 ",68,,13721,['https://leetcode.cn/tag/dynamic-programming/'],[],17702
评论 (103),furthest-building-you-can-reach,中等,"给你一个整数数组 heights ，表示建筑物的高度。另有一些砖块 bricks 和梯子 ladders 。
你从建筑物 0 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。
当从建筑物 i 移动到建筑物 i+1（下标 从 0 开始 ）时：
如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块
如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 (h[i+1] - h[i]) 个砖块
如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 从 0 开始 ）。
  示例 1：
输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
输出：4
解释：从建筑物 0 出发，你可以按此方案完成旅程：
- 不使用砖块或梯子到达建筑物 1 ，因为 4 >= 2
- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 < 7
- 不使用砖块或梯子到达建筑物 3 ，因为 7 >= 6
- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 < 9
无法越过建筑物 4 ，因为没有更多砖块或梯子。
示例 2：
输入：heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2
输出：7
示例 3：
输入：heights = [14,3,19,3], bricks = 17, ladders = 0
输出：3
  提示：
1 <= heights.length <= 105
1 <= heights[i] <= 106
0 <= bricks <= 109
0 <= ladders <= heights.length",83,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/q4.gif,8127,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],18058
评论 (29),kth-smallest-instructions,困难,"Bob 站在单元格 (0, 0) ，想要前往目的地 destination ：(row, column) 。他只能向 右 或向 下 走。你可以为 Bob 提供导航 指令 来帮助他到达目的地 destination 。
指令 用字符串表示，其中每个字符：
'H' ，意味着水平向右移动
'V' ，意味着竖直向下移动
能够为 Bob 导航到目的地 destination 的指令可以有多种，例如，如果目的地 destination 是 (2, 3)，""HHHVV"" 和 ""HVHVH"" 都是有效 指令 。
然而，Bob 很挑剔。因为他的幸运数字是 k，他想要遵循 按字典序排列后的第 k 条最小指令 的导航前往目的地 destination 。k  的编号 从 1 开始 。
给你一个整数数组 destination 和一个整数 k ，请你返回可以为 Bob 提供前往目的地 destination 导航的 按字典序排列后的第 k 条最小指令 。
  示例 1：
输入：destination = [2,3], k = 1
输出：""HHHVV""
解释：能前往 (2, 3) 的所有导航指令 按字典序排列后 如下所示：
[""HHHVV"", ""HHVHV"", ""HHVVH"", ""HVHHV"", ""HVHVH"", ""HVVHH"", ""VHHHV"", ""VHHVH"", ""VHVHH"", ""VVHHH""].
示例 2：
输入：destination = [2,3], k = 2
输出：""HHVHV""
示例 3：
输入：destination = [2,3], k = 3
输出：""HHVVH""
  提示：
destination.length == 2
1 <= row, column <= 15
1 <= k <= nCr(row + column, row)，其中 nCr(a, b) 表示组合数，即从 a 个物品中选 b 个物品的不同方案数。",45,,2617,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/combinatorics/']",[],5629
评论 (18),lowest-common-ancestor-of-a-binary-tree-ii,Unknown,,-1,,-1,[],[],-1
评论 (52),hopper-company-queries-ii,Unknown,,-1,,-1,[],[],-1
评论 (282),get-maximum-in-generated-array,简单,"给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：
nums[0] = 0
nums[1] = 1
当 2 <= 2 * i <= n 时，nums[2 * i] = nums[i]
当 2 <= 2 * i + 1 <= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]
返回生成数组 nums 中的 最大 值。
  示例 1：
输入：n = 7
输出：3
解释：根据规则：
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
因此，nums = [0,1,1,2,1,3,2,3]，最大值 3
示例 2：
输入：n = 2
输出：1
解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1
示例 3：
输入：n = 3
输出：2
解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2
  提示：
0 <= n <= 100",67,,40886,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/simulation/']",[],77337
评论 (76),minimum-deletions-to-make-character-frequencies-unique,中等,"如果字符串 s 中 不存在 两个不同字符 频次 相同的情况，就称 s 是 优质字符串 。
给你一个字符串 s，返回使 s 成为 优质字符串 需要删除的 最小 字符数。
字符串中字符的 频次 是该字符在字符串中的出现次数。例如，在字符串 ""aab"" 中，'a' 的频次是 2，而 'b' 的频次是 1 。
  示例 1：
输入：s = ""aab""
输出：0
解释：s 已经是优质字符串。
示例 2：
输入：s = ""aaabbbcc""
输出：2
解释：可以删除两个 'b' , 得到优质字符串 ""aaabcc"" 。
另一种方式是删除一个 'b' 和一个 'c' ，得到优质字符串 ""aaabbc"" 。
示例 3：
输入：s = ""ceabaacb""
输出：2
解释：可以删除两个 'c' 得到优质字符串 ""eabaab"" 。
注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）
  提示：
1 <= s.length <= 105
s 仅含小写英文字母",40,,9402,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],17739
评论 (86),sell-diminishing-valued-colored-balls,中等,"你有一些球的库存 inventory ，里面包含着不同颜色的球。一个顾客想要 任意颜色 总数为 orders 的球。
这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 同色球 的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6 。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）
给你整数数组 inventory ，其中 inventory[i] 表示第 i 种颜色球一开始的数目。同时给你整数 orders ，表示顾客总共想买的球数目。你可以按照 任意顺序 卖球。
请你返回卖了 orders 个球以后 最大 总价值之和。由于答案可能会很大，请你返回答案对 109 + 7 取余数 的结果。
  示例 1：
输入：inventory = [2,5], orders = 4
输出：14
解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。
最大总和为 2 + 5 + 4 + 3 = 14 。
示例 2：
输入：inventory = [3,5], orders = 6
输出：19
解释：卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。
最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。
示例 3：
输入：inventory = [2,8,4,10,6], orders = 20
输出：110
示例 4：
输入：inventory = [1000000000], orders = 1000000000
输出：21
解释：卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 500000000500000000 对 109 + 7 取余为 21 。
  提示：
1 <= inventory.length <= 105
1 <= inventory[i] <= 109
1 <= orders <= min(sum(inventory[i]), 109)",62,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/08/jj.gif,4882,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],16602
评论 (66),create-sorted-array-through-instructions,困难,"给你一个整数数组 instructions ，你需要根据 instructions 中的元素创建一个有序数组。一开始你有一个空的数组 nums ，你需要 从左到右 遍历 instructions 中的元素，将它们依次插入 nums 数组中。每一次插入操作的 代价 是以下两者的 较小值 ：
nums 中 严格小于  instructions[i] 的数字数目。
nums 中 严格大于  instructions[i] 的数字数目。
比方说，如果要将 3 插入到 nums = [1,2,3,5] ，那么插入操作的 代价 为 min(2, 1) (元素 1 和  2 小于 3 ，元素 5 大于 3 ），插入后 nums 变成 [1,2,3,3,5] 。
请你返回将 instructions 中所有元素依次插入 nums 后的 总最小代价 。由于答案会很大，请将它对 109 + 7 取余 后返回。
  示例 1：
输入：instructions = [1,5,6,2]
输出：1
解释：一开始 nums = [] 。
插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
插入 5 ，代价为 min(1, 0) = 0 ，现在 nums = [1,5] 。
插入 6 ，代价为 min(2, 0) = 0 ，现在 nums = [1,5,6] 。
插入 2 ，代价为 min(1, 2) = 1 ，现在 nums = [1,2,5,6] 。
总代价为 0 + 0 + 0 + 1 = 1 。
示例 2:
输入：instructions = [1,2,3,6,5,4]
输出：3
解释：一开始 nums = [] 。
插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
插入 2 ，代价为 min(1, 0) = 0 ，现在 nums = [1,2] 。
插入 3 ，代价为 min(2, 0) = 0 ，现在 nums = [1,2,3] 。
插入 6 ，代价为 min(3, 0) = 0 ，现在 nums = [1,2,3,6] 。
插入 5 ，代价为 min(3, 1) = 1 ，现在 nums = [1,2,3,5,6] 。
插入 4 ，代价为 min(3, 2) = 2 ，现在 nums = [1,2,3,4,5,6] 。
总代价为 0 + 0 + 0 + 0 + 1 + 2 = 3 。
示例 3：
输入：instructions = [1,3,3,3,2,4,2,1,2]
输出：4
解释：一开始 nums = [] 。
插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3] 。
插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3] 。
插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3,3] 。
插入 2 ，代价为 min(1, 3) = 1 ，现在 nums = [1,2,3,3,3] 。
插入 4 ，代价为 min(5, 0) = 0 ，现在 nums = [1,2,3,3,3,4] 。
插入 2 ，代价为 min(1, 4) = 1 ，现在 nums = [1,2,2,3,3,3,4] 。
插入 1 ，代价为 min(0, 6) = 0 ，现在 nums = [1,1,2,2,3,3,3,4] 。
插入 2 ，代价为 min(2, 4) = 2 ，现在 nums = [1,1,2,2,2,3,3,3,4] 。
总代价为 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4 。
  提示：
1 <= instructions.length <= 105
1 <= instructions[i] <= 105",40,,3258,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/merge-sort/']",[],6774
评论 (27),lowest-common-ancestor-of-a-binary-tree-iii,Unknown,,-1,,-1,[],[],-1
评论 (48),hopper-company-queries-iii,Unknown,,-1,,-1,[],[],-1
评论 (103),defuse-the-bomb,简单,"你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。
为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。
如果 k > 0 ，将第 i 个数字用 接下来 k 个数字之和替换。
如果 k < 0 ，将第 i 个数字用 之前 k 个数字之和替换。
如果 k == 0 ，将第 i 个数字用 0 替换。
由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。
给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！
  示例 1：
输入：code = [5,7,1,4], k = 3
输出：[12,10,16,13]
解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。
示例 2：
输入：code = [1,2,3,4], k = 0
输出：[0,0,0,0]
解释：当 k 为 0 时，所有数字都被 0 替换。
示例 3：
输入：code = [2,4,9,3], k = -2
输出：[12,5,6,13]
解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。
  提示：
n == code.length
1 <= n <= 100
1 <= code[i] <= 100
-(n - 1) <= k <= n - 1",24,,9376,['https://leetcode.cn/tag/array/'],[],14716
评论 (55),minimum-deletions-to-make-string-balanced,中等,"给你一个字符串 s ，它仅包含字符 'a' 和 'b' 。
你可以删除 s 中任意数目的字符，使得 s 平衡 。我们称 s 平衡的 当不存在下标对 (i,j) 满足 i < j 且 s[i] = 'b' 同时 s[j]= 'a' 。
请你返回使 s 平衡 的 最少 删除次数。
  示例 1：
输入：s = ""aababbab""
输出：2
解释：你可以选择以下任意一种方案：
下标从 0 开始，删除第 2 和第 6 个字符（""aababbab"" -> ""aaabbb""），
下标从 0 开始，删除第 3 和第 6 个字符（""aababbab"" -> ""aabbbb""）。
示例 2：
输入：s = ""bbaaaaabb""
输出：2
解释：唯一的最优解是删除最前面两个字符。
  提示：
1 <= s.length <= 105
s[i] 要么是 'a' 要么是 'b' 。",29,,5053,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],9507
评论 (90),minimum-jumps-to-reach-home,中等,"有一只跳蚤的家在数轴上的位置 x 处。请你帮助它从位置 0 出发，到达它的家。
跳蚤跳跃的规则如下：
它可以 往前 跳恰好 a 个位置（即往右跳）。
它可以 往后 跳恰好 b 个位置（即往左跳）。
它不能 连续 往后跳 2 次。
它不能跳到任何 forbidden 数组中的位置。
跳蚤可以往前跳 超过 它的家的位置，但是它 不能跳到负整数 的位置。
给你一个整数数组 forbidden ，其中 forbidden[i] 是跳蚤不能跳到的位置，同时给你整数 a， b 和 x ，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 x 的可行方案，请你返回 -1 。
  示例 1：
输入：forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9
输出：3
解释：往前跳 3 次（0 -> 3 -> 6 -> 9），跳蚤就到家了。
示例 2：
输入：forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11
输出：-1
示例 3：
输入：forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7
输出：2
解释：往前跳一次（0 -> 16），然后往回跳一次（16 -> 7），跳蚤就到家了。
  提示：
1 <= forbidden.length <= 1000
1 <= a, b, forbidden[i] <= 2000
0 <= x <= 2000
forbidden 中所有位置互不相同。
位置 x 不在 forbidden 中。",53,,5669,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],18935
评论 (24),distribute-repeating-integers,困难,"给你一个长度为 n 的整数数组 nums ，这个数组中至多有 50 个不同的值。同时你有 m 个顾客的订单 quantity ，其中，整数 quantity[i] 是第 i 位顾客订单的数目。请你判断是否能将 nums 中的整数分配给这些顾客，且满足：
第 i 位顾客 恰好 有 quantity[i] 个整数。
第 i 位顾客拿到的整数都是 相同的 。
每位顾客都满足上述两个要求。
如果你可以分配 nums 中的整数满足上面的要求，那么请返回 true ，否则返回 false 。
  示例 1：
输入：nums = [1,2,3,4], quantity = [2]
输出：false
解释：第 0 位顾客没办法得到两个相同的整数。
示例 2：
输入：nums = [1,2,3,3], quantity = [2]
输出：true
解释：第 0 位顾客得到 [3,3] 。整数 [1,2] 都没有被使用。
示例 3：
输入：nums = [1,1,2,2], quantity = [2,2]
输出：true
解释：第 0 位顾客得到 [1,1] ，第 1 位顾客得到 [2,2] 。
  提示：
n == nums.length
1 <= n <= 105
1 <= nums[i] <= 1000
m == quantity.length
1 <= m <= 10
1 <= quantity[i] <= 105
nums 中至多有 50 个不同的数字。",40,,2815,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",[],7215
评论 (76),design-an-ordered-stream,简单,"有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。
设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。
实现 OrderedStream 类：
OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。
String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后：
如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个  id + 1 。
否则，返回一个空列表。
  示例：
输入
[""OrderedStream"", ""insert"", ""insert"", ""insert"", ""insert"", ""insert""]
[[5], [3, ""ccccc""], [1, ""aaaaa""], [2, ""bbbbb""], [5, ""eeeee""], [4, ""ddddd""]]
输出
[null, [], [""aaaaa""], [""bbbbb"", ""ccccc""], [], [""ddddd"", ""eeeee""]]

解释
OrderedStream os= new OrderedStream(5);
os.insert(3, ""ccccc""); // 插入 (3, ""ccccc"")，返回 []
os.insert(1, ""aaaaa""); // 插入 (1, ""aaaaa"")，返回 [""aaaaa""]
os.insert(2, ""bbbbb""); // 插入 (2, ""bbbbb"")，返回 [""bbbbb"", ""ccccc""]
os.insert(5, ""eeeee""); // 插入 (5, ""eeeee"")，返回 []
os.insert(4, ""ddddd""); // 插入 (4, ""ddddd"")，返回 [""ddddd"", ""eeeee""]
  提示：
1 <= n <= 1000
1 <= id <= n
value.length == 5
value 仅由小写字母组成
每次调用 insert 都会使用一个唯一的 id
恰好调用 n 次 insert",21,,9580,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/data-stream/']",[],12303
评论 (71),determine-if-two-strings-are-close,中等,"如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：
操作 1：交换任意两个 现有 字符。
例如，abcde -> aecdb
操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。
例如，aacabb -> bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）
你可以根据需要对任意一个字符串多次使用这两种操作。
给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。
  示例 1：
输入：word1 = ""abc"", word2 = ""bca""
输出：true
解释：2 次操作从 word1 获得 word2 。
执行操作 1：""abc"" -> ""acb""
执行操作 1：""acb"" -> ""bca""
示例 2：
输入：word1 = ""a"", word2 = ""aa""
输出：false
解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。
示例 3：
输入：word1 = ""cabbba"", word2 = ""abbccc""
输出：true
解释：3 次操作从 word1 获得 word2 。
执行操作 1：""cabbba"" -> ""caabbb""
执行操作 2：""caabbb"" -> ""baaccc""
执行操作 2：""baaccc"" -> ""abbccc""
示例 4：
输入：word1 = ""cabbba"", word2 = ""aabbss""
输出：false
解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。
  提示：
1 <= word1.length, word2.length <= 105
word1 和 word2 仅包含小写英文字母",31,,6441,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],13805
评论 (111),minimum-operations-to-reduce-x-to-zero,中等,"给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。
如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。
  示例 1：
输入：nums = [1,1,4,2,3], x = 5
输出：2
解释：最佳解决方案是移除后两个元素，将 x 减到 0 。
示例 2：
输入：nums = [5,6,7,8,9], x = 4
输出：-1
示例 3：
输入：nums = [3,2,20,1,1,3], x = 10
输出：5
解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 104
1 <= x <= 109",100,,12498,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",[],39607
评论 (17),maximize-grid-happiness,困难,"给你四个整数 m、n、introvertsCount 和 extrovertsCount 。有一个 m x n 网格，和两种类型的人：内向的人和外向的人。总共有 introvertsCount 个内向的人和 extrovertsCount 个外向的人。
请你决定网格中应当居住多少人，并为每个人分配一个网格单元。 注意，不必 让所有人都生活在网格中。
每个人的 幸福感 计算如下：
内向的人 开始 时有 120 个幸福感，但每存在一个邻居（内向的或外向的）他都会 失去  30 个幸福感。
外向的人 开始 时有 40 个幸福感，每存在一个邻居（内向的或外向的）他都会 得到  20 个幸福感。
邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。
网格幸福感 是每个人幸福感的 总和 。 返回 最大可能的网格幸福感 。
  示例 1：
输入：m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2
输出：240
解释：假设网格坐标 (row, column) 从 1 开始编号。
将内向的人放置在单元 (1,1) ，将外向的人放置在单元 (1,3) 和 (2,3) 。
- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (0 * 30)（0 位邻居）= 120
- 位于 (1,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60
- 位于 (2,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60
网格幸福感为：120 + 60 + 60 = 240
上图展示该示例对应网格中每个人的幸福感。内向的人在浅绿色单元中，而外向的人在浅紫色单元中。
示例 2：
输入：m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1
输出：260
解释：将内向的人放置在单元 (1,1) 和 (3,1) ，将外向的人放置在单元 (2,1) 。
- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90
- 位于 (2,1) 的外向的人的幸福感：40（初始幸福感）+ (2 * 20)（2 位邻居）= 80
- 位于 (3,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90
网格幸福感为 90 + 80 + 90 = 260
示例 3：
输入：m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0
输出：240
  提示：
1 <= m, n <= 5
0 <= introvertsCount, extrovertsCount <= min(m * n, 6)",44,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/grid_happiness.png,1619,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],3823
评论 (10),correct-a-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (91),average-time-of-process-per-machine,Unknown,,-1,,-1,[],[],-1
评论 (140),check-if-two-string-arrays-are-equivalent,简单,"给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。
数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。
  示例 1：
输入：word1 = [""ab"", ""c""], word2 = [""a"", ""bc""]
输出：true
解释：
word1 表示的字符串为 ""ab"" + ""c"" -> ""abc""
word2 表示的字符串为 ""a"" + ""bc"" -> ""abc""
两个字符串相同，返回 true
示例 2：
输入：word1 = [""a"", ""cb""], word2 = [""ab"", ""c""]
输出：false
示例 3：
输入：word1  = [""abc"", ""d"", ""defg""], word2 = [""abcddefg""]
输出：true
  提示：
1 <= word1.length, word2.length <= 103
1 <= word1[i].length, word2[i].length <= 103
1 <= sum(word1[i].length), sum(word2[i].length) <= 103
word1[i] 和 word2[i] 由小写字母组成",23,,24765,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],30606
评论 (103),smallest-string-with-a-given-numeric-value,中等,"小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，c 的数值为 3 ，以此类推。
字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 ""abe"" 的数值等于 1 + 2 + 5 = 8 。
给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。
注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况：
x 是 y 的一个前缀；
如果 i 是 x[i] != y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。
  示例 1：
输入：n = 3, k = 27
输出：""aay""
解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。
示例 2：
输入：n = 5, k = 73
输出：""aaszz""
  提示：
1 <= n <= 105
n <= k <= 26 * n",36,,9028,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],15698
评论 (113),ways-to-make-a-fair-array,中等,"给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。
比方说，如果 nums = [6,1,7,4,1] ，那么：
选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。
选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。
选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。
如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。
请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。
  示例 1：
输入：nums = [2,1,6,4]
输出：1
解释：
删除下标 0 ：[1,6,4] -> 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。
删除下标 1 ：[2,6,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。
删除下标 2 ：[2,1,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。
删除下标 3 ：[2,1,6] -> 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。
只有一种让剩余数组成为平衡数组的方案。
示例 2：
输入：nums = [1,1,1]
输出：3
解释：你可以删除任意元素，剩余数组都是平衡数组。
示例 3：
输入：nums = [1,2,3]
输出：0
解释：不管删除哪个元素，剩下数组都不是平衡数组。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 104",31,,6324,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],11381
评论 (90),minimum-initial-energy-to-finish-tasks,困难,"给你一个任务数组 tasks ，其中 tasks[i] = [actuali, minimumi] ：
actuali 是完成第 i 个任务 需要耗费 的实际能量。
minimumi 是开始第 i 个任务前需要达到的最低能量。
比方说，如果任务为 [10, 12] 且你当前的能量为 11 ，那么你不能开始这个任务。如果你当前的能量为 13 ，你可以完成这个任务，且完成它后剩余能量为 3 。
你可以按照 任意顺序 完成任务。
请你返回完成所有任务的 最少 初始能量。
  示例 1：
输入：tasks = [[1,2],[2,4],[4,8]]
输出：8
解释：
一开始有 8 能量，我们按照如下顺序完成任务：
    - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。
    - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。
    - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。
注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。
示例 2：
输入：tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]
输出：32
解释：
一开始有 32 能量，我们按照如下顺序完成任务：
    - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。
    - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。
    - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。
    - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。
    - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。
示例 3：
输入：tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]
输出：27
解释：
一开始有 27 能量，我们按照如下顺序完成任务：
    - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。
    - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。
    - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。
    - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。
    - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。
    - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。
  提示：
1 <= tasks.length <= 105
1 <= actuali <= minimumi <= 104",42,,6025,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],9142
评论 (7),change-the-root-of-a-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (68),fix-names-in-a-table,简单,"SQL架构
表： Users
+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| user_id        | int     |
| name           | varchar |
+----------------+---------+
user_id 是该表的主键。
该表包含用户的 ID 和名字。名字仅由小写和大写字符组成。
  编写一个 SQL 查询来修复名字，使得只有第一个字符是大写的，其余都是小写的。
返回按 user_id 排序的结果表。
查询结果格式示例如下。
  示例 1：
输入：
Users table:
+---------+-------+
| user_id | name  |
+---------+-------+
| 1       | aLice |
| 2       | bOB   |
+---------+-------+
输出：
+---------+-------+
| user_id | name  |
+---------+-------+
| 1       | Alice |
| 2       | Bob   |
+---------+-------+",24,,12137,['https://leetcode.cn/tag/database/'],[],19232
评论 (116),maximum-repeating-substring,简单,"给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串，那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。如果 word 不是 sequence 的子串，那么重复值 k 为 0 。
给你一个字符串 sequence 和 word ，请你返回 最大重复值 k 。
  示例 1：
输入：sequence = ""ababc"", word = ""ab""
输出：2
解释：""abab"" 是 ""ababc"" 的子字符串。
示例 2：
输入：sequence = ""ababc"", word = ""ba""
输出：1
解释：""ba"" 是 ""ababc"" 的子字符串，但 ""baba"" 不是 ""ababc"" 的子字符串。
示例 3：
输入：sequence = ""ababc"", word = ""ac""
输出：0
解释：""ac"" 不是 ""ababc"" 的子字符串。
  提示：
1 <= sequence.length <= 100
1 <= word.length <= 100
sequence 和 word 都只包含小写英文字母。",20,,9340,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/string-matching/']",[],21072
评论 (121),merge-in-between-linked-lists,中等,"给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。
请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。
下图中蓝色边和节点展示了操作后的结果：
请你返回结果链表的头指针。
  示例 1：
输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
输出：[0,1,2,1000000,1000001,1000002,5]
解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。
示例 2：
输入：list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]
输出：[0,1,1000000,1000001,1000002,1000003,1000004,6]
解释：上图中蓝色的边和节点为答案链表。
  提示：
3 <= list1.length <= 104
1 <= a <= b < list1.length - 1
1 <= list2.length <= 104",47,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/fig1.png,17579,['https://leetcode.cn/tag/linked-list/'],[],23333
评论 (55),design-front-middle-back-queue,中等,"请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。
请你完成 FrontMiddleBack 类：
FrontMiddleBack() 初始化队列。
void pushFront(int val) 将 val 添加到队列的 最前面 。
void pushMiddle(int val) 将 val 添加到队列的 正中间 。
void pushBack(int val) 将 val 添加到队里的 最后面 。
int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：
将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。
从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。
  示例 1：
输入：
[""FrontMiddleBackQueue"", ""pushFront"", ""pushBack"", ""pushMiddle"", ""pushMiddle"", ""popFront"", ""popMiddle"", ""popMiddle"", ""popBack"", ""popFront""]
[[], [1], [2], [3], [4], [], [], [], [], []]
输出：
[null, null, null, null, null, 1, 3, 4, 2, -1]

解释：
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // 返回 1 -> [4, 3, 2]
q.popMiddle();    // 返回 3 -> [4, 2]
q.popMiddle();    // 返回 4 -> [2]
q.popBack();      // 返回 2 -> []
q.popFront();     // 返回 -1 -> [] （队列为空）
  提示：
1 <= val <= 109
最多调用 1000 次 pushFront， pushMiddle， pushBack， popFront，  和  。",21,,5866,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/data-stream/']",[],11065
评论 (34),minimum-number-of-removals-to-make-mountain-array,困难,"我们定义 arr 是 山形数组 当且仅当它满足：
arr.length >= 3
存在某个下标 i （从 0 开始） 满足 0 < i < arr.length - 1 且：
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
给你整数数组 nums ，请你返回将 nums 变成 山形状数组 的 最少 删除次数。
  示例 1：
输入：nums = [1,3,1]
输出：0
解释：数组本身就是山形数组，所以我们不需要删除任何元素。
示例 2：
输入：nums = [2,1,1,5,6,2,3,1]
输出：3
解释：一种方法是将下标为 0，1 和 5 的元素删除，剩余元素为 [1,5,6,3,1] ，是山形数组。
  提示：
3 <= nums.length <= 1000
1 <= nums[i] <= 109
题目保证 nums 删除一些元素后一定能得到山形数组。",25,,2637,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],5635
评论 (580),richest-customer-wealth,简单,"给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。
客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。
  示例 1：
输入：accounts = [[1,2,3],[3,2,1]]
输出：6
解释：
第 1 位客户的资产总量 = 1 + 2 + 3 = 6
第 2 位客户的资产总量 = 3 + 2 + 1 = 6
两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。
示例 2：
输入：accounts = [[1,5],[7,3],[3,5]]
输出：10
解释：
第 1 位客户的资产总量 = 6
第 2 位客户的资产总量 = 10 
第 3 位客户的资产总量 = 8
第 2 位客户是最富有的，资产总量是 10
示例 3：
输入：accounts = [[2,8,7],[7,1,3],[1,9,5]]
输出：17
  提示：
m == accounts.length
n == accounts[i].length
1 <= m, n <= 50
1 <= accounts[i][j] <= 100",109,,85704,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],97856
评论 (95),find-the-most-competitive-subsequence,中等,"给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。
数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。
在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。
  示例 1：
输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
示例 2：
输入：nums = [2,4,3,3,5,4,9,6], k = 4
输出：[2,3,3,4]
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 109
1 <= k <= nums.length",83,,9171,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/monotonic-stack/']",[],24685
评论 (51),minimum-moves-to-make-array-complementary,中等,"给你一个长度为 偶数 n 的整数数组 nums 和一个整数 limit 。每一次操作，你可以将 nums 中的任何整数替换为 1 到 limit 之间的另一个整数。
如果对于所有下标 i（下标从 0 开始），nums[i] + nums[n - 1 - i] 都等于同一个数，则数组 nums 是 互补的 。例如，数组 [1,2,3,4] 是互补的，因为对于所有下标 i ，nums[i] + nums[n - 1 - i] = 5 。
返回使数组 互补 的 最少 操作次数。
  示例 1：
输入：nums = [1,2,4,3], limit = 4
输出：1
解释：经过 1 次操作，你可以将数组 nums 变成 [1,2,2,3]（加粗元素是变更的数字）：
nums[0] + nums[3] = 1 + 3 = 4.
nums[1] + nums[2] = 2 + 2 = 4.
nums[2] + nums[1] = 2 + 2 = 4.
nums[3] + nums[0] = 3 + 1 = 4.
对于每个 i ，nums[i] + nums[n-1-i] = 4 ，所以 nums 是互补的。
示例 2：
输入：nums = [1,2,2,1], limit = 2
输出：2
解释：经过 2 次操作，你可以将数组 nums 变成 [2,2,2,2] 。你不能将任何数字变更为 3 ，因为 3 > limit 。
示例 3：
输入：nums = [1,2,1,2], limit = 2
输出：0
解释：nums 已经是互补的。
  提示：
n == nums.length
2 <= n <= 105
1 <= nums[i] <= limit <= 105
n 是偶数。",81,,3101,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']",[],7968
评论 (36),minimize-deviation-in-array,困难,"给你一个由 n 个正整数组成的数组 nums 。
你可以对数组的任意元素执行任意次数的两类操作：
如果元素是 偶数 ，除以 2
例如，如果数组是 [1,2,3,4] ，那么你可以对最后一个元素执行此操作，使其变成 [1,2,3,2]
如果元素是 奇数 ，乘上 2
例如，如果数组是 [1,2,3,4] ，那么你可以对第一个元素执行此操作，使其变成 [2,2,3,4]
数组的 偏移量 是数组中任意两个元素之间的 最大差值 。
返回数组在执行某些操作之后可以拥有的 最小偏移量 。
  示例 1：
输入：nums = [1,2,3,4]
输出：1
解释：你可以将数组转换为 [1,2,3,2]，然后转换成 [2,2,3,2]，偏移量是 3 - 2 = 1
示例 2：
输入：nums = [4,1,5,20,3]
输出：3
解释：两次操作后，你可以将数组转换为 [4,2,5,5,3]，偏移量是 5 - 2 = 3
示例 3：
输入：nums = [2,10,8]
输出：3
  提示：
n == nums.length
2 <= n <= 5 * 104
1 <= nums[i] <= 109",64,,3340,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],7734
评论 (12),lowest-common-ancestor-of-a-binary-tree-iv,Unknown,,-1,,-1,[],[],-1
评论 (61),products-worth-over-invoices,Unknown,,-1,,-1,[],[],-1
评论 (163),goal-parser-interpretation,简单,"请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 ""G""、""()"" 和/或 ""(al)"" 按某种顺序组成。Goal 解析器会将 ""G"" 解释为字符串 ""G""、""()"" 解释为字符串 ""o"" ，""(al)"" 解释为字符串 ""al"" 。然后，按原顺序将经解释得到的字符串连接成一个字符串。
给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。
  示例 1：
输入：command = ""G()(al)""
输出：""Goal""
解释：Goal 解析器解释命令的步骤如下所示：
G -> G
() -> o
(al) -> al
最后连接得到的结果是 ""Goal""
示例 2：
输入：command = ""G()()()()(al)""
输出：""Gooooal""
示例 3：
输入：command = ""(al)G(al)()()G""
输出：""alGalooG""
  提示：
1 <= command.length <= 100
command 由 ""G""、""()"" 和/或 ""(al)"" 按某种顺序组成",26,,22802,['https://leetcode.cn/tag/string/'],[],27346
评论 (79),max-number-of-k-sum-pairs,中等,"给你一个整数数组 nums 和一个整数 k 。
每一步操作中，你需要从数组中选出和为 k 的两个整数，并将它们移出数组。
返回你可以对数组执行的最大操作数。
  示例 1：
输入：nums = [1,2,3,4], k = 5
输出：2
解释：开始时 nums = [1,2,3,4]：
- 移出 1 和 4 ，之后 nums = [2,3]
- 移出 2 和 3 ，之后 nums = []
不再有和为 5 的数对，因此最多执行 2 次操作。
示例 2：
输入：nums = [3,1,3,4,3], k = 6
输出：1
解释：开始时 nums = [3,1,3,4,3]：
- 移出前两个 3 ，之后nums = [1,4,3]
不再有和为 6 的数对，因此最多执行 1 次操作。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= k <= 109",26,,8516,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],16675
评论 (81),concatenation-of-consecutive-binary-numbers,中等,"给你一个整数 n ，请你将 1 到 n 的二进制表示连接起来，并返回连接结果对应的 十进制 数字对 109 + 7 取余的结果。
  示例 1：
输入：n = 1
输出：1
解释：二进制的 ""1"" 对应着十进制的 1 。
示例 2：
输入：n = 3
输出：27
解释：二进制下，1，2 和 3 分别对应 ""1"" ，""10"" 和 ""11"" 。
将它们依次连接，我们得到 ""11011"" ，对应着十进制的 27 。
示例 3：
输入：n = 12
输出：505379714
解释：连接结果为 ""1101110010111011110001001101010111100"" 。
对应的十进制数字为 118505380540 。
对 109 + 7 取余后，结果为 505379714 。
  提示：
1 <= n <= 105",33,,6378,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],13313
评论 (45),minimum-incompatibility,困难,"给你一个整数数组 nums 和一个整数 k 。你需要将这个数组划分到 k 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。
一个子集的 不兼容性 是该子集里面最大值和最小值的差。
请你返回将数组分成 k 个子集后，各子集 不兼容性 的 和 的 最小值 ，如果无法分成分成 k 个子集，返回 -1 。
子集的定义是数组中一些数字的集合，对数字顺序没有要求。
  示例 1：
输入：nums = [1,2,1,4], k = 2
输出：4
解释：最优的分配是 [1,2] 和 [1,4] 。
不兼容性和为 (2-1) + (4-1) = 4 。
注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。
示例 2：
输入：nums = [6,3,8,1,3,1,2,2], k = 4
输出：6
解释：最优的子集分配为 [1,2]，[2,3]，[6,8] 和 [1,3] 。
不兼容性和为 (2-1) + (3-2) + (8-6) + (3-1) = 6 。
示例 3：
输入：nums = [5,3,3,6,3,3], k = 3
输出：-1
解释：没办法将这些数字分配到 3 个子集且满足每个子集里没有相同数字。
  提示：
1 <= k <= nums.length <= 16
nums.length 能被 k 整除。
1 <= nums[i] <= nums.length",48,,2884,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],7088
评论 (6),longest-palindromic-subsequence-ii,Unknown,,-1,,-1,[],[],-1
评论 (53),invalid-tweets,Unknown,,-1,,-1,[],[],-1
评论 (145),count-the-number-of-consistent-strings,简单,"给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。
请你返回 words 数组中 一致字符串 的数目。
  示例 1：
输入：allowed = ""ab"", words = [""ad"",""bd"",""aaab"",""baa"",""badab""]
输出：2
解释：字符串 ""aaab"" 和 ""baa"" 都是一致字符串，因为它们只包含字符 'a' 和 'b' 。
示例 2：
输入：allowed = ""abc"", words = [""a"",""b"",""c"",""ab"",""ac"",""bc"",""abc""]
输出：7
解释：所有字符串都是一致的。
示例 3：
输入：allowed = ""cad"", words = [""cc"",""acd"",""b"",""ba"",""bac"",""bad"",""ac"",""d""]
输出：4
解释：字符串 ""cc""，""acd""，""ac"" 和 ""d"" 是一致字符串。
  提示：
1 <= words.length <= 104
1 <= allowed.length <= 26
1 <= words[i].length <= 10
allowed 中的字符 互不相同 。
words[i] 和 allowed 只包含小写英文字母。",25,,21679,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],26355
评论 (70),sum-of-absolute-differences-in-a-sorted-array,中等,"给你一个 非递减 有序整数数组 nums 。
请你建立并返回一个整数数组 result，它跟 nums 长度相同，且result[i] 等于 nums[i] 与数组中所有其他元素差的绝对值之和。
换句话说， result[i] 等于 sum(|nums[i]-nums[j]|) ，其中 0 <= j < nums.length 且 j != i （下标从 0 开始）。
  示例 1：
输入：nums = [2,3,5]
输出：[4,3,5]
解释：假设数组下标从 0 开始，那么
result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4，
result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3，
result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5。
示例 2：
输入：nums = [1,4,6,8,10]
输出：[24,15,13,15,21]
  提示：
2 <= nums.length <= 105
1 <= nums[i] <= nums[i + 1] <= 104",28,,5350,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/prefix-sum/']",[],8416
评论 (49),stone-game-vi,中等,"Alice 和 Bob 轮流玩一个游戏，Alice 先手。
一堆石子里总共有 n 个石子，轮到某个玩家时，他可以 移出 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 不一样的的评判标准 。双方都知道对方的评判标准。
给你两个长度为 n 的整数数组 aliceValues 和 bobValues 。aliceValues[i] 和 bobValues[i] 分别表示 Alice 和 Bob 认为第 i 个石子的价值。
所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 最优策略 进行游戏。
请你推断游戏的结果，用如下的方式表示：
如果 Alice 赢，返回 1 。
如果 Bob 赢，返回 -1 。
如果游戏平局，返回 0 。
  示例 1：
输入：aliceValues = [1,3], bobValues = [2,1]
输出：1
解释：
如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。
Bob 只能选择石子 0 ，得到 2 分。
Alice 获胜。
示例 2：
输入：aliceValues = [1,2], bobValues = [3,1]
输出：0
解释：
Alice 拿石子 0 ， Bob 拿石子 1 ，他们得分都为 1 分。
打平。
示例 3：
输入：aliceValues = [2,4,3], bobValues = [1,6,7]
输出：-1
解释：
不管 Alice 怎么操作，Bob 都可以得到比 Alice 更高的得分。
比方说，Alice 拿石子 1 ，Bob 拿石子 2 ， Alice 拿石子 0 ，Alice 会得到 6 分而 Bob 得分为 7 分。
Bob 会获胜。
  提示：
n == aliceValues.length == bobValues.length
1 <= n <= 105
1 <= aliceValues[i], bobValues[i] <= 100",43,,3472,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/game-theory/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],7191
评论 (14),delivering-boxes-from-storage-to-ports,困难,"你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。
给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] = [portsi, weighti] 。
portsi 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。
portsCount 是码头的数目。
maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。
箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤：
卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。
对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。
卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。
卡车在将所有箱子运输并卸货后，最后必须回到仓库。
请你返回将所有箱子送到相应码头的 最少行程 次数。
  示例 1：
输入：boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
输出：4
解释：最优策略如下：
- 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。
所以总行程数为 4 。
注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。
示例 2：
输入：boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
输出：6
解释：最优策略如下：
- 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第五个箱子，到达码头 3 ，回到仓库，总共 2 趟行程。
总行程数为 2 + 2 + 2 = 6 。
示例 3：
输入：boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
输出：6
解释：最优策略如下：
- 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
总行程数为 2 + 2 + 2 = 6 。
示例 4：
输入：boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7
输出：14
解释：最优策略如下：
- 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。
- 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。
总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。
  提示：
1 <= boxes.length <= 105
1 <= portsCount, maxBoxes, maxWeight <= 105
1 <= portsi <= portsCount
1 <= weightsi <= maxWeight",36,,1393,"['https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/monotonic-queue/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],3206
评论 (368),count-of-matches-in-tournament,简单,"给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：
如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。
如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。
返回在比赛中进行的配对次数，直到决出获胜队伍为止。
  示例 1：
输入：n = 7
输出：6
解释：比赛详情：
- 第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。
- 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。
- 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。
总配对次数 = 3 + 2 + 1 = 6
示例 2：
输入：n = 14
输出：13
解释：比赛详情：
- 第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。
- 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 
- 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。
- 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。
总配对次数 = 7 + 3 + 2 + 1 = 13
  提示：
1 <= n <= 200",98,,54206,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],64285
评论 (115),partitioning-into-minimum-number-of-deci-binary-numbers,中等,"如果一个十进制数字不含任何前导零，且每一位上的数字不是 0 就是 1 ，那么该数字就是一个 十-二进制数 。例如，101 和 1100 都是 十-二进制数，而 112 和 3001 不是。
给你一个表示十进制整数的字符串 n ，返回和为 n 的 十-二进制数 的最少数目。
  示例 1：
输入：n = ""32""
输出：3
解释：10 + 11 + 11 = 32
示例 2：
输入：n = ""82734""
输出：8
示例 3：
输入：n = ""27346209830709182346""
输出：9
  提示：
1 <= n.length <= 105
n 仅由数字组成
n 不含任何前导零并总是表示正整数",29,,17802,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],20579
评论 (81),stone-game-vii,中等,"石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，爱丽丝先开始 。
有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。
鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 减小得分的差值 。爱丽丝的目标是最大限度地 扩大得分的差值 。
给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。
  示例 1：
输入：stones = [5,3,1,4,2]
输出：6
解释：
- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。
- 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。
- 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。
- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。
- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。
得分的差值 18 - 12 = 6 。
示例 2：
输入：stones = [7,90,5,1,100,10,10,2]
输出：122
  提示：
n == stones.length
2 <= n <= 1000
1 <= stones[i] <= 1000",61,,5252,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/']",[],9785
评论 (33),maximum-height-by-stacking-cuboids,困难,"给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。
如果 widthi <= widthj 且 lengthi <= lengthj 且 heighti <= heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。
返回 堆叠长方体 cuboids 可以得到的 最大高度 。
  示例 1：
输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]]
输出：190
解释：
第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。
第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。
第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。
总高度是 95 + 50 + 45 = 190 。
示例 2：
输入：cuboids = [[38,25,45],[76,35,3]]
输出：76
解释：
无法将任何长方体放在另一个上面。
选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。
示例 3：
输入：cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
输出：102
解释：
重新排列长方体后，可以看到所有长方体的尺寸都相同。
你可以把 11x7 的一面朝下，这样它们的高度就是 17 。
堆叠长方体的最大高度为 6 * 17 = 102 。
  提示：
n == cuboids.length
1 <= n <= 100
1 <= widthi, lengthi, heighti <= 100",36,,2891,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],5822
评论 (9),count-ways-to-distribute-candies,Unknown,,-1,,-1,[],[],-1
评论 (80),daily-leads-and-partners,简单,"SQL架构
表：DailySales
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| date_id     | date    |
| make_name   | varchar |
| lead_id     | int     |
| partner_id  | int     |
+-------------+---------+
该表没有主键。
该表包含日期、产品的名称，以及售给的领导和合伙人的编号。
名称只包含小写英文字母。
  写一条 SQL 语句，使得对于每一个 date_id 和 make_name，返回不同的 lead_id 以及不同的 partner_id 的数量。
按 任意顺序 返回结果表。
查询结果格式如下示例所示。
  示例 1:
输入：
DailySales 表：
+-----------+-----------+---------+------------+
| date_id   | make_name | lead_id | partner_id |
+-----------+-----------+---------+------------+
| 2020-12-8 | toyota    | 0       | 1          |
| 2020-12-8 | toyota    | 1       | 0          |
| 2020-12-8 | toyota    | 1       | 2          |
| 2020-12-7 | toyota    | 0       | 2          |
| 2020-12-7 | toyota    | 0       | 1          |
| 2020-12-8 | honda     | 1       | 2          |
| 2020-12-8 | honda     | 2       | 1          |
| 2020-12-7 | honda     | 0       | 1          |
| 2020-12-7 | honda     | 1       | 2          |
| 2020-12-7 | honda     | 2       | 1          |
+-----------+-----------+---------+------------+
输出：
+-----------+-----------+--------------+-----------------+
| date_id   | make_name | unique_leads | unique_partners |
+-----------+-----------+--------------+-----------------+
| 2020-12-8 | toyota    | 2            | 3               |
| 2020-12-7 | toyota    | 1            | 2               |
| 2020-12-8 | honda     | 2            | 2               |
| 2020-12-7 | honda     | 3            | 2               |
+-----------+-----------+--------------+-----------------+
解释：
在 2020-12-8，丰田（toyota）有领导者 = [0, 1] 和合伙人 = [0, 1, 2] ，同时本田（honda）有领导者 = [1, 2] 和合伙人 = [1, 2]。
在 2020-12-7，丰田（toyota）有领导者 = [0] 和合伙人 = [1, 2] ，同时本田（honda）有领导者 = [0, 1, 2] 和合伙人 = [1, 2]。",15,,7956,['https://leetcode.cn/tag/database/'],[],9733
评论 (106),reformat-phone-number,简单,"给你一个字符串形式的电话号码 number 。number 由数字、空格 ' '、和破折号 '-' 组成。
请你按下述方式重新格式化电话号码。
首先，删除 所有的空格和破折号。
其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块：
2 个数字：单个含 2 个数字的块。
3 个数字：单个含 3 个数字的块。
4 个数字：两个分别含 2 个数字的块。
最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。
返回格式化后的电话号码。
  示例 1：
输入：number = ""1-23-45 6""
输出：""123-456""
解释：数字是 ""123456""
步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 ""123"" 。
步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 ""456"" 。
连接这些块后得到 ""123-456"" 。
示例 2：
输入：number = ""123 4-567""
输出：""123-45-67""
解释：数字是 ""1234567"".
步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 ""123"" 。
步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 ""45"" 和 ""67"" 。
连接这些块后得到 ""123-45-67"" 。
示例 3：
输入：number = ""123 4-5678""
输出：""123-456-78""
解释：数字是 ""12345678"" 。
步骤 1：第 1 个块 ""123"" 。
步骤 2：第 2 个块 ""456"" 。
步骤 3：剩下 2 个数字，将它们放入单个含 2 个数字的块。第 3 个块是 ""78"" 。
连接这些块后得到 ""123-456-78"" 。
示例 4：
输入：number = ""12""
输出：""12""
示例 5：
输入：number = ""--17-5 229 35-39475 ""
输出：""175-229-353-94-75""
  提示：
2 <= number.length <= 100
number 由数字和字符 '-' 及 ' ' 组成。
number 中至少含 2 个数字。",11,,9662,['https://leetcode.cn/tag/string/'],[],15363
评论 (110),maximum-erasure-value,中等,"给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。
返回 只删除一个 子数组可获得的 最大得分 。
如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],...,a[r] ，那么它就是 a 的一个子数组。
  示例 1：
输入：nums = [4,2,4,5,6]
输出：17
解释：最优子数组是 [2,4,5,6]
示例 2：
输入：nums = [5,2,1,2,5,2,1,2,5]
输出：8
解释：最优子数组是 [5,2,1] 或 [1,2,5]
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 104",46,,9764,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sliding-window/']",[],19648
评论 (89),jump-game-vi,中等,"给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。
你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。
请你返回你能得到的 最大得分 。
  示例 1：
输入：nums = [1,-1,-2,4,-7,3], k = 2
输出：7
解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。
示例 2：
输入：nums = [10,-5,-2,4,0,3], k = 3
输出：17
解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。
示例 3：
输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
输出：0
  提示：
 1 <= nums.length, k <= 105
-104 <= nums[i] <= 104",84,,8728,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/monotonic-queue/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],21954
评论 (42),checking-existence-of-edge-length-limited-paths,困难,"给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。
给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。
请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。
  示例 1：
输入：n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
输出：[false,true]
解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。
对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。
对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。
示例 2：
输入：n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
输出：[true,false]
解释：上图为给定数据。
  提示：
2 <= n <= 105
1 <= edgeList.length, queries.length <= 105
edgeList[i].length == 3
queries[j].length == 3
0 <= ui, vi, pj, qj <= n - 1
ui != vi
pj != qj
1 <= disi, limitj <= 109
两个点之间可能有 多条 边。",51,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/h.png,2694,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],4978
评论 (12),number-of-distinct-substrings-in-a-string,Unknown,,-1,,-1,[],[],-1
评论 (90),number-of-calls-between-two-persons,Unknown,,-1,,-1,[],[],-1
评论 (164),number-of-students-unable-to-eat-lunch,简单,"学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：
如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。
否则，这名学生会 放弃这个三明治 并回到队列的尾部。
这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。
给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i 个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队列里第 j 名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。
  示例 1：
输入：students = [1,1,0,0], sandwiches = [0,1,0,1]
输出：0 
解释：
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。
所以所有学生都有三明治吃。
示例 2：
输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
输出：3
  提示：
1 <= students.length, sandwiches.length <= 100
students.length == sandwiches.length
sandwiches[i] 要么是 0 ，要么是 1 。
students[i] 要么是 0 ，要么是 1 。",43,,12063,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],17406
评论 (55),average-waiting-time,中等,"有一个餐厅，只有一位厨师。你有一个顾客数组 customers ，其中 customers[i] = [arrivali, timei] ：
arrivali 是第 i 位顾客到达的时间，到达时间按 非递减 顺序排列。
timei 是给第 i 位顾客做菜需要的时间。
当一位顾客到达时，他将他的订单给厨师，厨师一旦空闲的时候就开始做这位顾客的菜。每位顾客会一直等待到厨师完成他的订单。厨师同时只能做一个人的订单。厨师会严格按照 订单给他的顺序 做菜。
请你返回所有顾客需要等待的 平均 时间。与标准答案误差在 10-5 范围以内，都视为正确结果。
  示例 1：
输入：customers = [[1,2],[2,5],[4,3]]
输出：5.00000
解释：
1) 第一位顾客在时刻 1 到达，厨师拿到他的订单并在时刻 1 立马开始做菜，并在时刻 3 完成，第一位顾客等待时间为 3 - 1 = 2 。
2) 第二位顾客在时刻 2 到达，厨师在时刻 3 开始为他做菜，并在时刻 8 完成，第二位顾客等待时间为 8 - 2 = 6 。
3) 第三位顾客在时刻 4 到达，厨师在时刻 8 开始为他做菜，并在时刻 11 完成，第三位顾客等待时间为 11 - 4 = 7 。
平均等待时间为 (2 + 6 + 7) / 3 = 5 。
示例 2：
输入：customers = [[5,2],[5,4],[10,3],[20,1]]
输出：3.25000
解释：
1) 第一位顾客在时刻 5 到达，厨师拿到他的订单并在时刻 5 立马开始做菜，并在时刻 7 完成，第一位顾客等待时间为 7 - 5 = 2 。
2) 第二位顾客在时刻 5 到达，厨师在时刻 7 开始为他做菜，并在时刻 11 完成，第二位顾客等待时间为 11 - 5 = 6 。
3) 第三位顾客在时刻 10 到达，厨师在时刻 11 开始为他做菜，并在时刻 14 完成，第三位顾客等待时间为 14 - 10 = 4 。
4) 第四位顾客在时刻 20 到达，厨师拿到他的订单并在时刻 20 立马开始做菜，并在时刻 21 完成，第四位顾客等待时间为 21 - 20 = 1 。
平均等待时间为 (2 + 6 + 4 + 1) / 4 = 3.25 。
  提示：
1 <= customers.length <= 105
1 <= arrivali, timei <= 104
arrivali <= arrivali+1",6,,5115,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],8326
评论 (52),maximum-binary-string-after-change,中等,"给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：
操作 1 ：如果二进制串包含子字符串 ""00"" ，你可以用 ""10"" 将其替换。
比方说， ""00010"" -> ""10010""
操作 2 ：如果二进制串包含子字符串 ""10"" ，你可以用 ""01"" 将其替换。
比方说， ""00010"" -> ""00001""
请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。
  示例 1：
输入：binary = ""000110""
输出：""111011""
解释：一个可行的转换为：
""000110"" -> ""000101"" 
""000101"" -> ""100101"" 
""100101"" -> ""110101"" 
""110101"" -> ""110011"" 
""110011"" -> ""111011""
示例 2：
输入：binary = ""01""
输出：""01""
解释：""01"" 没办法进行任何转换。
  提示：
1 <= binary.length <= 105
binary 仅包含 '0' 和 '1' 。",21,,3632,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],7561
评论 (24),minimum-adjacent-swaps-for-k-consecutive-ones,困难,"给你一个整数数组 nums 和一个整数 k 。 nums 仅包含 0 和 1 。每一次移动，你可以选择 相邻 两个数字并将它们交换。
请你返回使 nums 中包含 k 个 连续 1 的 最少 交换次数。
  示例 1：
输入：nums = [1,0,0,1,0,1], k = 2
输出：1
解释：在第一次操作时，nums 可以变成 [1,0,0,0,1,1] 得到连续两个 1 。
示例 2：
输入：nums = [1,0,0,0,0,0,1,1], k = 3
输出：5
解释：通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,1,1,1] 。
示例 3：
输入：nums = [1,1,0,1], k = 2
输出：0
解释：nums 已经有连续 2 个 1 了。
  提示：
1 <= nums.length <= 105
nums[i] 要么是 0 ，要么是 1 。
1 <= k <= sum(nums)",45,,1810,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",[],4655
评论 (118),determine-if-string-halves-are-alike,简单,"给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。
两个字符串 相似 的前提是它们都含有相同数目的元音（'a'，'e'，'i'，'o'，'u'，'A'，'E'，'I'，'O'，'U'）。注意，s 可能同时含有大写和小写字母。
如果 a 和 b 相似，返回 true ；否则，返回 false 。
  示例 1：
输入：s = ""book""
输出：true
解释：a = ""bo"" 且 b = ""ok"" 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。
示例 2：
输入：s = ""textbook""
输出：false
解释：a = ""text"" 且 b = ""book"" 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。
注意，元音 o 在 b 中出现两次，记为 2 个。
  提示：
2 <= s.length <= 1000
s.length 是偶数
s 由 大写和小写 字母组成",10,,14881,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],19197
评论 (340),maximum-number-of-eaten-apples,中等,"有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。
你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。
给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。
  示例 1：
输入：apples = [1,2,3,5,2], days = [3,2,1,4,2]
输出：7
解释：你可以吃掉 7 个苹果：
- 第一天，你吃掉第一天长出来的苹果。
- 第二天，你吃掉一个第二天长出来的苹果。
- 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。
- 第四天到第七天，你吃的都是第四天长出来的苹果。
示例 2：
输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]
输出：5
解释：你可以吃掉 5 个苹果：
- 第一天到第三天，你吃的都是第一天长出来的苹果。
- 第四天和第五天不吃苹果。
- 第六天和第七天，你吃的都是第六天长出来的苹果。
  提示：
apples.length == n
days.length == n
1 <= n <= 2 * 104
0 <= apples[i], days[i] <= 2 * 104
只有在 apples[i] = 0 时，days[i] = 0 才成立",159,,26676,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],58921
评论 (458),where-will-the-ball-fall,中等,"用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。
箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。
将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。
将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。
在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 ""V"" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。
返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。
  示例 1：
输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
输出：[1,-1,-1,-1,-1]
解释：示例如图：
b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。
b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 ""V"" 形里。
b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 ""V"" 形里。
b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 ""V"" 形里。
b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 ""V"" 形里。
示例 2：
输入：grid = [[-1]]
输出：[-1]
解释：球被卡在箱子左侧边上。
示例 3：
输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
输出：[0,1,2,3,4,-1]
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] 为 1 或 -1",133,,31975,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],46152
评论 (190),maximum-xor-with-an-element-from-array,困难,"给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。
第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] <= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。
返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。
  示例 1：
输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
输出：[3,3,7]
解释：
1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.
示例 2：
输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
输出：[15,-1,5]
  提示：
1 <= nums.length, queries.length <= 105
queries[i].length == 2
0 <= nums[j], xi, mi <= 109",128,,15126,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/']",[],29991
评论 (21),largest-subarray-length-k,Unknown,,-1,,-1,[],[],-1
评论 (76),biggest-window-between-visits,Unknown,,-1,,-1,[],[],-1
评论 (131),maximum-units-on-a-truck,简单,"请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：
numberOfBoxesi 是类型 i 的箱子的数量。
numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。
整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。
返回卡车可以装载 单元 的 最大 总数。
  示例 1：
输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
输出：8
解释：箱子的情况如下：
- 1 个第一类的箱子，里面含 3 个单元。
- 2 个第二类的箱子，每个里面含 2 个单元。
- 3 个第三类的箱子，每个里面含 1 个单元。
可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。
单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8
示例 2：
输入：boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
输出：91
  提示：
1 <= boxTypes.length <= 1000
1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000
1 <= truckSize <= 106",35,,16008,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],22985
评论 (421),count-good-meals,中等,"大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。
你可以搭配 任意 两道餐品做一顿大餐。
给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。
注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。
  示例 1：
输入：deliciousness = [1,3,5,7,9]
输出：4
解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。
它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。
示例 2：
输入：deliciousness = [1,1,1,3,3,3,7]
输出：15
解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。
  提示：
1 <= deliciousness.length <= 105
0 <= deliciousness[i] <= 220",129,,31267,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],87079
评论 (80),ways-to-split-array-into-three-subarrays,中等,"我们称一个分割整数数组的方案是 好的 ，当它满足：
数组被分成三个 非空 连续子数组，从左至右分别命名为 left ， mid ， right 。
left 中元素和小于等于 mid 中元素和，mid 中元素和小于等于 right 中元素和。
给你一个 非负 整数数组 nums ，请你返回 好的 分割 nums 方案数目。由于答案可能会很大，请你将结果对 109 + 7 取余后返回。
  示例 1：
输入：nums = [1,1,1]
输出：1
解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。
示例 2：
输入：nums = [1,2,2,2,5,0]
输出：3
解释：nums 总共有 3 种好的分割方案：
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
示例 3：
输入：nums = [3,2,1]
输出：0
解释：没有好的分割方案。
  提示：
3 <= nums.length <= 105
0 <= nums[i] <= 104",74,,8859,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/']",[],32525
评论 (176),minimum-operations-to-make-a-subsequence,困难,"给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。
每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。
请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。
一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。
  示例 1：
输入：target = [5,1,3], arr = [9,4,2,3,4]
输出：2
解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。
示例 2：
输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]
输出：3
  提示：
1 <= target.length, arr.length <= 105
1 <= target[i], arr[i] <= 109
target 不包含任何重复元素。",176,,17144,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/']",[],34541
评论 (19),sum-of-special-evenly-spaced-elements-in-array,Unknown,,-1,,-1,[],[],-1
评论 (80),count-apples-and-oranges,Unknown,,-1,,-1,[],[],-1
评论 (560),calculate-money-in-leetcode-bank,简单,"Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。
最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。
给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。
  示例 1：
输入：n = 4
输出：10
解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。
示例 2：
输入：n = 10
输出：37
解释：第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。
示例 3：
输入：n = 20
输出：96
解释：第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。
  提示：
1 <= n <= 1000",71,,38060,['https://leetcode.cn/tag/math/'],[],54257
评论 (51),maximum-score-from-removing-substrings,中等,"给你一个字符串 s 和两个整数 x 和 y 。你可以执行下面两种操作任意次。
删除子字符串 ""ab"" 并得到 x 分。
比方说，从 ""cabxbae"" 删除 ab ，得到 ""cxbae"" 。
删除子字符串""ba"" 并得到 y 分。
比方说，从 ""cabxbae"" 删除 ba ，得到 ""cabxe"" 。
请返回对 s 字符串执行上面操作若干次能得到的最大得分。
  示例 1：
输入：s = ""cdbcbbaaabab"", x = 4, y = 5
输出：19
解释：
- 删除 ""cdbcbbaaabab"" 中加粗的 ""ba"" ，得到 s = ""cdbcbbaaab"" ，加 5 分。
- 删除 ""cdbcbbaaab"" 中加粗的 ""ab"" ，得到 s = ""cdbcbbaa"" ，加 4 分。
- 删除 ""cdbcbbaa"" 中加粗的 ""ba"" ，得到 s = ""cdbcba"" ，加 5 分。
- 删除 ""cdbcba"" 中加粗的 ""ba"" ，得到 s = ""cdbc"" ，加 5 分。
总得分为 5 + 4 + 5 + 5 = 19 。
示例 2：
输入：s = ""aabbaaxybbaabb"", x = 5, y = 4
输出：20
  提示：
1 <= s.length <= 105
1 <= x, y <= 104
s 只包含小写英文字母。",24,,2867,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],6459
评论 (51),construct-the-lexicographically-largest-valid-sequence,中等,"给你一个整数 n ，请你找到满足下面条件的一个序列：
整数 1 在序列中只出现一次。
2 到 n 之间每个整数都恰好出现两次。
对于每个 2 到 n 之间的整数 i ，两个 i 之间出现的距离恰好为 i 。
序列里面两个数 a[i] 和 a[j] 之间的 距离 ，我们定义为它们下标绝对值之差 |j - i| 。
请你返回满足上述条件中 字典序最大 的序列。题目保证在给定限制条件下，一定存在解。
一个序列 a 被认为比序列 b （两者长度相同）字典序更大的条件是： a 和 b 中第一个不一样的数字处，a 序列的数字比 b 序列的数字大。比方说，[0,1,9,0] 比 [0,1,5,6] 字典序更大，因为第一个不同的位置是第三个数字，且 9 比 5 大。
  示例 1：
输入：n = 3
输出：[3,1,2,3,2]
解释：[2,3,2,1,3] 也是一个可行的序列，但是 [3,1,2,3,2] 是字典序最大的序列。
示例 2：
输入：n = 5
输出：[5,3,1,4,3,5,2,4,2]
  提示：
1 <= n <= 20",32,,2587,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']",[],5159
评论 (318),number-of-ways-to-reconstruct-a-tree,困难,"给你一个数组 pairs ，其中 pairs[i] = [xi, yi] ，并且满足：
pairs 中没有重复元素
xi < yi
令 ways 为满足下面条件的有根树的方案数：
树所包含的所有节点值都在 pairs 中。
一个数对 [xi, yi] 出现在 pairs 中 当且仅当 xi 是 yi 的祖先或者 yi 是 xi 的祖先。
注意：构造出来的树不一定是二叉树。
两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。
请你返回：
如果 ways == 0 ，返回 0 。
如果 ways == 1 ，返回 1 。
如果 ways > 1 ，返回 2 。
一棵 有根树 指的是只有一个根节点的树，所有边都是从根往外的方向。
我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 祖先 。根节点没有祖先。
  示例 1：
输入：pairs = [[1,2],[2,3]]
输出：1
解释：如上图所示，有且只有一个符合规定的有根树。
示例 2：
输入：pairs = [[1,2],[2,3],[1,3]]
输出：2
解释：有多个符合规定的有根树，其中三个如上图所示。
示例 3：
输入：pairs = [[1,2],[2,3],[2,4],[1,5]]
输出：0
解释：没有符合规定的有根树。
  提示：
1 <= pairs.length <= 105
1 <= xi < yi <= 500
pairs 中的元素互不相同。",148,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/trees2.png,12667,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']",[],18161
评论 (335),decode-xored-array,简单,"未知 整数数组 arr 由 n 个非负整数组成。
经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。
给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。
请解码返回原数组 arr 。可以证明答案存在并且是唯一的。
  示例 1：
输入：encoded = [1,2,3], first = 1
输出：[1,0,2,1]
解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
示例 2：
输入：encoded = [6,2,7,3], first = 4
输出：[4,2,0,7,4]
  提示：
2 <= n <= 104
encoded.length == n - 1
0 <= encoded[i] <= 105
0 <= first <= 105",94,,50169,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/']",[],57872
评论 (120),swapping-nodes-in-a-linked-list,中等,"给你链表的头节点 head 和一个整数 k 。
交换 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 从 1 开始索引）。
  示例 1：
输入：head = [1,2,3,4,5], k = 2
输出：[1,4,3,2,5]
示例 2：
输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5
输出：[7,9,6,6,8,7,3,0,9,5]
示例 3：
输入：head = [1], k = 1
输出：[1]
示例 4：
输入：head = [1,2], k = 1
输出：[2,1]
示例 5：
输入：head = [1,2,3], k = 2
输出：[1,2,3]
  提示：
链表中节点的数目是 n
1 <= k <= n <= 105
0 <= Node.val <= 100",53,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/10/linked1.jpg,14917,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],23381
评论 (72),minimize-hamming-distance-after-swap-operations,中等,"给你两个整数数组 source 和 target ，长度都是 n 。还有一个数组 allowedSwaps ，其中每个 allowedSwaps[i] = [ai, bi] 表示你可以交换数组 source 中下标为 ai 和 bi（下标从 0 开始）的两个元素。注意，你可以按 任意 顺序 多次 交换一对特定下标指向的元素。
相同长度的两个数组 source 和 target 间的 汉明距离 是元素不同的下标数量。形式上，其值等于满足 source[i] != target[i] （下标从 0 开始）的下标 i（0 <= i <= n-1）的数量。
在对数组 source 执行 任意 数量的交换操作后，返回 source 和 target 间的 最小汉明距离 。
  示例 1：
输入：source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]
输出：1
解释：source 可以按下述方式转换：
- 交换下标 0 和 1 指向的元素：source = [2,1,3,4]
- 交换下标 2 和 3 指向的元素：source = [2,1,4,3]
source 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。
示例 2：
输入：source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []
输出：2
解释：不能对 source 执行交换操作。
source 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。
示例 3：
输入：source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]
输出：0
  提示：
n == source.length == target.length
1 <= n <= 105
1 <= source[i], target[i] <= 105
0 <= allowedSwaps.length <= 105
allowedSwaps[i].length == 2
0 <= ai, bi <= n - 1
ai != bi",54,,5327,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/']",[],10483
评论 (257),find-minimum-time-to-finish-all-jobs,困难,"给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。
请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。
返回分配方案中尽可能 最小 的 最大工作时间 。
  示例 1：
输入：jobs = [3,2,3], k = 3
输出：3
解释：给每位工人分配一项工作，最大工作时间是 3 。
示例 2：
输入：jobs = [1,2,4,7,8], k = 2
输出：11
解释：按下述方式分配工作：
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。
  提示：
1 <= k <= jobs.length <= 12
1 <= jobs[i] <= 107",266,,25688,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",[],50706
评论 (6),checking-existence-of-edge-length-limited-paths-ii,Unknown,,-1,,-1,[],[],-1
评论 (274),number-of-rectangles-that-can-form-the-largest-square,简单,"给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。
如果存在 k 同时满足 k <= li 和 k <= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。
设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。
请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 数目 。
  示例 1：
输入：rectangles = [[5,8],[3,9],[5,12],[16,5]]
输出：3
解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。
最大正方形的边长为 5 ，可以由 3 个矩形切分得到。
示例 2：
输入：rectangles = [[2,3],[3,7],[4,3],[3,7]]
输出：3
  提示：
1 <= rectangles.length <= 1000
rectangles[i].length == 2
1 <= li, wi <= 109
li != wi",57,,35238,['https://leetcode.cn/tag/array/'],[],42272
评论 (81),tuple-with-same-product,中等,"给你一个由 不同 正整数组成的数组 nums ，请你返回满足 a * b = c * d 的元组 (a, b, c, d) 的数量。其中 a、b、c 和 d 都是 nums 中的元素，且 a != b != c != d 。
  示例 1：
输入：nums = [2,3,4,6]
输出：8
解释：存在 8 个满足题意的元组：
(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)
(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)
示例 2：
输入：nums = [1,2,4,5,10]
输出：16
解释：存在 16 个满足题意的元组：
(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)
(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)
(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,4,5)
(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)
  提示：
1 <= nums.length <= 1000
1 <= nums[i] <= 104
nums 中的所有元素 互不相同",19,,6653,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],13279
评论 (57),largest-submatrix-with-rearrangements,中等,"给你一个二进制矩阵 matrix ，它的大小为 m x n ，你可以将 matrix 中的 列 按任意顺序重新排列。
请你返回最优方案下将 matrix 重新排列后，全是 1 的子矩阵面积。
  示例 1：
输入：matrix = [[0,0,1],[1,1,1],[1,0,1]]
输出：4
解释：你可以按照上图方式重新排列矩阵的每一列。
最大的全 1 子矩阵是上图中加粗的部分，面积为 4 。
示例 2：
输入：matrix = [[1,0,1,0,1]]
输出：3
解释：你可以按照上图方式重新排列矩阵的每一列。
最大的全 1 子矩阵是上图中加粗的部分，面积为 3 。
示例 3：
输入：matrix = [[1,1,0],[1,0,1]]
输出：2
解释：由于你只能整列整列重新排布，所以没有比面积为 2 更大的全 1 子矩形。
示例 4：
输入：matrix = [[0,0],[0,0]]
输出：0
解释：由于矩阵中没有 1 ，没有任何全 1 的子矩阵，所以面积为 0 。
  提示：
m == matrix.length
n == matrix[i].length
1 <= m * n <= 105
matrix[i][j] 要么是 0 ，要么是 1 。",46,,3903,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/sorting/']",[],6713
评论 (291),cat-and-mouse-ii,困难,"一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。
它们所处的环境设定是一个 rows x cols 的方格 grid ，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。
玩家由字符 'C' （代表猫）和 'M' （代表老鼠）表示。
地板由字符 '.' 表示，玩家可以通过这个格子。
墙用字符 '#' 表示，玩家不能通过这个格子。
食物用字符 'F' 表示，玩家可以通过这个格子。
字符 'C' ， 'M' 和 'F' 在 grid 中都只会出现一次。
猫和老鼠按照如下规则移动：
老鼠 先移动 ，然后两名玩家轮流移动。
每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出 grid 。
catJump 和 mouseJump 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。
它们可以停留在原地。
老鼠可以跳跃过猫的位置。
游戏有 4 种方式会结束：
如果猫跟老鼠处在相同的位置，那么猫获胜。
如果猫先到达食物，那么猫获胜。
如果老鼠先到达食物，那么老鼠获胜。
如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。
给你 rows x cols 的矩阵 grid 和两个整数 catJump 和 mouseJump ，双方都采取最优策略，如果老鼠获胜，那么请你返回 true ，否则返回 false 。
  示例 1：
输入：grid = [""####F"",""#C..."",""M....""], catJump = 1, mouseJump = 2
输出：true
解释：猫无法抓到老鼠，也没法比老鼠先到达食物。
示例 2：
输入：grid = [""M.C...F""], catJump = 1, mouseJump = 4
输出：true
示例 3：
输入：grid = [""M.C...F""], catJump = 1, mouseJump = 3
输出：false
示例 4：
输入：grid = [""C...#"",""...#F"",""....#"",""M....""], catJump = 2, mouseJump = 5
输出：false
示例 5：
输入：grid = ["".M..."",""..#.."",""#..#."",""C#.#."",""...#F""], catJump = 3, mouseJump = 1
输出：true
  提示：
rows == grid.length
cols = grid[i].length
1 <= rows, cols <= 8
grid[i][j] 只包含字符 'C' ，'M' ，'F' ，'.' 和 '#' 。
grid 中只包含一个 'C' ，'M' 和 'F' 。
1 <= catJump, mouseJump <= 8",154,,13243,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/game-theory/', 'https://leetcode.cn/tag/matrix/']",[],20422
评论 (72),find-followers-count,简单,"SQL架构
表： Followers
+-------------+------+
| Column Name | Type |
+-------------+------+
| user_id     | int  |
| follower_id | int  |
+-------------+------+
(user_id, follower_id) 是这个表的主键。
该表包含一个关注关系中关注者和用户的编号，其中关注者关注用户。
  写出 SQL 语句，对于每一个用户，返回该用户的关注者数量。
按 user_id 的顺序返回结果表。
查询结果的格式如下示例所示。
  示例 1：
输入：
Followers 表：
+---------+-------------+
| user_id | follower_id |
+---------+-------------+
| 0       | 1           |
| 1       | 0           |
| 2       | 0           |
| 2       | 1           |
+---------+-------------+
输出：
+---------+----------------+
| user_id | followers_count|
+---------+----------------+
| 0       | 1              |
| 1       | 1              |
| 2       | 2              |
+---------+----------------+
解释：
0 的关注者有 {1}
1 的关注者有 {0}
2 的关注者有 {0,1}",14,,7889,['https://leetcode.cn/tag/database/'],[],12556
评论 (39),shortest-path-to-get-food,Unknown,,-1,,-1,[],[],-1
评论 (64),the-number-of-employees-which-report-to-each-employee,Unknown,,-1,,-1,[],[],-1
评论 (139),find-the-highest-altitude,简单,"有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。
给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 <= i < n）。请你返回 最高点的海拔 。
  示例 1：
输入：gain = [-5,1,5,0,-7]
输出：1
解释：海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。
示例 2：
输入：gain = [-4,-3,-2,-1,4,3,2]
输出：0
解释：海拔高度依次为 [0,-4,-7,-9,-10,-6,-3,-1] 。最高海拔为 0 。
  提示：
n == gain.length
1 <= n <= 100
-100 <= gain[i] <= 100",19,,16106,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],20532
评论 (52),minimum-number-of-people-to-teach,中等,"在一个由 m 个用户组成的社交网络里，我们获取到一些用户之间的好友关系。两个用户之间可以相互沟通的条件是他们都掌握同一门语言。
给你一个整数 n ，数组 languages 和数组 friendships ，它们的含义如下：
总共有 n 种语言，编号从 1 到 n 。
languages[i] 是第 i 位用户掌握的语言集合。
friendships[i] = [ui, vi] 表示 ui 和 vi 为好友关系。
你可以选择 一门 语言并教会一些用户，使得所有好友之间都可以相互沟通。请返回你 最少 需要教会多少名用户。
请注意，好友关系没有传递性，也就是说如果 x 和 y 是好友，且 y 和 z 是好友， x 和 z 不一定是好友。
  示例 1：
输入：n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]
输出：1
解释：你可以选择教用户 1 第二门语言，也可以选择教用户 2 第一门语言。
示例 2：
输入：n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]
输出：2
解释：教用户 1 和用户 3 第三门语言，需要教 2 名用户。
  提示：
2 <= n <= 500
languages.length == m
1 <= m <= 500
1 <= languages[i].length <= n
1 <= languages[i][j] <= n
1 <= ui < vi <= languages.length
1 <= friendships.length <= 500
所有的好友关系 (ui, vi) 都是唯一的。
languages[i] 中包含的值互不相同。",20,,2669,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],5649
评论 (282),decode-xored-permutation,中等,"给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。
它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。
给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。
  示例 1：
输入：encoded = [3,1]
输出：[1,2,3]
解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]
示例 2：
输入：encoded = [6,5,4,6]
输出：[2,4,1,5,3]
  提示：
3 <= n < 105
n 是奇数。
encoded.length == n - 1",148,,28612,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/']",[],39555
评论 (20),count-ways-to-make-array-with-product,困难,"给你一个二维整数数组 queries ，其中 queries[i] = [ni, ki] 。第 i 个查询 queries[i] 要求构造长度为 ni 、每个元素都是正整数的数组，且满足所有元素的乘积为 ki ，请你找出有多少种可行的方案。由于答案可能会很大，方案数需要对 109 + 7 取余 。
请你返回一个整数数组 answer，满足 answer.length == queries.length ，其中 answer[i]是第 i 个查询的结果。
  示例 1：
输入：queries = [[2,6],[5,1],[73,660]]
输出：[4,1,50734910]
解释：每个查询之间彼此独立。
[2,6]：总共有 4 种方案得到长度为 2 且乘积为 6 的数组：[1,6]，[2,3]，[3,2]，[6,1]。
[5,1]：总共有 1 种方案得到长度为 5 且乘积为 1 的数组：[1,1,1,1,1]。
[73,660]：总共有 1050734917 种方案得到长度为 73 且乘积为 660 的数组。1050734917 对 109 + 7 取余得到 50734910 。
示例 2 ：
输入：queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]
输出：[1,2,3,10,5]
  提示：
1 <= queries.length <= 104
1 <= ni, ki <= 104",28,,1241,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],2494
评论 (285),latest-time-by-replacing-hidden-digits,Unknown,,-1,,-1,[],[],-1
评论 (93),change-minimum-characters-to-satisfy-one-of-three-conditions,中等,"给你两个字符串 a 和 b ，二者均由小写字母组成。一步操作中，你可以将 a 或 b 中的 任一字符 改变为 任一小写字母 。
操作的最终目标是满足下列三个条件 之一 ：
a 中的 每个字母 在字母表中 严格小于 b 中的 每个字母 。
b 中的 每个字母 在字母表中 严格小于 a 中的 每个字母 。
a 和 b 都 由 同一个 字母组成。
返回达成目标所需的 最少 操作数。
  示例 1：
输入：a = ""aba"", b = ""caa""
输出：2
解释：满足每个条件的最佳方案分别是：
1) 将 b 变为 ""ccc""，2 次操作，满足 a 中的每个字母都小于 b 中的每个字母；
2) 将 a 变为 ""bbb"" 并将 b 变为 ""aaa""，3 次操作，满足 b 中的每个字母都小于 a 中的每个字母；
3) 将 a 变为 ""aaa"" 并将 b 变为 ""aaa""，2 次操作，满足 a 和 b 由同一个字母组成。
最佳的方案只需要 2 次操作（满足条件 1 或者条件 3）。
示例 2：
输入：a = ""dabadd"", b = ""cda""
输出：3
解释：满足条件 1 的最佳方案是将 b 变为 ""eee"" 。
  提示：
1 <= a.length, b.length <= 105
a 和 b 只由小写字母组成",51,,4543,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/prefix-sum/']",[],13508
评论 (351),find-kth-largest-xor-coordinate-value,中等,"给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。
矩阵中坐标 (a, b) 的 值 可由对所有满足 0 <= i <= a < m 且 0 <= j <= b < n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。
请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。
  示例 1：
输入：matrix = [[5,2],[1,6]], k = 1
输出：7
解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。
示例 2：
输入：matrix = [[5,2],[1,6]], k = 2
输出：5
解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。
示例 3：
输入：matrix = [[5,2],[1,6]], k = 3
输出：4
解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。
示例 4：
输入：matrix = [[5,2],[1,6]], k = 4
输出：0
解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 1000
0 <= matrix[i][j] <= 106
1 <= k <= m * n",90,,29852,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/quickselect/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],45788
评论 (62),building-boxes,困难,"有一个立方体房间，其长度、宽度和高度都等于 n 个单位。请你在房间里放置 n 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：
你可以把盒子放在地板上的任何地方。
如果盒子 x 需要放置在盒子 y 的顶部，那么盒子 y 竖直的四个侧面都 必须 与另一个盒子或墙相邻。
给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。
  示例 1：
输入：n = 3
输出：3
解释：上图是 3 个盒子的摆放位置。
这些盒子放在房间的一角，对应左侧位置。
示例 2：
输入：n = 4
输出：3
解释：上图是 3 个盒子的摆放位置。
这些盒子放在房间的一角，对应左侧位置。
示例 3：
输入：n = 10
输出：6
解释：上图是 10 个盒子的摆放位置。
这些盒子放在房间的一角，对应后方位置。
  提示：
1 <= n <= 109",28,,3225,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],6662
评论 (20),find-distance-in-a-binary-tree,Unknown,,-1,,-1,[],[],-1
评论 (80),find-total-time-spent-by-each-employee,简单,"SQL架构
表: Employees
+-------------+------+
| Column Name | Type |
+-------------+------+
| emp_id      | int  |
| event_day   | date |
| in_time     | int  |
| out_time    | int  |
+-------------+------+
(emp_id, event_day, in_time) 是这个表的主键。
该表显示了员工在办公室的出入情况。
event_day 是此事件发生的日期，in_time 是员工进入办公室的时间，而 out_time 是他们离开办公室的时间。
in_time 和 out_time 的取值在1到1440之间。
题目保证同一天没有两个事件在时间上是相交的，并且保证 in_time 小于 out_time。
  编写一个SQL查询以计算每位员工每天在办公室花费的总时间（以分钟为单位）。 请注意，在一天之内，同一员工是可以多次进入和离开办公室的。 在办公室里一次进出所花费的时间为out_time 减去 in_time。
返回结果表单的顺序无要求。
查询结果的格式如下：
Employees table:
+--------+------------+---------+----------+
| emp_id | event_day  | in_time | out_time |
+--------+------------+---------+----------+
| 1      | 2020-11-28 | 4       | 32       |
| 1      | 2020-11-28 | 55      | 200      |
| 1      | 2020-12-03 | 1       | 42       |
| 2      | 2020-11-28 | 3       | 33       |
| 2      | 2020-12-09 | 47      | 74       |
+--------+------------+---------+----------+
Result table:
+------------+--------+------------+
| day        | emp_id | total_time |
+------------+--------+------------+
| 2020-11-28 | 1      | 173        |
| 2020-11-28 | 2      | 30         |
| 2020-12-03 | 1      | 41         |
| 2020-12-09 | 2      | 27         |
+------------+--------+------------+
雇员 1 有三次进出: 有两次发生在 2020-11-28 花费的时间为 (32 - 4) + (200 - 55) = 173, 有一次发生在 2020-12-03 花费的时间为 (42 - 1) = 41。
雇员 2 有两次进出: 有一次发生在 2020-11-28 花费的时间为 (33 - 3) = 30,  有一次发生在 2020-12-09 花费的时间为 (74 - 47) = 27。",16,,7601,['https://leetcode.cn/tag/database/'],[],8941
评论 (75),maximum-number-of-balls-in-a-box,简单,"你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。
你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。
给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。
  示例 1：
输入：lowLimit = 1, highLimit = 10
输出：2
解释：
盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...
小球数量：2 1 1 1 1 1 1 1 1 0  0  ...
编号 1 的盒子放有最多小球，小球数量为 2 。
示例 2：
输入：lowLimit = 5, highLimit = 15
输出：2
解释：
盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...
小球数量：1 1 1 1 2 2 1 1 1 0  0  ...
编号 5 和 6 的盒子放有最多小球，每个盒子中的小球数量都是 2 。
示例 3：
输入：lowLimit = 19, highLimit = 28
输出：2
解释：
盒子编号：1 2 3 4 5 6 7 8 9 10 11 12 ...
小球数量：0 1 1 1 1 1 1 1 1 2  0  0  ...
编号 10 的盒子放有最多小球，小球数量为 2 。
  提示：
1 <= lowLimit <= highLimit <= 105",18,,10483,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/counting/']",[],14759
评论 (243),restore-the-array-from-adjacent-pairs,中等,"存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。
给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。
题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。
返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。
  示例 1：
输入：adjacentPairs = [[2,1],[3,4],[3,2]]
输出：[1,2,3,4]
解释：数组的所有相邻元素对都在 adjacentPairs 中。
特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。
示例 2：
输入：adjacentPairs = [[4,-2],[1,4],[-3,1]]
输出：[-2,4,1,-3]
解释：数组中可能存在负数。
另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。
示例 3：
输入：adjacentPairs = [[100000,-100000]]
输出：[100000,-100000]
  提示：
nums.length == n
adjacentPairs.length == n - 1
adjacentPairs[i].length == 2
2 <= n <= 105
-105 <= nums[i], ui, vi <= 105
题目数据保证存在一些以 adjacentPairs 作为元素对的数组 nums",114,,23328,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],33499
评论 (585),can-you-eat-your-favorite-candy-on-your-favorite-day,中等,"给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。
你按照如下规则进行一场游戏：
你从第 0 天开始吃糖果。
你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。
在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。
请你构建一个布尔型数组 answer ，用以给出 queries 中每一项的对应答案。此数组满足：
answer.length == queries.length 。answer[i] 是 queries[i] 的答案。
answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。
注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。
请你返回得到的数组 answer 。
  示例 1：
输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
输出：[true,false,true]
提示：
1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。
2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。
3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。
示例 2：
输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]
输出：[false,true,true,false,false]
  提示：
1 <= candiesCount.length <= 105
1 <= candiesCount[i] <= 105
1 <= queries.length <= 105
queries[i].length == 3
0 <= favoriteTypei < candiesCount.length
0 <= favoriteDayi <= 109
1 <= dailyCapi <= 109",134,,29135,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],80489
评论 (44),palindrome-partitioning-iv,困难,"给你一个字符串 s ，如果可以将它分割成三个 非空 回文子字符串，那么返回 true ，否则返回 false 。
当一个字符串正着读和反着读是一模一样的，就称其为 回文字符串 。
  示例 1：
输入：s = ""abcbdd""
输出：true
解释：""abcbdd"" = ""a"" + ""bcb"" + ""dd""，三个子字符串都是回文的。
示例 2：
输入：s = ""bcbddxy""
输出：false
解释：s 没办法被分割成 3 个回文子字符串。
  提示：
3 <= s.length <= 2000
s 只包含小写英文字母。",26,,4121,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],8392
评论 (31),maximum-subarray-sum-after-one-operation,Unknown,,-1,,-1,[],[],-1
评论 (60),leetflex-banned-accounts,Unknown,,-1,,-1,[],[],-1
评论 (290),sum-of-unique-elements,简单,"给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。
请你返回 nums 中唯一元素的 和 。
  示例 1：
输入：nums = [1,2,3,2]
输出：4
解释：唯一元素为 [1,3] ，和为 4 。
示例 2：
输入：nums = [1,1,1,1,1]
输出：0
解释：没有唯一元素，和为 0 。
示例 3 ：
输入：nums = [1,2,3,4,5]
输出：15
解释：唯一元素为 [1,2,3,4,5] ，和为 15 。
  提示：
1 <= nums.length <= 100
1 <= nums[i] <= 100",65,,40315,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],51296
评论 (81),maximum-absolute-sum-of-any-subarray,中等,"给你一个整数数组 nums 。一个子数组 [numsl, numsl+1, ..., numsr-1, numsr] 的 和的绝对值 为 abs(numsl + numsl+1 + ... + numsr-1 + numsr) 。
请你找出 nums 中 和的绝对值 最大的任意子数组（可能为空），并返回该 最大值 。
abs(x) 定义如下：
如果 x 是负整数，那么 abs(x) = -x 。
如果 x 是非负整数，那么 abs(x) = x 。
  示例 1：
输入：nums = [1,-3,2,3,-4]
输出：5
解释：子数组 [2,3] 和的绝对值最大，为 abs(2+3) = abs(5) = 5 。
示例 2：
输入：nums = [2,-5,1,-4,3,-2]
输出：8
解释：子数组 [-5,1,-4] 和的绝对值最大，为 abs(-5+1-4) = abs(-8) = 8 。
  提示：
1 <= nums.length <= 105
-104 <= nums[i] <= 104",23,,5033,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],9393
评论 (49),minimum-length-of-string-after-deleting-similar-ends,中等,"给你一个只包含字符 'a'，'b' 和 'c' 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次：
选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。
选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。
前缀和后缀在字符串中任意位置都不能有交集。
前缀和后缀包含的所有字符都要相同。
同时删除前缀和后缀。
请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。
  示例 1：
输入：s = ""ca""
输出：2
解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。
示例 2：
输入：s = ""cabaabac""
输出：0
解释：最优操作序列为：
- 选择前缀 ""c"" 和后缀 ""c"" 并删除它们，得到 s = ""abaaba"" 。
- 选择前缀 ""a"" 和后缀 ""a"" 并删除它们，得到 s = ""baab"" 。
- 选择前缀 ""b"" 和后缀 ""b"" 并删除它们，得到 s = ""aa"" 。
- 选择前缀 ""a"" 和后缀 ""a"" 并删除它们，得到 s = """" 。
示例 3：
输入：s = ""aabccabba""
输出：3
解释：最优操作序列为：
- 选择前缀 ""aa"" 和后缀 ""a"" 并删除它们，得到 s = ""bccabb"" 。
- 选择前缀 ""b"" 和后缀 ""bb"" 并删除它们，得到 s = ""cca"" 。
  提示：
1 <= s.length <= 105
s 只包含字符 'a'，'b' 和 'c' 。",8,,4263,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],9557
评论 (61),maximum-number-of-events-that-can-be-attended-ii,困难,"给你一个 events 数组，其中 events[i] = [startDayi, endDayi, valuei] ，表示第 i 个会议在 startDayi 天开始，第 endDayi 天结束，如果你参加这个会议，你能得到价值 valuei 。同时给你一个整数 k 表示你能参加的最多会议数目。
你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。
请你返回能得到的会议价值 最大和 。
  示例 1：
输入：events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
输出：7
解释：选择绿色的活动会议 0 和 1，得到总价值和为 4 + 3 = 7 。
示例 2：
输入：events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
输出：10
解释：参加会议 2 ，得到价值和为 10 。
你没法再参加别的会议了，因为跟会议 2 有重叠。你 不 需要参加满 k 个会议。
示例 3：
输入：events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
输出：9
解释：尽管会议互不重叠，你只能参加 3 个会议，所以选择价值最大的 3 个会议。
  提示：
1 <= k <= events.length
1 <= k * events.length <= 106
1 <= startDayi <= endDayi <= 109
1 <= valuei <= 106",53,,3986,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],7786
评论 (98),check-if-array-is-sorted-and-rotated,简单,"给你一个数组 nums 。nums 的源数组中，所有元素与 nums 相同，但按非递减顺序排列。
如果 nums 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 true ；否则，返回 false 。
源数组中可能存在 重复项 。
注意：我们称数组 A 在轮转 x 个位置后得到长度相同的数组 B ，当它们满足 A[i] == B[(i+x) % A.length] ，其中 % 为取余运算。
  示例 1：
输入：nums = [3,4,5,1,2]
输出：true
解释：[1,2,3,4,5] 为有序的源数组。
可以轮转 x = 3 个位置，使新数组从值为 3 的元素开始：[3,4,5,1,2] 。
示例 2：
输入：nums = [2,1,3,4]
输出：false
解释：源数组无法经轮转得到 nums 。
示例 3：
输入：nums = [1,2,3]
输出：true
解释：[1,2,3] 为有序的源数组。
可以轮转 x = 0 个位置（即不轮转）得到 nums 。
  提示：
1 <= nums.length <= 100
1 <= nums[i] <= 100",18,,11236,['https://leetcode.cn/tag/array/'],[],17462
评论 (78),maximum-score-from-removing-stones,中等,"你正在玩一个单人游戏，面前放置着大小分别为 a、b 和 c 的 三堆 石子。
每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。
给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。
  示例 1：
输入：a = 2, b = 4, c = 6
输出：6
解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是：
- 从第一和第三堆取，石子状态现在是 (1, 4, 5)
- 从第一和第三堆取，石子状态现在是 (0, 4, 4)
- 从第二和第三堆取，石子状态现在是 (0, 3, 3)
- 从第二和第三堆取，石子状态现在是 (0, 2, 2)
- 从第二和第三堆取，石子状态现在是 (0, 1, 1)
- 从第二和第三堆取，石子状态现在是 (0, 0, 0)
总分：6 分 。
示例 2：
输入：a = 4, b = 4, c = 6
输出：7
解释：石子起始状态是 (4, 4, 6) ，最优的一组操作是：
- 从第一和第二堆取，石子状态现在是 (3, 3, 6)
- 从第一和第三堆取，石子状态现在是 (2, 3, 5)
- 从第一和第三堆取，石子状态现在是 (1, 3, 4)
- 从第一和第三堆取，石子状态现在是 (0, 3, 3)
- 从第二和第三堆取，石子状态现在是 (0, 2, 2)
- 从第二和第三堆取，石子状态现在是 (0, 1, 1)
- 从第二和第三堆取，石子状态现在是 (0, 0, 0)
总分：7 分 。
示例 3：
输入：a = 1, b = 8, c = 8
输出：8
解释：最优的一组操作是连续从第二和第三堆取 8 回合，直到将它们取空。
注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。
  提示：
1 <= a, b, c <= 105",26,,7598,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],12027
评论 (74),largest-merge-of-two-strings,中等,"给你两个字符串 word1 和 word2 。你需要按下述方式构造一个新字符串 merge ：如果 word1 或 word2 非空，选择 下面选项之一 继续操作：
如果 word1 非空，将 word1 中的第一个字符附加到 merge 的末尾，并将其从 word1 中移除。
例如，word1 = ""abc"" 且 merge = ""dv"" ，在执行此选项操作之后，word1 = ""bc"" ，同时 merge = ""dva"" 。
如果 word2 非空，将 word2 中的第一个字符附加到 merge 的末尾，并将其从 word2 中移除。
例如，word2 = ""abc"" 且 merge = """" ，在执行此选项操作之后，word2 = ""bc"" ，同时 merge = ""a"" 。
返回你可以构造的字典序 最大 的合并字符串 merge 。
长度相同的两个字符串 a 和 b 比较字典序大小，如果在 a 和 b 出现不同的第一个位置，a 中字符在字母表中的出现顺序位于 b 中相应字符之后，就认为字符串 a 按字典序比字符串 b 更大。例如，""abcd"" 按字典序比 ""abcc"" 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 d 在字母表中的出现顺序位于 c 之后。
  示例 1：
输入：word1 = ""cabaa"", word2 = ""bcaaa""
输出：""cbcabaaaaa""
解释：构造字典序最大的合并字符串，可行的一种方法如下所示：
- 从 word1 中取第一个字符：merge = ""c""，word1 = ""abaa""，word2 = ""bcaaa""
- 从 word2 中取第一个字符：merge = ""cb""，word1 = ""abaa""，word2 = ""caaa""
- 从 word2 中取第一个字符：merge = ""cbc""，word1 = ""abaa""，word2 = ""aaa""
- 从 word1 中取第一个字符：merge = ""cbca""，word1 = ""baa""，word2 = ""aaa""
- 从 word1 中取第一个字符：merge = ""cbcab""，word1 = ""aa""，word2 = ""aaa""
- 将 word1 和 word2 中剩下的 5 个 a 附加到 merge 的末尾。
示例 2：
输入：word1 = ""abcabc"", word2 = ""abdcaba""
输出：""abdcabcabcaba""
  提示：
1 <= word1.length, word2.length <= 3000
word1 和 word2 仅由小写英文组成",27,,4980,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],11564
评论 (58),closest-subsequence-sum,困难,"给你一个整数数组 nums 和一个目标值 goal 。
你需要从 nums 中选出一个子序列，使子序列元素总和最接近 goal 。也就是说，如果子序列元素和为 sum ，你需要 最小化绝对差 abs(sum - goal) 。
返回 abs(sum - goal) 可能的 最小值 。
注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。
  示例 1：
输入：nums = [5,-7,3,5], goal = 6
输出：0
解释：选择整个数组作为选出的子序列，元素和为 6 。
子序列和与目标值相等，所以绝对差为 0 。
示例 2：
输入：nums = [7,-9,15,-2], goal = -5
输出：1
解释：选出子序列 [7,-9,-2] ，元素和为 -4 。
绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。
示例 3：
输入：nums = [1,2,3], goal = -7
输出：7
  提示：
1 <= nums.length <= 40
-107 <= nums[i] <= 107
-109 <= goal <= 109",70,,4126,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],9649
评论 (14),design-most-recently-used-queue,Unknown,,-1,,-1,[],[],-1
评论 (77),recyclable-and-low-fat-products,简单,"SQL架构
表：Products
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_id  | int     |
| low_fats    | enum    |
| recyclable  | enum    |
+-------------+---------+
product_id 是这个表的主键。
low_fats 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品是低脂产品，'N' 表示不是低脂产品。
recyclable 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品可回收，而 'N' 表示不可回收。
  写出 SQL 语句，查找既是低脂又是可回收的产品编号。
返回结果 无顺序要求 。
查询结果格式如下例所示：
Products 表：
+-------------+----------+------------+
| product_id  | low_fats | recyclable |
+-------------+----------+------------+
| 0           | Y        | N          |
| 1           | Y        | Y          |
| 2           | N        | Y          |
| 3           | Y        | Y          |
| 4           | N        | N          |
+-------------+----------+------------+
Result 表：
+-------------+
| product_id  |
+-------------+
| 1           |
| 3           |
+-------------+
只有产品 id 为 1 和 3 的产品，既是低脂又是可回收的产品。",26,,25904,['https://leetcode.cn/tag/database/'],[],29366
评论 (72),minimum-changes-to-make-alternating-binary-string,简单,"给你一个仅由字符 '0' 和 '1' 组成的字符串 s 。一步操作中，你可以将任一 '0' 变成 '1' ，或者将 '1' 变成 '0' 。
交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 ""010"" 是交替字符串，而字符串 ""0100"" 不是。
返回使 s 变成 交替字符串 所需的 最少 操作数。
  示例 1：
输入：s = ""0100""
输出：1
解释：如果将最后一个字符变为 '1' ，s 就变成 ""0101"" ，即符合交替字符串定义。
示例 2：
输入：s = ""10""
输出：0
解释：s 已经是交替字符串。
示例 3：
输入：s = ""1111""
输出：2
解释：需要 2 步操作得到 ""0101"" 或 ""1010"" 。
  提示：
1 <= s.length <= 104
s[i] 是 '0' 或 '1'",35,,9008,['https://leetcode.cn/tag/string/'],[],14116
评论 (74),count-number-of-homogenous-substrings,中等,"给你一个字符串 s ，返回 s 中 同构子字符串 的数目。由于答案可能很大，只需返回对 109 + 7 取余 后的结果。
同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。
子字符串 是字符串中的一个连续字符序列。
  示例 1：
输入：s = ""abbcccaa""
输出：13
解释：同构子字符串如下所列：
""a""   出现 3 次。
""aa""  出现 1 次。
""b""   出现 2 次。
""bb""  出现 1 次。
""c""   出现 3 次。
""cc""  出现 2 次。
""ccc"" 出现 1 次。
3 + 1 + 2 + 1 + 3 + 2 + 1 = 13
示例 2：
输入：s = ""xy""
输出：2
解释：同构子字符串是 ""x"" 和 ""y"" 。
示例 3：
输入：s = ""zzzzz""
输出：15
  提示：
1 <= s.length <= 105
s 由小写字符串组成",22,,5534,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],12551
评论 (67),minimum-limit-of-balls-in-a-bag,中等,"给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。
你可以进行如下操作至多 maxOperations 次：
选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。
比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。
你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。
请你返回进行上述操作后的最小开销。
  示例 1：
输入：nums = [9], maxOperations = 2
输出：3
解释：
- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -> [6,3] 。
- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -> [3,3,3] 。
装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。
示例 2：
输入：nums = [2,4,8,2], maxOperations = 4
输出：2
解释：
- 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -> [2,4,4,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -> [2,2,2,4,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -> [2,2,2,2,2,4,2] 。
- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2] 。
装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。
示例 3：
输入：nums = [7,17], maxOperations = 2
输出：7
  提示：
1 <= nums.length <= 105
1 <= maxOperations, nums[i] <= 109",81,,6728,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],11885
评论 (31),minimum-degree-of-a-connected-trio-in-a-graph,困难,"给你一个无向图，整数 n 表示图中节点的数目，edges 数组表示图中的边，其中 edges[i] = [ui, vi] ，表示 ui 和 vi 之间有一条无向边。
一个 连通三元组 指的是 三个 节点组成的集合且这三个点之间 两两 有边。
连通三元组的度数 是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。
请你返回所有连通三元组中度数的 最小值 ，如果图中没有连通三元组，那么返回 -1 。
  示例 1：
输入：n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
输出：3
解释：只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。
示例 2：
输入：n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
输出：0
解释：有 3 个三元组：
1) [1,4,3]，度数为 0 。
2) [2,5,6]，度数为 2 。
3) [5,6,7]，度数为 2 。
  提示：
2 <= n <= 400
edges[i].length == 2
1 <= edges.length <= n * (n-1) / 2
1 <= ui, vi <= n
ui != vi
图中没有重复的边。",23,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios1.png,3036,['https://leetcode.cn/tag/graph/'],[],6811
评论 (18),buildings-with-an-ocean-view,Unknown,,-1,,-1,[],[],-1
评论 (312),longest-nice-substring,简单,"当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，""abABB"" 是美好字符串，因为 'A' 和 'a' 同时出现了，且 'B' 和 'b' 也同时出现了。然而，""abA"" 不是美好字符串因为 'b' 出现了，而 'B' 没有出现。
给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。
  示例 1：
输入：s = ""YazaAay""
输出：""aAa""
解释：""aAa"" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。
""aAa"" 是最长的美好子字符串。
示例 2：
输入：s = ""Bb""
输出：""Bb""
解释：""Bb"" 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。
示例 3：
输入：s = ""c""
输出：""""
解释：没有美好子字符串。
示例 4：
输入：s = ""dDzeE""
输出：""dD""
解释：""dD"" 和 ""eE"" 都是最长美好子字符串。
由于有多个美好子字符串，返回 ""dD"" ，因为它出现得最早。
  提示：
1 <= s.length <= 100
s 只包含大写和小写英文字母。",169,,24862,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],36075
评论 (49),form-array-by-concatenating-subarrays-of-another-array,中等,"给你一个长度为 n 的二维整数数组 groups ，同时给你一个整数数组 nums 。
你是否可以从 nums 中选出 n 个 不相交 的子数组，使得第 i 个子数组与 groups[i] （下标从 0 开始）完全相同，且如果 i > 0 ，那么第 (i-1) 个子数组在 nums 中出现的位置在第 i 个子数组前面。（也就是说，这些子数组在 nums 中出现的顺序需要与 groups 顺序相同）
如果你可以找出这样的 n 个子数组，请你返回 true ，否则返回 false 。
如果不存在下标为 k 的元素 nums[k] 属于不止一个子数组，就称这些子数组是 不相交 的。子数组指的是原数组中连续元素组成的一个序列。
  示例 1：
输入：groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
输出：true
解释：你可以分别在 nums 中选出第 0 个子数组 [1,-1,0,1,-1,-1,3,-2,0] 和第 1 个子数组 [1,-1,0,1,-1,-1,3,-2,0] 。
这两个子数组是不相交的，因为它们没有任何共同的元素。
示例 2：
输入：groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
输出：false
解释：选择子数组 [1,2,3,4,10,-2] 和 [1,2,3,4,10,-2] 是不正确的，因为它们出现的顺序与 groups 中顺序不同。
[10,-2] 必须出现在 [1,2,3,4] 之前。
示例 3：
输入：groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
输出：false
解释：选择子数组 [7,7,1,2,3,4,7,7] 和 [7,7,1,2,3,4,7,7] 是不正确的，因为它们不是不相交子数组。
它们有一个共同的元素 nums[4] （下标从 0 开始）。
  提示：
groups.length == n
1 <= n <= 103
1 <= groups[i].length, sum(groups[i].length) <= 103
1 <= nums.length <= 103
-107 <= groups[i][j], nums[k] <= 107",10,,3117,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string-matching/']",[],6496
评论 (262),map-of-highest-peak,中等,"给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。
如果 isWater[i][j] == 0 ，格子 (i, j) 是一个 陆地 格子。
如果 isWater[i][j] == 1 ，格子 (i, j) 是一个 水域 格子。
你需要按照如下规则给每个单元格安排高度：
每个格子的高度都必须是非负的。
如果一个格子是 水域 ，那么它的高度必须为 0 。
任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）
找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。
请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。
  示例 1：
输入：isWater = [[0,1],[0,0]]
输出：[[1,0],[2,1]]
解释：上图展示了给各个格子安排的高度。
蓝色格子是水域格，绿色格子是陆地格。
示例 2：
输入：isWater = [[0,0,1],[1,0,0],[0,0,0]]
输出：[[1,1,0],[0,1,1],[1,2,2]]
解释：所有安排方案中，最高可行高度为 2 。
任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。
  提示：
m == isWater.length
n == isWater[i].length
1 <= m, n <= 1000
isWater[i][j] 要么是 0 ，要么是 1 。
至少有 1 个水域格子。",103,,21826,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],32853
评论 (41),tree-of-coprimes,困难,"给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 n - 1 ，且恰好有 n - 1 条边，每个节点有一个值。树的 根节点 为 0 号点。
给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。nums[i] 表示第 i 个点的值，edges[j] = [uj, vj] 表示节点 uj 和节点 vj 在树中有一条边。
当 gcd(x, y) == 1 ，我们称两个数 x 和 y 是 互质的 ，其中 gcd(x, y) 是 x 和 y 的 最大公约数 。
从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。
请你返回一个大小为 n 的数组 ans ，其中 ans[i]是离节点 i 最近的祖先节点且满足 nums[i] 和 nums[ans[i]] 是 互质的 ，如果不存在这样的祖先节点，ans[i] 为 -1 。
  示例 1：
输入：nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
输出：[-1,0,0,1]
解释：上图中，每个节点的值在括号中表示。
- 节点 0 没有互质祖先。
- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。
- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。
- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。
示例 2：
输入：nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
输出：[-1,0,-1,0,0,0,-1]
  提示：
nums.length == n
1 <= nums[i] <= 50
1 <= n <= 105
edges.length == n - 1
edges[j].length == 2
0 <= uj, vj < n
uj != vj",20,,1740,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/math/']",[],4494
评论 (70),find-the-subtasks-that-did-not-execute,Unknown,,-1,,-1,[],[],-1
评论 (171),merge-strings-alternately,简单,"给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。
返回 合并后的字符串 。
  示例 1：
输入：word1 = ""abc"", word2 = ""pqr""
输出：""apbqcr""
解释：字符串合并情况如下所示：
word1：  a   b   c
word2：    p   q   r
合并后：  a p b q c r
示例 2：
输入：word1 = ""ab"", word2 = ""pqrs""
输出：""apbqrs""
解释：注意，word2 比 word1 长，""rs"" 需要追加到合并后字符串的末尾。
word1：  a   b 
word2：    p   q   r   s
合并后：  a p b q   r   s
示例 3：
输入：word1 = ""abcd"", word2 = ""pq""
输出：""apbqcd""
解释：注意，word1 比 word2 长，""cd"" 需要追加到合并后字符串的末尾。
word1：  a   b   c   d
word2：    p   q 
合并后：  a p b q c   d
  提示：
1 <= word1.length, word2.length <= 100
word1 和 word2 由小写英文字母组成",23,,17713,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],23335
评论 (95),minimum-number-of-operations-to-move-all-balls-to-each-box,中等,"有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 '0' 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 '1' 表示盒子里有 一个 小球。
在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。
返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。
每个 answer[i] 都需要根据盒子的 初始状态 进行计算。
  示例 1：
输入：boxes = ""110""
输出：[1,1,3]
解释：每个盒子对应的最小操作数如下：
1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。
2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。
3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。
示例 2：
输入：boxes = ""001011""
输出：[11,8,5,4,3,4]
  提示：
n == boxes.length
1 <= n <= 2000
boxes[i] 为 '0' 或 '1'",29,,12033,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],14093
评论 (110),maximum-score-from-performing-multiplication-operations,中等,"给你两个长度分别 n 和 m 的整数数组 nums 和 multipliers ，其中 n >= m ，数组下标 从 1 开始 计数。
初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要：
选择数组 nums 开头处或者末尾处 的整数 x 。
你获得 multipliers[i] * x 分，并累加到你的分数中。
将 x 从数组 nums 中移除。
在执行 m 步操作后，返回 最大 分数。
  示例 1：
输入：nums = [1,2,3], multipliers = [3,2,1]
输出：14
解释：一种最优解决方案如下：
- 选择末尾处的整数 3 ，[1,2,3] ，得 3 * 3 = 9 分，累加到分数中。
- 选择末尾处的整数 2 ，[1,2] ，得 2 * 2 = 4 分，累加到分数中。
- 选择末尾处的整数 1 ，[1] ，得 1 * 1 = 1 分，累加到分数中。
总分数为 9 + 4 + 1 = 14 。
示例 2：
输入：nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
输出：102
解释：一种最优解决方案如下：
- 选择开头处的整数 -5 ，[-5,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。
- 选择开头处的整数 -3 ，[-3,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。
- 选择开头处的整数 -3 ，[-3,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。
- 选择末尾处的整数 1 ，[-2,7,1] ，得 1 * 4 = 4 分，累加到分数中。
- 选择末尾处的整数 7 ，[-2,7] ，得 7 * 6 = 42 分，累加到分数中。
总分数为 50 + 15 - 9 + 4 + 42 = 102 。
  提示：
n == nums.length
m == multipliers.length
1 <= m <= 103
m <= n <= 105
-1000 <= nums[i], multipliers[i] <= 1000",73,,4881,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],12844
评论 (40),maximize-palindrome-length-from-subsequences,困难,"给你两个字符串 word1 和 word2 ，请你按下述方法构造一个字符串：
从 word1 中选出某个 非空 子序列 subsequence1 。
从 word2 中选出某个 非空 子序列 subsequence2 。
连接两个子序列 subsequence1 + subsequence2 ，得到字符串。
返回可按上述方法构造的最长 回文串 的 长度 。如果无法构造回文串，返回 0 。
字符串 s 的一个 子序列 是通过从 s 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。
回文串 是正着读和反着读结果一致的字符串。
  示例 1：
输入：word1 = ""cacb"", word2 = ""cbba""
输出：5
解释：从 word1 中选出 ""ab"" ，从 word2 中选出 ""cba"" ，得到回文串 ""abcba"" 。
示例 2：
输入：word1 = ""ab"", word2 = ""ab""
输出：3
解释：从 word1 中选出 ""ab"" ，从 word2 中选出 ""a"" ，得到回文串 ""aba"" 。
示例 3：
输入：word1 = ""aa"", word2 = ""bb""
输出：0
解释：无法按题面所述方法构造回文串，所以返回 0 。
  提示：
1 <= word1.length, word2.length <= 1000
word1 和 word2 由小写英文字母组成",45,,2685,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],7217
评论 (6),sort-features-by-popularity,Unknown,,-1,,-1,[],[],-1
评论 (112),count-items-matching-a-rule,简单,"给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。
另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。
如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：
ruleKey == ""type"" 且 ruleValue == typei 。
ruleKey == ""color"" 且 ruleValue == colori 。
ruleKey == ""name"" 且 ruleValue == namei 。
统计并返回 匹配检索规则的物品数量 。
  示例 1：
输入：items = [[""phone"",""blue"",""pixel""],[""computer"",""silver"",""lenovo""],[""phone"",""gold"",""iphone""]], ruleKey = ""color"", ruleValue = ""silver""
输出：1
解释：只有一件物品匹配检索规则，这件物品是 [""computer"",""silver"",""lenovo""] 。
示例 2：
输入：items = [[""phone"",""blue"",""pixel""],[""computer"",""silver"",""phone""],[""phone"",""gold"",""iphone""]], ruleKey = ""type"", ruleValue = ""phone""
输出：2
解释：只有两件物品匹配检索规则，这两件物品分别是 [""phone"",""blue"",""pixel""] 和 [""phone"",""gold"",""iphone""] 。注意，[""computer"",""silver"",""phone""] 未匹配检索规则。
  提示：
1 <= items.length <= 104
1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10
ruleKey 等于 ""type""、""color"" 或 ""name""
所有字符串仅由小写字母组成",20,,19457,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],23061
评论 (85),closest-dessert-cost,中等,"你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：
必须选择 一种 冰激凌基料。
可以添加 一种或多种 配料，也可以不添加任何配料。
每种类型的配料 最多两份 。
给你以下三个输入：
baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。
toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。
target ，一个整数，表示你制作甜点的目标价格。
你希望自己做的甜点总成本尽可能接近目标价格 target 。
返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。
  示例 1：
输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10
输出：10
解释：考虑下面的方案组合（所有下标均从 0 开始）：
- 选择 1 号基料：成本 7
- 选择 1 份 0 号配料：成本 1 x 3 = 3
- 选择 0 份 1 号配料：成本 0 x 4 = 0
总成本：7 + 3 + 0 = 10 。
示例 2：
输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18
输出：17
解释：考虑下面的方案组合（所有下标均从 0 开始）：
- 选择 1 号基料：成本 3
- 选择 1 份 0 号配料：成本 1 x 4 = 4
- 选择 2 份 1 号配料：成本 2 x 5 = 10
- 选择 0 份 2 号配料：成本 0 x 100 = 0
总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。
示例 3：
输入：baseCosts = [3,10], toppingCosts = [2,5], target = 9
输出：8
解释：可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。
示例 4：
输入：baseCosts = [10], toppingCosts = [1], target = 1
输出：10
解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。
  提示：
n == baseCosts.length
m == toppingCosts.length
1 <= n, m <= 10
1 <= baseCosts[i], toppingCosts[i] <= 104
1 <= target <= 104",41,,7105,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/']",[],13294
评论 (62),equal-sum-arrays-with-minimum-number-of-operations,中等,"给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。
每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。
请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。
  示例 1：
输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]
输出：3
解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。
- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。
- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。
- 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。
示例 2：
输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6]
输出：-1
解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。
示例 3：
输入：nums1 = [6,6], nums2 = [1]
输出：3
解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。
- 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。
- 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。
- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。
  提示：
1 <= nums1.length, nums2.length <= 105
1 <= nums1[i], nums2[i] <= 6",53,,5064,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],10441
评论 (28),car-fleet-ii,困难,"在一条单车道上有 n 辆车，它们朝着同样的方向行驶。给你一个长度为 n 的数组 cars ，其中 cars[i] = [positioni, speedi] ，它表示：
positioni 是第 i 辆车和道路起点之间的距离（单位：米）。题目保证 positioni < positioni+1 。
speedi 是第 i 辆车的初始速度（单位：米/秒）。
简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。
请你返回一个数组 answer ，其中 answer[i] 是第 i 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 answer[i] 为 -1 。答案精度误差需在 10-5 以内。
  示例 1：
输入：cars = [[1,2],[2,1],[4,3],[7,2]]
输出：[1.00000,-1.00000,3.00000,-1.00000]
解释：经过恰好 1 秒以后，第一辆车会与第二辆车相遇，并形成一个 1 m/s 的车队。经过恰好 3 秒以后，第三辆车会与第四辆车相遇，并形成一个 2 m/s 的车队。
示例 2：
输入：cars = [[3,4],[5,4],[6,3],[9,1]]
输出：[2.00000,1.00000,1.50000,-1.00000]
  提示：
1 <= cars.length <= 105
1 <= positioni, speedi <= 106
positioni < positioni+1",61,,2253,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/monotonic-stack/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],4819
评论 (101),products-price-for-each-store,Unknown,,-1,,-1,[],[],-1
评论 (5),shortest-path-in-a-hidden-grid,Unknown,,-1,,-1,[],[],-1
评论 (115),find-nearest-point-that-has-the-same-x-or-y-coordinate,简单,"给你两个整数 x 和 y ，表示你在一个笛卡尔坐标系下的 (x, y) 处。同时，在同一个坐标系下给你一个数组 points ，其中 points[i] = [ai, bi] 表示在 (ai, bi) 处有一个点。当一个点与你所在的位置有相同的 x 坐标或者相同的 y 坐标时，我们称这个点是 有效的 。
请返回距离你当前位置 曼哈顿距离 最近的 有效 点的下标（下标从 0 开始）。如果有多个最近的有效点，请返回下标 最小 的一个。如果没有有效点，请返回 -1 。
两个点 (x1, y1) 和 (x2, y2) 之间的 曼哈顿距离 为 abs(x1 - x2) + abs(y1 - y2) 。
  示例 1：
输入：x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]
输出：2
解释：所有点中，[3,1]，[2,4] 和 [4,4] 是有效点。有效点中，[2,4] 和 [4,4] 距离你当前位置的曼哈顿距离最小，都为 1 。[2,4] 的下标最小，所以返回 2 。
示例 2：
输入：x = 3, y = 4, points = [[3,4]]
输出：0
提示：答案可以与你当前所在位置坐标相同。
示例 3：
输入：x = 3, y = 4, points = [[2,3]]
输出：-1
解释：没有 有效点。
  提示：
1 <= points.length <= 104
points[i].length == 2
1 <= x, y, ai, bi <= 104",27,,12808,['https://leetcode.cn/tag/array/'],[],19761
评论 (87),check-if-number-is-a-sum-of-powers-of-three,中等,"给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。
对于一个整数 y ，如果存在整数 x 满足 y == 3x ，我们称这个整数 y 是三的幂。
  示例 1：
输入：n = 12
输出：true
解释：12 = 31 + 32
示例 2：
输入：n = 91
输出：true
解释：91 = 30 + 32 + 34
示例 3：
输入：n = 21
输出：false
  提示：
1 <= n <= 107",30,,6981,['https://leetcode.cn/tag/math/'],[],10389
评论 (60),sum-of-beauty-of-all-substrings,中等,"一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。
比方说，""abaacc"" 的美丽值为 3 - 1 = 2 。
给你一个字符串 s ，请你返回它所有子字符串的 美丽值 之和。
  示例 1：
输入：s = ""aabcb""
输出：5
解释：美丽值不为零的字符串包括 [""aab"",""aabc"",""aabcb"",""abcb"",""bcb""] ，每一个字符串的美丽值都为 1 。
示例 2：
输入：s = ""aabcbaa""
输出：17
  提示：
1 <= s.length <= 500
s 只包含小写英文字母。",17,,4889,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],9081
评论 (34),count-pairs-of-nodes,困难,"给你一个无向图，无向图由整数 n  ，表示图中节点的数目，和 edges 组成，其中 edges[i] = [ui, vi] 表示 ui 和 vi 之间有一条无向边。同时给你一个代表查询的整数数组 queries 。
第 j 个查询的答案是满足如下条件的点对 (a, b) 的数目：
a < b
cnt 是与 a 或者 b 相连的边的数目，且 cnt 严格大于 queries[j] 。
请你返回一个数组 answers ，其中 answers.length == queries.length 且 answers[j] 是第 j 个查询的答案。
请注意，图中可能会有 重复边 。
  示例 1：
输入：n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
输出：[6,5]
解释：每个点对中，与至少一个点相连的边的数目如上图所示。
示例 2：
输入：n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
输出：[10,10,9,8,6]
  提示：
2 <= n <= 2 * 104
1 <= edges.length <= 105
1 <= ui, vi <= n
ui != vi
1 <= queries.length <= 20
0 <= queries[j] < edges.length",30,https://pic.leetcode-cn.com/1614828447-GMnLVg-image.png,1475,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/']",[],4615
评论 (61),grand-slam-titles,Unknown,,-1,,-1,[],[],-1
评论 (137),check-if-binary-string-has-at-most-one-segment-of-ones,简单,"给你一个二进制字符串 s ，该字符串 不含前导零 。
如果 s 包含 零个或一个由连续的 '1' 组成的字段 ，返回 true 。否则，返回 false 。
  示例 1：
输入：s = ""1001""
输出：false
解释：字符串中的 1 没有形成一个连续字段。
示例 2：
输入：s = ""110""
输出：true
  提示：
1 <= s.length <= 100
s[i] 为 '0' 或 '1'
s[0] 为 '1'",17,,10660,['https://leetcode.cn/tag/string/'],[],25117
评论 (72),minimum-elements-to-add-to-form-a-given-sum,中等,"给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) <= limit 。
返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) <= limit 这一属性。
注意，如果 x >= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。
  示例 1：
输入：nums = [1,-1,1], limit = 3, goal = -4
输出：2
解释：可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。
示例 2：
输入：nums = [1,-10,9,1], limit = 100, goal = 0
输出：1
  提示：
1 <= nums.length <= 105
1 <= limit <= 106
-limit <= nums[i] <= limit
-109 <= goal <= 109",5,,7214,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],20115
评论 (79),number-of-restricted-paths-from-first-to-last-node,中等,"现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。
从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, ..., zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 <= i <= k-1 的节点 zi 和 zi+1 之间存在一条边。
路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 distanceToLastNode(zi) > distanceToLastNode(zi+1) 的一条路径，其中 0 <= i <= k-1 。
返回从节点 1 出发到节点 n 的 受限路径数 。由于数字可能很大，请返回对 109 + 7 取余 的结果。
  示例 1：
输入：n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
输出：3
解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5
示例 2：
输入：n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
输出：1
解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --> 3 --> 7 。
  提示：
1 <= n <= 2 * 104
n - 1 <= edges.length <= 4 * 104
edges[i].length == 3
1 <= ui, vi <= n
ui != vi
1 <= weighti <= 105
任意两个节点之间至多存在一条边
任意两个节点之间至少存在一条路径",72,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex1.png,4404,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/shortest-path/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],12575
评论 (237),make-the-xor-of-all-segments-equal-to-zero,困难,"给你一个整数数组 nums 和一个整数 k 。区间 [left, right]（left <= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR ... XOR nums[right] 。
返回数组中 要更改的最小元素数 ，以使所有长度为 k 的区间异或结果等于零。
  示例 1：
输入：nums = [1,2,0,3,0], k = 1
输出：3
解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0]
示例 2：
输入：nums = [3,4,5,2,1,7,3,4,7], k = 3
输出：3
解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7]
示例 3：
输入：nums = [1,2,4,1,2,5,1,2,6], k = 3
输出：3
解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3]
  提示：
1 <= k <= nums.length <= 2000
0 <= nums[i] < 210",131,,12217,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],18747
评论 (7),maximize-the-beauty-of-the-garden,Unknown,,-1,,-1,[],[],-1
评论 (83),primary-department-for-each-employee,Unknown,,-1,,-1,[],[],-1
评论 (164),check-if-one-string-swap-can-make-strings-equal,简单,"给你长度相等的两个字符串 s1 和 s2 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。
如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。
  示例 1：
输入：s1 = ""bank"", s2 = ""kanb""
输出：true
解释：例如，交换 s2 中的第一个和最后一个字符可以得到 ""bank""
示例 2：
输入：s1 = ""attack"", s2 = ""defend""
输出：false
解释：一次字符串交换无法使两个字符串相等
示例 3：
输入：s1 = ""kelb"", s2 = ""kelb""
输出：true
解释：两个字符串已经相等，所以不需要进行字符串交换
示例 4：
输入：s1 = ""abcd"", s2 = ""dcba""
输出：false
  提示：
1 <= s1.length, s2.length <= 100
s1.length == s2.length
s1 和 s2 仅由小写英文字母组成",31,,20332,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],35729
评论 (405),find-center-of-star-graph,简单,"有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。
给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。
  示例 1：
输入：edges = [[1,2],[2,3],[4,2]]
输出：2
解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。
示例 2：
输入：edges = [[1,2],[5,1],[1,3],[1,4]]
输出：1
  提示：
3 <= n <= 105
edges.length == n - 1
edges[i].length == 2
1 <= ui, vi <= n
ui != vi
题目数据给出的 edges 表示一个有效的星型图",57,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/14/star_graph.png,48643,['https://leetcode.cn/tag/graph/'],[],57957
评论 (98),maximum-average-pass-ratio,中等,"一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。
给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。
一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。
请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。
  示例 1：
输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2
输出：0.78333
解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。
示例 2：
输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4
输出：0.53485
  提示：
1 <= classes.length <= 105
classes[i].length == 2
1 <= passi <= totali <= 105
1 <= extraStudents <= 105",51,,7459,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],14583
评论 (65),maximum-score-of-a-good-subarray,困难,"给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。
一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i <= k <= j 。
请你返回 好 子数组的最大可能 分数 。
  示例 1：
输入：nums = [1,4,3,7,4,5], k = 3
输出：15
解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。
示例 2：
输入：nums = [5,5,4,5,4,1,1,1], k = 0
输出：20
解释：最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 2 * 104
0 <= k < nums.length",49,,4617,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/monotonic-stack/']",[],10732
评论 (7),count-pairs-of-equal-substrings-with-minimum-difference,Unknown,,-1,,-1,[],[],-1
评论 (75),rearrange-products-table,简单,"SQL架构
表：Products
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_id  | int     |
| store1      | int     |
| store2      | int     |
| store3      | int     |
+-------------+---------+
这张表的主键是product_id（产品Id）。
每行存储了这一产品在不同商店store1, store2, store3的价格。
如果这一产品在商店里没有出售，则值将为null。
  请你重构 Products 表，查询每个产品在不同商店的价格，使得输出的格式变为(product_id, store, price) 。如果这一产品在商店里没有出售，则不输出这一行。
输出结果表中的 顺序不作要求 。
查询输出格式请参考下面示例。
  示例 1：
输入：
Products table:
+------------+--------+--------+--------+
| product_id | store1 | store2 | store3 |
+------------+--------+--------+--------+
| 0          | 95     | 100    | 105    |
| 1          | 70     | null   | 80     |
+------------+--------+--------+--------+
输出：
+------------+--------+-------+
| product_id | store  | price |
+------------+--------+-------+
| 0          | store1 | 95    |
| 0          | store2 | 100   |
| 0          | store3 | 105   |
| 1          | store1 | 70    |
| 1          | store3 | 80    |
+------------+--------+-------+
解释：
产品0在store1，store2,store3的价格分别为95,100,105。
产品1在store1，store3的价格分别为70,80。在store2无法买到。",30,,9667,['https://leetcode.cn/tag/database/'],[],12174
评论 (97),second-largest-digit-in-a-string,简单,"给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。
混合字符串 由小写英文字母和数字组成。
  示例 1：
输入：s = ""dfa12321afd""
输出：2
解释：出现在 s 中的数字包括 [1, 2, 3] 。第二大的数字是 2 。
示例 2：
输入：s = ""abc1111""
输出：-1
解释：出现在 s 中的数字只包含 [1] 。没有第二大的数字。
  提示：
1 <= s.length <= 500
s 只包含小写英文字母和（或）数字。",10,,9584,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],19605
评论 (60),design-authentication-manager,中等,"你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。
请你实现 AuthenticationManager 类：
AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。
generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。
renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。
countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻，未过期 的验证码数目。
如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。
  示例 1：
输入：
[""AuthenticationManager"", ""renew"", ""generate"", ""countUnexpiredTokens"", ""generate"", ""renew"", ""renew"", ""countUnexpiredTokens""]
[[5], [""aaa"", 1], [""aaa"", 2], [6], [""bbb"", 7], [""aaa"", 8], [""bbb"", 10], [15]]
输出：
[null, null, null, 1, null, null, null, 0]

解释：
AuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 timeToLive = 5 秒。
authenticationManager.renew(""aaa"", 1); // 时刻 1 时，没有验证码的 tokenId 为 ""aaa"" ，没有验证码被更新。
authenticationManager.generate(""aaa"", 2); // 时刻 2 时，生成一个 tokenId 为 ""aaa"" 的新验证码。
authenticationManager.countUnexpiredTokens(6); // 时刻 6 时，只有 tokenId 为 ""aaa"" 的验证码未过期，所以返回 1 。
authenticationManager.generate(""bbb"", 7); // 时刻 7 时，生成一个 tokenId 为 ""bbb"" 的新验证码。
authenticationManager.renew(""aaa"", 8); // tokenId 为 ""aaa"" 的验证码在时刻 7 过期，且 8 >= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。
authenticationManager.renew(""bbb"", 10); // tokenId 为 ""bbb"" 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。
authenticationManager.countUnexpiredTokens(15); // tokenId 为 ""bbb"" 的验证码在时刻 15 过期，tokenId 为 ""aaa"" 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。
  提示：
1 <= timeToLive <= 108
1 <= currentTime <= 108
1 <= tokenId.length <= 5
tokenId 只包含小写英文字母。
所有 generate 函数的调用都会包含独一无二的 tokenId 值。
所有函数调用中，currentTime 的值 严格递增 。
所有函数的调用次数总共不超过 2000 次。",18,https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png,7956,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/']",[],13818
评论 (36),maximum-number-of-consecutive-values-you-can-make,中等,"给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。
请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。
你可能有多个相同值的硬币。
  示例 1：
输入：coins = [1,3]
输出：2
解释：你可以得到以下这些值：
- 0：什么都不取 []
- 1：取 [1]
从 0 开始，你可以构造出 2 个连续整数。
示例 2：
输入：coins = [1,1,1,4]
输出：8
解释：你可以得到以下这些值：
- 0：什么都不取 []
- 1：取 [1]
- 2：取 [1,1]
- 3：取 [1,1,1]
- 4：取 [4]
- 5：取 [4,1]
- 6：取 [4,1,1]
- 7：取 [4,1,1,1]
从 0 开始，你可以构造出 8 个连续整数。
示例 3：
输入：nums = [1,4,10,3,1]
输出：20
  提示：
coins.length == n
1 <= n <= 4 * 104
1 <= coins[i] <= 4 * 104",47,,3892,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],7213
评论 (28),maximize-score-after-n-operations,困难,"给你 nums ，它是一个大小为 2 * n 的正整数数组。你必须对这个数组执行 n 次操作。
在第 i 次操作时（操作编号从 1 开始），你需要：
选择两个元素 x 和 y 。
获得分数 i * gcd(x, y) 。
将 x 和 y 从 nums 中删除。
请你返回 n 次操作后你能获得的分数和最大为多少。
函数 gcd(x, y) 是 x 和 y 的最大公约数。
  示例 1：
输入：nums = [1,2]
输出：1
解释：最优操作是：
(1 * gcd(1, 2)) = 1
示例 2：
输入：nums = [3,4,6,8]
输出：11
解释：最优操作是：
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
示例 3：
输入：nums = [1,2,3,4,5,6]
输出：14
解释：最优操作是：
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
  提示：
1 <= n <= 7
nums.length == 2 * n
1 <= nums[i] <= 106",28,,2979,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/', 'https://leetcode.cn/tag/number-theory/']",[],5629
评论 (88),maximum-ascending-subarray-sum,简单,"给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。
子数组是数组中的一个连续数字序列。
已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l <= i < r），numsi < numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。
  示例 1：
输入：nums = [10,20,30,5,10,50]
输出：65
解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。
示例 2：
输入：nums = [10,20,30,40,50]
输出：150
解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 
示例 3：
输入：nums = [12,17,15,13,10,11,12]
输出：33
解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 
示例 4：
输入：nums = [100,10,1]
输出：100
  提示：
1 <= nums.length <= 100
1 <= nums[i] <= 100",27,,12353,['https://leetcode.cn/tag/array/'],[],18356
评论 (70),number-of-orders-in-the-backlog,中等,"给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。
订单类型 orderTypei 可以分为两种：
0 表示这是一批采购订单 buy
1 表示这是一批销售订单 sell
注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。
存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：
如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。
反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。
输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。
  示例 1：
输入：orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]
输出：6
解释：输入订单后会发生下述情况：
- 提交 5 笔采购订单，价格为 10 。没有销售订单，所以这 5 笔订单添加到积压订单中。
- 提交 2 笔销售订单，价格为 15 。没有采购订单的价格大于或等于 15 ，所以这 2 笔订单添加到积压订单中。
- 提交 1 笔销售订单，价格为 25 。没有采购订单的价格大于或等于 25 ，所以这 1 笔订单添加到积压订单中。
- 提交 4 笔采购订单，价格为 30 。前 2 笔采购订单与价格最低（价格为 15）的 2 笔销售订单匹配，从积压订单中删除这 2 笔销售订单。第 3 笔采购订单与价格最低的 1 笔销售订单匹配，销售订单价格为 25 ，从积压订单中删除这 1 笔销售订单。积压订单中不存在更多销售订单，所以第 4 笔采购订单需要添加到积压订单中。
最终，积压订单中有 5 笔价格为 10 的采购订单，和 1 笔价格为 30 的采购订单。所以积压订单中的订单总数为 6 。
示例 2：
输入：orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]
输出：999999984
解释：输入订单后会发生下述情况：
- 提交 109 笔销售订单，价格为 7 。没有采购订单，所以这 109 笔订单添加到积压订单中。
- 提交 3 笔采购订单，价格为 15 。这些采购订单与价格最低（价格为 7 ）的 3 笔销售订单匹配，从积压订单中删除这 3 笔销售订单。
- 提交 999999995 笔采购订单，价格为 5 。销售订单的最低价为 7 ，所以这 999999995 笔订单添加到积压订单中。
- 提交 1 笔销售订单，价格为 5 。这笔销售订单与价格最高（价格为 5 ）的 1 笔采购订单匹配，从积压订单中删除这 1 笔采购订单。
最终，积压订单中有 (1000000000-3) 笔价格为 7 的销售订单，和 (999999995-1) 笔价格为 5 的采购订单。所以积压订单中的订单总数为 1999999991 ，等于 999999984 % (109 + 7) 。
  提示：
1 <= orders.length <= 105
orders[i].length == 3
1 <= pricei, amounti <= 109
orderTypei 为 0 或 1",21,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex1.png,5032,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],12835
评论 (86),maximum-value-at-a-given-index-in-a-bounded-array,中等,"给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：
nums.length == n
nums[i] 是 正整数 ，其中 0 <= i < n
abs(nums[i] - nums[i+1]) <= 1 ，其中 0 <= i < n-1
nums 中所有元素之和不超过 maxSum
nums[index] 的值被 最大化
返回你所构造的数组中的 nums[index] 。
注意：abs(x) 等于 x 的前提是 x >= 0 ；否则，abs(x) 等于 -x 。
  示例 1：
输入：n = 4, index = 2,  maxSum = 6
输出：2
解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。
示例 2：
输入：n = 6, index = 1,  maxSum = 10
输出：3
  提示：
1 <= n <= maxSum <= 109
0 <= index < n",36,,5156,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/binary-search/']",[],18758
评论 (43),count-pairs-with-xor-in-a-range,困难,"给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数：low 和 high ，请返回 漂亮数对 的数目。
漂亮数对 是一个形如 (i, j) 的数对，其中 0 <= i < j < nums.length 且 low <= (nums[i] XOR nums[j]) <= high 。
  示例 1：
输入：nums = [1,4,2,7], low = 2, high = 6
输出：6
解释：所有漂亮数对 (i, j) 列出如下：
    - (0, 1): nums[0] XOR nums[1] = 5 
    - (0, 2): nums[0] XOR nums[2] = 3
    - (0, 3): nums[0] XOR nums[3] = 6
    - (1, 2): nums[1] XOR nums[2] = 6
    - (1, 3): nums[1] XOR nums[3] = 3
    - (2, 3): nums[2] XOR nums[3] = 5
示例 2：
输入：nums = [9,8,4,2,1], low = 5, high = 14
输出：8
解释：所有漂亮数对 (i, j) 列出如下：
    - (0, 2): nums[0] XOR nums[2] = 13
    - (0, 3): nums[0] XOR nums[3] = 11
    - (0, 4): nums[0] XOR nums[4] = 8
    - (1, 2): nums[1] XOR nums[2] = 12
    - (1, 3): nums[1] XOR nums[3] = 10
    - (1, 4): nums[1] XOR nums[4] = 9
    - (2, 3): nums[2] XOR nums[3] = 6
    - (2, 4): nums[2] XOR nums[4] = 5
  提示：
1 <= nums.length <= 2 * 104
1 <= nums[i] <= 2 * 104
1 <= low <= high <= 2 * 104",50,,2433,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/']",[],5844
评论 (20),implement-trie-ii-prefix-tree,Unknown,,-1,,-1,[],[],-1
评论 (131),number-of-different-integers-in-a-string,简单,"给你一个字符串 word ，该字符串由数字和小写英文字母组成。
请你用空格替换每个不是数字的字符。例如，""a123bc34d8ef34"" 将会变成 "" 123  34 8  34"" 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：""123""、""34""、""8"" 和 ""34"" 。
返回对 word 完成替换后形成的 不同 整数的数目。
只有当两个整数的 不含前导零 的十进制表示不同， 才认为这两个整数也不同。
  示例 1：
输入：word = ""a123bc34d8ef34""
输出：3
解释：不同的整数有 ""123""、""34"" 和 ""8"" 。注意，""34"" 只计数一次。
示例 2：
输入：word = ""leet1234code234""
输出：2
示例 3：
输入：word = ""a1b01c001""
输出：1
解释：""1""、""01"" 和 ""001"" 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。
  提示：
1 <= word.length <= 1000
word 由数字和小写英文字母组成",23,,13553,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],29473
评论 (72),minimum-number-of-operations-to-reinitialize-a-permutation,中等,"给你一个偶数 n ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i（下标 从 0 开始 计数）。
一步操作中，你将创建一个新数组 arr ，对于每个 i ：
如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]
如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]
然后将 arr 赋值给 perm 。
要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。
  示例 1：
输入：n = 2
输出：1
解释：最初，perm = [0,1]
第 1 步操作后，perm = [0,1]
所以，仅需执行 1 步操作
示例 2：
输入：n = 4
输出：2
解释：最初，perm = [0,1,2,3]
第 1 步操作后，perm = [0,2,1,3]
第 2 步操作后，perm = [0,1,2,3]
所以，仅需执行 2 步操作
示例 3：
输入：n = 6
输出：4
  提示：
2 <= n <= 1000
n 是一个偶数",20,,5732,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],8634
评论 (92),evaluate-the-bracket-pairs-of-a-string,中等,"给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。
比方说，字符串 ""(name)is(age)yearsold"" 中，有 两个 括号对，分别包含键 ""name"" 和 ""age"" 。
你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。
你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：
将 keyi 和括号用对应的值 valuei 替换。
如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 ""?"" 替换（不需要引号）。
knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。
请你返回替换 所有 括号对后的结果字符串。
  示例 1：
输入：s = ""(name)is(age)yearsold"", knowledge = [[""name"",""bob""],[""age"",""two""]]
输出：""bobistwoyearsold""
解释：
键 ""name"" 对应的值为 ""bob"" ，所以将 ""(name)"" 替换为 ""bob"" 。
键 ""age"" 对应的值为 ""two"" ，所以将 ""(age)"" 替换为 ""two"" 。
示例 2：
输入：s = ""hi(name)"", knowledge = [[""a"",""b""]]
输出：""hi?""
解释：由于不知道键 ""name"" 对应的值，所以用 ""?"" 替换 ""(name)"" 。
示例 3：
输入：s = ""(a)(a)(a)aaa"", knowledge = [[""a"",""yes""]]
输出：""yesyesyesaaa""
解释：相同的键在 s 中可能会出现多次。
键 ""a"" 对应的值为 ""yes"" ，所以将所有的 ""(a)"" 替换为 ""yes"" 。
注意，不在括号里的 ""a"" 不需要被替换。
  提示：
1 <= s.length <= 105
0 <= knowledge.length <= 105
knowledge[i].length == 2
1 <= keyi.length, valuei.length <= 10
s 只包含小写英文字母和圆括号 '(' 和 ')' 。
s 中每一个左圆括号 '(' 都有对应的右圆括号 ')' 。
s 中每对括号内的键都不会为空。
s 中不会有嵌套括号对。
keyi 和 valuei 只包含小写英文字母。
knowledge 中的 keyi 不会重复。",10,,6862,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],11614
评论 (52),maximize-number-of-nice-divisors,困难,"给你一个正整数 primeFactors 。你需要构造一个正整数 n ，它满足以下条件：
n 质因数（质因数需要考虑重复的情况）的数目 不超过 primeFactors 个。
n 好因子的数目最大化。如果 n 的一个因子可以被 n 的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。
请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 109 + 7 取余 的结果。
请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 n 的质因子是将 n 分解为若干个质因子，且它们的乘积为 n 。
  示例 1：
输入：primeFactors = 5
输出：6
解释：200 是一个可行的 n 。
它有 5 个质因子：[2,2,2,5,5] ，且有 6 个好因子：[10,20,40,50,100,200] 。
不存在别的 n 有至多 5 个质因子，且同时有更多的好因子。
示例 2：
输入：primeFactors = 8
输出：18
  提示：
1 <= primeFactors <= 109",33,,2749,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']",[],10007
评论 (67),ad-free-sessions,Unknown,,-1,,-1,[],[],-1
评论 (6),minimum-path-cost-in-a-hidden-grid,Unknown,,-1,,-1,[],[],-1
评论 (71),find-interview-candidates,Unknown,,-1,,-1,[],[],-1
评论 (155),determine-color-of-a-chessboard-square,简单,"给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。
如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。
给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。
  示例 1：
输入：coordinates = ""a1""
输出：false
解释：如上图棋盘所示，""a1"" 坐标的格子是黑色的，所以返回 false 。
示例 2：
输入：coordinates = ""h3""
输出：true
解释：如上图棋盘所示，""h3"" 坐标的格子是白色的，所以返回 true 。
示例 3：
输入：coordinates = ""c7""
输出：false
  提示：
coordinates.length == 2
'a' <= coordinates[0] <= 'h'
'1' <= coordinates[1] <= '8'",9,,11060,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],14103
评论 (61),sentence-similarity-iii,中等,"一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，""Hello World"" ，""HELLO"" ，""hello world hello world"" 都是句子。每个单词都 只 包含大写和小写英文字母。
如果两个句子 sentence1 和 sentence2 ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。比方说，sentence1 = ""Hello my name is Jane"" 且 sentence2 = ""Hello Jane"" ，我们可以往 sentence2 中 ""Hello"" 和 ""Jane"" 之间插入 ""my name is"" 得到 sentence1 。
给你两个句子 sentence1 和 sentence2 ，如果 sentence1 和 sentence2 是相似的，请你返回 true ，否则返回 false 。
  示例 1：
输入：sentence1 = ""My name is Haley"", sentence2 = ""My Haley""
输出：true
解释：可以往 sentence2 中 ""My"" 和 ""Haley"" 之间插入 ""name is"" ，得到 sentence1 。
示例 2：
输入：sentence1 = ""of"", sentence2 = ""A lot of words""
输出：false
解释：没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。
示例 3：
输入：sentence1 = ""Eating right now"", sentence2 = ""Eating""
输出：true
解释：可以往 sentence2 的结尾插入 ""right now"" 得到 sentence1 。
示例 4：
输入：sentence1 = ""Luky"", sentence2 = ""Lucccky""
输出：false
  提示：
1 <= sentence1.length, sentence2.length <= 100
sentence1 和 sentence2 都只包含大小写英文字母和空格。
sentence1 和 sentence2 中的单词都只由单个空格隔开。",17,,6195,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],12829
评论 (74),count-nice-pairs-in-an-array,中等,"给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) = 321 ， rev(120) = 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ：
0 <= i < j < nums.length
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。
  示例 1：
输入：nums = [42,11,1,97]
输出：2
解释：两个坐标对为：
 - (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。
 - (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。
示例 2：
输入：nums = [13,10,35,24,76]
输出：4
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 109",18,,4344,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/counting/']",[],12136
评论 (38),maximum-number-of-groups-getting-fresh-donuts,困难,"有一个甜甜圈商店，每批次都烤 batchSize 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 所有 甜甜圈都必须已经全部销售完毕。给你一个整数 batchSize 和一个整数数组 groups ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 groups[i] 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。
当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。
你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。
  示例 1：
输入：batchSize = 3, groups = [1,2,3,4,5,6]
输出：4
解释：你可以将这些批次的顾客顺序安排为 [6,2,4,5,1,3] 。那么第 1，2，4，6 组都会感到开心。
示例 2：
输入：batchSize = 4, groups = [1,3,2,5,2,2,1,6]
输出：4
  提示：
1 <= batchSize <= 9
1 <= groups.length <= 30
1 <= groups[i] <= 109",32,,2092,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],6823
评论 (422),truncate-sentence,简单,"句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。
例如，""Hello World""、""HELLO"" 和 ""hello world hello world"" 都是句子。
给你一个句子 s 和一个整数 k ，请你将 s 截断 ，使截断后的句子仅含 前 k 个单词。返回 截断 s 后得到的句子。
  示例 1：
输入：s = ""Hello how are you Contestant"", k = 4
输出：""Hello how are you""
解释：
s 中的单词为 [""Hello"", ""how"" ""are"", ""you"", ""Contestant""]
前 4 个单词为 [""Hello"", ""how"", ""are"", ""you""]
因此，应当返回 ""Hello how are you""
示例 2：
输入：s = ""What is the solution to this problem"", k = 4
输出：""What is the solution""
解释：
s 中的单词为 [""What"", ""is"" ""the"", ""solution"", ""to"", ""this"", ""problem""]
前 4 个单词为 [""What"", ""is"", ""the"", ""solution""]
因此，应当返回 ""What is the solution""
示例 3：
输入：s = ""chopper is not a tanuki"", k = 5
输出：""chopper is not a tanuki""
  提示：
1 <= s.length <= 500
k 的取值范围是 [1,  s 中单词的数目]
s 仅由大小写英文字母和空格组成
s 中的单词之间由单个空格隔开
不存在前导或尾随空格",56,,50033,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],68535
评论 (78),finding-the-users-active-minutes,中等,"给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDi, timei] 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。
多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。
指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。
请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（1 <= j <= k），answer[j] 表示 用户活跃分钟数 等于 j 的用户数。
返回上面描述的答案数组 answer 。
  示例 1：
输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5
输出：[0,2,0,0,0]
解释：
ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）
ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2
2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0
示例 2：
输入：logs = [[1,1],[2,2],[2,3]], k = 4
输出：[1,1,0,0]
解释：
ID=1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1
ID=2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2
1 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2 
因此，answer[1] = 1 ，answer[2] = 1 ，其余的值都是 0
  提示：
1 <= logs.length <= 104
0 <= IDi <= 109
1 <= timei <= 105
k 的取值范围是 [用户的最大用户活跃分钟数, 105]",13,,7038,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],10039
评论 (315),minimum-absolute-sum-difference,中等,"给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。
数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 <= i < n）的 总和（下标从 0 开始）。
你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。
在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。
|x| 定义为：
如果 x >= 0 ，值为 x ，或者
如果 x <= 0 ，值为 -x
  示例 1：
输入：nums1 = [1,7,5], nums2 = [2,3,5]
输出：3
解释：有两种可能的最优方案：
- 将第二个元素替换为第一个元素：[1,7,5] => [1,1,5] ，或者
- 将第二个元素替换为第三个元素：[1,7,5] => [1,5,5]
两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3
示例 2：
输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
输出：0
解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0
示例 3：
输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
输出：20
解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] => [10,10,4,4,2,7]
绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20
  提示：
n == nums1.length
n == nums2.length
1 <= n <= 105
1 <= nums1[i], nums2[i] <= 105",130,,27990,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/sorting/']",[],75003
评论 (26),number-of-different-subsequences-gcds,困难,"给你一个由正整数组成的数组 nums 。
数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。
例如，序列 [4,6,16] 的最大公约数是 2 。
数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。
例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。
计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。
  示例 1：
输入：nums = [6,10,3]
输出：5
解释：上图显示了所有的非空子序列与各自的最大公约数。
不同的最大公约数为 6 、10 、3 、2 和 1 。
示例 2：
输入：nums = [5,15,40,5,6]
输出：7
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 2 * 105",49,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/image-1.png,3010,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/number-theory/']",[],7488
评论 (4),maximum-number-of-accepted-invitations,Unknown,,-1,,-1,[],[],-1
评论 (49),find-customers-with-positive-revenue-this-year,Unknown,,-1,,-1,[],[],-1
评论 (163),sign-of-the-product-of-an-array,简单,"已知函数 signFunc(x) 将会根据 x 的正负返回特定值：
如果 x 是正数，返回 1 。
如果 x 是负数，返回 -1 。
如果 x 是等于 0 ，返回 0 。
给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。
返回 signFunc(product) 。
  示例 1：
输入：nums = [-1,-2,-3,-4,3,2,1]
输出：1
解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1
示例 2：
输入：nums = [1,5,0,2,-3]
输出：0
解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0
示例 3：
输入：nums = [-1,1,-1,1,-1]
输出：-1
解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1
  提示：
1 <= nums.length <= 1000
-100 <= nums[i] <= 100",23,,29738,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],39642
评论 (276),find-the-winner-of-the-circular-game,中等,"共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。
游戏遵循如下规则：
从第 1 名小伙伴所在位置 开始 。
沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
否则，圈子中最后一名小伙伴赢得游戏。
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。
  示例 1：
输入：n = 5, k = 2
输出：3
解释：游戏运行步骤如下：
1) 从小伙伴 1 开始。
2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。
3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。
4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。
5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。
6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。
7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。
8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。
9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。
示例 2：
输入：n = 6, k = 5
输出：1
解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。
  提示：
1 <= k <= n <= 500",143,https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png,44440,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],56282
评论 (130),minimum-sideway-jumps,中等,"给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。
给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。
比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。
这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。
比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。
这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。
注意：点 0 处和点 n 处的任一跑道都不会有障碍。
  示例 1：
输入：obstacles = [0,1,2,3,0]
输出：2 
解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。
注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。
示例 2：
输入：obstacles = [0,1,1,3,3,0]
输出：0
解释：跑道 2 没有任何障碍，所以不需要任何侧跳。
示例 3：
输入：obstacles = [0,2,1,0,3,0]
输出：2
解释：最优方案如上图所示。总共有 2 次侧跳。
  提示：
obstacles.length == n + 1
1 <= n <= 5 * 105
0 <= obstacles[i] <= 3
obstacles[0] == obstacles[n] == 0",38,https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png,8765,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],13624
评论 (79),finding-mk-average,困难,"给你两个整数 m 和 k ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 MK 平均值 。
MK 平均值 按照如下步骤计算：
如果数据流中的整数少于 m 个，MK 平均值 为 -1 ，否则将数据流中最后 m 个元素拷贝到一个独立的容器中。
从这个容器中删除最小的 k 个数和最大的 k 个数。
计算剩余元素的平均值，并 向下取整到最近的整数 。
请你实现 MKAverage 类：
MKAverage(int m, int k) 用一个空的数据流和两个整数 m 和 k 初始化 MKAverage 对象。
void addElement(int num) 往数据流中插入一个新的元素 num 。
int calculateMKAverage() 对当前的数据流计算并返回 MK 平均数 ，结果需 向下取整到最近的整数 。
  示例 1：
输入：
[""MKAverage"", ""addElement"", ""addElement"", ""calculateMKAverage"", ""addElement"", ""calculateMKAverage"", ""addElement"", ""addElement"", ""addElement"", ""calculateMKAverage""]
[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]
输出：
[null, null, null, -1, null, 3, null, null, null, 5]

解释：
MKAverage obj = new MKAverage(3, 1); 
obj.addElement(3);        // 当前元素为 [3]
obj.addElement(1);        // 当前元素为 [3,1]
obj.calculateMKAverage(); // 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素
obj.addElement(10);       // 当前元素为 [3,1,10]
obj.calculateMKAverage(); // 最后 3 个元素为 [3,1,10]
                          // 删除最小以及最大的 1 个元素后，容器为 [3]
                          // [3] 的平均值等于 3/1 = 3 ，故返回 3
obj.addElement(5);        // 当前元素为 [3,1,10,5]
obj.addElement(5);        // 当前元素为 [3,1,10,5,5]
obj.addElement(5);        // 当前元素为 [3,1,10,5,5,5]
obj.calculateMKAverage(); // 最后 3 个元素为 [5,5,5]
                          // 删除最小以及最大的 1 个元素后，容器为 [5]
                          // [5] 的平均值等于 5/1 = 5 ，故返回 5
  提示：
3 <= m <= 105
1 <= k*2 < m
1 <= num <= 105
addElement 与 calculateMKAverage 总操作次数不超过 105 次。",29,,2952,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],10205
评论 (13),faulty-sensor,Unknown,,-1,,-1,[],[],-1
评论 (116),minimum-operations-to-make-the-array-increasing,简单,"给你一个整数数组 nums （下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。
比方说，如果 nums = [1,2,3] ，你可以选择增加 nums[1] 得到 nums = [1,3,3] 。
请你返回使 nums 严格递增 的 最少 操作次数。
我们称数组 nums 是 严格递增的 ，当它满足对于所有的 0 <= i < nums.length - 1 都有 nums[i] < nums[i+1] 。一个长度为 1 的数组是严格递增的一种特殊情况。
  示例 1：
输入：nums = [1,1,1]
输出：3
解释：你可以进行如下操作：
1) 增加 nums[2] ，数组变为 [1,1,2] 。
2) 增加 nums[1] ，数组变为 [1,2,2] 。
3) 增加 nums[2] ，数组变为 [1,2,3] 。
示例 2：
输入：nums = [1,5,2,4,1]
输出：14
示例 3：
输入：nums = [8]
输出：0
  提示：
1 <= nums.length <= 5000
1 <= nums[i] <= 104",25,,14234,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],18168
评论 (80),queries-on-number-of-points-inside-a-circle,中等,"给你一个数组 points ，其中 points[i] = [xi, yi] ，表示第 i 个点在二维平面上的坐标。多个点可能会有 相同 的坐标。
同时给你一个数组 queries ，其中 queries[j] = [xj, yj, rj] ，表示一个圆心在 (xj, yj) 且半径为 rj 的圆。
对于每一个查询 queries[j] ，计算在第 j 个圆 内 点的数目。如果一个点在圆的 边界上 ，我们同样认为它在圆 内 。
请你返回一个数组 answer ，其中 answer[j]是第 j 个查询的答案。
  示例 1：
输入：points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]
输出：[3,2,2]
解释：所有的点和圆如上图所示。
queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。
示例 2：
输入：points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]
输出：[2,3,2,4]
解释：所有的点和圆如上图所示。
queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。
  提示：
1 <= points.length <= 500
points[i].length == 2
0 <= xi, yi <= 500
1 <= queries.length <= 500
queries[j].length == 3
0 <= xj, yj <= 500
1 <= rj <= 500
所有的坐标都是整数。",14,https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-34-16.png,10542,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],12187
评论 (63),maximum-xor-for-each-query,中等,"给你一个 有序 数组 nums ，它由 n 个非负整数组成，同时给你一个整数 maximumBit 。你需要执行以下查询 n 次：
找到一个非负整数 k < 2maximumBit ，使得 nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k 的结果 最大化 。k 是第 i 个查询的答案。
从当前数组 nums 删除 最后 一个元素。
请你返回一个数组 answer ，其中 answer[i]是第 i 个查询的结果。
  示例 1：
输入：nums = [0,1,1,3], maximumBit = 2
输出：[0,3,2,3]
解释：查询的答案如下：
第一个查询：nums = [0,1,1,3]，k = 0，因为 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3 。
第二个查询：nums = [0,1,1]，k = 3，因为 0 XOR 1 XOR 1 XOR 3 = 3 。
第三个查询：nums = [0,1]，k = 2，因为 0 XOR 1 XOR 2 = 3 。
第四个查询：nums = [0]，k = 3，因为 0 XOR 3 = 3 。
示例 2：
输入：nums = [2,3,4,7], maximumBit = 3
输出：[5,2,6,5]
解释：查询的答案如下：
第一个查询：nums = [2,3,4,7]，k = 5，因为 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7。
第二个查询：nums = [2,3,4]，k = 2，因为 2 XOR 3 XOR 4 XOR 2 = 7 。
第三个查询：nums = [2,3]，k = 6，因为 2 XOR 3 XOR 6 = 7 。
第四个查询：nums = [2]，k = 5，因为 2 XOR 5 = 7 。
示例 3：
输入：nums = [0,1,2,2,5,7], maximumBit = 3
输出：[4,3,6,4,6,7]
  提示：
nums.length == n
1 <= n <= 105
1 <= maximumBit <= 20
0 <= nums[i] < 2maximumBit
nums 中的数字已经按 升序 排好序。",18,,4984,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],7118
评论 (33),minimum-number-of-operations-to-make-string-sorted,困难,"给你一个字符串 s （下标从 0 开始）。你需要对 s 执行以下操作直到它变为一个有序字符串：
找到 最大下标 i ，使得 1 <= i < s.length 且 s[i] < s[i - 1] 。
找到 最大下标 j ，使得 i <= j < s.length 且对于所有在闭区间 [i, j] 之间的 k 都有 s[k] < s[i - 1] 。
交换下标为 i - 1 和 j 处的两个字符。
将下标 i 开始的字符串后缀反转。
请你返回将字符串变成有序的最少操作次数。由于答案可能会很大，请返回它对 109 + 7 取余 的结果。
  示例 1：
输入：s = ""cba""
输出：5
解释：模拟过程如下所示：
操作 1：i=2，j=2。交换 s[1] 和 s[2] 得到 s=""cab"" ，然后反转下标从 2 开始的后缀字符串，得到 s=""cab"" 。
操作 2：i=1，j=2。交换 s[0] 和 s[2] 得到 s=""bac"" ，然后反转下标从 1 开始的后缀字符串，得到 s=""bca"" 。
操作 3：i=2，j=2。交换 s[1] 和 s[2] 得到 s=""bac"" ，然后反转下标从 2 开始的后缀字符串，得到 s=""bac"" 。
操作 4：i=1，j=1。交换 s[0] 和 s[1] 得到 s=""abc"" ，然后反转下标从 1 开始的后缀字符串，得到 s=""acb"" 。
操作 5：i=2，j=2。交换 s[1] 和 s[2] 得到 s=""abc"" ，然后反转下标从 2 开始的后缀字符串，得到 s=""abc"" 。
示例 2：
输入：s = ""aabaa""
输出：2
解释：模拟过程如下所示：
操作 1：i=3，j=4。交换 s[2] 和 s[4] 得到 s=""aaaab"" ，然后反转下标从 3 开始的后缀字符串，得到 s=""aaaba"" 。
操作 2：i=4，j=4。交换 s[3] 和 s[4] 得到 s=""aaaab"" ，然后反转下标从 4 开始的后缀字符串，得到 s=""aaaab"" 。
示例 3：
输入：s = ""cdbea""
输出：63
示例 4：
输入：s = ""leetcodeleetcodeleetcode""
输出：982157772
  提示：
1 <= s.length <= 3000
s 只包含小写英文字母。",21,,1049,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/combinatorics/']",[],2087
评论 (73),maximum-transaction-each-day,Unknown,,-1,,-1,[],[],-1
评论 (152),check-if-the-sentence-is-pangram,简单,"全字母句 指包含英语字母表中每个字母至少一次的句子。
给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。
如果是，返回 true ；否则，返回 false 。
  示例 1：
输入：sentence = ""thequickbrownfoxjumpsoverthelazydog""
输出：true
解释：sentence 包含英语字母表中每个字母至少一次。
示例 2：
输入：sentence = ""leetcode""
输出：false
  提示：
1 <= sentence.length <= 1000
sentence 由小写英语字母组成",22,,17821,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],21703
评论 (369),maximum-ice-cream-bars,中等,"夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。
商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。
给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。
注意：Tony 可以按任意顺序购买雪糕。
  示例 1：
输入：costs = [1,3,2,4,1], coins = 7
输出：4
解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7
示例 2：
输入：costs = [10,6,8,7,7,8], coins = 5
输出：0
解释：Tony 没有足够的钱买任何一支雪糕。
示例 3：
输入：costs = [1,6,3,1,2,5], coins = 20
输出：6
解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。
  提示：
costs.length == n
1 <= n <= 105
1 <= costs[i] <= 105
1 <= coins <= 108",86,,45945,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],67367
评论 (95),single-threaded-cpu,中等,"给你一个二维数组 tasks ，用于表示 n 项从 0 到 n - 1 编号的任务。其中 tasks[i] = [enqueueTimei, processingTimei] 意味着第 i 项任务将会于 enqueueTimei 时进入任务队列，需要 processingTimei 的时长完成执行。
现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：
如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。
如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。
一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。
CPU 可以在完成一项任务后，立即开始执行一项新任务。
返回 CPU 处理任务的顺序。
  示例 1：
输入：tasks = [[1,2],[2,4],[3,2],[4,1]]
输出：[0,2,3,1]
解释：事件按下述流程运行： 
- time = 1 ，任务 0 进入任务队列，可执行任务项 = {0}
- 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {}
- time = 2 ，任务 1 进入任务队列，可执行任务项 = {1}
- time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2}
- 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1}
- time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3}
- time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1}
- time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {}
- time = 10 ，CPU 完成任务 1 并进入空闲状态
示例 2：
输入：tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
输出：[4,3,2,0,1]
解释：事件按下述流程运行： 
- time = 7 ，所有任务同时进入任务队列，可执行任务项  = {0,1,2,3,4}
- 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3}
- time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2}
- time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1}
- time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1}
- time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {}
- time = 40 ，CPU 完成任务 1 并进入空闲状态
  提示：
tasks.length == n
1 <= n <= 105
1 <= enqueueTimei, processingTimei <= 109",61,,7849,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],21525
评论 (56),find-xor-sum-of-all-pairs-bitwise-and,困难,"列表的 异或和（XOR sum）指对所有元素进行按位 XOR 运算的结果。如果列表中仅有一个元素，那么其 异或和 就等于该元素。
例如，[1,2,3,4] 的 异或和 等于 1 XOR 2 XOR 3 XOR 4 = 4 ，而 [3] 的 异或和 等于 3 。
给你两个下标 从 0 开始 计数的数组 arr1 和 arr2 ，两数组均由非负整数组成。
根据每个 (i, j) 数对，构造一个由 arr1[i] AND arr2[j]（按位 AND 运算）结果组成的列表。其中 0 <= i < arr1.length 且 0 <= j < arr2.length 。
返回上述列表的 异或和 。
  示例 1：
输入：arr1 = [1,2,3], arr2 = [6,5]
输出：0
解释：列表 = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1] ，
异或和 = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0 。
示例 2：
输入：arr1 = [12], arr2 = [4]
输出：4
解释：列表 = [12 AND 4] = [4] ，异或和 = 4 。
  提示：
1 <= arr1.length, arr2.length <= 105
0 <= arr1[i], arr2[j] <= 109",29,,4096,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],7812
评论 (20),remove-duplicates-from-an-unsorted-linked-list,Unknown,,-1,,-1,[],[],-1
评论 (61),sum-of-digits-in-base-k,简单,"给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。
转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。
  示例 1：
输入：n = 34, k = 6
输出：9
解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。
示例 2：
输入：n = 10, k = 10
输出：1
解释：n 本身就是 10 进制。 1 + 0 = 1 。
  提示：
1 <= n <= 100
2 <= k <= 10",19,,10350,['https://leetcode.cn/tag/math/'],[],13036
评论 (291),frequency-of-the-most-frequent-element,中等,"元素的 频数 是该元素在一个数组中出现的次数。
给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。
执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。
  示例 1：
输入：nums = [1,2,4], k = 5
输出：3
解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
4 是数组中最高频元素，频数是 3 。
示例 2：
输入：nums = [1,4,8,13], k = 5
输出：2
解释：存在多种最优解决方案：
- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。
- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。
- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。
示例 3：
输入：nums = [3,9,6], k = 2
输出：1
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 105
1 <= k <= 105",220,,32434,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",[],75614
评论 (121),longest-substring-of-all-vowels-in-order,中等,"当一个字符串满足如下条件时，我们称它是 美丽的 ：
所有 5 个英文元音字母（'a' ，'e' ，'i' ，'o' ，'u'）都必须 至少 出现一次。
这些元音字母的顺序都必须按照 字典序 升序排布（也就是说所有的 'a' 都在 'e' 前面，所有的 'e' 都在 'i' 前面，以此类推）
比方说，字符串 ""aeiou"" 和 ""aaaaaaeiiiioou"" 都是 美丽的 ，但是 ""uaeio"" ，""aeoiu"" 和 ""aaaeeeooo"" 不是美丽的 。
给你一个只包含英文元音字母的字符串 word ，请你返回 word 中 最长美丽子字符串的长度 。如果不存在这样的子字符串，请返回 0 。
子字符串 是字符串中一个连续的字符序列。
  示例 1：
输入：word = ""aeiaaioaaaaeiiiiouuuooaauuaeiu""
输出：13
解释：最长子字符串是 ""aaaaeiiiiouuu"" ，长度为 13 。
示例 2：
输入：word = ""aeeeiiiioooauuuaeiou""
输出：5
解释：最长子字符串是 ""aeiou"" ，长度为 5 。
示例 3：
输入：word = ""a""
输出：0
解释：没有美丽子字符串，所以返回 0 。
  提示：
1 <= word.length <= 5 * 105
word 只包含字符 'a'，'e'，'i'，'o' 和 'u' 。",27,,8449,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],15579
评论 (55),maximum-building-height,困难,"在一座城市里，你需要建 n 栋新的建筑。这些新的建筑会从 1 到 n 编号排成一列。
这座城市对这些新建筑有一些规定：
每栋建筑的高度必须是一个非负整数。
第一栋建筑的高度 必须 是 0 。
任意两栋相邻建筑的高度差 不能超过  1 。
除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 restrictions 的形式给出，其中 restrictions[i] = [idi, maxHeighti] ，表示建筑 idi 的高度 不能超过 maxHeighti 。
题目保证每栋建筑在 restrictions 中 至多出现一次 ，同时建筑 1 不会 出现在 restrictions 中。
请你返回 最高 建筑能达到的 最高高度 。
  示例 1：
输入：n = 5, restrictions = [[2,1],[4,1]]
输出：2
解释：上图中的绿色区域为每栋建筑被允许的最高高度。
我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。
示例 2：
输入：n = 6, restrictions = []
输出：5
解释：上图中的绿色区域为每栋建筑被允许的最高高度。
我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。
示例 3：
输入：n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]
输出：5
解释：上图中的绿色区域为每栋建筑被允许的最高高度。
我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。
  提示：
2 <= n <= 109
0 <= restrictions.length <= min(n - 1, 105)
2 <= idi <= n
idi 是 唯一的 。
0 <= maxHeighti <= 109",36,https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex1-1.png,2309,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],5851
评论 (83),league-statistics,Unknown,,-1,,-1,[],[],-1
评论 (13),next-palindrome-using-same-digits,Unknown,,-1,,-1,[],[],-1
评论 (63),suspicious-bank-accounts,Unknown,,-1,,-1,[],[],-1
评论 (82),replace-all-digits-with-characters,简单,"给你一个下标从 0 开始的字符串 s ，它的 偶数 下标处为小写英文字母，奇数 下标处为数字。
定义一个函数 shift(c, x) ，其中 c 是一个字符且 x 是一个数字，函数返回字母表中 c 后面第 x 个字符。
比方说，shift('a', 5) = 'f' 和 shift('x', 0) = 'x' 。
对于每个 奇数 下标 i ，你需要将数字 s[i] 用 shift(s[i-1], s[i]) 替换。
请你替换所有数字以后，将字符串 s 返回。题目 保证 shift(s[i-1], s[i]) 不会超过 'z' 。
  示例 1：
输入：s = ""a1c1e1""
输出：""abcdef""
解释：数字被替换结果如下：
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('c',1) = 'd'
- s[5] -> shift('e',1) = 'f'
示例 2：
输入：s = ""a1b2c3d4e""
输出：""abbdcfdhe""
解释：数字被替换结果如下：
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('b',2) = 'd'
- s[5] -> shift('c',3) = 'f'
- s[7] -> shift('d',4) = 'h'
  提示：
1 <= s.length <= 100
s 只包含小写英文字母和数字。
对所有 奇数 下标处的 i ，满足 shift(s[i-1], s[i]) <= 'z' 。",13,,9498,['https://leetcode.cn/tag/string/'],[],11958
评论 (82),seat-reservation-manager,中等,"请你设计一个管理 n 个座位预约的系统，座位编号从 1 到 n 。
请你实现 SeatManager 类：
SeatManager(int n) 初始化一个 SeatManager 对象，它管理从 1 到 n 编号的 n 个座位。所有座位初始都是可预约的。
int reserve() 返回可以预约座位的 最小编号 ，此座位变为不可预约。
void unreserve(int seatNumber) 将给定编号 seatNumber 对应的座位变成可以预约。
  示例 1：
输入：
[""SeatManager"", ""reserve"", ""reserve"", ""unreserve"", ""reserve"", ""reserve"", ""reserve"", ""reserve"", ""unreserve""]
[[5], [], [], [2], [], [], [], [], [5]]
输出：
[null, 1, 2, null, 2, 3, 4, 5, null]

解释：
SeatManager seatManager = new SeatManager(5); // 初始化 SeatManager ，有 5 个座位。
seatManager.reserve();    // 所有座位都可以预约，所以返回最小编号的座位，也就是 1 。
seatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。
seatManager.unreserve(2); // 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5] 。
seatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。
seatManager.reserve();    // 可以预约的座位为 [3,4,5] ，返回最小编号的座位，也就是 3 。
seatManager.reserve();    // 可以预约的座位为 [4,5] ，返回最小编号的座位，也就是 4 。
seatManager.reserve();    // 唯一可以预约的是座位 5 ，所以返回 5 。
seatManager.unreserve(5); // 将座位 5 变为可以预约，现在可预约的座位为 [5] 。
  提示：
1 <= n <= 105
1 <= seatNumber <= n
每一次对 reserve 的调用，题目保证至少存在一个可以预约的座位。
每一次对 unreserve 的调用，题目保证 seatNumber 在调用函数前都是被预约状态。
对 reserve 和 unreserve 的调用 总共 不超过 105 次。",14,,10564,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],21694
评论 (396),maximum-element-after-decreasing-and-rearranging,中等,"给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：
arr 中 第一个 元素必须为 1 。
任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 <= i < arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) <= 1 。abs(x) 为 x 的绝对值。
你可以执行以下 2 种操作任意次：
减小 arr 中任意元素的值，使其变为一个 更小的正整数 。
重新排列 arr 中的元素，你可以以任意顺序重新排列。
请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。
  示例 1：
输入：arr = [2,2,1,2,1]
输出：2
解释：
我们可以重新排列 arr 得到 [1,2,2,2,1] ，该数组满足所有条件。
arr 中最大元素为 2 。
示例 2：
输入：arr = [100,1,1000]
输出：3
解释：
一个可行的方案如下：
1. 重新排列 arr 得到 [1,100,1000] 。
2. 将第二个元素减小为 2 。
3. 将第三个元素减小为 3 。
现在 arr = [1,2,3] ，满足所有条件。
arr 中最大元素为 3 。
示例 3：
输入：arr = [1,2,3,4,5]
输出：5
解释：数组已经满足所有条件，最大元素为 5 。
  提示：
1 <= arr.length <= 105
1 <= arr[i] <= 109",72,,28994,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],45904
评论 (59),closest-room,困难,"一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] = [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。每一个房间号 roomIdi 保证是 独一无二 的。
同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] = [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：
房间的面积 至少 为 minSizej ，且
abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。
如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。
请你返回长度为 k 的数组 answer ，其中 answer[j] 为第 j 个查询的结果。
  示例 1：
输入：rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]
输出：[3,-1,3]
解释：查询的答案如下：
查询 [3,1] ：房间 3 的面积为 2 ，大于等于 1 ，且号码是最接近 3 的，为 abs(3 - 3) = 0 ，所以答案为 3 。
查询 [3,3] ：没有房间的面积至少为 3 ，所以答案为 -1 。
查询 [5,2] ：房间 3 的面积为 2 ，大于等于 2 ，且号码是最接近 5 的，为 abs(3 - 5) = 2 ，所以答案为 3 。
示例 2：
输入：rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]
输出：[2,1,3]
解释：查询的答案如下：
查询 [2,3] ：房间 2 的面积为 3 ，大于等于 3 ，且号码是最接近的，为 abs(2 - 2) = 0 ，所以答案为 2 。
查询 [2,4] ：房间 1 和 3 的面积都至少为 4 ，答案为 1 因为它房间编号更小。
查询 [2,5] ：房间 3 是唯一面积大于等于 5 的，所以答案为 3 。
  提示：
n == rooms.length
1 <= n <= 105
k == queries.length
1 <= k <= 104
1 <= roomIdi, preferredj <= 107
1 <= sizei, minSizej <= 107",29,,2980,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],7921
评论 (61),minimum-distance-to-the-target-element,简单,"给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数 target 和 start ，请你找出一个下标 i ，满足 nums[i] == target 且 abs(i - start) 最小化 。注意：abs(x) 表示 x 的绝对值。
返回 abs(i - start) 。
题目数据保证 target 存在于 nums 中。
  示例 1：
输入：nums = [1,2,3,4,5], target = 5, start = 3
输出：1
解释：nums[4] = 5 是唯一一个等于 target 的值，所以答案是 abs(4 - 3) = 1 。
示例 2：
输入：nums = [1], target = 1, start = 0
输出：0
解释：nums[0] = 1 是唯一一个等于 target 的值，所以答案是 abs(0 - 0) = 0 。
示例 3：
输入：nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
输出：0
解释：nums 中的每个值都是 1 ，但 nums[0] 使 abs(i - start) 的结果得以最小化，所以答案是 abs(0 - 0) = 0 。
  提示：
1 <= nums.length <= 1000
1 <= nums[i] <= 104
0 <= start < nums.length
target 存在于 nums 中",8,,9925,['https://leetcode.cn/tag/array/'],[],14706
评论 (105),splitting-a-string-into-descending-consecutive-values,中等,"给你一个仅由数字组成的字符串 s 。
请你判断能否将 s 拆分成两个或者多个 非空子字符串 ，使子字符串的 数值 按 降序 排列，且每两个 相邻子字符串 的数值之 差 等于 1 。
例如，字符串 s = ""0090089"" 可以拆分成 [""0090"", ""089""] ，数值为 [90,89] 。这些数值满足按降序排列，且相邻值相差 1 ，这种拆分方法可行。
另一个例子中，字符串 s = ""001"" 可以拆分成 [""0"", ""01""]、[""00"", ""1""] 或 [""0"", ""0"", ""1""] 。然而，所有这些拆分方法都不可行，因为对应数值分别是 [0,1]、[0,1] 和 [0,0,1] ，都不满足按降序排列的要求。
如果可以按要求拆分 s ，返回 true ；否则，返回 false 。
子字符串 是字符串中的一个连续字符序列。
  示例 1：
输入：s = ""1234""
输出：false
解释：不存在拆分 s 的可行方法。
示例 2：
输入：s = ""050043""
输出：true
解释：s 可以拆分为 [""05"", ""004"", ""3""] ，对应数值为 [5,4,3] 。
满足按降序排列，且相邻值相差 1 。
示例 3：
输入：s = ""9080701""
输出：false
解释：不存在拆分 s 的可行方法。
示例 4：
输入：s = ""10009998""
输出：true
解释：s 可以拆分为 [""100"", ""099"", ""98""] ，对应数值为 [100,99,98] 。
满足按降序排列，且相邻值相差 1 。
  提示：
1 <= s.length <= 20
s 仅由数字组成",22,,6396,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],19461
评论 (38),minimum-adjacent-swaps-to-reach-the-kth-smallest-number,中等,"给你一个表示大整数的字符串 num ，和一个整数 k 。
如果某个整数是 num 中各位数字的一个 排列 且它的 值大于 num ，则称这个整数为 妙数 。可能存在很多妙数，但是只需要关注 值最小 的那些。
例如，num = ""5489355142"" ：
第 1 个最小妙数是 ""5489355214""
第 2 个最小妙数是 ""5489355241""
第 3 个最小妙数是 ""5489355412""
第 4 个最小妙数是 ""5489355421""
返回要得到第 k 个 最小妙数 需要对 num 执行的 相邻位数字交换的最小次数 。
测试用例是按存在第 k 个最小妙数而生成的。
  示例 1：
输入：num = ""5489355142"", k = 4
输出：2
解释：第 4 个最小妙数是 ""5489355421"" ，要想得到这个数字：
- 交换下标 7 和下标 8 对应的位：""5489355142"" -> ""5489355412""
- 交换下标 8 和下标 9 对应的位：""5489355412"" -> ""5489355421""
示例 2：
输入：num = ""11112"", k = 4
输出：4
解释：第 4 个最小妙数是 ""21111"" ，要想得到这个数字：
- 交换下标 3 和下标 4 对应的位：""11112"" -> ""11121""
- 交换下标 2 和下标 3 对应的位：""11121"" -> ""11211""
- 交换下标 1 和下标 2 对应的位：""11211"" -> ""12111""
- 交换下标 0 和下标 1 对应的位：""12111"" -> ""21111""
示例 3：
输入：num = ""00123"", k = 1
输出：1
解释：第 1 个最小妙数是 ""00132"" ，要想得到这个数字：
- 交换下标 3 和下标 4 对应的位：""00123"" -> ""00132""
  提示：
2 <= num.length <= 1000
1 <= k <= 1000
num 仅由数字组成",41,,2819,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],4601
评论 (39),find-a-peak-element-ii,中等,"一个 2D 网格中的 顶峰元素 是指那些 严格大于 其相邻格子(上、下、左、右)的元素。
给你一个 从 0 开始编号 的 m x n 矩阵 mat ，其中任意两个相邻格子的值都 不相同 。找出 任意一个 顶峰元素 mat[i][j] 并 返回其位置 [i,j] 。
你可以假设整个矩阵周边环绕着一圈值为 -1 的格子。
要求必须写出时间复杂度为 O(m log(n)) 或 O(n log(m)) 的算法
    示例 1:
输入: mat = [[1,4],[3,2]]
输出: [0,1]
解释: 3和4都是顶峰元素，所以[1,0]和[0,1]都是可接受的答案。
示例 2:
输入: mat = [[10,20,15],[21,30,14],[7,16,32]]
输出: [1,1]
解释: 30和32都是顶峰元素，所以[1,1]和[2,2]都是可接受的答案。
  提示：
m == mat.length
n == mat[i].length
1 <= m, n <= 500
1 <= mat[i][j] <= 105
任意两个相邻元素均不相等.",38,,3800,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/matrix/']",[],6372
评论 (2),depth-of-bst-given-insertion-order,Unknown,,-1,,-1,[],[],-1
评论 (69),largest-odd-number-in-string,简单,"给你一个字符串 num ，表示一个大整数。请你在字符串 num 的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 """" 。
子字符串 是字符串中的一个连续的字符序列。
  示例 1：
输入：num = ""52""
输出：""5""
解释：非空子字符串仅有 ""5""、""2"" 和 ""52"" 。""5"" 是其中唯一的奇数。
示例 2：
输入：num = ""4206""
输出：""""
解释：在 ""4206"" 中不存在奇数。
示例 3：
输入：num = ""35427""
输出：""35427""
解释：""35427"" 本身就是一个奇数。
  提示：
1 <= num.length <= 105
num 仅由数字组成且不含前导零",23,,11236,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],18012
评论 (64),the-number-of-full-rounds-you-have-played,中等,"一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 00 到 23 的整数表示。游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。
给你两个字符串 startTime 和 finishTime ，均符合 ""HH:MM"" 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。
例如，如果 startTime = ""05:20"" 且 finishTime = ""05:59"" ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。
如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。
假设你是从 startTime 进入游戏，并在 finishTime 退出游戏，请计算并返回你完成的 完整对局的对局数 。
  示例 1：
输入：startTime = ""12:01"", finishTime = ""12:44""
输出：1
解释：你完成了从 12:15 到 12:30 的一个完整对局。
你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。
你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。
示例 2：
输入：startTime = ""20:00"", finishTime = ""06:00""
输出：40
解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。
16 + 24 = 40
示例 3：
输入：startTime = ""00:00"", finishTime = ""23:59""
输出：95
解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。
  提示：
startTime 和 finishTime 的格式为 HH:MM
00 <= HH <= 23
00 <= MM <= 59
startTime 和 finishTime 不相等",14,,4578,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/']",[],15219
评论 (173),count-sub-islands,中等,"给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。
如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。
请你返回 grid2 中 子岛屿 的 数目 。
  示例 1：
输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
输出：3
解释：如上图所示，左边为 grid1 ，右边为 grid2 。
grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。
示例 2：
输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
输出：2 
解释：如上图所示，左边为 grid1 ，右边为 grid2 。
grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。
  提示：
m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= 500
grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。",56,https://assets.leetcode.com/uploads/2021/06/10/test1.png,13515,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],20741
评论 (37),minimum-absolute-difference-queries,中等,"一个数组 a 的 差绝对值的最小值 定义为：0 <= i < j < a.length 且 a[i] != a[j] 的 |a[i] - a[j]| 的 最小值。如果 a 中所有元素都 相同 ，那么差绝对值的最小值为 -1 。
比方说，数组 [5,2,3,7,2] 差绝对值的最小值是 |2 - 3| = 1 。注意答案不为 0 ，因为 a[i] 和 a[j] 必须不相等。
给你一个整数数组 nums 和查询数组 queries ，其中 queries[i] = [li, ri] 。对于每个查询 i ，计算 子数组 nums[li...ri] 中 差绝对值的最小值 ，子数组 nums[li...ri] 包含 nums 数组（下标从 0 开始）中下标在 li 和 ri 之间的所有元素（包含 li 和 ri 在内）。
请你返回 ans 数组，其中 ans[i] 是第 i 个查询的答案。
子数组 是一个数组中连续的一段元素。
|x| 的值定义为：
如果 x >= 0 ，那么值为 x 。
如果 x < 0 ，那么值为 -x 。
  示例 1：
输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]
输出：[2,1,4,1]
解释：查询结果如下：
- queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。
- queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。
- queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。
- queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。
示例 2：
输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]
输出：[-1,1,1,3]
解释：查询结果如下：
- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。
- queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。
- queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。
- queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。
  提示：
2 <= nums.length <= 105
1 <= nums[i] <= 100
1 <= queries.length <= 2 * 104
0 <= li < ri < nums.length",39,,3011,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],7031
评论 (44),count-salary-categories,Unknown,,-1,,-1,[],[],-1
评论 (6),game-of-nim,Unknown,,-1,,-1,[],[],-1
评论 (67),remove-one-element-to-make-the-array-strictly-increasing,简单,"给你一个下标从 0 开始的整数数组 nums ，如果 恰好 删除 一个 元素后，数组 严格递增 ，那么请你返回 true ，否则返回 false 。如果数组本身已经是严格递增的，请你也返回 true 。
数组 nums 是 严格递增 的定义为：对于任意下标的 1 <= i < nums.length 都满足 nums[i - 1] < nums[i] 。
  示例 1：
输入：nums = [1,2,10,5,7]
输出：true
解释：从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。
[1,2,5,7] 是严格递增的，所以返回 true 。
示例 2：
输入：nums = [2,3,1,2]
输出：false
解释：
[3,1,2] 是删除下标 0 处元素后得到的结果。
[2,1,2] 是删除下标 1 处元素后得到的结果。
[2,3,2] 是删除下标 2 处元素后得到的结果。
[2,3,1] 是删除下标 3 处元素后得到的结果。
没有任何结果数组是严格递增的，所以返回 false 。
示例 3：
输入：nums = [1,1,1]
输出：false
解释：删除任意元素后的结果都是 [1,1] 。
[1,1] 不是严格递增的，所以返回 false 。
示例 4：
输入：nums = [1,2,3]
输出：true
解释：[1,2,3] 已经是严格递增的，所以返回 true 。
  提示：
2 <= nums.length <= 1000
1 <= nums[i] <= 1000",26,,6932,['https://leetcode.cn/tag/array/'],[],22202
评论 (56),remove-all-occurrences-of-a-substring,中等,"给你两个字符串 s 和 part ，请你对 s 反复执行以下操作直到 所有 子字符串 part 都被删除：
找到 s 中 最左边 的子字符串 part ，并将它从 s 中删除。
请你返回从 s 中删除所有 part 子字符串以后得到的剩余字符串。
一个 子字符串 是一个字符串中连续的字符序列。
  示例 1：
输入：s = ""daabcbaabcbc"", part = ""abc""
输出：""dab""
解释：以下操作按顺序执行：
- s = ""daabcbaabcbc"" ，删除下标从 2 开始的 ""abc"" ，得到 s = ""dabaabcbc"" 。
- s = ""dabaabcbc"" ，删除下标从 4 开始的 ""abc"" ，得到 s = ""dababc"" 。
- s = ""dababc"" ，删除下标从 3 开始的 ""abc"" ，得到 s = ""dab"" 。
此时 s 中不再含有子字符串 ""abc"" 。
示例 2：
输入：s = ""axxxxyyyyb"", part = ""xy""
输出：""ab""
解释：以下操作按顺序执行：
- s = ""axxxxyyyyb"" ，删除下标从 4 开始的 ""xy"" ，得到 s = ""axxxyyyb"" 。
- s = ""axxxyyyb"" ，删除下标从 3 开始的 ""xy"" ，得到 s = ""axxyyb"" 。
- s = ""axxyyb"" ，删除下标从 2 开始的 ""xy"" ，得到 s = ""axyb"" 。
- s = ""axyb"" ，删除下标从 1 开始的 ""xy"" ，得到 s = ""ab"" 。
此时 s 中不再含有子字符串 ""xy"" 。
  提示：
1 <= s.length <= 1000
1 <= part.length <= 1000
s 和 part 只包小写英文字母。",18,,4930,['https://leetcode.cn/tag/string/'],[],7407
评论 (59),maximum-alternating-subsequence-sum,中等,"一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。
比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。
一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。
  示例 1：
输入：nums = [4,2,5,3]
输出：7
解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。
示例 2：
输入：nums = [5,6,7,8]
输出：8
解释：最优子序列为 [8] ，交替和为 8 。
示例 3：
输入：nums = [6,2,1,2,4,5]
输出：10
解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 105",36,,4765,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],8337
评论 (46),design-movie-rental-system,困难,"你有一个电影租借公司和 n 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。
所有电影用二维整数数组 entries 表示，其中 entries[i] = [shopi, moviei, pricei] 表示商店 shopi 有一份电影 moviei 的拷贝，租借价格为 pricei 。每个商店有 至多一份 编号为 moviei 的电影拷贝。
系统需要支持以下操作：
Search：找到拥有指定电影且 未借出 的商店中 最便宜的 5 个 。商店需要按照 价格 升序排序，如果价格相同，则 shopi 较小 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。
Rent：从指定商店借出指定电影，题目保证指定电影在指定商店 未借出 。
Drop：在指定商店返还 之前已借出 的指定电影。
Report：返回 最便宜的 5 部已借出电影 （可能有重复的电影 ID），将结果用二维列表 res 返回，其中 res[j] = [shopj, moviej] 表示第 j 便宜的已借出电影是从商店 shopj 借出的电影 moviej 。res 中的电影需要按 价格 升序排序；如果价格相同，则 shopj 较小 的排在前面；如果仍然相同，则 moviej 较小 的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。
请你实现 MovieRentingSystem 类：
MovieRentingSystem(int n, int[][] entries) 将 MovieRentingSystem 对象用 n 个商店和 entries 表示的电影列表初始化。
List<Integer> search(int movie) 如上所述，返回 未借出 指定 movie 的商店列表。
void rent(int shop, int movie) 从指定商店 shop 借出指定电影 movie 。
void drop(int shop, int movie) 在指定商店 shop 返还之前借出的电影 movie 。
List<List<Integer>> report() 如上所述，返回最便宜的 已借出 电影列表。
注意：测试数据保证 rent 操作中指定商店拥有 未借出 的指定电影，且 drop 操作指定的商店 之前已借出 指定电影。
  示例 1：
输入：
[""MovieRentingSystem"", ""search"", ""rent"", ""rent"", ""report"", ""drop"", ""search""]
[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]
输出：
[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]

解释：
MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);
movieRentingSystem.search(1);  // 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。
movieRentingSystem.rent(0, 1); // 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。
movieRentingSystem.rent(1, 2); // 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。
movieRentingSystem.report();   // 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。
movieRentingSystem.drop(1, 2); // 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。
movieRentingSystem.search(2);  // 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。
  提示：
1 <= n <= 3 * 105
1 <= entries.length <= 105
0 <= shopi < n
1 <= moviei, pricei <= 104
每个商店 至多 有一份电影 moviei 的拷贝。
search，rent，drop 和 report 的调用 总共 不超过 105 次。",34,,3079,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],13075
评论 (57),maximum-product-difference-between-two-pairs,简单,"两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a * b) - (c * d) 。
例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 * 6) - (2 * 7) = 16 。
给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对 (nums[w], nums[x]) 和 (nums[y], nums[z]) 之间的 乘积差 取到 最大值 。
返回以这种方式取得的乘积差中的 最大值 。
  示例 1：
输入：nums = [5,6,2,7,4]
输出：34
解释：可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)
乘积差是 (6 * 7) - (2 * 4) = 34
示例 2：
输入：nums = [4,2,5,9,7,4,8]
输出：64
解释：可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)
乘积差是 (9 * 8) - (2 * 4) = 64
  提示：
4 <= nums.length <= 104
1 <= nums[i] <= 104",18,,13545,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],16415
评论 (68),cyclically-rotating-a-grid,中等,"给你一个大小为 m x n 的整数矩阵 grid ，其中 m 和 n 都是 偶数 ；另给你一个整数 k 。
矩阵由若干层组成，如下图所示，每种颜色代表一层：
矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 逆时针 方向的相邻元素。轮转示例如下：
返回执行 k 次循环轮转操作后的矩阵。
  示例 1：
输入：grid = [[40,10],[30,20]], k = 1
输出：[[10,20],[40,30]]
解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。
示例 2：
输入：grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2
输出：[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]
解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。
  提示：
m == grid.length
n == grid[i].length
2 <= m, n <= 50
m 和 n 都是 偶数
1 <= grid[i][j] <= 5000
1 <= k <= 109",12,https://assets.leetcode.com/uploads/2021/06/22/explanation_grid.jpg,3666,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],8145
评论 (56),number-of-wonderful-substrings,中等,"如果某个字符串中 至多一个 字母出现 奇数 次，则称其为 最美 字符串。
例如，""ccjjc"" 和 ""abab"" 都是最美字符串，但 ""ab"" 不是。
给你一个字符串 word ，该字符串由前十个小写英文字母组成（'a' 到 'j'）。请你返回 word 中 最美非空子字符串 的数目。如果同样的子字符串在 word 中出现多次，那么应当对 每次出现 分别计数。
子字符串 是字符串中的一个连续字符序列。
  示例 1：
输入：word = ""aba""
输出：4
解释：4 个最美子字符串如下所示：
- ""aba"" -> ""a""
- ""aba"" -> ""b""
- ""aba"" -> ""a""
- ""aba"" -> ""aba""
示例 2：
输入：word = ""aabb""
输出：9
解释：9 个最美子字符串如下所示：
- ""aabb"" -> ""a""
- ""aabb"" -> ""aa""
- ""aabb"" -> ""aab""
- ""aabb"" -> ""aabb""
- ""aabb"" -> ""a""
- ""aabb"" -> ""abb""
- ""aabb"" -> ""b""
- ""aabb"" -> ""bb""
- ""aabb"" -> ""b""
示例 3：
输入：word = ""he""
输出：2
解释：2 个最美子字符串如下所示：
- ""he"" -> ""h""
- ""he"" -> ""e""
  提示：
1 <= word.length <= 105
word 由从 'a' 到 'j' 的小写英文字母组成",72,,3445,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/prefix-sum/']",[],8467
评论 (18),count-ways-to-build-rooms-in-an-ant-colony,困难,"你是一只蚂蚁，负责为蚁群构筑 n 间编号从 0 到 n-1 的新房间。给你一个 下标从 0 开始 且长度为 n 的整数数组 prevRoom 作为扩建计划。其中，prevRoom[i] 表示在构筑房间 i 之前，你必须先构筑房间 prevRoom[i] ，并且这两个房间必须 直接 相连。房间 0 已经构筑完成，所以 prevRoom[0] = -1 。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 0 可以访问到每个房间。
你一次只能构筑 一个 房间。你可以在 已经构筑好的 房间之间自由穿行，只要这些房间是 相连的 。如果房间 prevRoom[i] 已经构筑完成，那么你就可以构筑房间 i。
返回你构筑所有房间的 不同顺序的数目 。由于答案可能很大，请返回对 109 + 7 取余 的结果。
  示例 1：
输入：prevRoom = [-1,0,1]
输出：1
解释：仅有一种方案可以完成所有房间的构筑：0 → 1 → 2
示例 2：
输入：prevRoom = [-1,0,0,1,2]
输出：6
解释：
有 6 种不同顺序：
0 → 1 → 3 → 2 → 4
0 → 2 → 4 → 1 → 3
0 → 1 → 2 → 3 → 4
0 → 1 → 2 → 4 → 3
0 → 2 → 1 → 3 → 4
0 → 2 → 1 → 4 → 3
  提示：
n == prevRoom.length
2 <= n <= 105
prevRoom[0] == -1
对于所有的 1 <= i < n ，都有 0 <= prevRoom[i] < n
题目保证所有房间都构筑完成后，从房间 0 可以访问到每个房间",34,https://assets.leetcode.com/uploads/2021/06/19/d1.JPG,1441,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/combinatorics/']",[],2568
评论 (41),leetcodify-friends-recommendations,Unknown,,-1,,-1,[],[],-1
评论 (9),kth-smallest-subarray-sum,Unknown,,-1,,-1,[],[],-1
评论 (39),leetcodify-similar-friends,Unknown,,-1,,-1,[],[],-1
评论 (92),build-array-from-permutation,简单,"给你一个 从 0 开始的排列 nums（下标也从 0 开始）。请你构建一个 同样长度 的数组 ans ，其中，对于每个 i（0 <= i < nums.length），都满足 ans[i] = nums[nums[i]] 。返回构建好的数组 ans 。
从 0 开始的排列 nums 是一个由 0 到 nums.length - 1（0 和 nums.length - 1 也包含在内）的不同整数组成的数组。
  示例 1：
输入：nums = [0,2,1,5,3,4]
输出：[0,1,2,4,5,3]
解释：数组 ans 构建如下：
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
示例 2：
输入：nums = [5,0,1,2,3,4]
输出：[4,5,0,1,2,3]
解释：数组 ans 构建如下：
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
  提示：
1 <= nums.length <= 1000
0 <= nums[i] < nums.length
nums 中的元素 互不相同",30,,22934,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],26221
评论 (70),eliminate-maximum-number-of-monsters,中等,"你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 下标从 0 开始 且长度为 n 的整数数组 dist ，其中 dist[i] 是第 i 个怪物与城市的 初始距离（单位：米）。
怪物以 恒定 的速度走向城市。给你一个长度为 n 的整数数组 speed 表示每个怪物的速度，其中 speed[i] 是第 i 个怪物的速度（单位：米/分）。
怪物从 第 0 分钟 时开始移动。你有一把武器，并可以 选择 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。
一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰 在某一分钟开始时到达城市，这会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。
返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  n 。
  示例 1：
输入：dist = [1,3,4], speed = [1,1,1]
输出：3
解释：
第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。
第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。
第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。
第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。
所有 3 个怪物都可以被消灭。
示例 2：
输入：dist = [1,1,2,3], speed = [1,1,1,1]
输出：1
解释：
第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。
第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。
你只能消灭 1 个怪物。
示例 3：
输入：dist = [3,2,4], speed = [5,3,2]
输出：1
解释：
第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。
第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。 
你只能消灭 1 个怪物。
  提示：
n == dist.length == speed.length
1 <= n <= 105
1 <= dist[i], speed[i] <= 105",22,,6670,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],18809
评论 (82),count-good-numbers,中等,"我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。
比方说，""2582"" 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 ""3245"" 不是 好数字，因为 3 在偶数下标处但不是偶数。
给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 109 + 7 取余后返回 。
一个 数字字符串 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 。
  示例 1：
输入：n = 1
输出：5
解释：长度为 1 的好数字包括 ""0""，""2""，""4""，""6""，""8"" 。
示例 2：
输入：n = 4
输出：400
示例 3：
输入：n = 50
输出：564908303
  提示：
1 <= n <= 1015",17,,5557,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']",[],15333
评论 (44),longest-common-subpath,困难,"一个国家由 n 个编号为 0 到 n - 1 的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。
总共有 m 个编号为 0 到 m - 1 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。
给你一个整数 n 和二维数组 paths ，其中 paths[i] 是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。
一个 子路径 指的是一条路径中连续的城市序列。
  示例 1：
输入：n = 5, paths = [[0,1,2,3,4],
                     [2,3,4],
                     [4,0,1,2,3]]
输出：2
解释：最长公共子路径为 [2,3] 。
示例 2：
输入：n = 3, paths = [[0],[1],[2]]
输出：0
解释：三条路径没有公共子路径。
示例 3：
输入：n = 5, paths = [[0,1,2,3,4],
                     [4,3,2,1,0]]
输出：1
解释：最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。
  提示：
1 <= n <= 105
m == paths.length
2 <= m <= 105
sum(paths[i].length) <= 105
0 <= paths[i][j] < n
paths[i] 中同一个城市不会连续重复出现。",33,,2003,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/suffix-array/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],7923
评论 (2),erect-the-fence-ii,Unknown,,-1,,-1,[],[],-1
评论 (51),count-square-sum-triples,简单,"一个 平方和三元组 (a,b,c) 指的是满足 a2 + b2 = c2 的 整数 三元组 a，b 和 c 。
给你一个整数 n ，请你返回满足 1 <= a, b, c <= n 的 平方和三元组 的数目。
  示例 1：
输入：n = 5
输出：2
解释：平方和三元组为 (3,4,5) 和 (4,3,5) 。
示例 2：
输入：n = 10
输出：4
解释：平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。
  提示：
1 <= n <= 250",11,,8075,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/']",[],11628
评论 (117),nearest-exit-from-entrance-in-maze,中等,"给你一个 m x n 的迷宫矩阵 maze （下标从 0 开始），矩阵中有空格子（用 '.' 表示）和墙（用 '+' 表示）。同时给你迷宫的入口 entrance ，用 entrance = [entrancerow, entrancecol] 表示你一开始所在格子的行和列。
每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 entrance 最近 的出口。出口 的含义是 maze 边界 上的 空格子。entrance 格子 不算 出口。
请你返回从 entrance 到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。
  示例 1：
输入：maze = [[""+"",""+"",""."",""+""],[""."",""."",""."",""+""],[""+"",""+"",""+"","".""]], entrance = [1,2]
输出：1
解释：总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。
一开始，你在入口格子 (1,2) 处。
- 你可以往左移动 2 步到达 (1,0) 。
- 你可以往上移动 1 步到达 (0,2) 。
从入口处没法到达 (2,3) 。
所以，最近的出口是 (0,2) ，距离为 1 步。
示例 2：
输入：maze = [[""+"",""+"",""+""],[""."",""."","".""],[""+"",""+"",""+""]], entrance = [1,0]
输出：2
解释：迷宫中只有 1 个出口，在 (1,2) 处。
(1,0) 不算出口，因为它是入口格子。
初始时，你在入口与格子 (1,0) 处。
- 你可以往右移动 2 步到达 (1,2) 处。
所以，最近的出口为 (1,2) ，距离为 2 步。
示例 3：
输入：maze = [[""."",""+""]], entrance = [0,0]
输出：-1
解释：这个迷宫中没有出口。
  提示：
maze.length == m
maze[i].length == n
1 <= m, n <= 100
maze[i][j] 要么是 '.' ，要么是 '+' 。
entrance.length == 2
0 <= entrancerow < m
0 <= entrancecol < n
entrance 一定是空格子。",19,https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg,6319,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],16614
评论 (34),sum-game,中等,"Alice 和 Bob 玩一个游戏，两人轮流行动，Alice 先手 。
给你一个 偶数长度 的字符串 num ，每一个字符为数字字符或者 '?' 。每一次操作中，如果 num 中至少有一个 '?' ，那么玩家可以执行以下操作：
选择一个下标 i 满足 num[i] == '?' 。
将 num[i] 用 '0' 到 '9' 之间的一个数字字符替代。
当 num 中没有 '?' 时，游戏结束。
Bob 获胜的条件是 num 中前一半数字的和 等于 后一半数字的和。Alice 获胜的条件是前一半的和与后一半的和 不相等 。
比方说，游戏结束时 num = ""243801"" ，那么 Bob 获胜，因为 2+4+3 = 8+0+1 。如果游戏结束时 num = ""243803"" ，那么 Alice 获胜，因为 2+4+3 != 8+0+3 。
在 Alice 和 Bob 都采取 最优 策略的前提下，如果 Alice 获胜，请返回 true ，如果 Bob 获胜，请返回 false 。
  示例 1：
输入：num = ""5023""
输出：false
解释：num 中没有 '?' ，没法进行任何操作。
前一半的和等于后一半的和：5 + 0 = 2 + 3 。
示例 2：
输入：num = ""25??""
输出：true
解释：Alice 可以将两个 '?' 中的一个替换为 '9' ，Bob 无论如何都无法使前一半的和等于后一半的和。
示例 3：
输入：num = ""?3295???""
输出：false
解释：Bob 总是能赢。一种可能的结果是：
- Alice 将第一个 '?' 用 '9' 替换。num = ""93295???"" 。
- Bob 将后面一半中的一个 '?' 替换为 '9' 。num = ""932959??"" 。
- Alice 将后面一半中的一个 '?' 替换为 '2' 。num = ""9329592?"" 。
- Bob 将后面一半中最后一个 '?' 替换为 '7' 。num = ""93295927"" 。
Bob 获胜，因为 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7 。
  提示：
2 <= num.length <= 105
num.length 是 偶数 。
num 只包含数字字符和 '?' 。",15,,2318,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/game-theory/']",[],5494
评论 (53),minimum-cost-to-reach-destination-in-time,困难,"一个国家有 n 个城市，城市编号为 0 到 n - 1 ，题目保证 所有城市 都由双向道路 连接在一起 。道路由二维整数数组 edges 表示，其中 edges[i] = [xi, yi, timei] 表示城市 xi 和 yi 之间有一条双向道路，耗费时间为 timei 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。
每次经过一个城市时，你需要付通行费。通行费用一个长度为 n 且下标从 0 开始的整数数组 passingFees 表示，其中 passingFees[j] 是你经过城市 j 需要支付的费用。
一开始，你在城市 0 ，你想要在 maxTime 分钟以内 （包含 maxTime 分钟）到达城市 n - 1 。旅行的 费用 为你经过的所有城市 通行费之和 （包括 起点和终点城市的通行费）。
给你 maxTime，edges 和 passingFees ，请你返回完成旅行的 最小费用 ，如果无法在 maxTime 分钟以内完成旅行，请你返回 -1 。
  示例 1：
输入：maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
输出：11
解释：最优路径为 0 -> 1 -> 2 -> 5 ，总共需要耗费 30 分钟，需要支付 11 的通行费。
示例 2：
输入：maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
输出：48
解释：最优路径为 0 -> 3 -> 4 -> 5 ，总共需要耗费 26 分钟，需要支付 48 的通行费。
你不能选择路径 0 -> 1 -> 2 -> 5 ，因为这条路径耗费的时间太长。
示例 3：
输入：maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
输出：-1
解释：无法在 25 分钟以内从城市 0 到达城市 5 。
  提示：
1 <= maxTime <= 1000
n == passingFees.length
2 <= n <= 1000
n - 1 <= edges.length <= 1000
0 <= xi, yi <= n - 1
1 <= timei <= 1000
1 <= passingFees[j] <= 1000 
图中两个节点之间可能有多条路径。
图中不含有自环。",35,,3440,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/dynamic-programming/']",[],8123
评论 (102),concatenation-of-array,简单,"给你一个长度为 n 的整数数组 nums 。请你构建一个长度为 2n 的答案数组 ans ，数组下标 从 0 开始计数 ，对于所有 0 <= i < n 的 i ，满足下述所有要求：
ans[i] == nums[i]
ans[i + n] == nums[i]
具体而言，ans 由两个 nums 数组 串联 形成。
返回数组 ans 。
  示例 1：
输入：nums = [1,2,1]
输出：[1,2,1,1,2,1]
解释：数组 ans 按下述方式形成：
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
示例 2：
输入：nums = [1,3,2,1]
输出：[1,3,2,1,1,3,2,1]
解释：数组 ans 按下述方式形成：
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
  提示：
n == nums.length
1 <= n <= 1000
1 <= nums[i] <= 1000",27,,26065,['https://leetcode.cn/tag/array/'],[],29875
评论 (83),unique-length-3-palindromic-subsequences,中等,"给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。
即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。
回文 是正着读和反着读一样的字符串。
子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。
例如，""ace"" 是 ""abcde"" 的一个子序列。
  示例 1：
输入：s = ""aabca""
输出：3
解释：长度为 3 的 3 个回文子序列分别是：
- ""aba"" (""aabca"" 的子序列)
- ""aaa"" (""aabca"" 的子序列)
- ""aca"" (""aabca"" 的子序列)
示例 2：
输入：s = ""adc""
输出：0
解释：""adc"" 不存在长度为 3 的回文子序列。
示例 3：
输入：s = ""bbcbaba""
输出：4
解释：长度为 3 的 4 个回文子序列分别是：
- ""bbb"" (""bbcbaba"" 的子序列)
- ""bcb"" (""bbcbaba"" 的子序列)
- ""bab"" (""bbcbaba"" 的子序列)
- ""aba"" (""bbcbaba"" 的子序列)
  提示：
3 <= s.length <= 105
s 仅由小写英文字母组成",17,,6472,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/prefix-sum/']",[],13162
评论 (69),painting-a-grid-with-three-different-colors,困难,"给你两个整数 m 和 n 。构造一个 m x n 的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。
涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 109 + 7 取余 的结果。
  示例 1：
输入：m = 1, n = 1
输出：3
解释：如上图所示，存在三种可能的涂色方案。
示例 2：
输入：m = 1, n = 2
输出：6
解释：如上图所示，存在六种可能的涂色方案。
示例 3：
输入：m = 5, n = 5
输出：580986
  提示：
1 <= m <= 5
1 <= n <= 1000",33,https://assets.leetcode.com/uploads/2021/06/22/colorthegrid.png,2464,['https://leetcode.cn/tag/dynamic-programming/'],[],4294
评论 (31),merge-bsts-to-create-single-bst,困难,"给你 n 个 二叉搜索树的根节点 ，存储在数组 trees 中（下标从 0 开始），对应 n 棵不同的二叉搜索树。trees 中的每棵二叉搜索树 最多有 3 个节点 ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：
选择两个 不同的 下标 i 和 j ，要求满足在 trees[i] 中的某个 叶节点 的值等于 trees[j] 的 根节点的值 。
用 trees[j] 替换 trees[i] 中的那个叶节点。
从 trees 中移除 trees[j] 。
如果在执行 n - 1 次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 根节点 ；如果无法构造一棵有效的二叉搜索树，返回 null 。
二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：
任意节点的左子树中的值都 严格小于 此节点的值。
任意节点的右子树中的值都 严格大于 此节点的值。
叶节点是不含子节点的节点。
  示例 1：
输入：trees = [[2,1],[3,2,5],[5,4]]
输出：[3,2,5,1,null,4]
解释：
第一步操作中，选出 i=1 和 j=0 ，并将 trees[0] 合并到 trees[1] 中。
删除 trees[0] ，trees = [[3,2,5,1],[5,4]] 。

在第二步操作中，选出 i=0 和 j=1 ，将 trees[1] 合并到 trees[0] 中。
删除 trees[1] ，trees = [[3,2,5,1,null,4]] 。

结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。
示例 2：
输入：trees = [[5,3,8],[3,2,6]]
输出：[]
解释：
选出 i=0 和 j=1 ，然后将 trees[1] 合并到 trees[0] 中。
删除 trees[1] ，trees = [[5,3,8,2,6]] 。

结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 null 。
示例 3：
输入：trees = [[5,4],[3]]
输出：[]
解释：无法执行任何操作。
  提示：
n == trees.length
1 <= n <= 5 * 104
每棵树中节点数目在范围 [1, 3] 内。
输入数据的每个节点可能有子节点但不存在子节点的子节点
trees 中不存在两棵树根节点值相同的情况。
输入中的所有树都是 有效的二叉树搜索树 。
1 <= TreeNode.val <= 5 * 104.",23,https://assets.leetcode.com/uploads/2021/06/08/d1.png,1549,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/binary-tree/']",[],4610
评论 (20),check-if-string-is-decomposable-into-value-equal-substrings,Unknown,,-1,,-1,[],[],-1
评论 (36),confirmation-rate,Unknown,,-1,,-1,[],[],-1
评论 (80),maximum-number-of-words-you-can-type,简单,"键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。
给你一个由若干单词组成的字符串 text ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 brokenLetters ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 text 中单词的数目。
  示例 1：
输入：text = ""hello world"", brokenLetters = ""ad""
输出：1
解释：无法输入 ""world"" ，因为字母键 'd' 已损坏。
示例 2：
输入：text = ""leet code"", brokenLetters = ""lt""
输出：1
解释：无法输入 ""leet"" ，因为字母键 'l' 和 't' 已损坏。
示例 3：
输入：text = ""leet code"", brokenLetters = ""e""
输出：0
解释：无法输入任何单词，因为字母键 'e' 已损坏。
  提示：
1 <= text.length <= 104
0 <= brokenLetters.length <= 26
text 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格
每个单词仅由小写英文字母组成
brokenLetters 由 互不相同 的小写英文字母组成",13,,9766,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],13615
评论 (52),add-minimum-number-of-rungs,中等,"给你一个 严格递增 的整数数组 rungs ，用于表示梯子上每一台阶的 高度 。当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。
另给你一个整数 dist 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过 dist 高度的台阶。当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。
返回爬到最后一阶时必须添加到梯子上的 最少 台阶数。
  示例 1：
输入：rungs = [1,3,5,10], dist = 2
输出：2
解释：
现在无法到达最后一阶。
在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 
梯子在高度为 [1,3,5,7,8,10] 的位置上有台阶。
示例 2：
输入：rungs = [3,6,8,10], dist = 3
输出：0
解释：
这个梯子无需增设新台阶也可以爬上去。
示例 3：
输入：rungs = [3,4,6,7], dist = 2
输出：1
解释：
现在无法从地板到达梯子的第一阶。 
在高度为 1 的位置增设新的台阶，以爬上梯子。 
梯子在高度为 [1,3,4,6,7] 的位置上有台阶。
示例 4：
输入：rungs = [5], dist = 10
输出：0
解释：这个梯子无需增设新台阶也可以爬上去。
  提示：
1 <= rungs.length <= 105
1 <= rungs[i] <= 109
1 <= dist <= 109
rungs 严格递增",9,,6786,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],14898
评论 (80),maximum-number-of-points-with-cost,中等,"给你一个 m x n 的整数矩阵 points （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。
你的得分方式为：每一行 中选取一个格子，选中坐标为 (r, c) 的格子会给你的总得分 增加 points[r][c] 。
然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 r 和 r + 1 （其中 0 <= r < m - 1），选中坐标为 (r, c1) 和 (r + 1, c2) 的格子，你的总得分 减少 abs(c1 - c2) 。
请你返回你能得到的 最大 得分。
abs(x) 定义为：
如果 x >= 0 ，那么值为 x 。
如果 x < 0 ，那么值为 -x 。
  示例 1：
输入：points = [[1,2,3],[1,5,1],[3,1,1]]
输出：9
解释：
蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。
你的总得分增加 3 + 5 + 3 = 11 。
但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。
你的最终得分为 11 - 2 = 9 。
示例 2：
输入：points = [[1,5],[2,3],[4,2]]
输出：11
解释：
蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。
你的总得分增加 5 + 3 + 4 = 12 。
但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。
你的最终得分为 12 - 1 = 11 。
  提示：
m == points.length
n == points[r].length
1 <= m, n <= 105
1 <= m * n <= 105
0 <= points[r][c] <= 105",71,https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png,3985,[],[],15065
评论 (35),maximum-genetic-difference-query,困难,"给你一棵 n 个节点的有根树，节点编号从 0 到 n - 1 。每个节点的编号表示这个节点的 独一无二的基因值 （也就是说节点 x 的基因值为 x）。两个基因值的 基因差 是两者的 异或和 。给你整数数组 parents ，其中 parents[i] 是节点 i 的父节点。如果节点 x 是树的 根 ，那么 parents[x] == -1 。
给你查询数组 queries ，其中 queries[i] = [nodei, vali] 。对于查询 i ，请你找到 vali 和 pi 的 最大基因差 ，其中 pi 是节点 nodei 到根之间的任意节点（包含 nodei 和根节点）。更正式的，你想要最大化 vali XOR pi 。
请你返回数组 ans ，其中 ans[i] 是第 i 个查询的答案。
  示例 1：
输入：parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
输出：[2,3,7]
解释：查询数组处理如下：
- [0,2]：最大基因差的对应节点为 0 ，基因差为 2 XOR 0 = 2 。
- [3,2]：最大基因差的对应节点为 1 ，基因差为 2 XOR 1 = 3 。
- [2,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。
示例 2：
输入：parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
输出：[6,14,7]
解释：查询数组处理如下：
- [4,6]：最大基因差的对应节点为 0 ，基因差为 6 XOR 0 = 6 。
- [1,15]：最大基因差的对应节点为 1 ，基因差为 15 XOR 1 = 14 。
- [0,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。
  提示：
2 <= parents.length <= 105
对于每个 不是 根节点的 i ，有 0 <= parents[i] <= parents.length - 1 。
parents[root] == -1
1 <= queries.length <= 3 * 104
0 <= nodei <= parents.length - 1
0 <= vali <= 2 * 105",37,https://assets.leetcode.com/uploads/2021/06/29/c1.png,1362,[],[],3714
评论 (47),users-that-actively-request-confirmation-messages,Unknown,,-1,,-1,[],[],-1
评论 (13),longest-common-subsequence-between-sorted-arrays,Unknown,,-1,,-1,[],[],-1
评论 (58),check-if-all-characters-have-equal-number-of-occurrences,简单,"给你一个字符串 s ，如果 s 是一个 好 字符串，请你返回 true ，否则请返回 false 。
如果 s 中出现过的 所有 字符的出现次数 相同 ，那么我们称字符串 s 是 好 字符串。
  示例 1：
输入：s = ""abacbc""
输出：true
解释：s 中出现过的字符为 'a'，'b' 和 'c' 。s 中所有字符均出现 2 次。
示例 2：
输入：s = ""aaabb""
输出：false
解释：s 中出现过的字符为 'a' 和 'b' 。
'a' 出现了 3 次，'b' 出现了 2 次，两者出现次数不同。
  提示：
1 <= s.length <= 1000
s 只包含小写英文字母。",11,,8278,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],11156
评论 (52),the-number-of-the-smallest-unoccupied-chair,中等,"有 n 个朋友在举办一个派对，这些朋友从 0 到 n - 1 编号。派对里有 无数 张椅子，编号为 0 到 infinity 。当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。
比方说，当一个朋友到达时，如果椅子 0 ，1 和 5 被占据了，那么他会占据 2 号椅子。
当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。
给你一个下标从 0 开始的二维整数数组 times ，其中 times[i] = [arrivali, leavingi] 表示第 i 个朋友到达和离开的时刻，同时给你一个整数 targetFriend 。所有到达时间 互不相同 。
请你返回编号为 targetFriend 的朋友占据的 椅子编号 。
  示例 1：
输入：times = [[1,4],[2,3],[4,6]], targetFriend = 1
输出：1
解释：
- 朋友 0 时刻 1 到达，占据椅子 0 。
- 朋友 1 时刻 2 到达，占据椅子 1 。
- 朋友 1 时刻 3 离开，椅子 1 变成未占据。
- 朋友 0 时刻 4 离开，椅子 0 变成未占据。
- 朋友 2 时刻 4 到达，占据椅子 0 。
朋友 1 占据椅子 1 ，所以返回 1 。
示例 2：
输入：times = [[3,10],[1,5],[2,6]], targetFriend = 0
输出：2
解释：
- 朋友 1 时刻 1 到达，占据椅子 0 。
- 朋友 2 时刻 2 到达，占据椅子 1 。
- 朋友 0 时刻 3 到达，占据椅子 2 。
- 朋友 1 时刻 5 离开，椅子 0 变成未占据。
- 朋友 2 时刻 6 离开，椅子 1 变成未占据。
- 朋友 0 时刻 10 离开，椅子 2 变成未占据。
朋友 0 占据椅子 2 ，所以返回 2 。
  提示：
n == times.length
2 <= n <= 104
times[i].length == 2
1 <= arrivali < leavingi <= 105
0 <= targetFriend <= n - 1
每个 arrivali 时刻 互不相同 。",23,,3779,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],9347
评论 (36),describe-the-painting,中等,"给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 独一无二 的颜色。给你二维整数数组 segments ，其中 segments[i] = [starti, endi, colori] 表示线段为 半开区间 [starti, endi) 且颜色为 colori 。
线段间重叠部分的颜色会被 混合 。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 集合 表示这个混合颜色。
比方说，如果颜色 2 ，4 和 6 被混合，那么结果颜色为 {2,4,6} 。
为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 和 来表示颜色集合。
你想要用 最少数目 不重叠 半开区间 来 表示 这幅混合颜色的画。这些线段可以用二维数组 painting 表示，其中 painting[j] = [leftj, rightj, mixj] 表示一个 半开区间[leftj, rightj) 的颜色 和 为 mixj 。
比方说，这幅画由 segments = [[1,4,5],[1,7,7]] 组成，那么它可以表示为 painting = [[1,4,12],[4,7,7]] ，因为：
[1,4) 由颜色 {5,7} 组成（和为 12），分别来自第一个线段和第二个线段。
[4,7) 由颜色 {7} 组成，来自第二个线段。
请你返回二维数组 painting ，它表示最终绘画的结果（没有 被涂色的部分不出现在结果中）。你可以按 任意顺序 返回最终数组的结果。
半开区间 [a, b) 是数轴上点 a 和点 b 之间的部分，包含 点 a 且 不包含 点 b 。
  示例 1：
输入：segments = [[1,4,5],[4,7,7],[1,7,9]]
输出：[[1,4,14],[4,7,16]]
解释：绘画借故偶可以表示为：
- [1,4) 颜色为 {5,9} （和为 14），分别来自第一和第二个线段。
- [4,7) 颜色为 {7,9} （和为 16），分别来自第二和第三个线段。
示例 2：
输入：segments = [[1,7,9],[6,8,15],[8,10,7]]
输出：[[1,6,9],[6,7,24],[7,8,15],[8,10,7]]
解释：绘画结果可以以表示为：
- [1,6) 颜色为 9 ，来自第一个线段。
- [6,7) 颜色为 {9,15} （和为 24），来自第一和第二个线段。
- [7,8) 颜色为 15 ，来自第二个线段。
- [8,10) 颜色为 7 ，来自第三个线段。
示例 3：
输入：segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]
输出：[[1,4,12],[4,7,12]]
解释：绘画结果可以表示为：
- [1,4) 颜色为 {5,7} （和为 12），分别来自第一和第二个线段。
- [4,7) 颜色为 {1,11} （和为 12），分别来自第三和第四个线段。
注意，只返回一个单独的线段 [1,7) 是不正确的，因为混合颜色的集合不相同。
  提示：
1 <= segments.length <= 2 * 104
segments[i].length == 3
1 <= starti < endi <= 105
1 <= colori <= 109
每种颜色 colori 互不相同。",16,https://assets.leetcode.com/uploads/2021/06/18/1.png,2439,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],5738
评论 (44),number-of-visible-people-in-a-queue,困难,"有 n 个人排成一个队列，从左到右 编号为 0 到 n - 1 。给你以一个整数数组 heights ，每个整数 互不相同，heights[i] 表示第 i 个人的高度。
一个人能 看到 他右边另一个人的条件是这两人之间的所有人都比他们两人 矮 。更正式的，第 i 个人能看到第 j 个人的条件是 i < j 且 min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]) 。
请你返回一个长度为 n 的数组 answer ，其中 answer[i] 是第 i 个人在他右侧队列中能 看到 的 人数 。
  示例 1：
输入：heights = [10,6,8,5,11,9]
输出：[3,1,2,1,1,0]
解释：
第 0 个人能看到编号为 1 ，2 和 4 的人。
第 1 个人能看到编号为 2 的人。
第 2 个人能看到编号为 3 和 4 的人。
第 3 个人能看到编号为 4 的人。
第 4 个人能看到编号为 5 的人。
第 5 个人谁也看不到因为他右边没人。
示例 2：
输入：heights = [5,1,2,3,10]
输出：[4,1,1,1,0]
  提示：
n == heights.length
1 <= n <= 105
1 <= heights[i] <= 105
heights 中所有数 互不相同 。",30,,3456,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/monotonic-stack/']",[],5691
评论 (61),sum-of-digits-of-string-after-convert,简单,"给你一个由小写字母组成的字符串 s ，以及一个整数 k 。
首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，'a' 用 1 替换，'b' 用 2 替换，... 'z' 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。
例如，如果 s = ""zbax"" 且 k = 2 ，那么执行下述步骤后得到的结果是整数 8 ：
转化：""zbax"" ➝ ""(26)(2)(1)(24)"" ➝ ""262124"" ➝ 262124
转换 #1：262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
转换 #2：17 ➝ 1 + 7 ➝ 8
返回执行上述操作后得到的结果整数。
  示例 1：
输入：s = ""iiii"", k = 1
输出：36
解释：操作如下：
- 转化：""iiii"" ➝ ""(9)(9)(9)(9)"" ➝ ""9999"" ➝ 9999
- 转换 #1：9999 ➝ 9 + 9 + 9 + 9 ➝ 36
因此，结果整数为 36 。
示例 2：
输入：s = ""leetcode"", k = 2
输出：6
解释：操作如下：
- 转化：""leetcode"" ➝ ""(12)(5)(5)(20)(3)(15)(4)(5)"" ➝ ""12552031545"" ➝ 12552031545
- 转换 #1：12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33
- 转换 #2：33 ➝ 3 + 3 ➝ 6
因此，结果整数为 6 。
  提示：
1 <= s.length <= 100
1 <= k <= 10
s 由小写英文字母组成",11,,8646,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],13237
评论 (47),largest-number-after-mutating-substring,中等,"给你一个字符串 num ，该字符串表示一个大整数。另给你一个长度为 10 且 下标从 0  开始 的整数数组 change ，该数组将 0-9 中的每个数字映射到另一个数字。更规范的说法是，数字 d 映射为数字 change[d] 。
你可以选择 突变  num 的任一子字符串。突变 子字符串意味着将每位数字 num[i] 替换为该数字在 change 中的映射（也就是说，将 num[i] 替换为 change[num[i]]）。
请你找出在对 num 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 最大整数 ，并用字符串表示返回。
子字符串 是字符串中的一个连续序列。
  示例 1：
输入：num = ""132"", change = [9,8,5,0,3,6,4,2,6,8]
输出：""832""
解释：替换子字符串 ""1""：
- 1 映射为 change[1] = 8 。
因此 ""132"" 变为 ""832"" 。
""832"" 是可以构造的最大整数，所以返回它的字符串表示。
示例 2：
输入：num = ""021"", change = [9,4,3,5,7,2,1,9,0,6]
输出：""934""
解释：替换子字符串 ""021""：
- 0 映射为 change[0] = 9 。
- 2 映射为 change[2] = 3 。
- 1 映射为 change[1] = 4 。
因此，""021"" 变为 ""934"" 。
""934"" 是可以构造的最大整数，所以返回它的字符串表示。 
示例 3：
输入：num = ""5"", change = [1,4,7,5,3,2,5,6,9,4]
输出：""5""
解释：""5"" 已经是可以构造的最大整数，所以返回它的字符串表示。
  提示：
1 <= num.length <= 105
num 仅由数字 0-9 组成
change.length == 10
0 <= change[d] <= 9",9,,6159,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],19716
评论 (59),maximum-compatibility-score-sum,中等,"有一份由 n 个问题组成的调查问卷，每个问题的答案要么是 0（no，否），要么是 1（yes，是）。
这份调查问卷被分发给 m 名学生和 m 名导师，学生和导师的编号都是从 0 到 m - 1 。学生的答案用一个二维整数数组 students 表示，其中 students[i] 是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。导师的答案用一个二维整数数组 mentors 表示，其中 mentors[j] 是一个整数数组，包含第 j 名导师对调查问卷给出的答案（下标从 0 开始）。
每个学生都会被分配给 一名 导师，而每位导师也会分配到 一名 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。
例如，学生答案为[1, 0, 1] 而导师答案为 [0, 0, 1] ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。
请你找出最优的学生与导师的配对方案，以 最大程度上 提高 兼容性评分和 。
给你 students 和 mentors ，返回可以得到的 最大兼容性评分和 。
  示例 1：
输入：students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]
输出：8
解释：按下述方式分配学生和导师：
- 学生 0 分配给导师 2 ，兼容性评分为 3 。
- 学生 1 分配给导师 0 ，兼容性评分为 2 。
- 学生 2 分配给导师 1 ，兼容性评分为 3 。
最大兼容性评分和为 3 + 2 + 3 = 8 。
示例 2：
输入：students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]
输出：0
解释：任意学生与导师配对的兼容性评分都是 0 。
  提示：
m == students.length == mentors.length
n == students[i].length == mentors[j].length
1 <= m, n <= 8
students[i][k] 为 0 或 1
mentors[j][k] 为 0 或 1",22,,5027,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",[],8985
评论 (19),delete-duplicate-folders-in-system,困难,"由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 paths，其中 paths[i] 是一个表示文件系统中第 i 个文件夹的绝对路径的数组。
例如，[""one"", ""two"", ""three""] 表示路径 ""/one/two/three"" 。
如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。
例如，下面文件结构中的文件夹 ""/a"" 和 ""/b"" 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除：
/a
/a/x
/a/x/y
/a/z
/b
/b/x
/b/x/y
/b/z
然而，如果文件结构中还包含路径 ""/b/w"" ，那么文件夹 ""/a"" 和 ""/b"" 就不相同。注意，即便添加了新的文件夹 ""/b/w"" ，仍然认为 ""/a/x"" 和 ""/b/x"" 相同。
一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 删除 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。
返回二维数组 ans ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 任意顺序 返回。
  示例 1：
输入：paths = [[""a""],[""c""],[""d""],[""a"",""b""],[""c"",""b""],[""d"",""a""]]
输出：[[""d""],[""d"",""a""]]
解释：文件结构如上所示。
文件夹 ""/a"" 和 ""/c""（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 ""b"" 的空文件夹。
示例 2：
输入：paths = [[""a""],[""c""],[""a"",""b""],[""c"",""b""],[""a"",""b"",""x""],[""a"",""b"",""x"",""y""],[""w""],[""w"",""y""]]
输出：[[""c""],[""c"",""b""],[""a""],[""a"",""b""]]
解释：文件结构如上所示。
文件夹 ""/a/b/x"" 和 ""/w""（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 ""y"" 的空文件夹。
注意，文件夹 ""/a"" 和 ""/c"" 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。
示例 3：
输入：paths = [[""a"",""b""],[""c"",""d""],[""c""],[""a""]]
输出：[[""c""],[""c"",""d""],[""a""],[""a"",""b""]]
解释：文件系统中所有文件夹互不相同。
注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。
示例 4：
输入：paths = [[""a""],[""a"",""x""],[""a"",""x"",""y""],[""a"",""z""],[""b""],[""b"",""x""],[""b"",""x"",""y""],[""b"",""z""]]
输出：[]
解释：文件结构如上所示。
文件夹 ""/a/x"" 和 ""/b/x""（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 ""y"" 的空文件夹。
文件夹 ""/a"" 和 ""/b""（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 ""z"" 的空文件夹以及上面提到的文件夹 ""x"" 。
示例 5：
输入：paths = [[""a""],[""a"",""x""],[""a"",""x"",""y""],[""a"",""z""],[""b""],[""b"",""x""],[""b"",""x"",""y""],[""b"",""z""],[""b"",""w""]]
输出：[[""b""],[""b"",""w""],[""b"",""z""],[""a""],[""a"",""z""]]
解释：本例与上例的结构基本相同，除了新增 ""/b/w"" 文件夹。
文件夹 ""/a/x"" 和 ""/b/x"" 仍然会被标记，但 ""/a"" 和 ""/b"" 不再被标记，因为 ""/b"" 中有名为 ""w"" 的空文件夹而 ""/a"" 没有。
注意，""/a/z"" 和 ""/b/z"" 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。
  提示：
1 <= paths.length <= 2 * 104
1 <= paths[i].length <= 500
1 <= paths[i][j].length <= 10
1 <= sum(paths[i][j].length) <= 2 * 105
path[i][j] 由小写英文字母组成
不会存在两个路径都指向同一个文件夹的情况
对于不在根层级的任意文件夹，其父文件夹也会包含在输入中",23,https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg,1203,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/hash-function/']",[],2361
评论 (48),strong-friendship,Unknown,,-1,,-1,[],[],-1
评论 (7),maximum-of-minimum-values-in-all-subarrays,Unknown,,-1,,-1,[],[],-1
评论 (47),all-the-pairs-with-the-maximum-number-of-common-followers,Unknown,,-1,,-1,[],[],-1
评论 (70),three-divisors,简单,"给你一个整数 n 。如果 n 恰好有三个正除数 ，返回 true ；否则，返回 false 。
如果存在整数 k ，满足 n = k * m ，那么整数 m 就是 n 的一个 除数 。
  示例 1：
输入：n = 2
输出：false
解释：2 只有两个除数：1 和 2 。
示例 2：
输入：n = 4
输出：true
解释：4 有三个除数：1、2 和 4 。
  提示：
1 <= n <= 104",17,,9553,['https://leetcode.cn/tag/math/'],[],17513
评论 (106),maximum-number-of-weeks-for-which-you-can-work,中等,"给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。
你可以按下面两个规则参与项目中的工作：
每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。
在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。
一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。
返回在不违反上面规则的情况下你 最多 能工作多少周。
  示例 1：
输入：milestones = [1,2,3]
输出：6
解释：一种可能的情形是：
- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
- 第 2 周，你参与并完成项目 2 中的一个阶段任务。
- 第 3 周，你参与并完成项目 1 中的一个阶段任务。
- 第 4 周，你参与并完成项目 2 中的一个阶段任务。
- 第 5 周，你参与并完成项目 1 中的一个阶段任务。
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。
总周数是 6 。
示例 2：
输入：milestones = [5,2,1]
输出：7
解释：一种可能的情形是：
- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
- 第 2 周，你参与并完成项目 1 中的一个阶段任务。
- 第 3 周，你参与并完成项目 0 中的一个阶段任务。
- 第 4 周，你参与并完成项目 1 中的一个阶段任务。
- 第 5 周，你参与并完成项目 0 中的一个阶段任务。
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。
- 第 7 周，你参与并完成项目 0 中的一个阶段任务。
总周数是 7 。
注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。
因此，项目 0 中会有一个阶段任务维持未完成状态。
  提示：
n == milestones.length
1 <= n <= 105
1 <= milestones[i] <= 109",33,,5113,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],14808
评论 (50),minimum-garden-perimeter-to-collect-enough-apples,中等,"给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 |i| + |j| 个苹果。
你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。
给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。
|x| 的值定义为：
如果 x >= 0 ，那么值为 x
如果 x < 0 ，那么值为 -x
  示例 1：
输入：neededApples = 1
输出：8
解释：边长长度为 1 的正方形不包含任何苹果。
但是边长为 2 的正方形包含 12 个苹果（如上图所示）。
周长为 2 * 4 = 8 。
示例 2：
输入：neededApples = 13
输出：16
示例 3：
输入：neededApples = 1000000000
输出：5040
  提示：
1 <= neededApples <= 1015",17,https://pic.leetcode-cn.com/1627790803-qcBKFw-image.png,5010,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],10271
评论 (30),count-number-of-special-subsequences,困难,"特殊序列 是由 正整数 个 0 ，紧接着 正整数 个 1 ，最后 正整数 个 2 组成的序列。
比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。
相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。
给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。
一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。
  示例 1：
输入：nums = [0,1,2,2]
输出：3
解释：特殊子序列为 [0,1,2,2]，[0,1,2,2] 和 [0,1,2,2] 。
示例 2：
输入：nums = [2,2,0,0]
输出：0
解释：数组 [2,2,0,0] 中没有特殊子序列。
示例 3：
输入：nums = [0,1,2,0,1,2]
输出：7
解释：特殊子序列包括：
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 2",21,,3093,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],6032
评论 (7),minimum-time-for-k-virus-variants-to-spread,Unknown,,-1,,-1,[],[],-1
评论 (54),delete-characters-to-make-fancy-string,简单,"一个字符串如果没有 三个连续 相同字符，那么它就是一个 好字符串 。
给你一个字符串 s ，请你从 s 删除 最少 的字符，使它变成一个 好字符串 。
请你返回删除后的字符串。题目数据保证答案总是 唯一的 。
  示例 1：
输入：s = ""leeetcode""
输出：""leetcode""
解释：
从第一组 'e' 里面删除一个 'e' ，得到 ""leetcode"" 。
没有连续三个相同字符，所以返回 ""leetcode"" 。
示例 2：
输入：s = ""aaabaaaa""
输出：""aabaa""
解释：
从第一组 'a' 里面删除一个 'a' ，得到 ""aabaaaa"" 。
从第二组 'a' 里面删除两个 'a' ，得到 ""aabaa"" 。
没有连续三个相同字符，所以返回 ""aabaa"" 。
示例 3：
输入：s = ""aab""
输出：""aab""
解释：没有连续三个相同字符，所以返回 ""aab"" 。
  提示：
1 <= s.length <= 105
s 只包含小写英文字母。",17,,7087,['https://leetcode.cn/tag/string/'],[],11707
评论 (52),check-if-move-is-legal,中等,"给你一个下标从 0 开始的 8 x 8 网格 board ，其中 board[r][c] 表示游戏棋盘上的格子 (r, c) 。棋盘上空格用 '.' 表示，白色格子用 'W' 表示，黑色格子用 'B' 表示。
游戏中每次操作步骤为：选择一个空格子，将它变成你正在执行的颜色（要么白色，要么黑色）。但是，合法 操作必须满足：涂色后这个格子是 好线段的一个端点 （好线段可以是水平的，竖直的或者是对角线）。
好线段 指的是一个包含 三个或者更多格子（包含端点格子）的线段，线段两个端点格子为 同一种颜色 ，且中间剩余格子的颜色都为 另一种颜色 （线段上不能有任何空格子）。你可以在下图找到好线段的例子：
给你两个整数 rMove 和 cMove 以及一个字符 color ，表示你正在执行操作的颜色（白或者黑），如果将格子 (rMove, cMove) 变成颜色 color 后，是一个 合法 操作，那么返回 true ，如果不是合法操作返回 false 。
  示例 1：
输入：board = [[""."",""."",""."",""B"",""."",""."",""."","".""],[""."",""."",""."",""W"",""."",""."",""."","".""],[""."",""."",""."",""W"",""."",""."",""."","".""],[""."",""."",""."",""W"",""."",""."",""."","".""],[""W"",""B"",""B"",""."",""W"",""W"",""W"",""B""],[""."",""."",""."",""B"",""."",""."",""."","".""],[""."",""."",""."",""B"",""."",""."",""."","".""],[""."",""."",""."",""W"",""."",""."",""."","".""]], rMove = 4, cMove = 3, color = ""B""
输出：true
解释：'.'，'W' 和 'B' 分别用颜色蓝色，白色和黑色表示。格子 (rMove, cMove) 用 'X' 标记。
以选中格子为端点的两个好线段在上图中用红色矩形标注出来了。
示例 2：
输入：board = [[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""B"",""."",""."",""W"",""."",""."","".""],[""."",""."",""W"",""."",""."",""."",""."","".""],[""."",""."",""."",""W"",""B"",""."",""."","".""],[""."",""."",""."",""."",""."",""."",""."","".""],[""."",""."",""."",""."",""B"",""W"",""."","".""],[""."",""."",""."",""."",""."",""."",""W"","".""],[""."",""."",""."",""."",""."",""."",""."",""B""]], rMove = 4, cMove = 4, color = ""W""
输出：false
解释：虽然选中格子涂色后，棋盘上产生了好线段，但选中格子是作为中间格子，没有产生以选中格子为端点的好线段。
  提示：
board.length == board[r].length == 8
0 <= rMove, cMove < 8
board[rMove][cMove] == '.'
color 要么是 'B' 要么是 'W' 。",9,https://assets.leetcode.com/uploads/2021/07/22/goodlines5.png,2947,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/enumeration/', 'https://leetcode.cn/tag/matrix/']",[],6839
评论 (29),minimum-total-space-wasted-with-k-resizing-operations,中等,"你正在设计一个动态数组。给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 i 时刻数组中的元素数目。除此以外，你还有一个整数 k ，表示你可以 调整 数组大小的 最多 次数（每次都可以调整成 任意 大小）。
t 时刻数组的大小 sizet 必须大于等于 nums[t] ，因为数组需要有足够的空间容纳所有元素。t 时刻 浪费的空间 为 sizet - nums[t] ，总 浪费空间为满足 0 <= t < nums.length 的每一个时刻 t 浪费的空间 之和 。
在调整数组大小不超过 k 次的前提下，请你返回 最小总浪费空间 。
注意：数组最开始时可以为 任意大小 ，且 不计入 调整大小的操作次数。
  示例 1：
输入：nums = [10,20], k = 0
输出：10
解释：size = [20,20].
我们可以让数组初始大小为 20 。
总浪费空间为 (20 - 10) + (20 - 20) = 10 。
示例 2：
输入：nums = [10,20,30], k = 1
输出：10
解释：size = [20,20,30].
我们可以让数组初始大小为 20 ，然后时刻 2 调整大小为 30 。
总浪费空间为 (20 - 10) + (20 - 20) + (30 - 30) = 10 。
示例 3：
输入：nums = [10,20,15,30,20], k = 2
输出：15
解释：size = [10,20,20,30,30].
我们可以让数组初始大小为 10 ，时刻 1 调整大小为 20 ，时刻 3 调整大小为 30 。
总浪费空间为 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15 。
  提示：
1 <= nums.length <= 200
1 <= nums[i] <= 106
0 <= k <= nums.length - 1",28,,1890,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],4357
评论 (21),maximum-product-of-the-length-of-two-palindromic-substrings,困难,"给你一个下标从 0 开始的字符串 s ，你需要找到两个 不重叠的回文 子字符串，它们的长度都必须为 奇数 ，使得它们长度的乘积最大。
更正式地，你想要选择四个整数 i ，j ，k ，l ，使得 0 <= i <= j < k <= l < s.length ，且子字符串 s[i...j] 和 s[k...l] 都是回文串且长度为奇数。s[i...j] 表示下标从 i 到 j 且 包含 两端下标的子字符串。
请你返回两个不重叠回文子字符串长度的 最大 乘积。
回文字符串 指的是一个从前往后读和从后往前读一模一样的字符串。子字符串 指的是一个字符串中一段连续字符。
  示例 1：
输入：s = ""ababbb""
输出：9
解释：子字符串 ""aba"" 和 ""bbb"" 为奇数长度的回文串。乘积为 3 * 3 = 9 。
示例 2：
输入：s = ""zaaaxbbby""
输出：9
解释：子字符串 ""aaa"" 和 ""bbb"" 为奇数长度的回文串。乘积为 3 * 3 = 9 。
  提示：
2 <= s.length <= 105
s 只包含小写英文字母。",18,,862,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],2853
评论 (60),check-if-string-is-a-prefix-of-array,简单,"给你一个字符串 s 和一个字符串数组 words ，请你判断 s 是否为 words 的 前缀字符串 。
字符串 s 要成为 words 的 前缀字符串 ，需要满足：s 可以由 words 中的前 k（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 words.length 。
如果 s 是 words 的 前缀字符串 ，返回 true ；否则，返回 false 。
  示例 1：
输入：s = ""iloveleetcode"", words = [""i"",""love"",""leetcode"",""apples""]
输出：true
解释：
s 可以由 ""i""、""love"" 和 ""leetcode"" 相连得到。
示例 2：
输入：s = ""iloveleetcode"", words = [""apples"",""i"",""love"",""leetcode""]
输出：false
解释：
数组的前缀相连无法得到 s 。
  提示：
1 <= words.length <= 100
1 <= words[i].length <= 20
1 <= s.length <= 1000
words[i] 和 s 仅由小写英文字母组成",9,,9310,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],17434
评论 (59),remove-stones-to-minimize-the-total,中等,"给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次：
选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] / 2) 颗石子。
注意：你可以对 同一堆 石子多次执行此操作。
返回执行 k 次操作后，剩下石子的 最小 总数。
floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。
  示例 1：
输入：piles = [5,4,9], k = 2
输出：12
解释：可能的执行情景如下：
- 对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,5] 。
- 对第 0 堆石子执行移除操作，石子分布情况变成 [3,4,5] 。
剩下石子的总数为 12 。
示例 2：
输入：piles = [4,3,6,7], k = 3
输出：12
解释：可能的执行情景如下：
- 对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,3,7] 。
- 对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,4] 。
- 对第 0 堆石子执行移除操作，石子分布情况变成 [2,3,3,4] 。
剩下石子的总数为 12 。
  提示：
1 <= piles.length <= 105
1 <= piles[i] <= 104
1 <= k <= 105",13,,6820,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],15111
评论 (66),minimum-number-of-swaps-to-make-the-string-balanced,中等,"给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。
只有能满足下述所有条件的字符串才能称为 平衡字符串 ：
字符串是一个空字符串，或者
字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者
字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。
你可以交换 任意 两个下标所对应的括号 任意 次数。
返回使 s 变成 平衡字符串 所需要的 最小 交换次数。
  示例 1：
输入：s = ""][][""
输出：1
解释：交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。
最终字符串变成 ""[[]]"" 。
示例 2：
输入：s = ""]]][[[""
输出：2
解释：执行下述操作可以使字符串变成平衡字符串：
- 交换下标 0 和下标 4 对应的括号，s = ""[]][]["" 。
- 交换下标 1 和下标 5 对应的括号，s = ""[[][]]"" 。
最终字符串变成 ""[[][]]"" 。
示例 3：
输入：s = ""[]""
输出：0
解释：这个字符串已经是平衡字符串。
  提示：
n == s.length
2 <= n <= 106
n 为偶数
s[i] 为'[' 或 ']'
开括号 '[' 的数目为 n / 2 ，闭括号 ']' 的数目也是 n / 2",29,,5534,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],8779
评论 (57),find-the-longest-valid-obstacle-course-at-each-position,困难,"你打算构建一些障碍赛跑路线。给你一个 下标从 0 开始 的整数数组 obstacles ，数组长度为 n ，其中 obstacles[i] 表示第 i 个障碍的高度。
对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标  i ，在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度：
你可以选择下标介于 0 到 i 之间（包含 0 和 i）的任意个障碍。
在这条路线中，必须包含第 i 个障碍。
你必须按障碍在 obstacles 中的 出现顺序 布置这些障碍。
除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。
返回长度为 n 的答案数组 ans ，其中 ans[i] 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。
  示例 1：
输入：obstacles = [1,2,3,2]
输出：[1,2,3,3]
解释：每个位置的最长有效障碍路线是：
- i = 0: [1], [1] 长度为 1
- i = 1: [1,2], [1,2] 长度为 2
- i = 2: [1,2,3], [1,2,3] 长度为 3
- i = 3: [1,2,3,2], [1,2,2] 长度为 3
示例 2：
输入：obstacles = [2,2,1]
输出：[1,2,1]
解释：每个位置的最长有效障碍路线是：
- i = 0: [2], [2] 长度为 1
- i = 1: [2,2], [2,2] 长度为 2
- i = 2: [2,2,1], [1] 长度为 1
示例 3：
输入：obstacles = [3,1,5,6,4,2]
输出：[1,1,2,3,2,2]
解释：每个位置的最长有效障碍路线是：
- i = 0: [3], [3] 长度为 1
- i = 1: [3,1], [1] 长度为 1
- i = 2: [3,1,5], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线
- i = 3: [3,1,5,6], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线
- i = 4: [3,1,5,6,4], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线
- i = 5: [3,1,5,6,4,2], [1,2] 长度为 2
  提示：
n == obstacles.length
1 <= n <= 105
1 <= obstacles[i] <= 107",25,,3733,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],9303
评论 (87),employees-with-missing-information,简单,"SQL架构
表: Employees
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| employee_id | int     |
| name        | varchar |
+-------------+---------+
employee_id 是这个表的主键。
每一行表示雇员的id 和他的姓名。
表: Salaries
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| employee_id | int     |
| salary      | int     |
+-------------+---------+
employee_id is 这个表的主键。
每一行表示雇员的id 和他的薪水。
  写出一个查询语句，找到所有 丢失信息 的雇员id。当满足下面一个条件时，就被认为是雇员的信息丢失：
雇员的 姓名 丢失了，或者
雇员的 薪水信息 丢失了，或者
返回这些雇员的id  employee_id ， 从小到大排序 。
查询结果格式如下面的例子所示。
  示例 1：
输入：
Employees table:
+-------------+----------+
| employee_id | name     |
+-------------+----------+
| 2           | Crew     |
| 4           | Haven    |
| 5           | Kristian |
+-------------+----------+
Salaries table:
+-------------+--------+
| employee_id | salary |
+-------------+--------+
| 5           | 76071  |
| 1           | 22517  |
| 4           | 63539  |
+-------------+--------+
输出：
+-------------+
| employee_id |
+-------------+
| 1           |
| 2           |
+-------------+
解释：
雇员1，2，4，5 都工作在这个公司。
1号雇员的姓名丢失了。
2号雇员的薪水信息丢失了。",22,,9768,['https://leetcode.cn/tag/database/'],[],13340
评论 (3),binary-searchable-numbers-in-an-unsorted-array,Unknown,,-1,,-1,[],[],-1
评论 (59),number-of-strings-that-appear-as-substrings-in-word,简单,"给你一个字符串数组 patterns 和一个字符串 word ，统计 patterns 中有多少个字符串是 word 的子字符串。返回字符串数目。
子字符串 是字符串中的一个连续字符序列。
  示例 1：
输入：patterns = [""a"",""abc"",""bc"",""d""], word = ""abc""
输出：3
解释：
- ""a"" 是 ""abc"" 的子字符串。
- ""abc"" 是 ""abc"" 的子字符串。
- ""bc"" 是 ""abc"" 的子字符串。
- ""d"" 不是 ""abc"" 的子字符串。
patterns 中有 3 个字符串作为子字符串出现在 word 中。
示例 2：
输入：patterns = [""a"",""b"",""c""], word = ""aaaaabbbbb""
输出：2
解释：
- ""a"" 是 ""aaaaabbbbb"" 的子字符串。
- ""b"" 是 ""aaaaabbbbb"" 的子字符串。
- ""c"" 不是 ""aaaaabbbbb"" 的字符串。
patterns 中有 2 个字符串作为子字符串出现在 word 中。
示例 3：
输入：patterns = [""a"",""a"",""a""], word = ""ab""
输出：3
解释：patterns 中的每个字符串都作为子字符串出现在 word ""ab"" 中。
  提示：
1 <= patterns.length <= 100
1 <= patterns[i].length <= 100
1 <= word.length <= 100
patterns[i] 和 word 由小写英文字母组成",5,,8600,['https://leetcode.cn/tag/string/'],[],10896
评论 (66),array-with-elements-not-equal-to-average-of-neighbors,中等,"给你一个 下标从 0 开始 的数组 nums ，数组由若干 互不相同的 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 不等于 其两侧相邻元素的 平均值 。
更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 1 <= i < nums.length - 1 中的每个 i ，(nums[i-1] + nums[i+1]) / 2 不等于 nums[i] 均成立 。
返回满足题意的任一重排结果。
  示例 1：
输入：nums = [1,2,3,4,5]
输出：[1,2,4,5,3]
解释：
i=1, nums[i] = 2, 两相邻元素平均值为 (1+4) / 2 = 2.5
i=2, nums[i] = 4, 两相邻元素平均值为 (2+5) / 2 = 3.5
i=3, nums[i] = 5, 两相邻元素平均值为 (4+3) / 2 = 3.5
示例 2：
输入：nums = [6,2,0,9,7]
输出：[9,7,6,2,0]
解释：
i=1, nums[i] = 7, 两相邻元素平均值为 (9+6) / 2 = 7.5
i=2, nums[i] = 6, 两相邻元素平均值为 (7+2) / 2 = 4.5
i=3, nums[i] = 2, 两相邻元素平均值为 (6+0) / 2 = 3
  提示：
3 <= nums.length <= 105
0 <= nums[i] <= 105",17,,5416,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],14439
评论 (61),minimum-non-zero-product-of-the-array-elements,中等,"给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：
从 nums 中选择两个元素 x 和 y  。
选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。
比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。
请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 109 + 7 取余 后返回。
注意：答案应为取余 之前 的最小值。
  示例 1：
输入：p = 1
输出：1
解释：nums = [1] 。
只有一个元素，所以乘积为该元素。
示例 2：
输入：p = 2
输出：6
解释：nums = [01, 10, 11] 。
所有交换要么使乘积变为 0 ，要么乘积与初始乘积相同。
所以，数组乘积 1 * 2 * 3 = 6 已经是最小值。
示例 3：
输入：p = 3
输出：1512
解释：nums = [001, 010, 011, 100, 101, 110, 111]
- 第一次操作中，我们交换第二个和第五个元素最左边的数位。
    - 结果数组为 [001, 110, 011, 100, 001, 110, 111] 。
- 第二次操作中，我们交换第三个和第四个元素中间的数位。
    - 结果数组为 [001, 110, 001, 110, 001, 110, 111] 。
数组乘积 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 是最小乘积。
  提示：
1 <= p <= 60",17,,3337,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']",[],11491
评论 (39),last-day-where-you-can-still-cross,困难,"给你一个下标从 1 开始的二进制矩阵，其中 0 表示陆地，1 表示水域。同时给你 row 和 col 分别表示矩阵中行和列的数目。
一开始在第 0 天，整个 矩阵都是 陆地 。但每一天都会有一块新陆地被 水 淹没变成水域。给你一个下标从 1 开始的二维数组 cells ，其中 cells[i] = [ri, ci] 表示在第 i 天，第 ri 行 ci 列（下标都是从 1 开始）的陆地会变成 水域 （也就是 0 变成 1 ）。
你想知道从矩阵最 上面 一行走到最 下面 一行，且只经过陆地格子的 最后一天 是哪一天。你可以从最上面一行的 任意 格子出发，到达最下面一行的 任意 格子。你只能沿着 四个 基本方向移动（也就是上下左右）。
请返回只经过陆地格子能从最 上面 一行走到最 下面 一行的 最后一天 。
  示例 1：
输入：row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
输出：2
解释：上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 2 天。
示例 2：
输入：row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
输出：1
解释：上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 1 天。
示例 3：
输入：row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
输出：3
解释：上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 3 天。
  提示：
2 <= row, col <= 2 * 104
4 <= row * col <= 2 * 104
cells.length == row * col
1 <= ri <= row
1 <= ci <= col
cells 中的所有格子坐标都是 唯一 的。",33,https://assets.leetcode.com/uploads/2021/07/27/1.png,2731,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/']",[],5598
评论 (58),find-if-path-exists-in-graph,简单,"有一个具有 n个顶点的 双向 图，其中每个顶点标记从 0 到 n - 1（包含 0 和 n - 1）。图中的边用一个二维整数数组 edges 表示，其中 edges[i] = [ui, vi] 表示顶点 ui 和顶点 vi 之间的双向边。 每个顶点对由 最多一条 边连接，并且没有顶点存在与自身相连的边。
请你确定是否存在从顶点 start 开始，到顶点 end 结束的 有效路径 。
给你数组 edges 和整数 n、start和end，如果从 start 到 end 存在 有效路径 ，则返回 true，否则返回 false 。
  示例 1：
输入：n = 3, edges = [[0,1],[1,2],[2,0]], start = 0, end = 2
输出：true
解释：存在由顶点 0 到顶点 2 的路径:
- 0 → 1 → 2 
- 0 → 2
示例 2：
输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], start = 0, end = 5
输出：false
解释：不存在由顶点 0 到顶点 5 的路径.
  提示:
1 <= n <= 2 * 105
0 <= edges.length <= 2 * 105
edges[i].length == 2
0 <= ui, vi <= n - 1
ui != vi
0 <= start, end <= n - 1
不存在双向边
不存在指向顶点自身的边",34,https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png,4002,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/']",[],9054
评论 (36),first-and-last-call-on-the-same-day,Unknown,,-1,,-1,[],[],-1
评论 (11),count-nodes-equal-to-sum-of-descendants,Unknown,,-1,,-1,[],[],-1
评论 (57),minimum-time-to-type-word-using-special-typewriter,简单,"有一个特殊打字机，它由一个 圆盘 和一个 指针 组成， 圆盘上标有小写英文字母 'a' 到 'z'。只有 当指针指向某个字母时，它才能被键入。指针 初始时 指向字符 'a' 。
每一秒钟，你可以执行以下操作之一：
将指针 顺时针 或者 逆时针 移动一个字符。
键入指针 当前 指向的字符。
给你一个字符串 word ，请你返回键入 word 所表示单词的 最少 秒数 。
  示例 1：
输入：word = ""abc""
输出：5
解释：
单词按如下操作键入：
- 花 1 秒键入字符 'a' in 1 ，因为指针初始指向 'a' ，故不需移动指针。
- 花 1 秒将指针顺时针移到 'b' 。
- 花 1 秒键入字符 'b' 。
- 花 1 秒将指针顺时针移到 'c' 。
- 花 1 秒键入字符 'c' 。
示例 2：
输入：word = ""bza""
输出：7
解释：
单词按如下操作键入：
- 花 1 秒将指针顺时针移到 'b' 。
- 花 1 秒键入字符 'b' 。
- 花 2 秒将指针逆时针移到 'z' 。
- 花 1 秒键入字符 'z' 。
- 花 1 秒将指针顺时针移到 'a' 。
- 花 1 秒键入字符 'a' 。
示例 3：
输入：word = ""zjpc""
输出：34
解释：
单词按如下操作键入：
- 花 1 秒将指针逆时针移到 'z' 。
- 花 1 秒键入字符 'z' 。
- 花 10 秒将指针顺时针移到 'j' 。
- 花 1 秒键入字符 'j' 。
- 花 6 秒将指针顺时针移到 'p' 。
- 花 1 秒键入字符 'p' 。
- 花 13 秒将指针逆时针移到 'c' 。
- 花 1 秒键入字符 'c' 。
  提示：
1 <= word.length <= 100
word 只包含小写英文字母。",10,https://assets.leetcode.com/uploads/2021/07/31/chart.jpg,6302,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],8706
评论 (28),maximum-matrix-sum,中等,"给你一个 n x n 的整数方阵 matrix 。你可以执行以下操作 任意次 ：
选择 matrix 中 相邻 两个元素，并将它们都 乘以 -1 。
如果两个元素有 公共边 ，那么它们就是 相邻 的。
你的目的是 最大化 方阵元素的和。请你在执行以上操作之后，返回方阵的 最大 和。
  示例 1：
输入：matrix = [[1,-1],[-1,1]]
输出：4
解释：我们可以执行以下操作使和等于 4 ：
- 将第一行的 2 个元素乘以 -1 。
- 将第一列的 2 个元素乘以 -1 。
示例 2：
输入：matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
输出：16
解释：我们可以执行以下操作使和等于 16 ：
- 将第二行的最后 2 个元素乘以 -1 。
  提示：
n == matrix.length == matrix[i].length
2 <= n <= 250
-105 <= matrix[i][j] <= 105",11,https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex1.png,3857,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],9643
评论 (52),number-of-ways-to-arrive-at-destination,中等,"你在一个城市里，城市由 n 个路口组成，路口编号为 0 到 n - 1 ，某些路口之间有 双向 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。
给你一个整数 n 和二维整数数组 roads ，其中 roads[i] = [ui, vi, timei] 表示在路口 ui 和 vi 之间有一条需要花费 timei 时间才能通过的道路。你想知道花费 最少时间 从路口 0 出发到达路口 n - 1 的方案数。
请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 109 + 7 取余 后返回。
  示例 1：
输入：n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
输出：4
解释：从路口 0 出发到路口 6 花费的最少时间是 7 分钟。
四条花费 7 分钟的路径分别为：
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6
示例 2：
输入：n = 2, roads = [[1,0,10]]
输出：1
解释：只有一条从路口 0 到路口 1 的路，花费 10 分钟。
  提示：
1 <= n <= 200
n - 1 <= roads.length <= n * (n - 1) / 2
roads[i].length == 3
0 <= ui, vi <= n - 1
1 <= timei <= 109
ui != vi
任意两个路口之间至多有一条路。
从任意路口出发，你能够到达其他任意路口。",32,https://assets.leetcode.com/uploads/2021/07/17/graph2.png,3360,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/shortest-path/']",[],10473
评论 (39),number-of-ways-to-separate-numbers,困难,"你写下了若干 正整数 ，并将它们连接成了一个字符串 num 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 0 。
请你返回有多少种可能的 正整数数组 可以得到字符串 num 。由于答案可能很大，将结果对 109 + 7 取余 后返回。
  示例 1：
输入：num = ""327""
输出：2
解释：以下为可能的方案：
3, 27
327
示例 2：
输入：num = ""094""
输出：0
解释：不能有数字有前导 0 ，且所有数字均为正数。
示例 3：
输入：num = ""0""
输出：0
解释：不能有数字有前导 0 ，且所有数字均为正数。
示例 4：
输入：num = ""9999999999999""
输出：101
  提示：
1 <= num.length <= 3500
num 只含有数字 '0' 到 '9' 。",25,,1069,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/suffix-array/']",[],3905
评论 (31),employees-whose-manager-left-the-company,Unknown,,-1,,-1,[],[],-1
评论 (77),find-greatest-common-divisor-of-array,简单,"给你一个整数数组 nums ，返回数组中最大数和最小数的 最大公约数 。
两个数的 最大公约数 是能够被两个数整除的最大正整数。
  示例 1：
输入：nums = [2,5,6,9,10]
输出：2
解释：
nums 中最小的数是 2
nums 中最大的数是 10
2 和 10 的最大公约数是 2
示例 2：
输入：nums = [7,5,6,8,3]
输出：1
解释：
nums 中最小的数是 3
nums 中最大的数是 8
3 和 8 的最大公约数是 1
示例 3：
输入：nums = [3,3]
输出：3
解释：
nums 中最小的数是 3
nums 中最大的数是 3
3 和 3 的最大公约数是 3
  提示：
2 <= nums.length <= 1000
1 <= nums[i] <= 1000",19,,13146,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/number-theory/']",[],16824
评论 (63),find-unique-binary-string,中等,"给你一个字符串数组 nums ，该数组由 n 个 互不相同 的二进制字符串组成，且每个字符串长度都是 n 。请你找出并返回一个长度为 n 且 没有出现 在 nums 中的二进制字符串。如果存在多种答案，只需返回 任意一个 即可。
  示例 1：
输入：nums = [""01"",""10""]
输出：""11""
解释：""11"" 没有出现在 nums 中。""00"" 也是正确答案。
示例 2：
输入：nums = [""00"",""01""]
输出：""11""
解释：""11"" 没有出现在 nums 中。""10"" 也是正确答案。
示例 3：
输入：nums = [""111"",""011"",""001""]
输出：""101""
解释：""101"" 没有出现在 nums 中。""000""、""010""、""100""、""110"" 也是正确答案。
  提示：
n == nums.length
1 <= n <= 16
nums[i].length == n
nums[i] 为 '0' 或 '1'
nums 中的所有字符串 互不相同",12,,7126,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],12017
评论 (68),minimize-the-difference-between-target-and-chosen-elements,中等,"给你一个大小为 m x n 的整数矩阵 mat 和一个整数 target 。
从矩阵的 每一行 中选择一个整数，你的目标是 最小化 所有选中元素之 和 与目标值 target 的 绝对差 。
返回 最小的绝对差 。
a 和 b 两数字的 绝对差 是 a - b 的绝对值。
  示例 1：
输入：mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13
输出：0
解释：一种可能的最优选择方案是：
- 第一行选出 1
- 第二行选出 5
- 第三行选出 7
所选元素的和是 13 ，等于目标值，所以绝对差是 0 。
示例 2：
输入：mat = [[1],[2],[3]], target = 100
输出：94
解释：唯一一种选择方案是：
- 第一行选出 1
- 第二行选出 2
- 第三行选出 3
所选元素的和是 6 ，绝对差是 94 。
示例 3：
输入：mat = [[1,2,9,8,7]], target = 6
输出：1
解释：最优的选择方案是选出第一行的 7 。
绝对差是 1 。
  提示：
m == mat.length
n == mat[i].length
1 <= m, n <= 70
1 <= mat[i][j] <= 70
1 <= target <= 800",46,,5526,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],17520
评论 (13),find-array-given-subset-sums,困难,"存在一个未知数组需要你进行还原，给你一个整数 n 表示该数组的长度。另给你一个数组 sums ，由未知数组中全部 2n 个 子集的和 组成（子集中的元素没有特定的顺序）。
返回一个长度为 n 的数组 ans 表示还原得到的未知数组。如果存在 多种 答案，只需返回其中 任意一个 。
如果可以由数组 arr 删除部分元素（也可能不删除或全删除）得到数组 sub ，那么数组 sub 就是数组 arr 的一个 子集 。sub 的元素之和就是 arr 的一个 子集的和 。一个空数组的元素之和为 0 。
注意：生成的测试用例将保证至少存在一个正确答案。
  示例 1：
输入：n = 3, sums = [-3,-2,-1,0,0,1,2,3]
输出：[1,2,-3]
解释：[1,2,-3] 能够满足给出的子集的和：
- []：和是 0
- [1]：和是 1
- [2]：和是 2
- [1,2]：和是 3
- [-3]：和是 -3
- [1,-3]：和是 -2
- [2,-3]：和是 -1
- [1,2,-3]：和是 0
注意，[1,2,-3] 的任何排列和 [-1,-2,3] 的任何排列都会被视作正确答案。
示例 2：
输入：n = 2, sums = [0,0,0,0]
输出：[0,0]
解释：唯一的正确答案是 [0,0] 。
示例 3：
输入：n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
输出：[0,-1,4,5]
解释：[0,-1,4,5] 能够满足给出的子集的和。
  提示：
1 <= n <= 15
sums.length == 2n
-104 <= sums[i] <= 104",31,,1098,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/']",[],2376
评论 (4),widest-pair-of-indices-with-equal-range-sum,Unknown,,-1,,-1,[],[],-1
评论 (303),minimum-difference-between-highest-and-lowest-of-k-scores,简单,"给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。
从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。
返回可能的 最小差值 。
  示例 1：
输入：nums = [90], k = 1
输出：0
解释：选出 1 名学生的分数，仅有 1 种方法：
- [90] 最高分和最低分之间的差值是 90 - 90 = 0
可能的最小差值是 0
示例 2：
输入：nums = [9,4,1,7], k = 2
输出：2
解释：选出 2 名学生的分数，有 6 种方法：
- [9,4,1,7] 最高分和最低分之间的差值是 9 - 4 = 5
- [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 = 8
- [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 = 2
- [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 = 3
- [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 = 3
- [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 = 6
可能的最小差值是 2
  提示：
1 <= k <= nums.length <= 1000
0 <= nums[i] <= 105",88,,39502,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/sliding-window/']",[],62929
评论 (68),find-the-kth-largest-integer-in-the-array,中等,"给你一个字符串数组 nums 和一个整数 k 。nums 中的每个字符串都表示一个不含前导零的整数。
返回 nums 中表示第 k 大整数的字符串。
注意：重复的数字在统计时会视为不同元素考虑。例如，如果 nums 是 [""1"",""2"",""2""]，那么 ""2"" 是最大的整数，""2"" 是第二大的整数，""1"" 是第三大的整数。
  示例 1：
输入：nums = [""3"",""6"",""7"",""10""], k = 4
输出：""3""
解释：
nums 中的数字按非递减顺序排列为 [""3"",""6"",""7"",""10""]
其中第 4 大整数是 ""3""
示例 2：
输入：nums = [""2"",""21"",""12"",""1""], k = 3
输出：""2""
解释：
nums 中的数字按非递减顺序排列为 [""1"",""2"",""12"",""21""]
其中第 3 大整数是 ""2""
示例 3：
输入：nums = [""0"",""0""], k = 2
输出：""0""
解释：
nums 中的数字按非递减顺序排列为 [""0"",""0""]
其中第 2 大整数是 ""0""
  提示：
1 <= k <= nums.length <= 104
1 <= nums[i].length <= 100
nums[i] 仅由数字组成
nums[i] 不含任何前导零",27,,8140,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/quickselect/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],19509
评论 (69),minimum-number-of-work-sessions-to-finish-the-tasks,中等,"你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。
你需要按照如下条件完成给定任务：
如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。
完成一个任务后，你可以 立马 开始一个新的任务。
你可以按 任意顺序 完成任务。
给你 tasks 和 sessionTime ，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。
测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。
  示例 1：
输入：tasks = [1,2,3], sessionTime = 3
输出：2
解释：你可以在两个工作时间段内完成所有任务。
- 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。
- 第二个工作时间段：完成第三个任务，花费 3 小时。
示例 2：
输入：tasks = [3,1,3,1,1], sessionTime = 8
输出：2
解释：你可以在两个工作时间段内完成所有任务。
- 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。
- 第二个工作时间段，完成最后一个任务，花费 1 小时。
示例 3：
输入：tasks = [1,2,3,4,5], sessionTime = 15
输出：1
解释：你可以在一个工作时间段以内完成所有任务。
  提示：
n == tasks.length
1 <= n <= 14
1 <= tasks[i] <= 10
max(tasks[i]) <= sessionTime <= 15",69,,4842,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/bitmask/']",[],16107
评论 (20),number-of-unique-good-subsequences,困难,"给你一个二进制字符串 binary 。 binary 的一个 子序列 如果是 非空 的且没有 前导 0 （除非数字是 ""0"" 本身），那么它就是一个 好 的子序列。
请你找到 binary 不同好子序列 的数目。
比方说，如果 binary = ""001"" ，那么所有 好 子序列为 [""0"", ""0"", ""1""] ，所以 不同 的好子序列为 ""0"" 和 ""1"" 。 注意，子序列 ""00"" ，""01"" 和 ""001"" 不是好的，因为它们有前导 0 。
请你返回 binary 中 不同好子序列 的数目。由于答案可能很大，请将它对 109 + 7 取余 后返回。
一个 子序列 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。
  示例 1：
输入：binary = ""001""
输出：2
解释：好的二进制子序列为 [""0"", ""0"", ""1""] 。
不同的好子序列为 ""0"" 和 ""1"" 。
示例 2：
输入：binary = ""11""
输出：2
解释：好的二进制子序列为 [""1"", ""1"", ""11""] 。
不同的好子序列为 ""1"" 和 ""11"" 。
示例 3：
输入：binary = ""101""
输出：5
解释：好的二进制子序列为 [""1"", ""0"", ""1"", ""10"", ""11"", ""101""] 。
不同的好子序列为 ""0"" ，""1"" ，""10"" ，""11"" 和 ""101"" 。
  提示：
1 <= binary.length <= 105
binary 只含有 '0' 和 '1' 。",34,,1814,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],3752
评论 (53),find-cutoff-score-for-each-school,Unknown,,-1,,-1,[],[],-1
评论 (6),maximum-number-of-people-that-can-be-caught-in-tag,Unknown,,-1,,-1,[],[],-1
评论 (40),count-the-number-of-experiments,Unknown,,-1,,-1,[],[],-1
评论 (76),find-the-middle-index-in-array,简单,"给你一个下标从 0 开始的整数数组 nums ，请你找到 最左边 的中间位置 middleIndex （也就是所有可能中间位置下标最小的一个）。
中间位置 middleIndex 是满足 nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1] 的数组下标。
如果 middleIndex == 0 ，左边部分的和定义为 0 。类似的，如果 middleIndex == nums.length - 1 ，右边部分的和定义为 0 。
请你返回满足上述条件 最左边 的 middleIndex ，如果不存在这样的中间位置，请你返回 -1 。
  示例 1：
输入：nums = [2,3,-1,8,4]
输出：3
解释：
下标 3 之前的数字和为：2 + 3 + -1 = 4
下标 3 之后的数字和为：4 = 4
示例 2：
输入：nums = [1,-1,4]
输出：2
解释：
下标 2 之前的数字和为：1 + -1 = 0
下标 2 之后的数字和为：0
示例 3：
输入：nums = [2,5]
输出：-1
解释：
不存在符合要求的 middleIndex 。
示例 4：
输入：nums = [1]
输出：0
解释：
下标 0 之前的数字和为：0
下标 0 之后的数字和为：0
  提示：
1 <= nums.length <= 100
-1000 <= nums[i] <= 1000
  注意：本题与主站 724 题相同：https://leetcode-cn.com/problems/find-pivot-index/",19,,11019,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],16936
评论 (63),find-all-groups-of-farmland,中等,"给你一个下标从 0 开始，大小为 m x n 的二进制矩阵 land ，其中 0 表示一单位的森林土地，1 表示一单位的农场土地。
为了让农场保持有序，农场土地之间以矩形的 农场组 的形式存在。每一个农场组都 仅 包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 不会 与另一个农场组的任何一块土地在四个方向上相邻。
land 可以用坐标系统表示，其中 land 左上角坐标为 (0, 0) ，右下角坐标为 (m-1, n-1) 。请你找到所有 农场组 最左上角和最右下角的坐标。一个左上角坐标为 (r1, c1) 且右下角坐标为 (r2, c2) 的 农场组 用长度为 4 的数组 [r1, c1, r2, c2] 表示。
请你返回一个二维数组，它包含若干个长度为 4 的子数组，每个子数组表示 land 中的一个 农场组 。如果没有任何农场组，请你返回一个空数组。可以以 任意顺序 返回所有农场组。
示例 1：
输入：land = [[1,0,0],[0,1,1],[0,1,1]]
输出：[[0,0,0,0],[1,1,2,2]]
解释：
第一个农场组的左上角为 land[0][0] ，右下角为 land[0][0] 。
第二个农场组的左上角为 land[1][1] ，右下角为 land[2][2] 。
示例 2：
输入：land = [[1,1],[1,1]]
输出：[[0,0,1,1]]
解释：
第一个农场组左上角为 land[0][0] ，右下角为 land[1][1] 。
示例 3：
输入：land = [[0]]
输出：[]
解释：
没有任何农场组。
  提示：
m == land.length
n == land[i].length
1 <= m, n <= 300
land 只包含 0 和 1 。
农场组都是 矩形 的形状。",9,,4266,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],7159
评论 (62),operations-on-tree,中等,"给你一棵 n 个节点的树，编号从 0 到 n - 1 ，以父节点数组 parent 的形式给出，其中 parent[i] 是第 i 个节点的父节点。树的根节点为 0 号节点，所以 parent[0] = -1 ，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。
数据结构需要支持如下函数：
Lock：指定用户给指定节点 上锁 ，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。
Unlock：指定用户给指定节点 解锁 ，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。
Upgrade：指定用户给指定节点 上锁 ，并且将该节点的所有子孙节点 解锁 。只有如下 3 个条件 全部 满足时才能执行升级操作：
指定节点当前状态为未上锁。
指定节点至少有一个上锁状态的子孙节点（可以是 任意 用户上锁的）。
指定节点没有任何上锁的祖先节点。
请你实现 LockingTree 类：
LockingTree(int[] parent) 用父节点数组初始化数据结构。
lock(int num, int user) 如果 id 为 user 的用户可以给节点 num 上锁，那么返回 true ，否则返回 false 。如果可以执行此操作，节点 num 会被 id 为 user 的用户 上锁 。
unlock(int num, int user) 如果 id 为 user 的用户可以给节点 num 解锁，那么返回 true ，否则返回 false 。如果可以执行此操作，节点 num 变为 未上锁 状态。
upgrade(int num, int user) 如果 id 为 user 的用户可以给节点 num 升级，那么返回 true ，否则返回 false 。如果可以执行此操作，节点 num 会被 升级 。
  示例 1：
输入：
[""LockingTree"", ""lock"", ""unlock"", ""unlock"", ""lock"", ""upgrade"", ""lock""]
[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
输出：
[null, true, false, true, true, true, false]

解释：
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
lockingTree.lock(2, 2);    // 返回 true ，因为节点 2 未上锁。
                           // 节点 2 被用户 2 上锁。
lockingTree.unlock(2, 3);  // 返回 false ，因为用户 3 无法解锁被用户 2 上锁的节点。
lockingTree.unlock(2, 2);  // 返回 true ，因为节点 2 之前被用户 2 上锁。
                           // 节点 2 现在变为未上锁状态。
lockingTree.lock(4, 5);    // 返回 true ，因为节点 4 未上锁。
                           // 节点 4 被用户 5 上锁。
lockingTree.upgrade(0, 1); // 返回 true ，因为节点 0 未上锁且至少有一个被上锁的子孙节点（节点 4）。
                           // 节点 0 被用户 1 上锁，节点 4 变为未上锁。
lockingTree.lock(0, 1);    // 返回 false ，因为节点 0 已经被上锁了。
  提示：
n == parent.length
2 <= n <= 2000
对于 i != 0 ，满足 0 <= parent[i] <= n - 1
parent[0] == -1
0 <= num <= n - 1
1 <= user <= 104
parent 表示一棵合法的树。
lock ，unlock 和 upgrade 的调用 总共 不超过 2000 次。",14,,2379,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/']",[],6116
评论 (180),the-number-of-good-subsets,困难,"给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。
比方说，如果 nums = [1, 2, 3, 4] ：
[2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
[1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。
nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。
  示例 1：
输入：nums = [1,2,3,4]
输出：6
解释：好子集为：
- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
示例 2：
输入：nums = [4,2,3,15]
输出：5
解释：好子集为：
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 30",129,,15155,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],26708
评论 (238),count-special-quadruplets,简单,"给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：
nums[a] + nums[b] + nums[c] == nums[d] ，且
a < b < c < d
  示例 1：
输入：nums = [1,2,3,6]
输出：1
解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。
示例 2：
输入：nums = [3,3,6,4,5]
输出：0
解释：[3,3,6,4,5] 中不存在满足要求的四元组。
示例 3：
输入：nums = [1,1,1,3,5]
输出：4
解释：满足要求的 4 个四元组如下：
- (0, 1, 2, 3): 1 + 1 + 1 == 3
- (0, 1, 3, 4): 1 + 1 + 3 == 5
- (0, 2, 3, 4): 1 + 1 + 3 == 5
- (1, 2, 3, 4): 1 + 1 + 3 == 5
  提示：
4 <= nums.length <= 50
1 <= nums[i] <= 100",110,,34216,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/enumeration/']",[],51604
评论 (226),the-number-of-weak-characters-in-the-game,中等,"你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。
如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj > attacki 且 defensej > defensei 。
返回 弱角色 的数量。
  示例 1：
输入：properties = [[5,5],[6,3],[3,6]]
输出：0
解释：不存在攻击和防御都严格高于其他角色的角色。
示例 2：
输入：properties = [[2,2],[3,3]]
输出：1
解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。
示例 3：
输入：properties = [[1,5],[10,4],[4,3]]
输出：1
解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。
  提示：
2 <= properties.length <= 105
properties[i].length == 2
1 <= attacki, defensei <= 105",148,,26953,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/monotonic-stack/']",[],65047
评论 (61),first-day-where-you-have-been-in-all-the-rooms,中等,"你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。
最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：
假设某一天，你访问 i 号房间。
如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 <= nextVisit[i] <= i 。
如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。
请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 109 + 7 取余后的结果。
  示例 1：
输入：nextVisit = [0,0]
输出：2
解释：
- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。
  下一天你需要访问房间的编号是 nextVisit[0] = 0
- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。
  下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1
- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。
示例 2：
输入：nextVisit = [0,0,2]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。
第 6 天是你访问完所有房间的第一天。
示例 3：
输入：nextVisit = [0,1,2,0]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。
第 6 天是你访问完所有房间的第一天。
  提示：
n == nextVisit.length
2 <= n <= 105
0 <= nextVisit[i] <= i",37,,2793,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],8144
评论 (26),gcd-sort-of-an-array,困难,"给你一个整数数组 nums ，你可以在 nums 上执行下述操作 任意次 ：
如果 gcd(nums[i], nums[j]) > 1 ，交换 nums[i] 和 nums[j] 的位置。其中 gcd(nums[i], nums[j]) 是 nums[i] 和 nums[j] 的最大公因数。
如果能使用上述交换方式将 nums 按 非递减顺序 排列，返回 true ；否则，返回 false 。
  示例 1：
输入：nums = [7,21,3]
输出：true
解释：可以执行下述操作完成对 [7,21,3] 的排序：
- 交换 7 和 21 因为 gcd(7,21) = 7 。nums = [21,7,3]
- 交换 21 和 3 因为 gcd(21,3) = 3 。nums = [3,7,21]
示例 2：
输入：nums = [5,2,6,2]
输出：false
解释：无法完成排序，因为 5 不能与其他元素交换。
示例 3：
输入：nums = [10,5,9,3,15]
输出：true
解释：
可以执行下述操作完成对 [10,5,9,3,15] 的排序：
- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [15,5,9,3,10]
- 交换 15 和 3 因为 gcd(15,3) = 3 。nums = [3,5,9,15,10]
- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [3,5,9,10,15]
  提示：
1 <= nums.length <= 3 * 104
2 <= nums[i] <= 105",28,,2057,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",[],4743
评论 (4),smallest-greater-multiple-made-of-two-digits,Unknown,,-1,,-1,[],[],-1
评论 (243),reverse-prefix-of-word,简单,"给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。
例如，如果 word = ""abcdefd"" 且 ch = ""d"" ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 ""dcbaefd"" 。
返回 结果字符串 。
  示例 1：
输入：word = ""abcdefd"", ch = ""d""
输出：""dcbaefd""
解释：""d"" 第一次出现在下标 3 。 
反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 ""dcbaefd"" 。
示例 2：
输入：word = ""xyxzxe"", ch = ""z""
输出：""zxyxxe""
解释：""z"" 第一次也是唯一一次出现是在下标 3 。
反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 ""zxyxxe"" 。
示例 3：
输入：word = ""abcd"", ch = ""z""
输出：""abcd""
解释：""z"" 不存在于 word 中。
无需执行反转操作，结果字符串是 ""abcd"" 。
  提示：
1 <= word.length <= 250
word 由小写英文字母组成
ch 是一个小写英文字母",56,,31958,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],40256
评论 (27),the-category-of-each-member-in-the-store,Unknown,,-1,,-1,[],[],-1
评论 (1),minimum-cost-to-separate-sentence-into-rows,Unknown,,-1,,-1,[],[],-1
评论 (63),kth-distinct-string-in-an-array,简单,"独一无二的字符串 指的是在一个数组中只出现过 一次 的字符串。
给你一个字符串数组 arr 和一个整数 k ，请你返回 arr 中第 k 个 独一无二的字符串 。如果 少于 k 个独一无二的字符串，那么返回 空字符串 """" 。
注意，按照字符串在原数组中的 顺序 找到第 k 个独一无二字符串。
  示例 1:
输入：arr = [""d"",""b"",""c"",""b"",""c"",""a""], k = 2
输出：""a""
解释：
arr 中独一无二字符串包括 ""d"" 和 ""a"" 。
""d"" 首先出现，所以它是第 1 个独一无二字符串。
""a"" 第二个出现，所以它是 2 个独一无二字符串。
由于 k == 2 ，返回 ""a"" 。
示例 2:
输入：arr = [""aaa"",""aa"",""a""], k = 1
输出：""aaa""
解释：
arr 中所有字符串都是独一无二的，所以返回第 1 个字符串 ""aaa"" 。
示例 3：
输入：arr = [""a"",""b"",""a""], k = 3
输出：""""
解释：
唯一一个独一无二字符串是 ""b"" 。由于少于 3 个独一无二字符串，我们返回空字符串 """" 。
  提示：
1 <= k <= arr.length <= 1000
1 <= arr[i].length <= 5
arr[i] 只包含小写英文字母。",8,,6351,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],8765
评论 (50),two-best-non-overlapping-events,中等,"给你一个下标从 0 开始的二维整数数组 events ，其中 events[i] = [startTimei, endTimei, valuei] 。第 i 个活动开始于 startTimei ，结束于 endTimei ，如果你参加这个活动，那么你可以得到价值 valuei 。你 最多 可以参加 两个时间不重叠 活动，使得它们的价值之和 最大 。
请你返回价值之和的 最大值 。
注意，活动的开始时间和结束时间是 包括 在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的结束时间。更具体的，如果你参加一个活动，且结束时间为 t ，那么下一个活动必须在 t + 1 或之后的时间开始。
  示例 1:
输入：events = [[1,3,2],[4,5,2],[2,4,3]]
输出：4
解释：选择绿色的活动 0 和 1 ，价值之和为 2 + 2 = 4 。
示例 2：
输入：events = [[1,3,2],[4,5,2],[1,5,5]]
输出：5
解释：选择活动 2 ，价值和为 5 。
示例 3：
输入：events = [[1,5,3],[1,5,1],[6,6,5]]
输出：8
解释：选择活动 0 和 2 ，价值之和为 3 + 5 = 8 。
  提示：
2 <= events.length <= 105
events[i].length == 3
1 <= startTimei <= endTimei <= 109
1 <= valuei <= 106",28,,3335,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],9351
评论 (406),plates-between-candles,中等,"给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。
同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。
比方说，s = ""||**||**|*"" ，查询 [3, 8] ，表示的是子字符串 ""*||**|"" 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。
请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。
  示例 1:
输入：s = ""**|**|***|"", queries = [[2,5],[5,9]]
输出：[2,3]
解释：
- queries[0] 有两个盘子在蜡烛之间。
- queries[1] 有三个盘子在蜡烛之间。
示例 2:
输入：s = ""***|**|*****|**||**|*"", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
输出：[9,0,0,0,0]
解释：
- queries[0] 有 9 个盘子在蜡烛之间。
- 另一个查询没有盘子在蜡烛之间。
  提示：
3 <= s.length <= 105
s 只包含字符 '*' 和 '|' 。
1 <= queries.length <= 105
queries[i].length == 2
0 <= lefti <= righti < s.length",148,,31989,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/']",[],73964
评论 (15),number-of-valid-move-combinations-on-chessboard,困难,"有一个 8 x 8 的棋盘，它包含 n 个棋子（棋子包括车，后和象三种）。给你一个长度为 n 的字符串数组 pieces ，其中 pieces[i] 表示第 i 个棋子的类型（车，后或象）。除此以外，还给你一个长度为 n 的二维整数数组 positions ，其中 positions[i] = [ri, ci] 表示第 i 个棋子现在在棋盘上的位置为 (ri, ci) ，棋盘下标从 1 开始。
棋盘上每个棋子都可以移动 至多一次 。每个棋子的移动中，首先选择移动的 方向 ，然后选择 移动的步数 ，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：
车可以 水平或者竖直 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1) 或者 (r, c-1) 移动。
后可以 水平竖直或者斜对角 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1)，(r, c-1)，(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。
象可以 斜对角 从 (r, c) 沿着方向 (r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。
移动组合 包含所有棋子的 移动 。每一秒，每个棋子都沿着它们选择的方向往前移动 一步 ，直到它们到达目标位置。所有棋子从时刻 0 开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 不有效 。
请你返回 有效 移动组合的数目。
注意：
初始时，不会有两个棋子 在 同一个位置 。
有可能在一个移动组合中，有棋子不移动。
如果两个棋子 直接相邻 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 交换位置 。
  示例 1:
输入：pieces = [""rook""], positions = [[1,1]]
输出：15
解释：上图展示了棋子所有可能的移动。
示例 2：
输入：pieces = [""queen""], positions = [[1,1]]
输出：22
解释：上图展示了棋子所有可能的移动。
示例 3:
输入：pieces = [""bishop""], positions = [[4,3]]
输出：12
解释：上图展示了棋子所有可能的移动。
示例 4:
输入：pieces = [""rook"",""rook""], positions = [[1,1],[8,8]]
输出：223
解释：每个车有 15 种移动，所以总共有 15 * 15 = 225 种移动组合。
但是，有两个是不有效的移动组合：
- 将两个车都移动到 (8, 1) ，会导致它们在同一个格子相遇。
- 将两个车都移动到 (1, 8) ，会导致它们在同一个格子相遇。
所以，总共有 225 - 2 = 223 种有效移动组合。
注意，有两种有效的移动组合，分别是一个车在 (1, 8) ，另一个车在 (8, 1) 。
即使棋盘状态是相同的，这两个移动组合被视为不同的，因为每个棋子移动操作是不相同的。
示例 5：
输入：pieces = [""queen"",""bishop""], positions = [[5,7],[3,4]]
输出：281
解释：总共有 12 * 24 = 288 种移动组合。
但是，有一些不有效的移动组合：
- 如果后停在 (6, 7) ，它会阻挡象到达 (6, 7) 或者 (7, 8) 。
- 如果后停在 (5, 6) ，它会阻挡象到达 (5, 6) ，(6, 7) 或者 (7, 8) 。
- 如果象停在 (5, 2) ，它会阻挡后到达 (5, 2) 或者 (5, 1) 。
在 288 个移动组合当中，281 个是有效的。
  提示：
n == pieces.length
n == positions.length
1 <= n <= 4
pieces 只包含字符串 ""rook"" ，""queen"" 和 ""bishop"" 。
棋盘上总共最多只有一个后。
1 <= xi, yi <= 8
每一个 positions[i] 互不相同。",7,,816,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/simulation/']",[],1335
评论 (38),smallest-index-with-equal-value,简单,"给你一个下标从 0 开始的整数数组 nums ，返回 nums 中满足 i mod 10 == nums[i] 的最小下标 i ；如果不存在这样的下标，返回 -1 。
x mod y 表示 x 除以 y 的 余数 。
  示例 1：
输入：nums = [0,1,2]
输出：0
解释：
i=0: 0 mod 10 = 0 == nums[0].
i=1: 1 mod 10 = 1 == nums[1].
i=2: 2 mod 10 = 2 == nums[2].
所有下标都满足 i mod 10 == nums[i] ，所以返回最小下标 0
示例 2：
输入：nums = [4,3,2,1]
输出：2
解释：
i=0: 0 mod 10 = 0 != nums[0].
i=1: 1 mod 10 = 1 != nums[1].
i=2: 2 mod 10 = 2 == nums[2].
i=3: 3 mod 10 = 3 != nums[3].
2 唯一一个满足 i mod 10 == nums[i] 的下标
示例 3：
输入：nums = [1,2,3,4,5,6,7,8,9,0]
输出：-1
解释：不存在满足 i mod 10 == nums[i] 的下标
示例 4：
输入：nums = [2,1,3,5,2]
输出：1
解释：1 是唯一一个满足 i mod 10 == nums[i] 的下标
  提示：
1 <= nums.length <= 100
0 <= nums[i] <= 9",6,,8539,['https://leetcode.cn/tag/array/'],[],11155
评论 (41),find-the-minimum-and-maximum-number-of-nodes-between-critical-points,中等,"链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。
如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个  局部极大值点 。
如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个  局部极小值点 。
注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。
给你一个链表 head ，返回一个长度为 2 的数组 [minDistance, maxDistance] ，其中 minDistance 是任意两个不同临界点之间的最小距离，maxDistance 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 [-1，-1] 。
  示例 1：
输入：head = [3,1]
输出：[-1,-1]
解释：链表 [3,1] 中不存在临界点。
示例 2：
输入：head = [5,3,1,2,5,1,2]
输出：[1,3]
解释：存在三个临界点：
- [5,3,1,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。
- [5,3,1,2,5,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。
- [5,3,1,2,5,1,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。
第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。
第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。
示例 3：
输入：head = [1,3,2,2,3,2,2,2,7]
输出：[3,3]
解释：存在两个临界点：
- [1,3,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。
- [1,3,2,2,3,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。
最小和最大距离都存在于第二个节点和第五个节点之间。
因此，minDistance 和 maxDistance 是 5 - 2 = 3 。
注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。
示例 4：
输入：head = [2,3,3,2]
输出：[-1,-1]
解释：链表 [2,3,3,2] 中不存在临界点。
  提示：
链表中节点的数量在范围 [2, 105] 内
1 <= Node.val <= 105",11,,6117,['https://leetcode.cn/tag/linked-list/'],[],10851
评论 (75),minimum-operations-to-convert-number,中等,"给你一个下标从 0 开始的整数数组 nums ，该数组由 互不相同 的数字组成。另给你两个整数 start 和 goal 。
整数 x 的值最开始设为 start ，你打算执行一些运算使 x 转化为 goal 。你可以对数字 x 重复执行下述运算：
如果 0 <= x <= 1000 ，那么，对于数组中的任一下标 i（0 <= i < nums.length），可以将 x 设为下述任一值：
x + nums[i]
x - nums[i]
x ^ nums[i]（按位异或 XOR）
注意，你可以按任意顺序使用每个 nums[i] 任意次。使 x 越过 0 <= x <= 1000 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。
返回将 x = start 转化为 goal 的最小操作数；如果无法完成转化，则返回 -1 。
  示例 1：
输入：nums = [2,4,12], start = 2, goal = 12
输出：2
解释：
可以按 2 → 14 → 12 的转化路径进行，只需执行下述 2 次运算：
- 2 + 12 = 14
- 14 - 2 = 12
示例 2：
输入：nums = [3,5,7], start = 0, goal = -4
输出：2
解释：
可以按 0 → 3 → -4 的转化路径进行，只需执行下述 2 次运算：
- 0 + 3 = 3
- 3 - 7 = -4
注意，最后一步运算使 x 超过范围 0 <= x <= 1000 ，但该运算仍然可以生效。
示例 3：
输入：nums = [2,8,16], start = 0, goal = 1
输出：-1
解释：
无法将 0 转化为 1
  提示：
1 <= nums.length <= 1000
-109 <= nums[i], goal <= 109
0 <= start <= 1000
start != goal
nums 中的所有整数互不相同",29,,4972,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/']",[],11106
评论 (40),check-if-an-original-string-exists-given-two-encoded-strings,困难,"原字符串由小写字母组成，可以按下述步骤编码：
任意将其 分割 为由若干 非空 子字符串组成的一个 序列 。
任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。
重新 顺次连接 序列，得到编码后的字符串。
例如，编码 ""abcdefghijklmnop"" 的一种方法可以描述为：
将原字符串分割得到一个序列：[""ab"", ""cdefghijklmn"", ""o"", ""p""] 。
选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 [""ab"", ""12"", ""1"", ""p""] 。
重新顺次连接序列中的元素，得到编码后的字符串：""ab121p"" 。
给你两个编码后的字符串 s1 和 s2 ，由小写英文字母和数字 1-9 组成。如果存在能够同时编码得到 s1 和 s2 原字符串，返回 true ；否则，返回 false。
注意：生成的测试用例满足 s1 和 s2 中连续数字数不超过 3 。
  示例 1：
输入：s1 = ""internationalization"", s2 = ""i18n""
输出：true
解释：""internationalization"" 可以作为原字符串
- ""internationalization"" 
  -> 分割：      [""internationalization""]
  -> 不替换任何元素
  -> 连接：      ""internationalization""，得到 s1
- ""internationalization""
  -> 分割：      [""i"", ""nternationalizatio"", ""n""]
  -> 替换：      [""i"", ""18"",                 ""n""]
  -> 连接：      ""i18n""，得到 s2
示例 2：
输入：s1 = ""l123e"", s2 = ""44""
输出：true
解释：""leetcode"" 可以作为原字符串
- ""leetcode"" 
  -> 分割：       [""l"", ""e"", ""et"", ""cod"", ""e""]
  -> 替换：       [""l"", ""1"", ""2"",  ""3"",   ""e""]
  -> 连接：       ""l123e""，得到 s1
- ""leetcode"" 
  -> 分割：       [""leet"", ""code""]
  -> 替换：       [""4"",    ""4""]
  -> 连接：       ""44""，得到 s2
示例 3：
输入：s1 = ""a5b"", s2 = ""c5b""
输出：false
解释：不存在这样的原字符串
- 编码为 s1 的字符串必须以字母 'a' 开头
- 编码为 s2 的字符串必须以字母 'c' 开头
示例 4：
输入：s1 = ""112s"", s2 = ""g841""
输出：true
解释：""gaaaaaaaaaaaas"" 可以作为原字符串
- ""gaaaaaaaaaaaas""
  -> 分割：       [""g"", ""aaaaaaaaaaaa"", ""s""]
  -> 替换：       [""1"", ""12"",           ""s""]
  -> 连接：       ""112s""，得到 s1
- ""gaaaaaaaaaaaas""
  -> 分割：       [""g"", ""aaaaaaaa"", ""aaaa"", ""s""]
  -> 替换：       [""g"", ""8"",        ""4"",    ""1""]
  -> 连接         ""g841""，得到 s2
示例 5：
输入：s1 = ""ab"", s2 = ""a2""
输出：false
解释：不存在这样的原字符串
- 编码为 s1 的字符串由两个字母组成
- 编码为 s2 的字符串由三个字母组成
  提示：
1 <= s1.length, s2.length <= 40
s1 和 s2 仅由数字 1-9 和小写英文字母组成
s1 和 s2 中连续数字数不超过 3",31,,1230,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],3263
评论 (18),number-of-spaces-cleaning-robot-cleaned,Unknown,,-1,,-1,[],[],-1
评论 (50),count-vowel-substrings-of-a-string,简单,"子字符串 是字符串中的一个连续（非空）的字符序列。
元音子字符串 是 仅 由元音（'a'、'e'、'i'、'o' 和 'u'）组成的一个子字符串，且必须包含 全部五种 元音。
给你一个字符串 word ，统计并返回 word 中 元音子字符串的数目 。
  示例 1：
输入：word = ""aeiouu""
输出：2
解释：下面列出 word 中的元音子字符串（斜体加粗部分）：
- ""aeiouu""
- ""aeiouu""
示例 2：
输入：word = ""unicornarihan""
输出：0
解释：word 中不含 5 种元音，所以也不会存在元音子字符串。
示例 3：
输入：word = ""cuaieuouac""
输出：7
解释：下面列出 word 中的元音子字符串（斜体加粗部分）：
- ""cuaieuouac""
- ""cuaieuouac""
- ""cuaieuouac""
- ""cuaieuouac""
- ""cuaieuouac""
- ""cuaieuouac""
- ""cuaieuouac""
示例 4：
输入：word = ""bbaeixoubb""
输出：0
解释：所有包含全部五种元音的子字符串都含有辅音，所以不存在元音子字符串。
  提示：
1 <= word.length <= 100
word 仅由小写英文字母组成",21,,6563,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],10664
评论 (71),vowels-of-all-substrings,中等,"给你一个字符串 word ，返回 word 的所有子字符串中 元音的总数 ，元音是指 'a'、'e'、'i'、'o' 和 'u' 。
子字符串 是字符串中一个连续（非空）的字符序列。
注意：由于对 word 长度的限制比较宽松，答案可能超过有符号 32 位整数的范围。计算时需当心。
  示例 1：
输入：word = ""aba""
输出：6
解释：
所有子字符串是：""a""、""ab""、""aba""、""b""、""ba"" 和 ""a"" 。
- ""b"" 中有 0 个元音
- ""a""、""ab""、""ba"" 和 ""a"" 每个都有 1 个元音
- ""aba"" 中有 2 个元音
因此，元音总数 = 0 + 1 + 1 + 1 + 1 + 2 = 6 。
示例 2：
输入：word = ""abc""
输出：3
解释：
所有子字符串是：""a""、""ab""、""abc""、""b""、""bc"" 和 ""c"" 。
- ""a""、""ab"" 和 ""abc"" 每个都有 1 个元音
- ""b""、""bc"" 和 ""c"" 每个都有 0 个元音
因此，元音总数 = 1 + 1 + 1 + 0 + 0 + 0 = 3 。
示例 3：
输入：word = ""ltcd""
输出：0
解释：""ltcd"" 的子字符串均不含元音。
示例 4：
输入：word = ""noosabasboosa""
输出：237
解释：所有子字符串中共有 237 个元音。
  提示：
1 <= word.length <= 105
word 由小写英文字母组成",17,,5082,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/combinatorics/']",[],10135
评论 (42),minimized-maximum-of-products-distributed-to-any-store,中等,"给你一个整数 n ，表示有 n 间零售商店。总共有 m 种产品，每种产品的数目用一个下标从 0 开始的整数数组 quantities 表示，其中 quantities[i] 表示第 i 种商品的数目。
你需要将 所有商品 分配到零售商店，并遵守这些规则：
一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。
分配后，每间商店都会被分配一定数目的商品（可能为 0 件）。用 x 表示所有商店中分配商品数目的最大值，你希望 x 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的 最大值 。
请你返回最小的可能的 x 。
  示例 1：
输入：n = 6, quantities = [11,6]
输出：3
解释： 一种最优方案为：
- 11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。
- 6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。
分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) = 3 。
示例 2：
输入：n = 7, quantities = [15,10,10]
输出：5
解释：一种最优方案为：
- 15 件种类为 0 的商品被分配到前 3 间商店，分配数目为：5，5，5 。
- 10 件种类为 1 的商品被分配到接下来 2 间商店，数目为：5，5 。
- 10 件种类为 2 的商品被分配到最后 2 间商店，数目为：5，5 。
分配给所有商店的最大商品数目为 max(5, 5, 5, 5, 5, 5, 5) = 5 。
示例 3：
输入：n = 1, quantities = [100000]
输出：100000
解释：唯一一种最优方案为：
- 所有 100000 件商品 0 都分配到唯一的商店中。
分配给所有商店的最大商品数目为 max(100000) = 100000 。
  提示：
m == quantities.length
1 <= m <= n <= 105
1 <= quantities[i] <= 105",30,,4409,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],10212
评论 (45),maximum-path-quality-of-a-graph,困难,"给你一张 无向 图，图中有 n 个节点，节点编号从 0 到 n - 1 （都包括）。同时给你一个下标从 0 开始的整数数组 values ，其中 values[i] 是第 i 个节点的 价值 。同时给你一个下标从 0 开始的二维整数数组 edges ，其中 edges[j] = [uj, vj, timej] 表示节点 uj 和 vj 之间有一条需要 timej 秒才能通过的无向边。最后，给你一个整数 maxTime 。
合法路径 指的是图中任意一条从节点 0 开始，最终回到节点 0 ，且花费的总时间 不超过 maxTime 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 价值 定义为路径中 不同节点 的价值 之和 （每个节点的价值 至多 算入价值总和中一次）。
请你返回一条合法路径的 最大 价值。
注意：每个节点 至多 有 四条 边与之相连。
  示例 1：
输入：values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49
输出：75
解释：
一条可能的路径为：0 -> 1 -> 0 -> 3 -> 0 。总花费时间为 10 + 10 + 10 + 10 = 40 <= 49 。
访问过的节点为 0 ，1 和 3 ，最大路径价值为 0 + 32 + 43 = 75 。
示例 2：
输入：values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30
输出：25
解释：
一条可能的路径为：0 -> 3 -> 0 。总花费时间为 10 + 10 = 20 <= 30 。
访问过的节点为 0 和 3 ，最大路径价值为 5 + 20 = 25 。
示例 3：
输入：values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50
输出：7
解释：
一条可能的路径为：0 -> 1 -> 3 -> 1 -> 0 。总花费时间为 10 + 13 + 13 + 10 = 46 <= 50 。
访问过的节点为 0 ，1 和 3 ，最大路径价值为 1 + 2 + 4 = 7 。
示例 4：
输入：values = [0,1,2], edges = [[1,2,10]], maxTime = 10
输出：0
解释：
唯一一条路径为 0 。总花费时间为 0 。
唯一访问过的节点为 0 ，最大路径价值为 0 。
  提示：
n == values.length
1 <= n <= 1000
0 <= values[i] <= 108
0 <= edges.length <= 2000
edges[j].length == 3
0 <= uj < vj <= n - 1
10 <= timej, maxTime <= 100
[uj, vj] 所有节点对 互不相同 。
每个节点 至多有四条 边。
图可能不连通。",20,,2385,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/']",[],4443
评论 (28),account-balance,Unknown,,-1,,-1,[],[],-1
评论 (4),number-of-equal-count-substrings,Unknown,,-1,,-1,[],[],-1
评论 (50),check-whether-two-strings-are-almost-equivalent,简单,"如果两个字符串 word1 和 word2 中从 'a' 到 'z' 每一个字母出现频率之差都 不超过 3 ，那么我们称这两个字符串 word1 和 word2 几乎相等 。
给你两个长度都为 n 的字符串 word1 和 word2 ，如果 word1 和 word2 几乎相等 ，请你返回 true ，否则返回 false 。
一个字母 x 的出现 频率 指的是它在字符串中出现的次数。
  示例 1：
输入：word1 = ""aaaa"", word2 = ""bccb""
输出：false
解释：字符串 ""aaaa"" 中有 4 个 'a' ，但是 ""bccb"" 中有 0 个 'a' 。
两者之差为 4 ，大于上限 3 。
示例 2：
输入：word1 = ""abcdeef"", word2 = ""abaaacc""
输出：true
解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：
- 'a' 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。
- 'b' 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。
- 'c' 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。
- 'd' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。
- 'e' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。
- 'f' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。
示例 3：
输入：word1 = ""cccddabba"", word2 = ""babababab""
输出：true
解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：
- 'a' 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。
- 'b' 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。
- 'c' 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。
- 'd' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。
  提示：
n == word1.length == word2.length
1 <= n <= 100
word1 和 word2 都只包含小写英文字母。",8,,5534,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],7754
评论 (65),walking-robot-simulation-ii,中等,"给你一个在 XY 平面上的 width x height 的网格图，左下角 的格子为 (0, 0) ，右上角 的格子为 (width - 1, height - 1) 。网格图中相邻格子为四个基本方向之一（""North""，""East""，""South"" 和 ""West""）。一个机器人 初始 在格子 (0, 0) ，方向为 ""East"" 。
机器人可以根据指令移动指定的 步数 。每一步，它可以执行以下操作。
沿着当前方向尝试 往前一步 。
如果机器人下一步将到达的格子 超出了边界 ，机器人会 逆时针 转 90 度，然后再尝试往前一步。
如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。
请你实现 Robot 类：
Robot(int width, int height) 初始化一个 width x height 的网格图，机器人初始在 (0, 0) ，方向朝 ""East"" 。
void move(int num) 给机器人下达前进 num 步的指令。
int[] getPos() 返回机器人当前所处的格子位置，用一个长度为 2 的数组 [x, y] 表示。
String getDir() 返回当前机器人的朝向，为 ""North"" ，""East"" ，""South"" 或者 ""West"" 。
  示例 1：
输入：
[""Robot"", ""move"", ""move"", ""getPos"", ""getDir"", ""move"", ""move"", ""move"", ""getPos"", ""getDir""]
[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]
输出：
[null, null, null, [4, 0], ""East"", null, null, null, [1, 2], ""West""]

解释：
Robot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。
robot.move(2);  // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。
robot.move(2);  // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。
robot.getPos(); // 返回 [4, 0]
robot.getDir(); // 返回 ""East""
robot.move(2);  // 朝东移动 1 步到达 (5, 0) ，并朝东。
                // 下一步继续往东移动将出界，所以逆时针转变方向朝北。
                // 然后，往北移动 1 步到达 (5, 1) ，并朝北。
robot.move(1);  // 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。
robot.move(4);  // 下一步继续往北移动将出界，所以逆时针转变方向朝西。
                // 然后，移动 4 步到 (1, 2) ，并朝西。
robot.getPos(); // 返回 [1, 2]
robot.getDir(); // 返回 ""West""
  提示：
2 <= width, height <= 100
1 <= num <= 105
move ，getPos 和 getDir 总共 调用次数不超过 104 次。",16,,3362,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/simulation/']",[],16295
评论 (39),most-beautiful-item-for-each-query,中等,"给你一个二维整数数组 items ，其中 items[i] = [pricei, beautyi] 分别表示每一个物品的 价格 和 美丽值 。
同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。
请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。
  示例 1：
输入：items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]
输出：[2,4,5,5,6,6]
解释：
- queries[0]=1 ，[1,2] 是唯一价格 <= 1 的物品。所以这个查询的答案为 2 。
- queries[1]=2 ，符合条件的物品有 [1,2] 和 [2,4] 。
  它们中的最大美丽值为 4 。
- queries[2]=3 和 queries[3]=4 ，符合条件的物品都为 [1,2] ，[3,2] ，[2,4] 和 [3,5] 。
  它们中的最大美丽值为 5 。
- queries[4]=5 和 queries[5]=6 ，所有物品都符合条件。
  所以，答案为所有物品中的最大美丽值，为 6 。
示例 2：
输入：items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]
输出：[4]
解释：
每个物品的价格均为 1 ，所以我们选择最大美丽值 4 。
注意，多个物品可能有相同的价格和美丽值。
示例 3：
输入：items = [[10,1000]], queries = [5]
输出：[0]
解释：
没有物品的价格小于等于 5 ，所以没有物品可以选择。
因此，查询的结果为 0 。
  提示：
1 <= items.length, queries.length <= 105
items[i].length == 2
1 <= pricei, beautyi, queries[j] <= 109",12,,3104,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],7070
评论 (25),maximum-number-of-tasks-you-can-assign,困难,"给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] >= tasks[i] ）。
除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。
给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。
  示例 1：
输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1
输出：3
解释：
我们可以按照如下方案安排药丸：
- 给 0 号工人药丸。
- 0 号工人完成任务 2（0 + 1 >= 1）
- 1 号工人完成任务 1（3 >= 2）
- 2 号工人完成任务 0（3 >= 3）
示例 2：
输入：tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5
输出：1
解释：
我们可以按照如下方案安排药丸：
- 给 0 号工人药丸。
- 0 号工人完成任务 0（0 + 5 >= 5）
示例 3：
输入：tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10
输出：2
解释：
我们可以按照如下方案安排药丸：
- 给 0 号和 1 号工人药丸。
- 0 号工人完成任务 0（0 + 10 >= 10）
- 1 号工人完成任务 1（10 + 10 >= 15）
示例 4：
输入：tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5
输出：3
解释：
我们可以按照如下方案安排药丸：
- 给 2 号工人药丸。
- 1 号工人完成任务 0（6 >= 5）
- 2 号工人完成任务 2（4 + 5 >= 8）
- 4 号工人完成任务 3（6 >= 5）
  提示：
n == tasks.length
m == workers.length
1 <= n, m <= 5 * 104
0 <= pills <= m
0 <= tasks[i], workers[j], strength <= 109",39,,1565,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/monotonic-queue/']",[],4356
评论 (34),the-winner-university,Unknown,,-1,,-1,[],[],-1
评论 (47),time-needed-to-buy-tickets,简单,"有 n 个人前来排队买票，其中第 0 人站在队伍 最前方 ，第 (n - 1) 人站在队伍 最后方 。
给你一个下标从 0 开始的整数数组 tickets ，数组长度为 n ，其中第 i 人想要购买的票数为 tickets[i] 。
每个人买票都需要用掉 恰好 1 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到  队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。
返回位于位置 k（下标从 0 开始）的人完成买票需要的时间（以秒为单位）。
  示例 1：
输入：tickets = [2,3,2], k = 2
输出：6
解释： 
- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。
- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。
位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。
示例 2：
输入：tickets = [5,1,1,1], k = 0
输出：8
解释：
- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。
- 接下来的 4 轮，只有位置 0 的人在买票。
位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。
  提示：
n == tickets.length
1 <= n <= 100
1 <= tickets[i] <= 100
0 <= k < n",15,,8683,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],13915
评论 (90),reverse-nodes-in-even-length-groups,中等,"给你一个链表的头节点 head 。
链表中的节点 按顺序 划分成若干 非空 组，这些非空组的长度构成一个自然数序列（1, 2, 3, 4, ...）。一个组的 长度 就是组中分配到的节点数目。换句话说：
节点 1 分配给第一组
节点 2 和 3 分配给第二组
节点 4、5 和 6 分配给第三组，以此类推
注意，最后一组的长度可能小于或者等于 1 + 倒数第二组的长度 。
反转 每个 偶数 长度组中的节点，并返回修改后链表的头节点 head 。
  示例 1：
输入：head = [5,2,6,3,9,1,7,3,8,4]
输出：[5,6,2,3,9,1,4,8,3,7]
解释：
- 第一组长度为 1 ，奇数，没有发生反转。
- 第二组长度为 2 ，偶数，节点反转。
- 第三组长度为 3 ，奇数，没有发生反转。
- 最后一组长度为 4 ，偶数，节点反转。
示例 2：
输入：head = [1,1,0,6]
输出：[1,0,1,6]
解释：
- 第一组长度为 1 ，没有发生反转。
- 第二组长度为 2 ，节点反转。
- 最后一组长度为 1 ，没有发生反转。
示例 3：
输入：head = [2,1]
输出：[2,1]
解释：
- 第一组长度为 1 ，没有发生反转。
- 最后一组长度为 1 ，没有发生反转。
  提示：
链表中节点数目范围是 [1, 105]
0 <= Node.val <= 105",15,,4975,['https://leetcode.cn/tag/linked-list/'],[],11499
评论 (42),decode-the-slanted-ciphertext,中等,"字符串 originalText 使用 斜向换位密码 ，经由 行数固定 为 rows 的矩阵辅助，加密得到一个字符串 encodedText 。
originalText 先按从左上到右下的方式放置到矩阵中。
先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 originalText 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 ' ' 进行填充。矩阵的列数需满足：用 originalText 填充之后，最右侧列 不为空 。
接着按行将字符附加到矩阵中，构造 encodedText 。
先把蓝色单元格中的字符附加到 encodedText 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。
例如，如果 originalText = ""cipher"" 且 rows = 3 ，那么我们可以按下述方法将其编码：
蓝色箭头标识 originalText 是如何放入矩阵中的，红色箭头标识形成 encodedText 的顺序。在上述例子中，encodedText = ""ch   ie   pr"" 。
给你编码后的字符串 encodedText 和矩阵的行数 rows ，返回源字符串 originalText 。
注意：originalText 不 含任何尾随空格 ' ' 。生成的测试用例满足 仅存在一个 可能的 originalText 。
  示例 1：
输入：encodedText = ""ch   ie   pr"", rows = 3
输出：""cipher""
解释：此示例与问题描述中的例子相同。
示例 2：
输入：encodedText = ""iveo    eed   l te   olc"", rows = 4
输出：""i love leetcode""
解释：上图标识用于编码 originalText 的矩阵。 
蓝色箭头展示如何从 encodedText 找到 originalText 。
示例 3：
输入：encodedText = ""coding"", rows = 1
输出：""coding""
解释：由于只有 1 行，所以 originalText 和 encodedText 是相同的。
示例 4：
输入：encodedText = "" b  ac"", rows = 2
输出："" abc""
解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。
  提示：
0 <= encodedText.length <= 106
encodedText 仅由小写英文字母和 ' ' 组成
encodedText 是对某个 不含 尾随空格的 originalText 的一个有效编码
1 <= rows <= 1000
生成的测试用例满足 仅存在一个 可能的 originalText",7,https://assets.leetcode.com/uploads/2021/11/07/exa11.png,3807,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],8232
评论 (43),process-restricted-friend-requests,困难,"给你一个整数 n ，表示网络上的用户数目。每个用户按从 0 到 n - 1 进行编号。
给你一个下标从 0 开始的二维整数数组 restrictions ，其中 restrictions[i] = [xi, yi] 意味着用户 xi 和用户 yi 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。
最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 requests 表示好友请求的列表，其中 requests[j] = [uj, vj] 是用户 uj 和用户 vj 之间的一条好友请求。
如果 uj 和 vj 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，requests[j] 会在 requests[j + 1] 前）。一旦请求成功，那么对所有未来的好友请求而言， uj 和 vj 将会 成为直接朋友 。
返回一个 布尔数组 result ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 result[j] 就是 true ；否则，为 false 。
注意：如果 uj 和 vj 已经是直接朋友，那么他们之间的请求将仍然 成功 。
  示例 1：
输入：n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]
输出：[true,false]
解释：
请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。
示例 2：
输入：n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]
输出：[true,false]
解释：
请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。
示例 3：
输入：n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]
输出：[true,false,true,false]
解释：
请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。
请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 
请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。
  提示：
2 <= n <= 1000
0 <= restrictions.length <= 1000
restrictions[i].length == 2
0 <= xi, yi <= n - 1
xi != yi
1 <= requests.length <= 1000
requests[j].length == 2
0 <= uj, vj <= n - 1
uj != vj",25,,2975,"['https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/']",[],5938
评论 (5),paths-in-maze-that-lead-to-same-room,Unknown,,-1,,-1,[],[],-1
评论 (51),two-furthest-houses-with-different-colors,简单,"街上有 n 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 0 开始且长度为 n 的整数数组 colors ，其中 colors[i] 表示第  i 栋房子的颜色。
返回 两栋 颜色 不同 房子之间的 最大 距离。
第 i 栋房子和第 j 栋房子之间的距离是 abs(i - j) ，其中 abs(x) 是 x 的绝对值。
  示例 1：
输入：colors = [1,1,1,6,1,1,1]
输出：3
解释：上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。
两栋颜色不同且距离最远的房子是房子 0 和房子 3 。
房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。
注意，房子 3 和房子 6 也可以产生最佳答案。
示例 2：
输入：colors = [1,8,3,8,3]
输出：4
解释：上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。
两栋颜色不同且距离最远的房子是房子 0 和房子 4 。
房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。
示例 3：
输入：colors = [0,1]
输出：1
解释：两栋颜色不同且距离最远的房子是房子 0 和房子 1 。
房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。
  提示：
n == colors.length
2 <= n <= 100
0 <= colors[i] <= 100
生成的测试数据满足 至少 存在 2 栋颜色不同的房子",14,,8716,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],11874
评论 (71),watering-plants,中等,"你打算用一个水罐给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。x = -1 处有一条河，你可以在那里重新灌满你的水罐。
每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：
按从左到右的顺序给植物浇水。
在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。
你 不能 提前重新灌满水罐。
最初，你在河边（也就是，x = -1），在 x 轴上每移动 一个单位 都需要 一步 。
给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有一个整数 capacity 表示水罐的容量，返回浇灌所有植物需要的 步数 。
  示例 1：
输入：plants = [2,2,3,3], capacity = 5
输出：14
解释：从河边开始，此时水罐是装满的：
- 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。
- 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。
- 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。
- 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。
- 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。
- 走到植物 3 (4 步) ，浇水。
需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。
示例 2：
输入：plants = [1,1,1,4,2,3], capacity = 4
输出：30
解释：从河边开始，此时水罐是装满的：
- 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。
- 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。
- 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。
- 走到植物 5 (6 步) ，浇水。
需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。
示例 3：
输入：plants = [7,7,7,7,7,7,7], capacity = 8
输出：49
解释：每次浇水都需要重新灌满水罐。
需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。
  提示：
n == plants.length
1 <= n <= 1000
1 <= plants[i] <= 106
max(plants[i]) <= capacity <= 109",11,,6698,['https://leetcode.cn/tag/array/'],[],8579
评论 (76),range-frequency-queries,中等,"请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。
子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。
请你实现 RangeFreqQuery 类：
RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。
int query(int left, int right, int value) 返回子数组 arr[left...right] 中 value 的 频率 。
一个 子数组 指的是数组中一段连续的元素。arr[left...right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。
  示例 1：
输入：
[""RangeFreqQuery"", ""query"", ""query""]
[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
输出：
[null, 1, 2]

解释：
RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);
rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。
rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。
  提示：
1 <= arr.length <= 105
1 <= arr[i], value <= 104
0 <= left <= right < arr.length
调用 query 不超过 105 次。",36,,6641,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/']",[],22602
评论 (54),sum-of-k-mirror-numbers,困难,"一个 k 镜像数字 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 没有前导 0 的 正 整数。
比方说，9 是一个 2 镜像数字。9 在十进制下为 9 ，二进制下为 1001 ，两者从前往后读和从后往前读都一样。
相反地，4 不是一个 2 镜像数字。4 在二进制下为 100 ，从前往后和从后往前读不相同。
给你进制 k 和一个数字 n ，请你返回 k 镜像数字中 最小 的 n 个数 之和 。
  示例 1：
输入：k = 2, n = 5
输出：25
解释：
最小的 5 个 2 镜像数字和它们的二进制表示如下：
  十进制       二进制
    1          1
    3          11
    5          101
    7          111
    9          1001
它们的和为 1 + 3 + 5 + 7 + 9 = 25 。
示例 2：
输入：k = 3, n = 7
输出：499
解释：
7 个最小的 3 镜像数字和它们的三进制表示如下：
  十进制       三进制
    1          1
    2          2
    4          11
    8          22
    121        11111
    151        12121
    212        21212
它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。
示例 3：
输入：k = 7, n = 17
输出：20379000
解释：17 个最小的 7 镜像数字分别为：
1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596
  提示：
2 <= k <= 9
1 <= n <= 30",23,,2717,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/']",[],6453
评论 (24),the-number-of-rich-customers,Unknown,,-1,,-1,[],[],-1
评论 (6),substrings-that-begin-and-end-with-the-same-letter,Unknown,,-1,,-1,[],[],-1
评论 (45),drop-type-1-orders-for-customers-with-type-0-orders,Unknown,,-1,,-1,[],[],-1
评论 (39),count-common-words-with-one-occurrence,简单,"给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。
  示例 1：
输入：words1 = [""leetcode"",""is"",""amazing"",""as"",""is""], words2 = [""amazing"",""leetcode"",""is""]
输出：2
解释：
- ""leetcode"" 在两个数组中都恰好出现一次，计入答案。
- ""amazing"" 在两个数组中都恰好出现一次，计入答案。
- ""is"" 在两个数组中都出现过，但在 words1 中出现了 2 次，不计入答案。
- ""as"" 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。
所以，有 2 个字符串在两个数组中都恰好出现了一次。
示例 2：
输入：words1 = [""b"",""bb"",""bbb""], words2 = [""a"",""aa"",""aaa""]
输出：0
解释：没有字符串在两个数组中都恰好出现一次。
示例 3：
输入：words1 = [""a"",""ab""], words2 = [""a"",""a"",""a"",""ab""]
输出：1
解释：唯一在两个数组中都出现一次的字符串是 ""ab"" 。
  提示：
1 <= words1.length, words2.length <= 1000
1 <= words1[i].length, words2[j].length <= 30
words1[i] 和 words2[j] 都只包含小写英文字母。",4,,5598,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],7723
评论 (44),minimum-number-of-buckets-required-to-collect-rainwater-from-houses,中等,"给你一个下标从 0 开始的字符串 street 。street 中每个字符要么是表示房屋的 'H' ，要么是表示空位的 '.' 。
你可以在 空位 放置水桶，从相邻的房屋收集雨水。位置在 i - 1 或者 i + 1 的水桶可以收集位置为 i 处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。
在确保 每个 房屋旁边都 至少 有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 -1 。
  示例 1：
输入：street = ""H..H""
输出：2
解释：
我们可以在下标为 1 和 2 处放水桶。
""H..H"" -> ""HBBH""（'B' 表示放置水桶）。
下标为 0 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。
所以每个房屋旁边都至少有一个水桶收集雨水。
示例 2：
输入：street = "".H.H.""
输出：1
解释：
我们可以在下标为 2 处放置一个水桶。
"".H.H."" -> "".HBH.""（'B' 表示放置水桶）。
下标为 1 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。
所以每个房屋旁边都至少有一个水桶收集雨水。
示例 3：
输入：street = "".HHH.""
输出：-1
解释：
没有空位可以放置水桶收集下标为 2 处的雨水。
所以没有办法收集所有房屋的雨水。
示例 4：
输入：street = ""H""
输出：-1
解释：
没有空位放置水桶。
所以没有办法收集所有房屋的雨水。
示例 5：
输入：street = "".""
输出：0
解释：
没有房屋需要收集雨水。
所以需要 0 个水桶。
  提示：
1 <= street.length <= 105
street[i] 要么是 'H' ，要么是 '.' 。",18,,3887,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],8553
评论 (59),minimum-cost-homecoming-of-a-robot-in-a-grid,中等,"给你一个 m x n 的网格图，其中 (0, 0) 是最左上角的格子，(m - 1, n - 1) 是最右下角的格子。给你一个整数数组 startPos ，startPos = [startrow, startcol] 表示 初始 有一个 机器人 在格子 (startrow, startcol) 处。同时给你一个整数数组 homePos ，homePos = [homerow, homecol] 表示机器人的 家 在格子 (homerow, homecol) 处。
机器人需要回家。每一步它可以往四个方向移动：上，下，左，右，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从 0 开始的额整数数组：长度为 m 的数组 rowCosts  和长度为 n 的数组 colCosts 。
如果机器人往 上 或者往 下 移动到第 r 行 的格子，那么代价为 rowCosts[r] 。
如果机器人往 左 或者往 右 移动到第 c 列 的格子，那么代价为 colCosts[c] 。
请你返回机器人回家需要的 最小总代价 。
  示例 1：
输入：startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]
输出：18
解释：一个最优路径为：
从 (1, 0) 开始
-> 往下走到 (2, 0) 。代价为 rowCosts[2] = 3 。
-> 往右走到 (2, 1) 。代价为 colCosts[1] = 2 。
-> 往右走到 (2, 2) 。代价为 colCosts[2] = 6 。
-> 往右走到 (2, 3) 。代价为 colCosts[3] = 7 。
总代价为 3 + 2 + 6 + 7 = 18
示例 2：
输入：startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]
输出：0
解释：机器人已经在家了，所以不需要移动。总代价为 0 。
  提示：
m == rowCosts.length
n == colCosts.length
1 <= m, n <= 105
0 <= rowCosts[r], colCosts[c] <= 104
startPos.length == 2
homePos.length == 2
0 <= startrow, homerow < m
0 <= startcol, homecol < n",7,,2912,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],6009
评论 (25),count-fertile-pyramids-in-a-land,困难,"有一个 矩形网格 状的农场，划分为 m 行 n 列的单元格。每个格子要么是 肥沃的 （用 1 表示），要么是 贫瘠 的（用 0 表示）。网格图以外的所有与格子都视为贫瘠的。
农场中的 金字塔 区域定义如下：
区域内格子数目 大于 1 且所有格子都是 肥沃的 。
金字塔 顶端 是这个金字塔 最上方 的格子。金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r <= i <= r + h - 1 且 c - (i - r) <= j <= c + (i - r) 。
一个 倒金字塔 类似定义如下：
区域内格子数目 大于 1 且所有格子都是 肥沃的 。
倒金字塔的 顶端 是这个倒金字塔 最下方 的格子。倒金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r - h + 1 <= i <= r 且 c - (r - i) <= j <= c + (r - i) 。
下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。
给你一个下标从 0 开始且大小为 m x n 的二进制矩阵 grid ，它表示农场，请你返回 grid 中金字塔和倒金字塔的 总数目 。
  示例 1：
   输入：grid = [[0,1,1,0],[1,1,1,1]]
输出：2
解释：
2 个可能的金字塔区域分别如上图蓝色和红色区域所示。
这个网格图中没有倒金字塔区域。
所以金字塔区域总数为 2 + 0 = 2 。
示例 2：
   输入：grid = [[1,1,1],[1,1,1]]
输出：2
解释：
金字塔区域如上图蓝色区域所示，倒金字塔如上图红色区域所示。
所以金字塔区域总数目为 1 + 1 = 2 。
示例 3：
输入：grid = [[1,0,1],[0,0,0],[1,0,1]]
输出：0
解释：
网格图中没有任何金字塔或倒金字塔区域。
示例 4：
    输入：grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
输出：13
解释：
有 7 个金字塔区域。上图第二和第三张图中展示了它们中的 3 个。
有 6 个倒金字塔区域。上图中最后一张图展示了它们中的 2 个。
所以金字塔区域总数目为 7 + 6 = 13.
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 1000
1 <= m * n <= 105
grid[i][j] 要么是 0 ，要么是 1 。",14,,1872,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],2993
评论 (57),find-target-indices-after-sorting-array,简单,"给你一个下标从 0 开始的整数数组 nums 以及一个目标元素 target 。
目标下标 是一个满足 nums[i] == target 的下标 i 。
将 nums 按 非递减 顺序排序后，返回由 nums 中目标下标组成的列表。如果不存在目标下标，返回一个 空 列表。返回的列表必须按 递增 顺序排列。
  示例 1：
输入：nums = [1,2,5,2,3], target = 2
输出：[1,2]
解释：排序后，nums 变为 [1,2,2,3,5] 。
满足 nums[i] == 2 的下标是 1 和 2 。
示例 2：
输入：nums = [1,2,5,2,3], target = 3
输出：[3]
解释：排序后，nums 变为 [1,2,2,3,5] 。
满足 nums[i] == 3 的下标是 3 。
示例 3：
输入：nums = [1,2,5,2,3], target = 5
输出：[4]
解释：排序后，nums 变为 [1,2,2,3,5] 。
满足 nums[i] == 5 的下标是 4 。
示例 4：
输入：nums = [1,2,5,2,3], target = 4
输出：[]
解释：nums 中不含值为 4 的元素。
  提示：
1 <= nums.length <= 100
1 <= nums[i], target <= 100",15,,11635,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],14389
评论 (52),k-radius-subarray-averages,中等,"给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。
半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。
构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。
x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。
例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。
  示例 1：
输入：nums = [7,4,3,9,1,8,5,2,6], k = 3
输出：[-1,-1,-1,5,4,4,-1,-1,-1]
解释：
- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。
- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。
  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。
- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。
- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。
- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。
示例 2：
输入：nums = [100000], k = 0
输出：[100000]
解释：
- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。
  avg[0] = 100000 / 1 = 100000 。
示例 3：
输入：nums = [8], k = 100000
输出：[-1]
解释：
- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。
  提示：
n == nums.length
1 <= n <= 105
0 <= nums[i], k <= 105",13,,6447,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/']",[],17936
评论 (51),removing-minimum-and-maximum-from-array,中等,"给你一个下标从 0 开始的数组 nums ，数组由若干 互不相同 的整数组成。
nums 中有一个值最小的元素和一个值最大的元素。分别称为 最小值 和 最大值 。你的目标是从数组中移除这两个元素。
一次 删除 操作定义为从数组的 前面 移除一个元素或从数组的 后面 移除一个元素。
返回将数组中最小值和最大值 都 移除需要的最小删除次数。
  示例 1：
输入：nums = [2,10,7,5,4,1,8,6]
输出：5
解释：
数组中的最小元素是 nums[5] ，值为 1 。
数组中的最大元素是 nums[1] ，值为 10 。
将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。
结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。
示例 2：
输入：nums = [0,-4,19,1,8,-2,-3,5]
输出：3
解释：
数组中的最小元素是 nums[1] ，值为 -4 。
数组中的最大元素是 nums[2] ，值为 19 。
将最大值和最小值都移除需要从数组前面移除 3 个元素。
结果是 3 ，这是所有可能情况中的最小删除次数。 
示例 3：
输入：nums = [101]
输出：1
解释：
数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。
移除它只需要 1 次删除操作。
  提示：
1 <= nums.length <= 105
-105 <= nums[i] <= 105
nums 中的整数 互不相同",9,,6511,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],11467
评论 (115),find-all-people-with-secret,困难,"给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号。另外给你一个下标从 0 开始的二维整数数组 meetings ，其中 meetings[i] = [xi, yi, timei] 表示专家 xi 和专家 yi 在时间 timei 要开一场会。一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson 。
专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密，那么他将会与专家 yi 分享这个秘密，反之亦然。
秘密共享是 瞬时发生 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。
在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 任何顺序 返回答案。
  示例 1：
输入：n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
输出：[0,1,2,3,5]
解释：
时间 0 ，专家 0 将秘密与专家 1 共享。
时间 5 ，专家 1 将秘密与专家 2 共享。
时间 8 ，专家 2 将秘密与专家 3 共享。
时间 10 ，专家 1 将秘密与专家 5 共享。
因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。
示例 2：
输入：n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
输出：[0,1,3]
解释：
时间 0 ，专家 0 将秘密与专家 3 共享。
时间 2 ，专家 1 与专家 2 都不知晓这个秘密。
时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。
因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。
示例 3：
输入：n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
输出：[0,1,2,3,4]
解释：
时间 0 ，专家 0 将秘密与专家 1 共享。
时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。
注意，专家 2 可以在收到秘密的同一时间分享此秘密。
时间 2 ，专家 3 将秘密与专家 4 共享。
因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。
  提示：
2 <= n <= 105
1 <= meetings.length <= 105
meetings[i].length == 3
0 <= xi, yi <= n - 1
xi != yi
1 <= timei <= 105
1 <= firstPerson <= n - 1",28,,4670,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/sorting/']",[],16863
评论 (10),minimum-cost-to-reach-city-with-discounts,Unknown,,-1,,-1,[],[],-1
评论 (87),finding-3-digit-even-numbers,简单,"给你一个整数数组 digits ，其中每个元素是一个数字（0 - 9）。数组中可能存在重复元素。
你需要找出 所有 满足下述条件且 互不相同 的整数：
该整数由 digits 中的三个元素按 任意 顺序 依次连接 组成。
该整数不含 前导零
该整数是一个 偶数
例如，给定的 digits 是 [1, 2, 3] ，整数 132 和 312 满足上面列出的全部条件。
将找出的所有互不相同的整数按 递增顺序 排列，并以数组形式返回。
  示例 1：
输入：digits = [2,1,3,0]
输出：[102,120,130,132,210,230,302,310,312,320]
解释：
所有满足题目条件的整数都在输出数组中列出。 
注意，答案数组中不含有 奇数 或带 前导零 的整数。
示例 2：
输入：digits = [2,2,8,8,2]
输出：[222,228,282,288,822,828,882]
解释：
同样的数字（0 - 9）在构造整数时可以重复多次，重复次数最多与其在 digits 中出现的次数一样。 
在这个例子中，数字 8 在构造 288、828 和 882 时都重复了两次。 
示例 3：
输入：digits = [3,7,5]
输出：[]
解释：
使用给定的 digits 无法构造偶数。
  提示：
3 <= digits.length <= 100
0 <= digits[i] <= 9",16,,8277,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/enumeration/', 'https://leetcode.cn/tag/sorting/']",[],14897
评论 (51),delete-the-middle-node-of-a-linked-list,中等,"给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。
长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。
对于 n = 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。
  示例 1：
输入：head = [1,3,4,7,1,2,6]
输出：[1,3,4,1,2,6]
解释：
上图表示给出的链表。节点的下标分别标注在每个节点的下方。
由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。
返回结果为移除节点后的新链表。 
示例 2：
输入：head = [1,2,3,4]
输出：[1,2,4]
解释：
上图表示给出的链表。
对于 n = 4 ，值为 3 的节点 2 是中间节点，用红色标注。
示例 3：
输入：head = [2,1]
输出：[2]
解释：
上图表示给出的链表。
对于 n = 2 ，值为 1 的节点 1 是中间节点，用红色标注。
值为 2 的节点 0 是移除节点 1 后剩下的唯一一个节点。
  提示：
链表中节点的数目在范围 [1, 105] 内
1 <= Node.val <= 105",18,,9144,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],15625
评论 (98),step-by-step-directions-from-a-binary-tree-node-to-another,中等,"给你一棵 二叉树 的根节点 root ，这棵二叉树总共有 n 个节点。每个节点的值为 1 到 n 中的一个整数，且互不相同。给你一个整数 startValue ，表示起点节点 s 的值，和另一个不同的整数 destValue ，表示终点节点 t 的值。
请找到从节点 s 到节点 t 的 最短路径 ，并以字符串的形式返回每一步的方向。每一步用 大写 字母 'L' ，'R' 和 'U' 分别表示一种方向：
'L' 表示从一个节点前往它的 左孩子 节点。
'R' 表示从一个节点前往它的 右孩子 节点。
'U' 表示从一个节点前往它的 父 节点。
请你返回从 s 到 t 最短路径 每一步的方向。
  示例 1：
输入：root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
输出：""UURL""
解释：最短路径为：3 → 1 → 5 → 2 → 6 。
示例 2：
输入：root = [2,1], startValue = 2, destValue = 1
输出：""L""
解释：最短路径为：2 → 1 。
  提示：
树中节点数目为 n 。
2 <= n <= 105
1 <= Node.val <= n
树中所有节点的值 互不相同 。
1 <= startValue, destValue <= n
startValue != destValue",34,,5457,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-tree/']",[],12888
评论 (60),valid-arrangement-of-pairs,困难,"给你一个下标从 0 开始的二维整数数组 pairs ，其中 pairs[i] = [starti, endi] 。如果 pairs 的一个重新排列，满足对每一个下标 i （ 1 <= i < pairs.length ）都有 endi-1 == starti ，那么我们就认为这个重新排列是 pairs 的一个 合法重新排列 。
请你返回 任意一个 pairs 的合法重新排列。
注意：数据保证至少存在一个 pairs 的合法重新排列。
  示例 1：
输入：pairs = [[5,1],[4,5],[11,9],[9,4]]
输出：[[11,9],[9,4],[4,5],[5,1]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 9 == 9 = start1 
end1 = 4 == 4 = start2
end2 = 5 == 5 = start3
示例 2：
输入：pairs = [[1,3],[3,2],[2,1]]
输出：[[1,3],[3,2],[2,1]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 3 == 3 = start1
end1 = 2 == 2 = start2
重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。
示例 3：
输入：pairs = [[1,2],[1,3],[2,1]]
输出：[[1,2],[2,1],[1,3]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 2 == 2 = start1
end1 = 1 == 1 = start2
  提示：
1 <= pairs.length <= 105
pairs[i].length == 2
0 <= starti, endi <= 109
starti != endi
pairs 中不存在一模一样的数对。
至少 存在 一个合法的 pairs 重新排列。",33,,2193,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/eulerian-circuit/']",[],6029
评论 (3),subsequence-of-size-k-with-the-largest-even-sum,Unknown,,-1,,-1,[],[],-1
评论 (68),find-subsequence-of-length-k-with-the-largest-sum,简单,"给你一个整数数组 nums 和一个整数 k 。你需要找到 nums 中长度为 k 的 子序列 ，且这个子序列的 和最大 。
请你返回 任意 一个长度为 k 的整数子序列。
子序列 定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。
  示例 1：
输入：nums = [2,1,3,3], k = 2
输出：[3,3]
解释：
子序列有最大和：3 + 3 = 6 。
示例 2：
输入：nums = [-1,-2,3,4], k = 3
输出：[-1,3,4]
解释：
子序列有最大和：-1 + 3 + 4 = 6 。
示例 3：
输入：nums = [3,4,3,3], k = 2
输出：[3,4]
解释：
子序列有最大和：3 + 4 = 7 。
另一个可行的子序列为 [4, 3] 。
  提示：
1 <= nums.length <= 1000
-105 <= nums[i] <= 105
1 <= k <= nums.length",18,,5897,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],12114
评论 (368),find-good-days-to-rob-the-bank,中等,"你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。
如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子：
第 i 天前和后都分别至少有 time 天。
第 i 天前连续 time 天警卫数目都是非递增的。
第 i 天后连续 time 天警卫数目都是非递减的。
更正式的，第 i 天是一个合适打劫银行的日子当且仅当：security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].
请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。
  示例 1：
输入：security = [5,3,3,3,5,6,2], time = 2
输出：[2,3]
解释：
第 2 天，我们有 security[0] >= security[1] >= security[2] <= security[3] <= security[4] 。
第 3 天，我们有 security[1] >= security[2] >= security[3] <= security[4] <= security[5] 。
没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。
示例 2：
输入：security = [1,1,1,1,1], time = 0
输出：[0,1,2,3,4]
解释：
因为 time 等于 0 ，所以每一天都是适合打劫银行的日子，所以返回每一天。
示例 3：
输入：security = [1,2,3,4,5,6], time = 2
输出：[]
解释：
没有任何一天的前 2 天警卫数目是非递增的。
所以没有适合打劫银行的日子，返回空数组。
  提示：
1 <= security.length <= 105
0 <= security[i], time <= 105",129,,32316,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/prefix-sum/']",[],66422
评论 (68),detonate-the-maximum-bombs,中等,"给你一个炸弹列表。一个炸弹的 爆炸范围 定义为以炸弹为圆心的一个圆。
炸弹用一个下标从 0 开始的二维整数数组 bombs 表示，其中 bombs[i] = [xi, yi, ri] 。xi 和 yi 表示第 i 个炸弹的 X 和 Y 坐标，ri 表示爆炸范围的 半径 。
你需要选择引爆 一个 炸弹。当这个炸弹被引爆时，所有 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。
给你数组 bombs ，请你返回在引爆 一个 炸弹的前提下，最多 能引爆的炸弹数目。
  示例 1：
输入：bombs = [[2,1,3],[6,1,4]]
输出：2
解释：
上图展示了 2 个炸弹的位置和爆炸范围。
如果我们引爆左边的炸弹，右边的炸弹不会被影响。
但如果我们引爆右边的炸弹，两个炸弹都会爆炸。
所以最多能引爆的炸弹数目是 max(1, 2) = 2 。
示例 2：
输入：bombs = [[1,1,5],[10,10,5]]
输出：1
解释：
引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 1 。
示例 3：
输入：bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
输出：5
解释：
最佳引爆炸弹为炸弹 0 ，因为：
- 炸弹 0 引爆炸弹 1 和 2 。红色圆表示炸弹 0 的爆炸范围。
- 炸弹 2 引爆炸弹 3 。蓝色圆表示炸弹 2 的爆炸范围。
- 炸弹 3 引爆炸弹 4 。绿色圆表示炸弹 3 的爆炸范围。
所以总共有 5 个炸弹被引爆。
  提示：
1 <= bombs.length <= 100
bombs[i].length == 3
1 <= xi, yi, ri <= 105",20,,3562,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],9158
评论 (56),sequentially-ordinal-rank-tracker,困难,"一个观光景点由它的名字 name 和景点评分 score 组成，其中 name 是所有观光景点中 唯一 的字符串，score 是一个整数。景点按照最好到最坏排序。景点评分 越高 ，这个景点越好。如果有两个景点的评分一样，那么 字典序较小 的景点更好。
你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：
添加 景点，每次添加 一个 景点。
查询 已经添加景点中第 i 好 的景点，其中 i 是系统目前位置查询的次数（包括当前这一次）。
比方说，如果系统正在进行第 4 次查询，那么需要返回所有已经添加景点中第 4 好的。
注意，测试数据保证 任意查询时刻 ，查询次数都 不超过 系统中景点的数目。
请你实现 SORTracker 类：
SORTracker() 初始化系统。
void add(string name, int score) 向系统中添加一个名为 name 评分为 score 的景点。
string get() 查询第 i 好的景点，其中 i 是目前系统查询的次数（包括当前这次查询）。
  示例：
输入：
[""SORTracker"", ""add"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""get""]
[[], [""bradford"", 2], [""branford"", 3], [], [""alps"", 2], [], [""orland"", 2], [], [""orlando"", 3], [], [""alpine"", 2], [], []]
输出：
[null, null, null, ""branford"", null, ""alps"", null, ""bradford"", null, ""bradford"", null, ""bradford"", ""orland""]

解释：
SORTracker tracker = new SORTracker(); // 初始化系统
tracker.add(""bradford"", 2); // 添加 name=""bradford"" 且 score=2 的景点。
tracker.add(""branford"", 3); // 添加 name=""branford"" 且 score=3 的景点。
tracker.get();              // 从好带坏的景点为：branford ，bradford 。
                            // 注意到 branford 比 bradford 好，因为它的 评分更高 (3 > 2) 。
                            // 这是第 1 次调用 get() ，所以返回最好的景点：""branford"" 。
tracker.add(""alps"", 2);     // 添加 name=""alps"" 且 score=2 的景点。
tracker.get();              // 从好到坏的景点为：branford, alps, bradford 。
                            // 注意 alps 比 bradford 好，虽然它们评分相同，都为 2 。
                            // 这是因为 ""alps"" 字典序 比 ""bradford"" 小。
                            // 返回第 2 好的地点 ""alps"" ，因为当前为第 2 次调用 get() 。
tracker.add(""orland"", 2);   // 添加 name=""orland"" 且 score=2 的景点。
tracker.get();              // 从好到坏的景点为：branford, alps, bradford, orland 。
                            // 返回 ""bradford"" ，因为当前为第 3 次调用 get() 。
tracker.add(""orlando"", 3);  // 添加 name=""orlando"" 且 score=3 的景点。
tracker.get();              // 从好到坏的景点为：branford, orlando, alps, bradford, orland 。
                            // 返回 ""bradford"".
tracker.add(""alpine"", 2);   // 添加 name=""alpine"" 且 score=2 的景点。
tracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。
                            // 返回 ""bradford"" 。
tracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。
                            // 返回 ""orland"" 。
  提示：
name 只包含小写英文字母，且每个景点名字互不相同。
1 <= name.length <= 10
1 <= score <= 105
任意时刻，调用 get 的次数都不超过调用 add 的次数。
总共 调用 add 和 get 不超过 4 * 104 ",23,,2295,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/data-stream/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],4293
评论 (69),rings-and-rods,简单,"总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 0 到 9 的杆上。
给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环：
第 i 对中的 第一个 字符表示第 i 个环的 颜色（'R'、'G'、'B'）。
第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（'0' 到 '9'）。
例如，""R3G2B1"" 表示：共有 n == 3 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。
找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。
  示例 1：
输入：rings = ""B0B6G0R6R0R6G9""
输出：1
解释：
- 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。
- 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。
- 编号 9 的杆上只有 1 个绿色环。
因此，集齐全部三种颜色环的杆的数目为 1 。
示例 2：
输入：rings = ""B0R0G0R9R0B0G0""
输出：1
解释：
- 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。
- 编号 9 的杆上只有 1 个红色环。
因此，集齐全部三种颜色环的杆的数目为 1 。
示例 3：
输入：rings = ""G4""
输出：0
解释：
只给了一个环，因此，不存在集齐全部三种颜色环的杆。
  提示：
rings.length == 2 * n
1 <= n <= 100
如 i 是 偶数 ，则 rings[i] 的值可以取 'R'、'G' 或 'B'（下标从 0 开始计数）
如 i 是 奇数 ，则 rings[i] 的值可以取 '0' 到 '9' 中的一个数字（下标从 0 开始计数）",13,https://assets.leetcode.com/uploads/2021/11/23/ex1final.png,8006,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],9975
评论 (314),sum-of-subarray-ranges,中等,"给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。
返回 nums 中 所有 子数组范围的 和 。
子数组是数组中一个连续 非空 的元素序列。
  示例 1：
输入：nums = [1,2,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0 
[2]，范围 = 2 - 2 = 0
[3]，范围 = 3 - 3 = 0
[1,2]，范围 = 2 - 1 = 1
[2,3]，范围 = 3 - 2 = 1
[1,2,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4
示例 2：
输入：nums = [1,3,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0
[3]，范围 = 3 - 3 = 0
[3]，范围 = 3 - 3 = 0
[1,3]，范围 = 3 - 1 = 2
[3,3]，范围 = 3 - 3 = 0
[1,3,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4
示例 3：
输入：nums = [4,-2,-3,4,1]
输出：59
解释：nums 中所有子数组范围的和是 59
  提示：
1 <= nums.length <= 1000
-109 <= nums[i] <= 109
  进阶：你可以设计一种时间复杂度为 O(n) 的解决方案吗？",196,,36322,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/monotonic-stack/']",[],57874
评论 (43),watering-plants-ii,中等,"Alice 和 Bob 打算给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。
每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，最初是满的 。他们按下面描述的方式完成浇水：
 Alice 按 从左到右 的顺序给植物浇水，从植物 0 开始。Bob 按 从右到左 的顺序给植物浇水，从植物 n - 1 开始。他们 同时 给植物浇水。
如果没有足够的水 完全 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。
不管植物需要多少水，浇水所耗费的时间都是一样的。
不能 提前重新灌满水罐。
每株植物都可以由 Alice 或者 Bob 来浇水。
如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。
给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。
  示例 1：
输入：plants = [2,2,3,3], capacityA = 5, capacityB = 5
输出：1
解释：
- 最初，Alice 和 Bob 的水罐中各有 5 单元水。
- Alice 给植物 0 浇水，Bob 给植物 3 浇水。
- Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。
- Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。
所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。
示例 2：
输入：plants = [2,2,3,3], capacityA = 3, capacityB = 4
输出：2
解释：
- 最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。
- Alice 给植物 0 浇水，Bob 给植物 3 浇水。
- Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。
- 由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。
所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。
示例 3：
输入：plants = [5], capacityA = 10, capacityB = 8
输出：0
解释：
- 只有一株植物
- Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。
所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。
  提示：
n == plants.length
1 <= n <= 105
1 <= plants[i] <= 106
max(plants[i]) <= capacityA, capacityB <= 109",3,,5413,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/simulation/']",[],9913
评论 (52),maximum-fruits-harvested-after-at-most-k-steps,困难,"在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。
另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。
返回你可以摘到水果的 最大总数 。
  示例 1：
输入：fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
输出：9
解释：
最佳路线为：
- 向右移动到位置 6 ，摘到 3 个水果
- 向右移动到位置 8 ，摘到 6 个水果
移动 3 步，共摘到 3 + 6 = 9 个水果
示例 2：
输入：fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
输出：14
解释：
可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。
最佳路线为：
- 在初始位置 5 ，摘到 7 个水果
- 向左移动到位置 4 ，摘到 1 个水果
- 向右移动到位置 6 ，摘到 2 个水果
- 向右移动到位置 7 ，摘到 4 个水果
移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果
示例 3：
输入：fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
输出：0
解释：
最多可以移动 k = 2 步，无法到达任一有水果的地方
  提示：
1 <= fruits.length <= 105
fruits[i].length == 2
0 <= startPos, positioni <= 2 * 105
对于任意 i > 0 ，positioni-1 < positioni 均成立（下标从 0 开始计数）
1 <= amounti <= 104
0 <= k <= 2 * 105",30,https://assets.leetcode.com/uploads/2021/11/21/1.png,3907,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",[],11817
评论 (7),number-of-unique-flavors-after-sharing-k-candies,Unknown,,-1,,-1,[],[],-1
评论 (49),find-first-palindromic-string-in-the-array,简单,"给你一个字符串数组 words ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 """" 。
回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串 。
  示例 1：
输入：words = [""abc"",""car"",""ada"",""racecar"",""cool""]
输出：""ada""
解释：第一个回文字符串是 ""ada"" 。
注意，""racecar"" 也是回文字符串，但它不是第一个。
示例 2：
输入：words = [""notapalindrome"",""racecar""]
输出：""racecar""
解释：第一个也是唯一一个回文字符串是 ""racecar"" 。
示例 3：
输入：words = [""def"",""ghi""]
输出：""""
解释：不存在回文字符串，所以返回一个空字符串。
  提示：
1 <= words.length <= 100
1 <= words[i].length <= 100
words[i] 仅由小写英文字母组成",7,,9527,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],12023
评论 (68),adding-spaces-to-a-string,中等,"给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces 。
数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。
例如，s = ""EnjoyYourCoffee"" 且 spaces = [5, 9] ，那么我们需要在 'Y' 和 'C' 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 ""Enjoy Your Coffee"" 。
请你添加空格，并返回修改后的字符串。
  示例 1：
输入：s = ""LeetcodeHelpsMeLearn"", spaces = [8,13,15]
输出：""Leetcode Helps Me Learn""
解释：
下标 8、13 和 15 对应 ""LeetcodeHelpsMeLearn"" 中加粗斜体字符。
接着在这些字符前添加空格。
示例 2：
输入：s = ""icodeinpython"", spaces = [1,5,7,9]
输出：""i code in py thon""
解释：
下标 1、5、7 和 9 对应 ""icodeinpython"" 中加粗斜体字符。
接着在这些字符前添加空格。
示例 3：
输入：s = ""spacing"", spaces = [0,1,2,3,4,5,6]
输出："" s p a c i n g""
解释：
字符串的第一个字符前可以添加空格。
  提示：
1 <= s.length <= 3 * 105
s 仅由大小写英文字母组成
1 <= spaces.length <= 3 * 105
0 <= spaces[i] <= s.length - 1
spaces 中的所有值 严格递增",12,,7647,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],12511
评论 (102),number-of-smooth-descent-periods-of-a-stock,中等,"给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。
一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。
请你返回 平滑下降阶段 的数目。
  示例 1：
输入：prices = [3,2,1,4]
输出：7
解释：总共有 7 个平滑下降阶段：
[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]
注意，仅一天按照定义也是平滑下降阶段。
示例 2：
输入：prices = [8,6,7,7]
输出：4
解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]
由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。
示例 3：
输入：prices = [1]
输出：1
解释：总共有 1 个平滑下降阶段：[1]
  提示：
1 <= prices.length <= 105
1 <= prices[i] <= 105",15,,7446,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],14341
评论 (77),minimum-operations-to-make-the-array-k-increasing,困难,"给你一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。
如果对于每个满足 k <= i <= n-1 的下标 i ，都有 arr[i-k] <= arr[i] ，那么我们称 arr 是 K 递增 的。
比方说，arr = [4, 1, 5, 2, 6, 2] 对于 k = 2 是 K 递增的，因为：
arr[0] <= arr[2] (4 <= 5)
arr[1] <= arr[3] (1 <= 2)
arr[2] <= arr[4] (5 <= 6)
arr[3] <= arr[5] (2 <= 2)
但是，相同的数组 arr 对于 k = 1 不是 K 递增的（因为 arr[0] > arr[1]），对于 k = 3 也不是 K 递增的（因为 arr[0] > arr[3] ）。
每一次 操作 中，你可以选择一个下标 i 并将 arr[i] 改成任意 正整数。
请你返回对于给定的 k ，使数组变成 K 递增的 最少操作次数 。
  示例 1：
输入：arr = [5,4,3,2,1], k = 1
输出：4
解释：
对于 k = 1 ，数组最终必须变成非递减的。
可行的 K 递增结果数组为 [5,6,7,8,9]，[1,1,1,1,1]，[2,2,3,4,4] 。它们都需要 4 次操作。
次优解是将数组变成比方说 [6,7,8,9,10] ，因为需要 5 次操作。
显然我们无法使用少于 4 次操作将数组变成 K 递增的。
示例 2：
输入：arr = [4,1,5,2,6,2], k = 2
输出：0
解释：
这是题目描述中的例子。
对于每个满足 2 <= i <= 5 的下标 i ，有 arr[i-2] <= arr[i] 。
由于给定数组已经是 K 递增的，我们不需要进行任何操作。
示例 3：
输入：arr = [4,1,5,2,6,2], k = 3
输出：2
解释：
下标 3 和 5 是仅有的 3 <= i <= 5 且不满足 arr[i-3] <= arr[i] 的下标。
将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。
数组变为 [4,1,5,4,6,5] 。
可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。
  提示：
1 <= arr.length <= 105
1 <= arr[i], k <= arr.length",43,,3906,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],11725
评论 (33),the-airport-with-the-most-traffic,Unknown,,-1,,-1,[],[],-1
评论 (6),elements-in-array-after-removing-and-replacing-elements,Unknown,,-1,,-1,[],[],-1
评论 (67),maximum-number-of-words-found-in-sentences,简单,"一个 句子 由一些 单词 以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。
给你一个字符串数组 sentences ，其中 sentences[i] 表示单个 句子 。
请你返回单个句子里 单词的最多数目 。
  示例 1：
输入：sentences = [""alice and bob love leetcode"", ""i think so too"", ""this is great thanks very much""]
输出：6
解释：
- 第一个句子 ""alice and bob love leetcode"" 总共有 5 个单词。
- 第二个句子 ""i think so too"" 总共有 4 个单词。
- 第三个句子 ""this is great thanks very much"" 总共有 6 个单词。
所以，单个句子中有最多单词数的是第三个句子，总共有 6 个单词。
示例 2：
输入：sentences = [""please wait"", ""continue to fight"", ""continue to win""]
输出：3
解释：可能有多个句子有相同单词数。
这个例子中，第二个句子和第三个句子（加粗斜体）有相同数目的单词数。
  提示：
1 <= sentences.length <= 100
1 <= sentences[i].length <= 100
sentences[i] 只包含小写英文字母和 ' ' 。
sentences[i] 的开头和结尾都没有空格。
sentences[i] 中所有单词由单个空格隔开。",14,,10979,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],12781
评论 (64),find-all-possible-recipes-from-given-supplies,中等,"你有 n 道不同菜的信息。给你一个字符串数组 recipes 和一个二维字符串数组 ingredients 。第 i 道菜的名字为 recipes[i] ，如果你有它 所有 的原材料 ingredients[i] ，那么你可以 做出 这道菜。一道菜的原材料可能是 另一道 菜，也就是说 ingredients[i] 可能包含 recipes 中另一个字符串。
同时给你一个字符串数组 supplies ，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。
请你返回你可以做出的所有菜。你可以以 任意顺序 返回它们。
注意两道菜在它们的原材料中可能互相包含。
  示例 1：
输入：recipes = [""bread""], ingredients = [[""yeast"",""flour""]], supplies = [""yeast"",""flour"",""corn""]
输出：[""bread""]
解释：
我们可以做出 ""bread"" ，因为我们有原材料 ""yeast"" 和 ""flour"" 。
示例 2：
输入：recipes = [""bread"",""sandwich""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""]], supplies = [""yeast"",""flour"",""meat""]
输出：[""bread"",""sandwich""]
解释：
我们可以做出 ""bread"" ，因为我们有原材料 ""yeast"" 和 ""flour"" 。
我们可以做出 ""sandwich"" ，因为我们有原材料 ""meat"" 且可以做出原材料 ""bread"" 。
示例 3：
输入：recipes = [""bread"",""sandwich"",""burger""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""],[""sandwich"",""meat"",""bread""]], supplies = [""yeast"",""flour"",""meat""]
输出：[""bread"",""sandwich"",""burger""]
解释：
我们可以做出 ""bread"" ，因为我们有原材料 ""yeast"" 和 ""flour"" 。
我们可以做出 ""sandwich"" ，因为我们有原材料 ""meat"" 且可以做出原材料 ""bread"" 。
我们可以做出 ""burger"" ，因为我们有原材料 ""meat"" 且可以做出原材料 ""bread"" 和 ""sandwich"" 。
示例 4：
输入：recipes = [""bread""], ingredients = [[""yeast"",""flour""]], supplies = [""yeast""]
输出：[]
解释：
我们没法做出任何菜，因为我们只有原材料 ""yeast"" 。
  提示：
n == recipes.length == ingredients.length
1 <= n <= 100
1 <= ingredients[i].length, supplies.length <= 100
1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10
recipes[i], ingredients[i][j] 和 supplies[k] 只包含小写英文字母。
所有 recipes 和 supplies 中的值互不相同。
ingredients[i] 中的字符串互不相同。",21,,4207,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],10844
评论 (34),check-if-a-parentheses-string-can-be-valid,中等,"一个括号字符串是只由 '(' 和 ')' 组成的 非空 字符串。如果一个字符串满足下面 任意 一个条件，那么它就是有效的：
字符串为 ().
它可以表示为 AB（A 与 B 连接），其中A 和 B 都是有效括号字符串。
它可以表示为 (A) ，其中 A 是一个有效括号字符串。
给你一个括号字符串 s 和一个字符串 locked ，两者长度都为 n 。locked 是一个二进制字符串，只包含 '0' 和 '1' 。对于 locked 中 每一个 下标 i ：
如果 locked[i] 是 '1' ，你 不能 改变 s[i] 。
如果 locked[i] 是 '0' ，你 可以 将 s[i] 变为 '(' 或者 ')' 。
如果你可以将 s 变为有效括号字符串，请你返回 true ，否则返回 false 。
  示例 1：
输入：s = ""))()))"", locked = ""010100""
输出：true
解释：locked[1] == '1' 和 locked[3] == '1' ，所以我们无法改变 s[1] 或者 s[3] 。
我们可以将 s[0] 和 s[4] 变为 '(' ，不改变 s[2] 和 s[5] ，使 s 变为有效字符串。
示例 2：
输入：s = ""()()"", locked = ""0000""
输出：true
解释：我们不需要做任何改变，因为 s 已经是有效字符串了。
示例 3：
输入：s = "")"", locked = ""0""
输出：false
解释：locked 允许改变 s[0] 。
但无论将 s[0] 变为 '(' 或者 ')' 都无法使 s 变为有效字符串。
  提示：
n == s.length == locked.length
1 <= n <= 105
s[i] 要么是 '(' 要么是 ')' 。
locked[i] 要么是 '0' 要么是 '1' 。",21,,2821,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],9311
评论 (27),abbreviating-the-product-of-a-range,困难,"给你两个正整数 left 和 right ，满足 left <= right 。请你计算 闭区间 [left, right] 中所有整数的 乘积 。
由于乘积可能非常大，你需要将它按照以下步骤 缩写 ：
统计乘积中 后缀 0 的数目，并 移除 这些 0 ，将这个数目记为 C 。
比方说，1000 中有 3 个后缀 0 ，546 中没有后缀 0 。
将乘积中剩余数字的位数记为 d 。如果 d > 10 ，那么将乘积表示为 <pre>...<suf> 的形式，其中 <pre> 表示乘积最 开始 的 5 个数位，<suf> 表示删除后缀 0 之后 结尾的 5 个数位。如果 d <= 10 ，我们不对它做修改。
比方说，我们将 1234567654321 表示为 12345...54321 ，但是 1234567 仍然表示为 1234567 。
最后，将乘积表示为 字符串 ""<pre>...<suf>eC"" 。
比方说，12345678987600000 被表示为 ""12345...89876e5"" 。
请你返回一个字符串，表示 闭区间 [left, right] 中所有整数 乘积 的 缩写 。
  示例 1：
输入：left = 1, right = 4
输出：""24e0""
解释：
乘积为 1 × 2 × 3 × 4 = 24 。
由于没有后缀 0 ，所以 24 保持不变，缩写的结尾为 ""e0"" 。
因为乘积的结果是 2 位数，小于 10 ，所欲我们不进一步将它缩写。
所以，最终将乘积表示为 ""24e0"" 。
示例 2：
输入：left = 2, right = 11
输出：""399168e2""
解释：乘积为 39916800 。
有 2 个后缀 0 ，删除后得到 399168 。缩写的结尾为 ""e2"" 。 
删除后缀 0 后是 6 位数，不需要进一步缩写。 
所以，最终将乘积表示为 ""399168e2"" 。
示例 3：
输入：left = 371, right = 375
输出：""7219856259e3""
解释：乘积为 7219856259000 。
  提示：
1 <= left <= right <= 104",6,,1204,['https://leetcode.cn/tag/math/'],[],3600
评论 (16),build-the-equation,Unknown,,-1,,-1,[],[],-1
评论 (82),a-number-after-a-double-reversal,简单,"反转 一个整数意味着倒置它的所有位。
例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。
给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。
  示例 1：
输入：num = 526
输出：true
解释：反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。
示例 2：
输入：num = 1800
输出：false
解释：反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。 
示例 3：
输入：num = 0
输出：true
解释：反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。
  提示：
0 <= num <= 106",12,,10062,['https://leetcode.cn/tag/math/'],[],13209
评论 (49),execution-of-all-suffix-instructions-staying-in-a-grid,中等,"现有一个 n x n 大小的网格，左上角单元格坐标 (0, 0) ，右下角单元格坐标 (n - 1, n - 1) 。给你整数 n 和一个整数数组 startPos ，其中 startPos = [startrow, startcol] 表示机器人最开始在坐标为 (startrow, startcol) 的单元格上。
另给你一个长度为 m 、下标从 0 开始的字符串 s ，其中 s[i] 是对机器人的第 i 条指令：'L'（向左移动），'R'（向右移动），'U'（向上移动）和 'D'（向下移动）。
机器人可以从 s 中的任一第 i 条指令开始执行。它将会逐条执行指令直到 s 的末尾，但在满足下述条件之一时，机器人将会停止：
下一条指令将会导致机器人移动到网格外。
没有指令可以执行。
返回一个长度为 m 的数组 answer ，其中 answer[i] 是机器人从第 i 条指令 开始 ，可以执行的 指令数目 。
  示例 1：
输入：n = 3, startPos = [0,1], s = ""RRDDLU""
输出：[1,5,4,3,1,0]
解释：机器人从 startPos 出发，并从第 i 条指令开始执行：
- 0: ""RRDDLU"" 在移动到网格外之前，只能执行一条 ""R"" 指令。
- 1:  ""RDDLU"" 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。
- 2:   ""DDLU"" 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。
- 3:    ""DLU"" 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。
- 4:     ""LU"" 在移动到网格外之前，只能执行一条 ""L"" 指令。
- 5:      ""U"" 如果向上移动，将会移动到网格外。
示例 2：
输入：n = 2, startPos = [1,1], s = ""LURD""
输出：[4,1,0,0]
解释：
- 0: ""LURD""
- 1:  ""URD""
- 2:   ""RD""
- 3:    ""D""
示例 3：
输入：n = 1, startPos = [0,0], s = ""LRUD""
输出：[0,0,0,0]
解释：无论机器人从哪条指令开始执行，都会移动到网格外。
  提示：
m == s.length
1 <= n, m <= 500
startPos.length == 2
0 <= startrow, startcol < n
s 由 'L'、'R'、'U' 和 'D' 组成",8,,6275,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],7616
评论 (98),intervals-between-identical-elements,中等,"给你一个下标从 0 开始、由 n 个整数组成的数组 arr 。
arr 中两个元素的 间隔 定义为它们下标之间的 绝对差 。更正式地，arr[i] 和 arr[j] 之间的间隔是 |i - j| 。
返回一个长度为 n 的数组 intervals ，其中 intervals[i] 是 arr[i] 和 arr 中每个相同元素（与 arr[i] 的值相同）的 间隔之和 。
注意：|x| 是 x 的绝对值。
  示例 1：
输入：arr = [2,1,3,1,2,3,3]
输出：[4,2,7,2,4,4,5]
解释：
- 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4
- 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2
- 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7
- 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2
- 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4
- 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4
- 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5
示例 2：
输入：arr = [10,5,10,10]
输出：[5,0,3,4]
解释：
- 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5
- 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0
- 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3
- 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4
  提示：
n == arr.length
1 <= n <= 105
1 <= arr[i] <= 105",39,,5303,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']",[],14451
评论 (44),recover-the-original-array,困难,"Alice 有一个下标从 0 开始的数组 arr ，由 n 个正整数组成。她会选择一个任意的 正整数 k 并按下述方式创建两个下标从 0 开始的新整数数组 lower 和 higher ：
对每个满足 0 <= i < n 的下标 i ，lower[i] = arr[i] - k
对每个满足 0 <= i < n 的下标 i ，higher[i] = arr[i] + k
不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 lower 和 higher 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。
给你一个由 2n 个整数组成的整数数组 nums ，其中 恰好 n 个整数出现在 lower ，剩下的出现在 higher ，还原并返回 原数组 arr 。如果出现答案不唯一的情况，返回 任一 有效数组。
注意：生成的测试用例保证存在 至少一个 有效数组 arr 。
  示例 1：
输入：nums = [2,10,6,4,8,12]
输出：[3,7,11]
解释：
如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。
组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。
另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。
示例 2：
输入：nums = [1,1,3,3]
输出：[2,2]
解释：
如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。
组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。
注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。
这种方案是无效的，k 必须是一个正整数。
示例 3：
输入：nums = [5,435]
输出：[220]
解释：
唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。
  提示：
2 * n == nums.length
1 <= n <= 1000
1 <= nums[i] <= 109
生成的测试用例保证存在 至少一个 有效数组 arr",26,,3301,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/enumeration/', 'https://leetcode.cn/tag/sorting/']",[],8093
评论 (1),minimum-operations-to-remove-adjacent-ones-in-matrix,Unknown,,-1,,-1,[],[],-1
评论 (75),check-if-all-as-appears-before-all-bs,简单,"给你一个 仅 由字符 'a' 和 'b' 组成的字符串  s 。如果字符串中 每个 'a' 都出现在 每个 'b' 之前，返回 true ；否则，返回 false 。
  示例 1：
输入：s = ""aaabbb""
输出：true
解释：
'a' 位于下标 0、1 和 2 ；而 'b' 位于下标 3、4 和 5 。
因此，每个 'a' 都出现在每个 'b' 之前，所以返回 true 。
示例 2：
输入：s = ""abab""
输出：false
解释：
存在一个 'a' 位于下标 2 ，而一个 'b' 位于下标 1 。
因此，不能满足每个 'a' 都出现在每个 'b' 之前，所以返回 false 。
示例 3：
输入：s = ""bbb""
输出：true
解释：
不存在 'a' ，因此可以视作每个 'a' 都出现在每个 'b' 之前，所以返回 true 。
  提示：
1 <= s.length <= 100
s[i] 为 'a' 或 'b'",5,,8659,['https://leetcode.cn/tag/string/'],[],12282
评论 (57),number-of-laser-beams-in-a-bank,中等,"银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 '0' 和若干 '1' 组成。'0' 表示单元格是空的，而 '1' 表示单元格有一个安全设备。
对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：
两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 < r2 。
满足 r1 < i < r2 的 所有 行 i ，都 没有安全设备 。
激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。
返回银行中激光束的总数量。
  示例 1：
输入：bank = [""011001"",""000000"",""010100"",""001000""]
输出：8
解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：
 * bank[0][1] -- bank[2][1]
 * bank[0][1] -- bank[2][3]
 * bank[0][2] -- bank[2][1]
 * bank[0][2] -- bank[2][3]
 * bank[0][5] -- bank[2][1]
 * bank[0][5] -- bank[2][3]
 * bank[2][1] -- bank[3][2]
 * bank[2][3] -- bank[3][2]
注意，第 0 行和第 3 行上的设备之间不存在激光束。
这是因为第 2 行存在安全设备，这不满足第 2 个条件。
示例 2：
输入：bank = [""000"",""111"",""000""]
输出：0
解释：不存在两个位于不同行的设备
  提示：
m == bank.length
n == bank[i].length
1 <= m, n <= 500
bank[i][j] 为 '0' 或 '1'",7,,7387,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/matrix/']",[],8821
评论 (63),destroying-asteroids,中等,"给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。
你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。
如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。
  示例 1：
输入：mass = 10, asteroids = [3,9,19,5,21]
输出：true
解释：一种安排小行星的方式为 [9,19,5,3,21] ：
- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19
- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38
- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43
- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46
- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67
所有小行星都被摧毁。
示例 2：
输入：mass = 5, asteroids = [4,9,23,4]
输出：false
解释：
行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。
行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。
它比 23 小，所以无法摧毁最后一颗小行星。
  提示：
1 <= mass <= 105
1 <= asteroids.length <= 105
1 <= asteroids[i] <= 105",10,,6849,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],14125
评论 (63),maximum-employees-to-be-invited-to-a-meeting,困难,"一个公司准备组织一场会议，邀请名单上有 n 位员工。公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工。
员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。
给你一个下标从 0 开始的整数数组 favorite ，其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。
  示例 1：
输入：favorite = [2,2,1,2]
输出：3
解释：
上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。
没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。
注意，公司也可以邀请员工 1，2 和 3 参加会议。
所以最多参加会议的员工数目为 3 。
示例 2：
输入：favorite = [1,2,0]
输出：3
解释：
每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。
座位安排同图 1 所示：
- 员工 0 坐在员工 2 和 1 之间。
- 员工 1 坐在员工 0 和 2 之间。
- 员工 2 坐在员工 1 和 0 之间。
参与会议的最多员工数目为 3 。
示例 3：
输入：favorite = [3,0,1,4,1]
输出：4
解释：
上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。
员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。
所以公司只能不邀请员工 2 。
参加会议的最多员工数目为 4 。
  提示：
n == favorite.length
2 <= n <= 105
0 <= favorite[i] <= n - 1
favorite[i] != i",54,,2422,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']",[],8051
评论 (8),remove-all-ones-with-row-and-column-flips,Unknown,,-1,,-1,[],[],-1
评论 (52),capitalize-the-title,简单,"给你一个字符串 title ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 大写 ：
如果单词的长度为 1 或者 2 ，所有字母变成小写。
否则，将单词首字母大写，剩余字母变成小写。
请你返回 大写后 的 title 。
  示例 1：
输入：title = ""capiTalIze tHe titLe""
输出：""Capitalize The Title""
解释：
由于所有单词的长度都至少为 3 ，将每个单词首字母大写，剩余字母变为小写。
示例 2：
输入：title = ""First leTTeR of EACH Word""
输出：""First Letter of Each Word""
解释：
单词 ""of"" 长度为 2 ，所以它保持完全小写。
其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。
示例 3：
输入：title = ""i lOve leetcode""
输出：""i Love Leetcode""
解释：
单词 ""i"" 长度为 1 ，所以它保留小写。
其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。
  提示：
1 <= title.length <= 100
title 由单个空格隔开的单词组成，且不含有任何前导或后缀空格。
每个单词由大写和小写英文字母组成，且都是 非空 的。",6,,5861,['https://leetcode.cn/tag/string/'],[],9549
评论 (37),maximum-twin-sum-of-a-linked-list,中等,"在一个大小为 n 且 n 为 偶数 的链表中，对于 0 <= i <= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。
比方说，n = 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n = 4 的链表中所有的孪生节点。
孪生和 定义为一个节点和它孪生节点两者值之和。
给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。
  示例 1：
输入：head = [5,4,2,1]
输出：6
解释：
节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。
链表中没有其他孪生节点。
所以，链表的最大孪生和是 6 。
示例 2：
输入：head = [4,2,2,3]
输出：7
解释：
链表中的孪生节点为：
- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。
- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。
所以，最大孪生和为 max(7, 4) = 7 。
示例 3：
输入：head = [1,100000]
输出：100001
解释：
链表中只有一对孪生节点，孪生和为 1 + 100000 = 100001 。
  提示：
链表的节点数目是 [2, 105] 中的 偶数 。
1 <= Node.val <= 105",10,,5998,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],7264
评论 (51),longest-palindrome-by-concatenating-two-letter-words,中等,"给你一个字符串数组 words 。words 中每个元素都是一个包含 两个 小写英文字母的单词。
请你从 words 中选择一些元素并按 任意顺序 连接它们，并得到一个 尽可能长的回文串 。每个元素 至多 只能使用一次。
请你返回你能得到的最长回文串的 长度 。如果没办法得到任何一个回文串，请你返回 0 。
回文串 指的是从前往后和从后往前读一样的字符串。
  示例 1：
输入：words = [""lc"",""cl"",""gg""]
输出：6
解释：一个最长的回文串为 ""lc"" + ""gg"" + ""cl"" = ""lcggcl"" ，长度为 6 。
""clgglc"" 是另一个可以得到的最长回文串。
示例 2：
输入：words = [""ab"",""ty"",""yt"",""lc"",""cl"",""ab""]
输出：8
解释：最长回文串是 ""ty"" + ""lc"" + ""cl"" + ""yt"" = ""tylcclyt"" ，长度为 8 。
""lcyttycl"" 是另一个可以得到的最长回文串。
示例 3：
输入：words = [""cc"",""ll"",""xx""]
输出：2
解释：最长回文串是 ""cc"" ，长度为 2 。
""ll"" 是另一个可以得到的最长回文串。""xx"" 也是。
  提示：
1 <= words.length <= 105
words[i].length == 2
words[i] 仅包含小写英文字母。",11,,4218,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],10966
评论 (40),stamping-the-grid,困难,"给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。
给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：
覆盖所有 空 格子。
不覆盖任何 被占据 的格子。
我们可以放入任意数目的邮票。
邮票可以相互有 重叠 部分。
邮票不允许 旋转 。
邮票必须完全在矩阵 内 。
如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。
  示例 1：
输入：grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3
输出：true
解释：我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。
示例 2：
输入：grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 
输出：false 
解释：没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。
  提示：
m == grid.length
n == grid[r].length
1 <= m, n <= 105
1 <= m * n <= 2 * 105
grid[r][c] 要么是 0 ，要么是 1 。
1 <= stampHeight, stampWidth <= 105",33,,1873,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/prefix-sum/']",[],7292
评论 (51),check-if-every-row-and-column-contains-all-numbers,简单,"对一个大小为 n x n 的矩阵而言，如果其每一行和每一列都包含从 1 到 n 的 全部 整数（含 1 和 n），则认为该矩阵是一个 有效 矩阵。
给你一个大小为 n x n 的整数矩阵 matrix ，请你判断矩阵是否为一个有效矩阵：如果是，返回 true ；否则，返回 false 。
  示例 1：
输入：matrix = [[1,2,3],[3,1,2],[2,3,1]]
输出：true
解释：在此例中，n = 3 ，每一行和每一列都包含数字 1、2、3 。
因此，返回 true 。
示例 2：
输入：matrix = [[1,1,1],[1,2,3],[1,2,3]]
输出：false
解释：在此例中，n = 3 ，但第一行和第一列不包含数字 2 和 3 。
因此，返回 false 。
  提示：
n == matrix.length == matrix[i].length
1 <= n <= 100
1 <= matrix[i][j] <= n",8,,7916,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/matrix/']",[],14054
评论 (76),minimum-swaps-to-group-all-1s-together-ii,中等,"交换 定义为选中一个数组中的两个 互不相同 的位置并交换二者的值。
环形 数组是一个数组，可以认为 第一个 元素和 最后一个 元素 相邻 。
给你一个 二进制环形 数组 nums ，返回在 任意位置 将数组中的所有 1 聚集在一起需要的最少交换次数。
  示例 1：
输入：nums = [0,1,0,1,1,0,0]
输出：1
解释：这里列出一些能够将所有 1 聚集在一起的方案：
[0,0,1,1,1,0,0] 交换 1 次。
[0,1,1,1,0,0,0] 交换 1 次。
[1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。
无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。
因此，需要的最少交换次数为 1 。
示例 2：
输入：nums = [0,1,1,1,0,0,1,1,0]
输出：2
解释：这里列出一些能够将所有 1 聚集在一起的方案：
[1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。
[1,1,1,1,1,0,0,0,0] 交换 2 次。
无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。
因此，需要的最少交换次数为 2 。
示例 3：
输入：nums = [1,1,0,0,1]
输出：0
解释：得益于数组的环形特性，所有的 1 已经聚集在一起。
因此，需要的最少交换次数为 0 。
  提示：
1 <= nums.length <= 105
nums[i] 为 0 或者 1",36,,5761,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/']",[],12208
评论 (59),count-words-obtained-after-adding-a-letter,中等,"给你两个下标从 0 开始的字符串数组 startWords 和 targetWords 。每个字符串都仅由 小写英文字母 组成。
对于 targetWords 中的每个字符串，检查是否能够从 startWords 中选出一个字符串，执行一次 转换操作 ，得到的结果与当前 targetWords 字符串相等。
转换操作 如下面两步所述：
追加 任何 不存在 于当前字符串的任一小写字母到当前字符串的末尾。
例如，如果字符串为 ""abc"" ，那么字母 'd'、'e' 或 'y' 都可以加到该字符串末尾，但 'a' 就不行。如果追加的是 'd' ，那么结果字符串为 ""abcd"" 。
重排 新字符串中的字母，可以按 任意 顺序重新排布字母。
例如，""abcd"" 可以重排为 ""acbd""、""bacd""、""cbda""，以此类推。注意，它也可以重排为 ""abcd"" 自身。
找出 targetWords 中有多少字符串能够由 startWords 中的 任一 字符串执行上述转换操作获得。返回 targetWords 中这类 字符串的数目 。
注意：你仅能验证 targetWords 中的字符串是否可以由 startWords 中的某个字符串经执行操作获得。startWords  中的字符串在这一过程中 不 发生实际变更。
  示例 1：
输入：startWords = [""ant"",""act"",""tack""], targetWords = [""tack"",""act"",""acti""]
输出：2
解释：
- 为了形成 targetWords[0] = ""tack"" ，可以选用 startWords[1] = ""act"" ，追加字母 'k' ，并重排 ""actk"" 为 ""tack"" 。
- startWords 中不存在可以用于获得 targetWords[1] = ""act"" 的字符串。
  注意 ""act"" 确实存在于 startWords ，但是 必须 在重排前给这个字符串追加一个字母。
- 为了形成 targetWords[2] = ""acti"" ，可以选用 startWords[1] = ""act"" ，追加字母 'i' ，并重排 ""acti"" 为 ""acti"" 自身。
示例 2：
输入：startWords = [""ab"",""a""], targetWords = [""abc"",""abcd""]
输出：1
解释：
- 为了形成 targetWords[0] = ""abc"" ，可以选用 startWords[0] = ""ab"" ，追加字母 'c' ，并重排为 ""abc"" 。
- startWords 中不存在可以用于获得 targetWords[1] = ""abcd"" 的字符串。
  提示：
1 <= startWords.length, targetWords.length <= 5 * 104
1 <= startWords[i].length, targetWords[j].length <= 26
startWords 和 targetWords 中的每个字符串都仅由小写英文字母组成
在 startWords 或 targetWords 的任一字符串中，每个字母至多出现一次",21,,4404,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],12846
评论 (39),earliest-possible-day-of-full-bloom,困难,"你有 n 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 0 开始的整数数组 plantTime 和 growTime ，每个数组的长度都是 n ：
plantTime[i] 是 播种 第 i 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 plantTime[i] 之后才算完成。
growTime[i] 是第 i 枚种子完全种下后生长所需的 完整天数 。在它生长的最后一天 之后 ，将会开花并且永远 绽放 。
从第 0 开始，你可以按 任意 顺序播种种子。
返回所有种子都开花的 最早 一天是第几天。
  示例 1：
输入：plantTime = [1,4,3], growTime = [2,3,1]
输出：9
解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。
一种最优方案是：
第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。
第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。
第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。
因此，在第 9 天，所有种子都开花。 
示例 2：
输入：plantTime = [1,2,3,2], growTime = [2,1,2,1]
输出：9
解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 
一种最优方案是：
第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。
第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。
第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。
第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。
因此，在第 9 天，所有种子都开花。 
示例 3：
输入：plantTime = [1], growTime = [1]
输出：2
解释：第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。
因此，在第 2 天，所有种子都开花。
  提示：
n == plantTime.length == growTime.length
1 <= n <= 105
1 <= plantTime[i], growTime[i] <= 104",25,https://assets.leetcode.com/uploads/2021/12/21/1.png,3167,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],4962
评论 (7),pour-water-between-buckets-to-make-water-levels-equal,Unknown,,-1,,-1,[],[],-1
评论 (64),divide-a-string-into-groups-of-size-k,简单,"字符串 s 可以按下述步骤划分为若干长度为 k 的组：
第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。
对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。
注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。
给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。
  示例 1：
输入：s = ""abcdefghi"", k = 3, fill = ""x""
输出：[""abc"",""def"",""ghi""]
解释：
前 3 个字符是 ""abc"" ，形成第一组。
接下来 3 个字符是 ""def"" ，形成第二组。
最后 3 个字符是 ""ghi"" ，形成第三组。
由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。
因此，形成 3 组，分别是 ""abc""、""def"" 和 ""ghi"" 。
示例 2：
输入：s = ""abcdefghij"", k = 3, fill = ""x""
输出：[""abc"",""def"",""ghi"",""jxx""]
解释：
与前一个例子类似，形成前三组 ""abc""、""def"" 和 ""ghi"" 。
对于最后一组，字符串中仅剩下字符 'j' 可以用。为了补全这一组，使用填充字符 'x' 两次。
因此，形成 4 组，分别是 ""abc""、""def""、""ghi"" 和 ""jxx"" 。
  提示：
1 <= s.length <= 100
s 仅由小写英文字母组成
1 <= k <= 100
fill 是一个小写英文字母",9,,8045,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],11975
评论 (82),minimum-moves-to-reach-target-score,中等,"你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。
在一次行动中，你可以做下述两种操作之一：
递增，将当前整数的值加 1（即， x = x + 1）。
加倍，使当前整数的值翻倍（即，x = 2 * x）。
在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。
给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。
  示例 1：
输入：target = 5, maxDoubles = 0
输出：4
解释：一直递增 1 直到得到 target 。
示例 2：
输入：target = 19, maxDoubles = 2
输出：7
解释：最初，x = 1 。
递增 3 次，x = 4 。
加倍 1 次，x = 8 。
递增 1 次，x = 9 。
加倍 1 次，x = 18 。
递增 1 次，x = 19 。
示例 3：
输入：target = 10, maxDoubles = 4
输出：4
解释：
最初，x = 1 。 
递增 1 次，x = 2 。 
加倍 1 次，x = 4 。 
递增 1 次，x = 5 。 
加倍 1 次，x = 10 。 
  提示：
1 <= target <= 109
0 <= maxDoubles <= 100",12,,7292,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/']",[],14389
评论 (92),solving-questions-with-brainpower,中等,"给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri] 。
这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。
比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：
如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。
如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。
请你返回这场考试里你能获得的 最高 分数。
  示例 1：
输入：questions = [[3,2],[4,3],[4,4],[2,5]]
输出：5
解释：解决问题 0 和 3 得到最高分。
- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。
- 不能解决问题 1 和 2
- 解决问题 3 ：获得 2 分
总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。
示例 2：
输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
输出：7
解释：解决问题 1 和 4 得到最高分。
- 跳过问题 0
- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。
- 不能解决问题 2 和 3
- 解决问题 4 ：获得 5 分
总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。
  提示：
1 <= questions.length <= 105
questions[i].length == 2
1 <= pointsi, brainpoweri <= 105",45,,6748,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],16199
评论 (61),maximum-running-time-of-n-computers,困难,"你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。
一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。
注意，你不能给电池充电。
请你返回你可以让 n 台电脑同时运行的 最长 分钟数。
  示例 1：
输入：n = 2, batteries = [3,3,3]
输出：4
解释：
一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。
2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。
在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。
在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。
我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。
示例 2：
输入：n = 2, batteries = [1,1,1,1]
输出：2
解释：
一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。
一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。
1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。
我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。
  提示：
1 <= n <= batteries.length <= 105
1 <= batteries[i] <= 109",48,,4175,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],10517
评论 (26),the-number-of-passengers-in-each-bus-i,Unknown,,-1,,-1,[],[],-1
评论 (1),choose-numbers-from-two-arrays-in-range,Unknown,,-1,,-1,[],[],-1
评论 (43),minimum-cost-of-buying-candies-with-discount,简单,"一家商店正在打折销售糖果。每购买 两个 糖果，商店会 免费 送一个糖果。
免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 较小值 。
比方说，总共有 4 个糖果，价格分别为 1 ，2 ，3 和 4 ，一位顾客买了价格为 2 和 3 的糖果，那么他可以免费获得价格为 1 的糖果，但不能获得价格为 4 的糖果。
给你一个下标从 0 开始的整数数组 cost ，其中 cost[i] 表示第 i 个糖果的价格，请你返回获得 所有 糖果的 最小 总开销。
  示例 1：
输入：cost = [1,2,3]
输出：5
解释：我们购买价格为 2 和 3 的糖果，然后免费获得价格为 1 的糖果。
总开销为 2 + 3 = 5 。这是开销最小的 唯一 方案。
注意，我们不能购买价格为 1 和 3 的糖果，并免费获得价格为 2 的糖果。
这是因为免费糖果的价格必须小于等于购买的 2 个糖果价格的较小值。
示例 2：
输入：cost = [6,5,7,9,2,2]
输出：23
解释：最小总开销购买糖果方案为：
- 购买价格为 9 和 7 的糖果
- 免费获得价格为 6 的糖果
- 购买价格为 5 和 2 的糖果
- 免费获得价格为 2 的最后一个糖果
因此，最小总开销为 9 + 7 + 5 + 2 = 23 。
示例 3：
输入：cost = [5,5]
输出：10
解释：由于只有 2 个糖果，我们需要将它们都购买，而且没有免费糖果。
所以总最小开销为 5 + 5 = 10 。
  提示：
1 <= cost.length <= 100
1 <= cost[i] <= 100",8,,6503,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],9572
评论 (49),count-the-hidden-sequences,中等,"给你一个下标从 0 开始且长度为 n 的整数数组 differences ，它表示一个长度为 n + 1 的 隐藏 数组 相邻 元素之间的 差值 。更正式的表述为：我们将隐藏数组记作 hidden ，那么 differences[i] = hidden[i + 1] - hidden[i] 。
同时给你两个整数 lower 和 upper ，它们表示隐藏数组中所有数字的值都在 闭 区间 [lower, upper] 之间。
比方说，differences = [1, -3, 4] ，lower = 1 ，upper = 6 ，那么隐藏数组是一个长度为 4 且所有值都在 1 和 6 （包含两者）之间的数组。
[3, 4, 1, 5] 和 [4, 5, 2, 6] 都是符合要求的隐藏数组。
[5, 6, 3, 7] 不符合要求，因为它包含大于 6 的元素。
[1, 2, 3, 4] 不符合要求，因为相邻元素的差值不符合给定数据。
请你返回 符合 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 0 。
  示例 1：
输入：differences = [1,-3,4], lower = 1, upper = 6
输出：2
解释：符合要求的隐藏数组为：
- [3, 4, 1, 5]
- [4, 5, 2, 6]
所以返回 2 。
示例 2：
输入：differences = [3,-4,5,1,-2], lower = -4, upper = 5
输出：4
解释：符合要求的隐藏数组为：
- [-3, 0, -4, 1, 2, 0]
- [-2, 1, -3, 2, 3, 1]
- [-1, 2, -2, 3, 4, 2]
- [0, 3, -1, 4, 5, 3]
所以返回 4 。
示例 3：
输入：differences = [4,-7,2], lower = 3, upper = 6
输出：0
解释：没有符合要求的隐藏数组，所以返回 0 。
  提示：
n == differences.length
1 <= n <= 105
-105 <= differences[i] <= 105
-105 <= lower <= upper <= 105",16,,4363,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],12756
评论 (56),k-highest-ranked-items-within-a-price-range,中等,"给你一个下标从 0 开始的二维整数数组 grid ，它的大小为 m x n ，表示一个商店中物品的分布图。数组中的整数含义为：
0 表示无法穿越的一堵墙。
1 表示可以自由通过的一个空格子。
所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。
从一个格子走到上下左右相邻格子花费 1 步。
同时给你一个整数数组 pricing 和 start ，其中 pricing = [low, high] 且 start = [row, col] ，表示你开始位置为 (row, col) ，同时你只对物品价格在 闭区间 [low, high] 之内的物品感兴趣。同时给你一个整数 k 。
你想知道给定范围 内 且 排名最高 的 k 件物品的 位置 。排名按照优先级从高到低的以下规则制定：
距离：定义为从 start 到一件物品的最短路径需要的步数（较近 距离的排名更高）。
价格：较低 价格的物品有更高优先级，但只考虑在给定范围之内的价格。
行坐标：较小 行坐标的有更高优先级。
列坐标：较小 列坐标的有更高优先级。
请你返回给定价格内排名最高的 k 件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 k 件物品，那么请将它们的坐标 全部 返回。
  示例 1：
输入：grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3
输出：[[0,1],[1,1],[2,1]]
解释：起点为 (0,0) 。
价格范围为 [2,5] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(2,1) 和 (2,2) 。
这些物品的排名为：
- (0,1) 距离为 1
- (1,1) 距离为 2
- (2,1) 距离为 3
- (2,2) 距离为 4
所以，给定价格范围内排名最高的 3 件物品的坐标为 (0,1)，(1,1) 和 (2,1) 。
示例 2：
输入：grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2
输出：[[2,1],[1,2]]
解释：起点为 (2,3) 。
价格范围为 [2,3] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(1,2) 和 (2,1) 。
这些物品的排名为： 
- (2,1) 距离为 2 ，价格为 2
- (1,2) 距离为 2 ，价格为 3
- (1,1) 距离为 3
- (0,1) 距离为 4
所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (1,2) 。
示例 3：
输入：grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3
输出：[[2,1],[2,0]]
解释：起点为 (0,0) 。
价格范围为 [2,3] ，我们可以选择的物品坐标为 (2,0) 和 (2,1) 。
这些物品的排名为：
- (2,1) 距离为 5
- (2,0) 距离为 6
所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (2,0) 。
注意，k = 3 但给定价格范围内只有 2 件物品。
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 105
1 <= m * n <= 105
0 <= grid[i][j] <= 105
pricing.length == 2
2 <= low <= high <= 105
start.length == 2
0 <= row <= m - 1
0 <= col <= n - 1
grid[row][col] > 0
1 <= k <= m * n",18,,3216,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],8307
评论 (35),number-of-ways-to-divide-a-long-corridor,困难,"在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 0 开始，长度为 n 的字符串 corridor ，它包含字母 'S' 和 'P' ，其中每个 'S' 表示一个座位，每个 'P' 表示一株植物。
在下标 0 的左边和下标 n - 1 的右边 已经 分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置 i - 1 和 i 之间（1 <= i <= n - 1），至多能放一个屏风。
请你将走廊用屏风划分为若干段，且每一段内都 恰好有两个座位 ，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 不同 方案。
请你返回划分走廊的方案数。由于答案可能很大，请你返回它对 109 + 7 取余 的结果。如果没有任何方案，请返回 0 。
  示例 1：
输入：corridor = ""SSPPSPS""
输出：3
解释：总共有 3 种不同分隔走廊的方案。
上图中黑色的竖线表示已经放置好的屏风。
上图每种方案中，每一段都恰好有 两个 座位。
示例 2：
输入：corridor = ""PPSPSP""
输出：1
解释：只有 1 种分隔走廊的方案，就是不放置任何屏风。
放置任何的屏风都会导致有一段无法恰好有 2 个座位。
示例 3：
输入：corridor = ""S""
输出：0
解释：没有任何方案，因为总是有一段无法恰好有 2 个座位。
  提示：
n == corridor.length
1 <= n <= 105
corridor[i] 要么是 'S' ，要么是 'P' 。",9,,2820,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],7054
评论 (76),count-elements-with-strictly-smaller-and-greater-elements,简单,"给你一个整数数组 nums ，统计并返回在 nums 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。
  示例 1：
输入：nums = [11,7,2,15]
输出：2
解释：元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。
元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。
总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。
示例 2：
输入：nums = [-3,3,3,90]
输出：2
解释：元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。
由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。
  提示：
1 <= nums.length <= 100
-105 <= nums[i] <= 105",10,,8917,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],15373
评论 (50),rearrange-array-elements-by-sign,中等,"给你一个下标从 0 开始的整数数组 nums ，数组长度为 偶数 ，由数目相等的正整数和负整数组成。
你需要 重排 nums 中的元素，使修改后的数组满足下述条件：
任意 连续 的两个整数 符号相反
对于符号相同的所有整数，保留 它们在 nums 中的 顺序 。
重排后数组以正整数开头。
重排元素满足上述条件后，返回修改后的数组。
  示例 1：
输入：nums = [3,1,-2,-5,2,-4]
输出：[3,-2,1,-5,2,-4]
解释：
nums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。
重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。
像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 
示例 2：
输入：nums = [-1,1]
输出：[1,-1]
解释：
1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。
所以 nums 重排为 [1,-1] 。
  提示：
2 <= nums.length <= 2 * 105
nums.length 是 偶数
1 <= |nums[i]| <= 105
nums 由 相等 数量的正整数和负整数组成",12,,8430,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/simulation/']",[],10444
评论 (45),find-all-lonely-numbers-in-the-array,中等,"给你一个整数数组 nums 。如果数字 x 在数组中仅出现 一次 ，且没有 相邻 数字（即，x + 1 和 x - 1）出现在数组中，则认为数字 x 是 孤独数字 。
返回 nums 中的 所有 孤独数字。你可以按 任何顺序 返回答案。
  示例 1：
输入：nums = [10,6,5,8]
输出：[10,8]
解释：
- 10 是一个孤独数字，因为它只出现一次，并且 9 和 11 没有在 nums 中出现。
- 8 是一个孤独数字，因为它只出现一次，并且 7 和 9 没有在 nums 中出现。
- 5 不是一个孤独数字，因为 6 出现在 nums 中，反之亦然。
因此，nums 中的孤独数字是 [10, 8] 。
注意，也可以返回 [8, 10] 。
示例 2：
输入：nums = [1,3,5,3]
输出：[1,5]
解释：
- 1 是一个孤独数字，因为它只出现一次，并且 0 和 2 没有在 nums 中出现。
- 5 是一个孤独数字，因为它只出现一次，并且 4 和 6 没有在 nums 中出现。
- 3 不是一个孤独数字，因为它出现两次。
因此，nums 中的孤独数字是 [1, 5] 。
注意，也可以返回 [5, 1] 。
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 106",6,,7459,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],12332
评论 (86),maximum-good-people-based-on-statements,困难,"游戏中存在两种角色：
好人：该角色只说真话。
坏人：该角色可能说真话，也可能说假话。
给你一个下标从 0 开始的二维整数数组 statements ，大小为 n x n ，表示 n 个玩家对彼此角色的陈述。具体来说，statements[i][j] 可以是下述值之一：
0 表示 i 的陈述认为 j 是 坏人 。
1 表示 i 的陈述认为 j 是 好人 。
2 表示 i 没有对 j 作出陈述。
另外，玩家不会对自己进行陈述。形式上，对所有 0 <= i < n ，都有 statements[i][i] = 2 。
根据这 n 个玩家的陈述，返回可以认为是 好人 的 最大 数目。
  示例 1：
输入：statements = [[2,1,2],[1,2,2],[2,0,2]]
输出：2
解释：每个人都做一条陈述。
- 0 认为 1 是好人。
- 1 认为 0 是好人。
- 2 认为 1 是坏人。
以 2 为突破点。
- 假设 2 是一个好人：
    - 基于 2 的陈述，1 是坏人。
    - 那么可以确认 1 是坏人，2 是好人。
    - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能：
        - 说真话。在这种情况下会出现矛盾，所以假设无效。
        - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。
    - 在认为 2 是好人的情况下，这组玩家中只有一个好人。
- 假设 2 是一个坏人：
    - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能：
        - 说真话。在这种情况下，0 和 1 都是坏人。
            - 在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。
        - 说假话。在这种情况下，1 是好人。
            - 由于 1 是好人，0 也是好人。
            - 在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。
在最佳情况下，至多有两个好人，所以返回 2 。
注意，能得到此结论的方法不止一种。
示例 2：
输入：statements = [[2,0],[0,2]]
输出：1
解释：每个人都做一条陈述。
- 0 认为 1 是坏人。
- 1 认为 0 是坏人。
以 0 为突破点。
- 假设 0 是一个好人：
    - 基于与 0 的陈述，1 是坏人并说假话。
    - 在认为 0 是好人的情况下，这组玩家中只有一个好人。
- 假设 0 是一个坏人：
    - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能：
        - 说真话。在这种情况下，0 和 1 都是坏人。
            - 在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。
        - 说假话。在这种情况下，1 是好人。
            - 在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。
在最佳情况下，至多有一个好人，所以返回 1 。 
注意，能得到此结论的方法不止一种。
  提示：
n == statements.length == statements[i].length
2 <= n <= 15
statements[i][j] 的值为 0、1 或 2
statements[i][i] == 2",31,https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg,4560,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/enumeration/']",[],9377
评论 (10),minimum-number-of-lines-to-cover-points,Unknown,,-1,,-1,[],[],-1
评论 (15),the-number-of-passengers-in-each-bus-ii,Unknown,,-1,,-1,[],[],-1
评论 (86),keep-multiplying-found-values-by-two,简单,"给你一个整数数组 nums ，另给你一个整数 original ，这是需要在 nums 中搜索的第一个数字。
接下来，你需要按下述步骤操作：
如果在 nums 中找到 original ，将 original 乘以 2 ，得到新 original（即，令 original = 2 * original）。
否则，停止这一过程。
只要能在数组中找到新 original ，就对新 original 继续 重复 这一过程。
返回 original 的 最终 值。
  示例 1：
输入：nums = [5,3,6,1,12], original = 3
输出：24
解释： 
- 3 能在 nums 中找到。3 * 2 = 6 。
- 6 能在 nums 中找到。6 * 2 = 12 。
- 12 能在 nums 中找到。12 * 2 = 24 。
- 24 不能在 nums 中找到。因此，返回 24 。
示例 2：
输入：nums = [2,7,9], original = 4
输出：4
解释：
- 4 不能在 nums 中找到。因此，返回 4 。
  提示：
1 <= nums.length <= 1000
1 <= nums[i], original <= 1000",10,,10344,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/simulation/']",[],13872
评论 (65),all-divisions-with-the-highest-score-of-a-binary-array,中等,"给你一个下标从 0 开始的二进制数组 nums ，数组长度为 n 。nums 可以按下标 i（ 0 <= i <= n ）拆分成两个数组（可能为空）：numsleft 和 numsright 。
numsleft 包含 nums 中从下标 0 到 i - 1 的所有元素（包括 0 和 i - 1 ），而 numsright 包含 nums 中从下标 i 到 n - 1 的所有元素（包括 i 和 n - 1 ）。
如果 i == 0 ，numsleft 为 空 ，而 numsright 将包含 nums 中的所有元素。
如果 i == n ，numsleft 将包含 nums 中的所有元素，而 numsright 为 空 。
下标 i 的 分组得分 为 numsleft 中 0 的个数和 numsright 中 1 的个数之 和 。
返回 分组得分 最高 的 所有不同下标 。你可以按 任意顺序 返回答案。
  示例 1：
输入：nums = [0,0,1,0]
输出：[2,4]
解释：按下标分组
- 0 ：numsleft 为 [] 。numsright 为 [0,0,1,0] 。得分为 0 + 1 = 1 。
- 1 ：numsleft 为 [0] 。numsright 为 [0,1,0] 。得分为 1 + 1 = 2 。
- 2 ：numsleft 为 [0,0] 。numsright 为 [1,0] 。得分为 2 + 1 = 3 。
- 3 ：numsleft 为 [0,0,1] 。numsright 为 [0] 。得分为 2 + 0 = 2 。
- 4 ：numsleft 为 [0,0,1,0] 。numsright 为 [] 。得分为 3 + 0 = 3 。
下标 2 和 4 都可以得到最高的分组得分 3 。
注意，答案 [4,2] 也被视为正确答案。
示例 2：
输入：nums = [0,0,0]
输出：[3]
解释：按下标分组
- 0 ：numsleft 为 [] 。numsright 为 [0,0,0] 。得分为 0 + 0 = 0 。
- 1 ：numsleft 为 [0] 。numsright 为 [0,0] 。得分为 1 + 0 = 1 。
- 2 ：numsleft 为 [0,0] 。numsright 为 [0] 。得分为 2 + 0 = 2 。
- 3 ：numsleft 为 [0,0,0] 。numsright 为 [] 。得分为 3 + 0 = 3 。
只有下标 3 可以得到最高的分组得分 3 。
示例 3：
输入：nums = [1,1]
输出：[0]
解释：按下标分组
- 0 ：numsleft 为 [] 。numsright 为 [1,1] 。得分为 0 + 2 = 2 。
- 1 ：numsleft 为 [1] 。numsright 为 [1] 。得分为 0 + 1 = 1 。
- 2 ：numsleft 为 [1,1] 。numsright 为 [] 。得分为 0 + 0 = 0 。
只有下标 0 可以得到最高的分组得分 2 。
  提示：
n == nums.length
1 <= n <= 105
nums[i] 为 0 或 1",15,,6638,['https://leetcode.cn/tag/array/'],[],10357
评论 (111),find-substring-with-given-hash-value,中等,"给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算：
hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.
其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val('a') = 1 到 val('z') = 26 。
给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) == hashValue 。
测试数据保证一定 存在 至少一个这样的子串。
子串 定义为一个字符串中连续非空字符组成的序列。
  示例 1：
输入：s = ""leetcode"", power = 7, modulo = 20, k = 2, hashValue = 0
输出：""ee""
解释：""ee"" 的哈希值为 hash(""ee"", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。
""ee"" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 ""ee"" 。
示例 2：
输入：s = ""fbxzaad"", power = 31, modulo = 100, k = 3, hashValue = 32
输出：""fbx""
解释：""fbx"" 的哈希值为 hash(""fbx"", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32 。
""bxz"" 的哈希值为 hash(""bxz"", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32 。
""fbx"" 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 ""fbx"" 。
注意，""bxz"" 的哈希值也为 32 ，但是它在字符串中比 ""fbx"" 更晚出现。
  提示：
1 <= k <= s.length <= 2 * 104
1 <= power, modulo <= 109
0 <= hashValue < modulo
s 只包含小写英文字母。
测试数据保证一定 存在 满足条件的子串。",32,,4676,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],19316
评论 (78),groups-of-strings,困难,"给你一个下标从 0 开始的字符串数组 words 。每个字符串都只包含 小写英文字母 。words 中任意一个子串中，每个字母都至多只出现一次。
如果通过以下操作之一，我们可以从 s1 的字母集合得到 s2 的字母集合，那么我们称这两个字符串为 关联的 ：
往 s1 的字母集合中添加一个字母。
从 s1 的字母集合中删去一个字母。
将 s1 中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。
数组 words 可以分为一个或者多个无交集的 组 。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。
注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。
请你返回一个长度为 2 的数组 ans ：
ans[0] 是 words 分组后的 总组数 。
ans[1] 是字符串数目最多的组所包含的字符串数目。
  示例 1：
输入：words = [""a"",""b"",""ab"",""cde""]
输出：[2,3]
解释：
- words[0] 可以得到 words[1] （将 'a' 替换为 'b'）和 words[2] （添加 'b'）。所以 words[0] 与 words[1] 和 words[2] 关联。
- words[1] 可以得到 words[0] （将 'b' 替换为 'a'）和 words[2] （添加 'a'）。所以 words[1] 与 words[0] 和 words[2] 关联。
- words[2] 可以得到 words[0] （删去 'b'）和 words[1] （删去 'a'）。所以 words[2] 与 words[0] 和 words[1] 关联。
- words[3] 与 words 中其他字符串都不关联。
所以，words 可以分成 2 个组 [""a"",""b"",""ab""] 和 [""cde""] 。最大的组大小为 3 。
示例 2：
输入：words = [""a"",""ab"",""abc""]
输出：[1,3]
解释：
- words[0] 与 words[1] 关联。
- words[1] 与 words[0] 和 words[2] 关联。
- words[2] 与 words[1] 关联。
由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。
所以最大的组大小为 3 。
  提示：
1 <= words.length <= 2 * 104
1 <= words[i].length <= 26
words[i] 只包含小写英文字母。
words[i] 中每个字母最多只出现一次。",35,,2866,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/string/']",[],9535
评论 (5),amount-of-new-area-painted-each-day,Unknown,,-1,,-1,[],[],-1
评论 (25),order-two-columns-independently,Unknown,,-1,,-1,[],[],-1
评论 (70),minimum-sum-of-four-digit-number-after-splitting-digits,简单,"给你一个四位 正 整数 num 。请你使用 num 中的 数位 ，将 num 拆成两个新的整数 new1 和 new2 。new1 和 new2 中可以有 前导 0 ，且 num 中 所有 数位都必须使用。
比方说，给你 num = 2932 ，你拥有的数位包括：两个 2 ，一个 9 和一个 3 。一些可能的 [new1, new2] 数对为 [22, 93]，[23, 92]，[223, 9] 和 [2, 329] 。
请你返回可以得到的 new1 和 new2 的 最小 和。
  示例 1：
输入：num = 2932
输出：52
解释：可行的 [new1, new2] 数对为 [29, 23] ，[223, 9] 等等。
最小和为数对 [29, 23] 的和：29 + 23 = 52 。
示例 2：
输入：num = 4009
输出：13
解释：可行的 [new1, new2] 数对为 [0, 49] ，[490, 0] 等等。
最小和为数对 [4, 9] 的和：4 + 9 = 13 。
  提示：
1000 <= num <= 9999",12,,7887,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",[],9215
评论 (51),partition-array-according-to-given-pivot,中等,"给你一个下标从 0 开始的整数数组 nums 和一个整数 pivot 。请你将 nums 重新排列，使得以下条件均成立：
所有小于 pivot 的元素都出现在所有大于 pivot 的元素 之前 。
所有等于 pivot 的元素都出现在小于和大于 pivot 的元素 中间 。
小于 pivot 的元素之间和大于 pivot 的元素之间的 相对顺序 不发生改变。
更正式的，考虑每一对 pi，pj ，pi 是初始时位置 i 元素的新位置，pj 是初始时位置 j 元素的新位置。对于小于 pivot 的元素，如果 i < j 且 nums[i] < pivot 和 nums[j] < pivot 都成立，那么 pi < pj 也成立。类似的，对于大于 pivot 的元素，如果 i < j 且 nums[i] > pivot 和 nums[j] > pivot 都成立，那么 pi < pj 。
请你返回重新排列 nums 数组后的结果数组。
  示例 1：
输入：nums = [9,12,5,10,14,3,10], pivot = 10
输出：[9,5,3,10,10,12,14]
解释：
元素 9 ，5 和 3 小于 pivot ，所以它们在数组的最左边。
元素 12 和 14 大于 pivot ，所以它们在数组的最右边。
小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [9, 5, 3] 和 [12, 14] ，它们在结果数组中的相对顺序需要保留。
示例 2：
输入：nums = [-3,4,3,2], pivot = 2
输出：[-3,2,4,3]
解释：
元素 -3 小于 pivot ，所以在数组的最左边。
元素 4 和 3 大于 pivot ，所以它们在数组的最右边。
小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [-3] 和 [4, 3] ，它们在结果数组中的相对顺序需要保留。
  提示：
1 <= nums.length <= 105
-106 <= nums[i] <= 106
pivot 等于 nums 中的一个元素。",11,,5703,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/simulation/']",[],6767
评论 (78),minimum-cost-to-set-cooking-time,中等,"常见的微波炉可以设置加热时间，且加热时间满足以下条件：
至少为 1 秒钟。
至多为 99 分 99 秒。
你可以 最多 输入 4 个数字 来设置加热时间。如果你输入的位数不足 4 位，微波炉会自动加 前缀 0 来补足 4 位。微波炉会将设置好的四位数中，前 两位当作分钟数，后 两位当作秒数。它们所表示的总时间就是加热时间。比方说：
你输入 9 5 4 （三个数字），被自动补足为 0954 ，并表示 9 分 54 秒。
你输入 0 0 0 8 （四个数字），表示 0 分 8 秒。
你输入 8 0 9 0 ，表示 80 分 90 秒。
你输入 8 1 3 0 ，表示 81 分 30 秒。
给你整数 startAt ，moveCost ，pushCost 和 targetSeconds 。一开始，你的手指在数字 startAt 处。将手指移到 任何其他数字 ，需要花费 moveCost 的单位代价。每 输入你手指所在位置的数字一次，需要花费 pushCost 的单位代价。
要设置 targetSeconds 秒的加热时间，可能会有多种设置方法。你想要知道这些方法中，总代价最小为多少。
请你能返回设置 targetSeconds 秒钟加热时间需要花费的最少代价。
请记住，虽然微波炉的秒数最多可以设置到 99 秒，但一分钟等于 60 秒。
  示例 1：
输入：startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600
输出：6
解释：以下为设置加热时间的所有方法。
- 1 0 0 0 ，表示 10 分 0 秒。
  手指一开始就在数字 1 处，输入 1 （代价为 1），移到 0 处（代价为 2），输入 0（代价为 1），输入 0（代价为 1），输入 0（代价为 1）。
  总代价为：1 + 2 + 1 + 1 + 1 = 6 。这是所有方案中的最小代价。
- 0 9 6 0，表示 9 分 60 秒。它也表示 600 秒。
  手指移到 0 处（代价为 2），输入 0 （代价为 1），移到 9 处（代价为 2），输入 9（代价为 1），移到 6 处（代价为 2），输入 6（代价为 1），移到 0 处（代价为 2），输入 0（代价为 1）。
  总代价为：2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12 。
- 9 6 0，微波炉自动补全为 0960 ，表示 9 分 60 秒。
  手指移到 9 处（代价为 2），输入 9 （代价为 1），移到 6 处（代价为 2），输入 6（代价为 1），移到 0 处（代价为 2），输入 0（代价为 1）。
  总代价为：2 + 1 + 2 + 1 + 2 + 1 = 9 。
示例 2：
输入：startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76
输出：6
解释：最优方案为输入两个数字 7 6，表示 76 秒。
手指移到 7 处（代价为 1），输入 7 （代价为 2），移到 6 处（代价为 1），输入 6（代价为 2）。总代价为：1 + 2 + 1 + 2 = 6
其他可行方案为 0076 ，076 ，0116 和 116 ，但是它们的代价都比 6 大。
  提示：
0 <= startAt <= 9
1 <= moveCost, pushCost <= 105
1 <= targetSeconds <= 6039",2,,2775,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/']",[],8604
评论 (41),minimum-difference-in-sums-after-removal-of-elements,困难,"给你一个下标从 0 开始的整数数组 nums ，它包含 3 * n 个元素。
你可以从 nums 中删除 恰好 n 个元素，剩下的 2 * n 个元素将会被分成两个 相同大小 的部分。
前面 n 个元素属于第一部分，它们的和记为 sumfirst 。
后面 n 个元素属于第二部分，它们的和记为 sumsecond 。
两部分和的 差值 记为 sumfirst - sumsecond 。
比方说，sumfirst = 3 且 sumsecond = 2 ，它们的差值为 1 。
再比方，sumfirst = 2 且 sumsecond = 3 ，它们的差值为 -1 。
请你返回删除 n 个元素之后，剩下两部分和的 差值的最小值 是多少。
  示例 1：
输入：nums = [3,1,2]
输出：-1
解释：nums 有 3 个元素，所以 n = 1 。
所以我们需要从 nums 中删除 1 个元素，并将剩下的元素分成两部分。
- 如果我们删除 nums[0] = 3 ，数组变为 [1,2] 。两部分和的差值为 1 - 2 = -1 。
- 如果我们删除 nums[1] = 1 ，数组变为 [3,2] 。两部分和的差值为 3 - 2 = 1 。
- 如果我们删除 nums[2] = 2 ，数组变为 [3,1] 。两部分和的差值为 3 - 1 = 2 。
两部分和的最小差值为 min(-1,1,2) = -1 。
示例 2：
输入：nums = [7,9,5,8,1,3]
输出：1
解释：n = 2 。所以我们需要删除 2 个元素，并将剩下元素分为 2 部分。
如果我们删除元素 nums[2] = 5 和 nums[3] = 8 ，剩下元素为 [7,9,1,3] 。和的差值为 (7+9) - (1+3) = 12 。
为了得到最小差值，我们应该删除 nums[1] = 9 和 nums[4] = 1 ，剩下的元素为 [7,5,8,3] 。和的差值为 (7+5) - (8+3) = 1 。
观察可知，最优答案为 1 。
  提示：
nums.length == 3 * n
1 <= n <= 105
1 <= nums[i] <= 105",27,,2400,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],4987
评论 (55),sort-even-and-odd-indices-independently,简单,"给你一个下标从 0 开始的整数数组 nums 。根据下述规则重排 nums 中的值：
按 非递增 顺序排列 nums 奇数下标 上的所有值。
举个例子，如果排序前 nums = [4,1,2,3] ，对奇数下标的值排序后变为 [4,3,2,1] 。奇数下标 1 和 3 的值按照非递增顺序重排。
按 非递减 顺序排列 nums 偶数下标 上的所有值。
举个例子，如果排序前 nums = [4,1,2,3] ，对偶数下标的值排序后变为 [2,1,4,3] 。偶数下标 0 和 2 的值按照非递减顺序重排。
返回重排 nums 的值之后形成的数组。
  示例 1：
输入：nums = [4,1,2,3]
输出：[2,3,4,1]
解释：
首先，按非递增顺序重排奇数下标（1 和 3）的值。
所以，nums 从 [4,1,2,3] 变为 [4,3,2,1] 。
然后，按非递减顺序重排偶数下标（0 和 2）的值。
所以，nums 从 [4,1,2,3] 变为 [2,3,4,1] 。
因此，重排之后形成的数组是 [2,3,4,1] 。
示例 2：
输入：nums = [2,1]
输出：[2,1]
解释：
由于只有一个奇数下标和一个偶数下标，所以不会发生重排。
形成的结果数组是 [2,1] ，和初始数组一样。 
  提示：
1 <= nums.length <= 100
1 <= nums[i] <= 100",7,,7922,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],11377
评论 (71),smallest-value-of-the-rearranged-number,中等,"给你一个整数 num 。重排 num 中的各位数字，使其值 最小化 且不含 任何 前导零。
返回不含前导零且值最小的重排数字。
注意，重排各位数字后，num 的符号不会改变。
  示例 1：
输入：num = 310
输出：103
解释：310 中各位数字的可行排列有：013、031、103、130、301、310 。
不含任何前导零且值最小的重排数字是 103 。
示例 2：
输入：num = -7605
输出：-7650
解释：-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。
不含任何前导零且值最小的重排数字是 -7650 。
  提示：
-1015 <= num <= 1015",6,,6499,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",[],11806
评论 (87),design-bitset,中等,"位集 Bitset 是一种能以紧凑形式存储位的数据结构。
请你实现 Bitset 类。
Bitset(int size) 用 size 个位初始化 Bitset ，所有位都是 0 。
void fix(int idx) 将下标为 idx 的位上的值更新为 1 。如果值已经是 1 ，则不会发生任何改变。
void unfix(int idx) 将下标为 idx 的位上的值更新为 0 。如果值已经是 0 ，则不会发生任何改变。
void flip() 翻转 Bitset 中每一位上的值。换句话说，所有值为 0 的位将会变成 1 ，反之亦然。
boolean all() 检查 Bitset 中 每一位 的值是否都是 1 。如果满足此条件，返回 true ；否则，返回 false 。
boolean one() 检查 Bitset 中 是否 至少一位 的值是 1 。如果满足此条件，返回 true ；否则，返回 false 。
int count() 返回 Bitset 中值为 1 的位的 总数 。
String toString() 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 i 个下标处的字符应该与 Bitset 中的第 i 位一致。
  示例：
输入
[""Bitset"", ""fix"", ""fix"", ""flip"", ""all"", ""unfix"", ""flip"", ""one"", ""unfix"", ""count"", ""toString""]
[[5], [3], [1], [], [], [0], [], [], [0], [], []]
输出
[null, null, null, null, false, null, null, true, null, 2, ""01010""]

解释
Bitset bs = new Bitset(5); // bitset = ""00000"".
bs.fix(3);     // 将 idx = 3 处的值更新为 1 ，此时 bitset = ""00010"" 。
bs.fix(1);     // 将 idx = 1 处的值更新为 1 ，此时 bitset = ""01010"" 。
bs.flip();     // 翻转每一位上的值，此时 bitset = ""10101"" 。
bs.all();      // 返回 False ，bitset 中的值不全为 1 。
bs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = ""00101"" 。
bs.flip();     // 翻转每一位上的值，此时 bitset = ""11010"" 。
bs.one();      // 返回 True ，至少存在一位的值为 1 。
bs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = ""01010"" 。
bs.count();    // 返回 2 ，当前有 2 位的值为 1 。
bs.toString(); // 返回 ""01010"" ，即 bitset 的当前组成情况。
  提示：
1 <= size <= 105
0 <= idx <= size - 1
至多调用 fix、unfix、flip、all、one、count 和 toString 方法 总共 105 次
至少调用 all、one、count 或 toString 方法一次
至多调用 toString 方法 5 次",20,,4976,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],16966
评论 (46),minimum-time-to-remove-all-cars-containing-illegal-goods,困难,"给你一个下标从 0 开始的二进制字符串 s ，表示一个列车车厢序列。s[i] = '0' 表示第 i 节车厢 不 含违禁货物，而 s[i] = '1' 表示第 i 节车厢含违禁货物。
作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：
从列车 左 端移除一节车厢（即移除 s[0]），用去 1 单位时间。
从列车 右 端移除一节车厢（即移除 s[s.length - 1]），用去 1 单位时间。
从列车车厢序列的 任意位置 移除一节车厢，用去 2 单位时间。
返回移除所有载有违禁货物车厢所需要的 最少 单位时间数。
注意，空的列车车厢序列视为没有车厢含违禁货物。
  示例 1：
输入：s = ""1100101""
输出：5
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 1 次。所用时间是 1 。
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2 + 1 + 2 = 5 。

一种替代方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间也是 2 + 3 = 5 。

5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
示例 2：
输入：s = ""0010""
输出：2
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间是 3.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
总时间是 2.

2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
  提示：
1 <= s.length <= 2 * 105
s[i] 为 '0' 或 '1'",38,,3710,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],7720
评论 (11),unique-substrings-with-equal-digit-frequency,Unknown,,-1,,-1,[],[],-1
评论 (63),count-operations-to-obtain-zero,简单,"给你两个 非负 整数 num1 和 num2 。
每一步 操作 中，如果 num1 >= num2 ，你必须用 num1 减 num2 ；否则，你必须用 num2 减 num1 。
例如，num1 = 5 且 num2 = 4 ，应该用 num1 减 num2 ，因此，得到 num1 = 1 和 num2 = 4 。然而，如果 num1 = 4且 num2 = 5 ，一步操作后，得到 num1 = 4 和 num2 = 1 。
返回使 num1 = 0 或 num2 = 0 的 操作数 。
  示例 1：
输入：num1 = 2, num2 = 3
输出：3
解释：
- 操作 1 ：num1 = 2 ，num2 = 3 。由于 num1 < num2 ，num2 减 num1 得到 num1 = 2 ，num2 = 3 - 2 = 1 。
- 操作 2 ：num1 = 2 ，num2 = 1 。由于 num1 > num2 ，num1 减 num2 。
- 操作 3 ：num1 = 1 ，num2 = 1 。由于 num1 == num2 ，num1 减 num2 。
此时 num1 = 0 ，num2 = 1 。由于 num1 == 0 ，不需要再执行任何操作。
所以总操作数是 3 。
示例 2：
输入：num1 = 10, num2 = 10
输出：1
解释：
- 操作 1 ：num1 = 10 ，num2 = 10 。由于 num1 == num2 ，num1 减 num2 得到 num1 = 10 - 10 = 0 。
此时 num1 = 0 ，num2 = 10 。由于 num1 == 0 ，不需要再执行任何操作。
所以总操作数是 1 。
  提示：
0 <= num1, num2 <= 105",6,,11381,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],14993
评论 (105),minimum-operations-to-make-the-array-alternating,中等,"给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。
如果满足下述条件，则数组 nums 是一个 交替数组 ：
nums[i - 2] == nums[i] ，其中 2 <= i <= n - 1 。
nums[i - 1] != nums[i] ，其中 1 <= i <= n - 1 。
在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。
返回使数组变成交替数组的 最少操作数 。
  示例 1：
输入：nums = [3,1,3,2,4,3]
输出：3
解释：
使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。
在这种情况下，操作数为 3 。
可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。
示例 2：
输入：nums = [1,2,2,2,2]
输出：2
解释：
使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1].
在这种情况下，操作数为 2 。
注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 105",29,,6713,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],22861
评论 (108),removing-minimum-number-of-magic-beans,中等,"给你一个 正 整数数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。
请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少 还有 一颗 魔法豆的袋子）魔法豆的数目 相等 。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。
请你返回你需要拿出魔法豆的 最少数目。
  示例 1：
输入：beans = [4,1,6,5]
输出：4
解释：
- 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,6,5]
- 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,4,5]
- 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,4,4]
总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。
没有比取出 4 个魔法豆更少的方案。
示例 2：
输入：beans = [2,10,3,2]
输出：7
解释：
- 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,3,2]
- 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,3,0]
- 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,0,0]
总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。
没有比取出 7 个魔法豆更少的方案。
  提示：
1 <= beans.length <= 105
1 <= beans[i] <= 105",33,,7297,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sorting/']",[],18641
评论 (37),maximum-and-sum-of-array,困难,"给你一个长度为 n 的整数数组 nums 和一个整数 numSlots ，满足2 * numSlots >= n 。总共有 numSlots 个篮子，编号为 1 到 numSlots 。
你需要把所有 n 个整数分到这些篮子中，且每个篮子 至多 有 2 个整数。一种分配方案的 与和 定义为每个数与它所在篮子编号的 按位与运算 结果之和。
比方说，将数字 [1, 3] 放入篮子 1 中，[4, 6] 放入篮子 2 中，这个方案的与和为 (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4 。
请你返回将 nums 中所有数放入 numSlots 个篮子中的最大与和。
  示例 1：
输入：nums = [1,2,3,4,5,6], numSlots = 3
输出：9
解释：一个可行的方案是 [1, 4] 放入篮子 1 中，[2, 6] 放入篮子 2 中，[3, 5] 放入篮子 3 中。
最大与和为 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。
示例 2：
输入：nums = [1,3,10,4,7,1], numSlots = 9
输出：24
解释：一个可行的方案是 [1, 1] 放入篮子 1 中，[3] 放入篮子 3 中，[4] 放入篮子 4 中，[7] 放入篮子 7 中，[10] 放入篮子 9 中。
最大与和为 (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。
注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。
  提示：
n == nums.length
1 <= numSlots <= 9
1 <= n <= 2 * numSlots
1 <= nums[i] <= 15",40,,3321,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],6955
评论 (23),longest-winning-streak,Unknown,,-1,,-1,[],[],-1
评论 (4),remove-all-ones-with-row-and-column-flips-ii,Unknown,,-1,,-1,[],[],-1
评论 (28),the-change-in-global-rankings,Unknown,,-1,,-1,[],[],-1
评论 (31),count-equal-and-divisible-pairs-in-an-array,简单,"给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 k ，请你返回满足 0 <= i < j < n ，nums[i] == nums[j] 且 (i * j) 能被 k 整除的数对 (i, j) 的 数目 。
  示例 1：
输入：nums = [3,1,2,2,2,1,3], k = 2
输出：4
解释：
总共有 4 对数符合所有要求：
- nums[0] == nums[6] 且 0 * 6 == 0 ，能被 2 整除。
- nums[2] == nums[3] 且 2 * 3 == 6 ，能被 2 整除。
- nums[2] == nums[4] 且 2 * 4 == 8 ，能被 2 整除。
- nums[3] == nums[4] 且 3 * 4 == 12 ，能被 2 整除。
示例 2：
输入：nums = [1,2,3,4], k = 1
输出：0
解释：由于数组中没有重复数值，所以没有数对 (i,j) 符合所有要求。
  提示：
1 <= nums.length <= 100
1 <= nums[i], k <= 100",6,,6874,['https://leetcode.cn/tag/array/'],[],8535
评论 (42),find-three-consecutive-integers-that-sum-to-a-given-number,中等,"给你一个整数 num ，请你返回三个连续的整数，它们的 和 为 num 。如果 num 无法被表示成三个连续整数的和，请你返回一个 空 数组。
  示例 1：
输入：num = 33
输出：[10,11,12]
解释：33 可以表示为 10 + 11 + 12 = 33 。
10, 11, 12 是 3 个连续整数，所以返回 [10, 11, 12] 。
示例 2：
输入：num = 4
输出：[]
解释：没有办法将 4 表示成 3 个连续整数的和。
  提示：
0 <= num <= 1015",6,,5944,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],8605
评论 (51),maximum-split-of-positive-even-integers,中等,"给你一个整数 finalSum 。请你将它拆分成若干个 互不相同 的正偶数之和，且拆分出来的正偶数数目 最多 。
比方说，给你 finalSum = 12 ，那么这些拆分是 符合要求 的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意 finalSum 不能拆分成 (2 + 2 + 4 + 4) ，因为拆分出来的整数必须互不相同。
请你返回一个整数数组，表示将整数拆分成 最多 数目的正偶数数组。如果没有办法将 finalSum 进行拆分，请你返回一个 空 数组。你可以按 任意 顺序返回这些整数。
  示例 1：
输入：finalSum = 12
输出：[2,4,6]
解释：以下是一些符合要求的拆分：(2 + 10)，(2 + 4 + 6) 和 (4 + 8) 。
(2 + 4 + 6) 为最多数目的整数，数目为 3 ，所以我们返回 [2,4,6] 。
[2,6,4] ，[6,2,4] 等等也都是可行的解。
示例 2：
输入：finalSum = 7
输出：[]
解释：没有办法将 finalSum 进行拆分。
所以返回空数组。
示例 3：
输入：finalSum = 28
输出：[6,8,2,12]
解释：以下是一些符合要求的拆分：(2 + 26)，(6 + 8 + 2 + 12) 和 (4 + 24) 。
(6 + 8 + 2 + 12) 有最多数目的整数，数目为 4 ，所以我们返回 [6,8,2,12] 。
[10,2,4,12] ，[6,2,4,16] 等等也都是可行的解。
  提示：
1 <= finalSum <= 1010",11,,5549,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/']",[],10032
评论 (61),count-good-triplets-in-an-array,困难,"给你两个下标从 0 开始且长度为 n 的整数数组 nums1 和 nums2 ，两者都是 [0, 1, ..., n - 1] 的 排列 。
好三元组 指的是 3 个 互不相同 的值，且它们在数组 nums1 和 nums2 中出现顺序保持一致。换句话说，如果我们将 pos1v 记为值 v 在 nums1 中出现的位置，pos2v 为值 v 在 nums2 中的位置，那么一个好三元组定义为 0 <= x, y, z <= n - 1 ，且 pos1x < pos1y < pos1z 和 pos2x < pos2y < pos2z 都成立的 (x, y, z) 。
请你返回好三元组的 总数目 。
  示例 1：
输入：nums1 = [2,0,1,3], nums2 = [0,1,2,3]
输出：1
解释：
总共有 4 个三元组 (x,y,z) 满足 pos1x < pos1y < pos1z ，分别是 (2,0,1) ，(2,0,3) ，(2,1,3) 和 (0,1,3) 。
这些三元组中，只有 (0,1,3) 满足 pos2x < pos2y < pos2z 。所以只有 1 个好三元组。
示例 2：
输入：nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
输出：4
解释：总共有 4 个好三元组 (4,0,3) ，(4,0,2) ，(4,1,3) 和 (4,1,2) 。
  提示：
n == nums1.length == nums2.length
3 <= n <= 105
0 <= nums1[i], nums2[i] <= n - 1
nums1 和 nums2 是 [0, 1, ..., n - 1] 的排列。",34,,2448,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/merge-sort/']",[],7417
评论 (47),count-integers-with-even-digit-sum,简单,"给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。
正整数的 各位数字之和 是其所有位上的对应数字相加的结果。
  示例 1：
输入：num = 4
输出：2
解释：
只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。    
示例 2：
输入：num = 30
输出：14
解释：
只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： 
2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。
  提示：
1 <= num <= 1000",6,,8901,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/simulation/']",[],13753
评论 (72),merge-nodes-in-between-zeros,中等,"给你一个链表的头节点 head ，该链表包含由 0 分隔开的一连串整数。链表的 开端 和 末尾 的节点都满足 Node.val == 0 。
对于每两个相邻的 0 ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。
 返回修改后链表的头节点 head 。
  示例 1：
输入：head = [0,3,1,0,4,5,2,0]
输出：[4,11]
解释：
上图表示输入的链表。修改后的链表包含：
- 标记为绿色的节点之和：3 + 1 = 4
- 标记为红色的节点之和：4 + 5 + 2 = 11
示例 2：
输入：head = [0,1,0,3,0,2,2,0]
输出：[1,3,4]
解释：
上图表示输入的链表。修改后的链表包含：
- 标记为绿色的节点之和：1 = 1
- 标记为红色的节点之和：3 = 3
- 标记为黄色的节点之和：2 + 2 = 4
  提示：
列表中的节点数目在范围 [3, 2 * 105] 内
0 <= Node.val <= 1000
不 存在连续两个 Node.val == 0 的节点
链表的 开端 和 末尾 节点都满足 Node.val == 0",11,,9539,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/simulation/']",[],11081
评论 (55),construct-string-with-repeat-limit,中等,"给你一个字符串 s 和一个整数 repeatLimit ，用 s 中的字符构造一个新字符串 repeatLimitedString ，使任何字母 连续 出现的次数都不超过 repeatLimit 次。你不必使用 s 中的全部字符。
返回 字典序最大的 repeatLimitedString 。
如果在字符串 a 和 b 不同的第一个位置，字符串 a 中的字母在字母表中出现时间比字符串 b 对应的字母晚，则认为字符串 a 比字符串 b 字典序更大 。如果字符串中前 min(a.length, b.length) 个字符都相同，那么较长的字符串字典序更大。
  示例 1：
输入：s = ""cczazcc"", repeatLimit = 3
输出：""zzcccac""
解释：使用 s 中的所有字符来构造 repeatLimitedString ""zzcccac""。
字母 'a' 连续出现至多 1 次。
字母 'c' 连续出现至多 3 次。
字母 'z' 连续出现至多 2 次。
因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。
该字符串是字典序最大的 repeatLimitedString ，所以返回 ""zzcccac"" 。
注意，尽管 ""zzcccca"" 字典序更大，但字母 'c' 连续出现超过 3 次，所以它不是一个有效的 repeatLimitedString 。
示例 2：
输入：s = ""aababab"", repeatLimit = 2
输出：""bbabaa""
解释：
使用 s 中的一些字符来构造 repeatLimitedString ""bbabaa""。 
字母 'a' 连续出现至多 2 次。 
字母 'b' 连续出现至多 2 次。 
因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 
该字符串是字典序最大的 repeatLimitedString ，所以返回 ""bbabaa"" 。 
注意，尽管 ""bbabaaa"" 字典序更大，但字母 'a' 连续出现超过 2 次，所以它不是一个有效的 repeatLimitedString 。
  提示：
1 <= repeatLimit <= s.length <= 105
s 由小写英文字母组成",21,,5952,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],12419
评论 (36),count-array-pairs-divisible-by-k,困难,"给你一个下标从 0 开始、长度为 n 的整数数组 nums 和一个整数 k ，返回满足下述条件的下标对 (i, j) 的数目：
0 <= i < j <= n - 1 且
nums[i] * nums[j] 能被 k 整除。
  示例 1：
输入：nums = [1,2,3,4,5], k = 2
输出：7
解释：
共有 7 对下标的对应积可以被 2 整除：
(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)
它们的积分别是 2、4、6、8、10、12 和 20 。
其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。    
示例 2：
输入：nums = [1,2,3,4], k = 5
输出：0
解释：不存在对应积可以被 5 整除的下标对。
  提示：
1 <= nums.length <= 105
1 <= nums[i], k <= 105",44,,3917,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/number-theory/']",[],14549
评论 (10),number-of-ways-to-build-sturdy-brick-wall,Unknown,,-1,,-1,[],[],-1
评论 (59),counting-words-with-a-given-prefix,简单,"给你一个字符串数组 words 和一个字符串 pref 。
返回 words 中以 pref 作为 前缀 的字符串的数目。
字符串 s 的 前缀 就是  s 的任一前导连续字符串。
  示例 1：
输入：words = [""pay"",""attention"",""practice"",""attend""], pref = ""at""
输出：2
解释：以 ""at"" 作为前缀的字符串有两个，分别是：""attention"" 和 ""attend"" 。
示例 2：
输入：words = [""leetcode"",""win"",""loops"",""success""], pref = ""code""
输出：0
解释：不存在以 ""code"" 作为前缀的字符串。
  提示：
1 <= words.length <= 100
1 <= words[i].length, pref.length <= 100
words[i] 和 pref 由小写英文字母组成",8,,10874,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],13662
评论 (53),minimum-number-of-steps-to-make-two-strings-anagram-ii,中等,"给你两个字符串 s 和 t 。在一步操作中，你可以给 s 或者 t 追加 任一字符 。
返回使 s 和 t 互为 字母异位词 所需的最少步骤数。
字母异位词 指字母相同但是顺序不同（或者相同）的字符串。
  示例 1：
输入：s = ""leetcode"", t = ""coats""
输出：7
解释：
- 执行 2 步操作，将 ""as"" 追加到 s = ""leetcode"" 中，得到 s = ""leetcodeas"" 。
- 执行 5 步操作，将 ""leede"" 追加到 t = ""coats"" 中，得到 t = ""coatsleede"" 。
""leetcodeas"" 和 ""coatsleede"" 互为字母异位词。
总共用去 2 + 5 = 7 步。
可以证明，无法用少于 7 步操作使这两个字符串互为字母异位词。
示例 2：
输入：s = ""night"", t = ""thing""
输出：0
解释：给出的字符串已经互为字母异位词。因此，不需要任何进一步操作。
  提示：
1 <= s.length, t.length <= 2 * 105
s 和 t 由小写英文字符组成",9,,8960,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],12507
评论 (97),minimum-time-to-complete-trips,中等,"给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。
每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。
给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。
  示例 1：
输入：time = [1,2,3], totalTrips = 5
输出：3
解释：
- 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。
  已完成的总旅途数为 1 + 0 + 0 = 1 。
- 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。
  已完成的总旅途数为 2 + 1 + 0 = 3 。
- 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。
  已完成的总旅途数为 3 + 1 + 1 = 5 。
所以总共完成至少 5 趟旅途的最少时间为 3 。
示例 2：
输入：time = [2], totalTrips = 1
输出：2
解释：
只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。
所以完成 1 趟旅途的最少时间为 2 。
  提示：
1 <= time.length <= 105
1 <= time[i], totalTrips <= 107",32,,9510,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],36268
评论 (49),minimum-time-to-finish-the-race,困难,"给你一个下标从 0 开始的二维整数数组 tires ，其中 tires[i] = [fi, ri] 表示第 i 种轮胎如果连续使用，第 x 圈需要耗时 fi * ri(x-1) 秒。
比方说，如果 fi = 3 且 ri = 2 ，且一直使用这种类型的同一条轮胎，那么该轮胎完成第 1 圈赛道耗时 3 秒，完成第 2 圈耗时 3 * 2 = 6 秒，完成第 3 圈耗时 3 * 22 = 12 秒，依次类推。
同时给你一个整数 changeTime 和一个整数 numLaps 。
比赛总共包含 numLaps 圈，你可以选择 任意 一种轮胎开始比赛。每一种轮胎都有 无数条 。每一圈后，你可以选择耗费 changeTime 秒 换成 任意一种轮胎（也可以换成当前种类的新轮胎）。
请你返回完成比赛需要耗费的 最少 时间。
  示例 1：
输入：tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4
输出：21
解释：
第 1 圈：使用轮胎 0 ，耗时 2 秒。
第 2 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。
第 3 圈：耗费 5 秒换一条新的轮胎 0 ，然后耗时 2 秒完成这一圈。
第 4 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。
总耗时 = 2 + 6 + 5 + 2 + 6 = 21 秒。
完成比赛的最少时间为 21 秒。
示例 2：
输入：tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5
输出：25
解释：
第 1 圈：使用轮胎 1 ，耗时 2 秒。
第 2 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。
第 3 圈：耗时 6 秒换一条新的轮胎 1 ，然后耗时 2 秒完成这一圈。
第 4 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。
第 5 圈：耗时 6 秒换成轮胎 0 ，然后耗时 1 秒完成这一圈。
总耗时 = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 秒。
完成比赛的最少时间为 25 秒。
  提示：
1 <= tires.length <= 105
tires[i].length == 2
1 <= fi, changeTime <= 105
2 <= ri <= 105
1 <= numLaps <= 1000",53,,3608,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],8493
评论 (1),number-of-ways-to-build-house-of-cards,Unknown,,-1,,-1,[],[],-1
评论 (55),most-frequent-number-following-key-in-an-array,简单,"给你一个下标从 0 开始的整数数组 nums ，同时给你一个整数 key ，它在 nums 出现过。
统计 在 nums 数组中紧跟着 key 后面出现的不同整数 target 的出现次数。换言之，target 的出现次数为满足以下条件的 i 的数目：
0 <= i <= n - 2
nums[i] == key 且
nums[i + 1] == target 。
请你返回出现 最多 次数的 target 。测试数据保证出现次数最多的 target 是唯一的。
  示例 1：
输入：nums = [1,100,200,1,100], key = 1
输出：100
解释：对于 target = 100 ，在下标 1 和 4 处出现过 2 次，且都紧跟着 key 。
没有其他整数在 key 后面紧跟着出现，所以我们返回 100 。
示例 2：
输入：nums = [2,2,2,2,3], key = 2
输出：2
解释：对于 target = 2 ，在下标 1 ，2 和 3 处出现过 3 次，且都紧跟着 key 。
对于 target = 3 ，在下标 4 出出现过 1 次，且紧跟着 key 。
target = 2 是紧跟着 key 之后出现次数最多的数字，所以我们返回 2 。
  提示：
2 <= nums.length <= 1000
1 <= nums[i] <= 1000
测试数据保证答案是唯一的。",5,,6464,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],11062
评论 (81),sort-the-jumbled-numbers,中等,"给你一个下标从 0 开始的整数数组 mapping ，它表示一个十进制数的映射规则，mapping[i] = j 表示这个规则下将数位 i 映射为数位 j 。
一个整数 映射后的值 为将原数字每一个数位 i （0 <= i <= 9）映射为 mapping[i] 。
另外给你一个整数数组 nums ，请你将数组 nums 中每个数按照它们映射后对应数字非递减顺序排序后返回。
注意：
如果两个数字映射后对应的数字大小相同，则将它们按照输入中的 相对顺序 排序。
nums 中的元素只有在排序的时候需要按照映射后的值进行比较，返回的值应该是输入的元素本身。
  示例 1：
输入：mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]
输出：[338,38,991]
解释：
将数字 991 按照如下规则映射：
1. mapping[9] = 6 ，所有数位 9 都会变成 6 。
2. mapping[1] = 9 ，所有数位 1 都会变成 8 。
所以，991 映射的值为 669 。
338 映射为 007 ，去掉前导 0 后得到 7 。
38 映射为 07 ，去掉前导 0 后得到 7 。
由于 338 和 38 映射后的值相同，所以它们的前后顺序保留原数组中的相对位置关系，338 在 38 的前面。
所以，排序后的数组为 [338,38,991] 。
示例 2：
输入：mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]
输出：[123,456,789]
解释：789 映射为 789 ，456 映射为 456 ，123 映射为 123 。所以排序后数组为 [123,456,789] 。
  提示：
mapping.length == 10
0 <= mapping[i] <= 9
mapping[i] 的值 互不相同 。
1 <= nums.length <= 3 * 104
0 <= nums[i] < 109",8,,5626,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],13444
评论 (62),all-ancestors-of-a-node-in-a-directed-acyclic-graph,中等,"给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。
给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。
请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。
如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。
  示例 1：
输入：n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]
输出：[[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]
解释：
上图为输入所对应的图。
- 节点 0 ，1 和 2 没有任何祖先。
- 节点 3 有 2 个祖先 0 和 1 。
- 节点 4 有 2 个祖先 0 和 2 。
- 节点 5 有 3 个祖先 0 ，1 和 3 。
- 节点 6 有 5 个祖先 0 ，1 ，2 ，3 和 4 。
- 节点 7 有 4 个祖先 0 ，1 ，2 和 3 。
示例 2：
输入：n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
输出：[[],[0],[0,1],[0,1,2],[0,1,2,3]]
解释：
上图为输入所对应的图。
- 节点 0 没有任何祖先。
- 节点 1 有 1 个祖先 0 。
- 节点 2 有 2 个祖先 0 和 1 。
- 节点 3 有 3 个祖先 0 ，1 和 2 。
- 节点 4 有 4 个祖先 0 ，1 ，2 和 3 。
  提示：
1 <= n <= 1000
0 <= edges.length <= min(2000, n * (n - 1) / 2)
edges[i].length == 2
0 <= fromi, toi <= n - 1
fromi != toi
图中不会有重边。
图是 有向 且 无环 的。",18,,4372,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']",[],10401
评论 (36),minimum-number-of-moves-to-make-palindrome,困难,"给你一个只包含小写英文字母的字符串 s 。
每一次 操作 ，你可以选择 s 中两个 相邻 的字符，并将它们交换。
请你返回将 s 变成回文串的 最少操作次数 。
注意 ，输入数据会确保 s 一定能变成一个回文串。
  示例 1：
输入：s = ""aabb""
输出：2
解释：
我们可以将 s 变成 2 个回文串，""abba"" 和 ""baab"" 。
- 我们可以通过 2 次操作得到 ""abba"" ：""aabb"" -> ""abab"" -> ""abba"" 。
- 我们可以通过 2 次操作得到 ""baab"" ：""aabb"" -> ""abab"" -> ""baab"" 。
因此，得到回文串的最少总操作次数为 2 。
示例 2：
输入：s = ""letelt""
输出：2
解释：
通过 2 次操作从 s 能得到回文串 ""lettel"" 。
其中一种方法是：""letelt"" -> ""letetl"" -> ""lettel"" 。
其他回文串比方说 ""tleelt"" 也可以通过 2 次操作得到。
可以证明少于 2 次操作，无法得到回文串。
  提示：
1 <= s.length <= 2000
s 只包含小写英文字母。
s 可以通过有限次操作得到一个回文串。",28,,2382,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],5049
评论 (69),cells-in-a-range-on-an-excel-sheet,简单,"Excel 表中的一个单元格 (r, c) 会以字符串 ""<col><row>"" 的形式进行表示，其中：
<col> 即单元格的列号 c 。用英文字母表中的 字母 标识。
例如，第 1 列用 'A' 表示，第 2 列用 'B' 表示，第 3 列用 'C' 表示，以此类推。
<row> 即单元格的行号 r 。第 r 行就用 整数 r 标识。
给你一个格式为 ""<col1><row1>:<col2><row2>"" 的字符串 s ，其中 <col1> 表示 c1 列，<row1> 表示 r1 行，<col2> 表示 c2 列，<row2> 表示 r2 行，并满足 r1 <= r2 且 c1 <= c2 。
找出所有满足 r1 <= x <= r2 且 c1 <= y <= c2 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 字符串 表示，并以 非递减 顺序排列（先按列排，再按行排）。
  示例 1：
输入：s = ""K1:L2""
输出：[""K1"",""K2"",""L1"",""L2""]
解释：
上图显示了列表中应该出现的单元格。
红色箭头指示单元格的出现顺序。
示例 2：
输入：s = ""A1:F1""
输出：[""A1"",""B1"",""C1"",""D1"",""E1"",""F1""]
解释：
上图显示了列表中应该出现的单元格。 
红色箭头指示单元格的出现顺序。
  提示：
s.length == 5
'A' <= s[0] <= s[3] <= 'Z'
'1' <= s[1] <= s[4] <= '9'
s 由大写英文字母、数字、和 ':' 组成",10,,10383,['https://leetcode.cn/tag/string/'],[],12209
评论 (161),append-k-integers-with-minimal-sum,中等,"给你一个整数数组 nums 和一个整数 k 。请你向 nums 中追加 k 个 未 出现在 nums 中的、互不相同 的 正 整数，并使结果数组的元素和 最小 。
返回追加到 nums 中的 k 个整数之和。
  示例 1：
输入：nums = [1,4,25,10,25], k = 2
输出：5
解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。
nums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。
所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。
示例 2：
输入：nums = [5,6], k = 6
输出：25
解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。
nums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。
所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。
  提示：
1 <= nums.length <= 105
1 <= nums[i], k <= 109",31,,9471,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/sorting/']",[],41226
评论 (68),create-binary-tree-from-descriptions,中等,"给你一个二维整数数组 descriptions ，其中 descriptions[i] = [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外：
如果 isLefti == 1 ，那么 childi 就是 parenti 的左子节点。
如果 isLefti == 0 ，那么 childi 就是 parenti 的右子节点。
请你根据 descriptions 的描述来构造二叉树并返回其 根节点 。
测试用例会保证可以构造出 有效 的二叉树。
  示例 1：
输入：descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
输出：[50,20,80,15,17,19]
解释：根节点是值为 50 的节点，因为它没有父节点。
结果二叉树如上图所示。
示例 2：
输入：descriptions = [[1,2,1],[2,3,0],[3,4,1]]
输出：[1,2,null,null,3,4]
解释：根节点是值为 1 的节点，因为它没有父节点。 
结果二叉树如上图所示。 
  提示：
1 <= descriptions.length <= 104
descriptions[i].length == 3
1 <= parenti, childi <= 105
0 <= isLefti <= 1
descriptions 所描述的二叉树是一棵有效二叉树",24,,7179,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-tree/']",[],9815
评论 (82),replace-non-coprime-numbers-in-array,困难,"给你一个整数数组 nums 。请你对数组执行下述操作：
从 nums 中找出 任意 两个 相邻 的 非互质 数。
如果不存在这样的数，终止 这一过程。
否则，删除这两个数，并 替换 为它们的 最小公倍数（Least Common Multiple，LCM）。
只要还能找出两个相邻的非互质数就继续 重复 这一过程。
返回修改后得到的 最终 数组。可以证明的是，以 任意 顺序替换相邻的非互质数都可以得到相同的结果。
生成的测试用例可以保证最终数组中的值 小于或者等于 108 。
两个数字 x 和 y 满足 非互质数 的条件是：GCD(x, y) > 1 ，其中 GCD(x, y) 是 x 和 y 的 最大公约数 。
  示例 1 ：
输入：nums = [6,4,3,2,7,6,2]
输出：[12,7,6]
解释：
- (6, 4) 是一组非互质数，且 LCM(6, 4) = 12 。得到 nums = [12,3,2,7,6,2] 。
- (12, 3) 是一组非互质数，且 LCM(12, 3) = 12 。得到 nums = [12,2,7,6,2] 。
- (12, 2) 是一组非互质数，且 LCM(12, 2) = 12 。得到 nums = [12,7,6,2] 。
- (6, 2) 是一组非互质数，且 LCM(6, 2) = 6 。得到 nums = [12,7,6] 。
现在，nums 中不存在相邻的非互质数。
因此，修改后得到的最终数组是 [12,7,6] 。
注意，存在其他方法可以获得相同的最终数组。
示例 2 ：
输入：nums = [2,2,1,1,3,3,3]
输出：[2,1,1,3]
解释：
- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,3,3] 。
- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,3] 。
- (2, 2) 是一组非互质数，且 LCM(2, 2) = 2 。得到 nums = [2,1,1,3] 。
现在，nums 中不存在相邻的非互质数。 
因此，修改后得到的最终数组是 [2,1,1,3] 。 
注意，存在其他方法可以获得相同的最终数组。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 105
生成的测试用例可以保证最终数组中的值 小于或者等于 108 。",25,,4768,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/number-theory/']",[],14407
评论 (4),number-of-single-divisor-triplets,Unknown,,-1,,-1,[],[],-1
评论 (16),finding-the-topic-of-each-post,Unknown,,-1,,-1,[],[],-1
评论 (66),find-all-k-distant-indices-in-an-array,简单,"给你一个下标从 0 开始的整数数组 nums 和两个整数 key 和 k 。K 近邻下标 是 nums 中的一个下标 i ，并满足至少存在一个下标 j 使得 |i - j| <= k 且 nums[j] == key 。
以列表形式返回按 递增顺序 排序的所有 K 近邻下标。
  示例 1：
输入：nums = [3,4,9,1,3,9,5], key = 9, k = 1
输出：[1,2,3,4,5,6]
解释：因此，nums[2] == key 且 nums[5] == key 。
- 对下标 0 ，|0 - 2| > k 且 |0 - 5| > k ，所以不存在 j 使得 |0 - j| <= k 且 nums[j] == key 。所以 0 不是一个 K 近邻下标。
- 对下标 1 ，|1 - 2| <= k 且 nums[2] == key ，所以 1 是一个 K 近邻下标。
- 对下标 2 ，|2 - 2| <= k 且 nums[2] == key ，所以 2 是一个 K 近邻下标。
- 对下标 3 ，|3 - 2| <= k 且 nums[2] == key ，所以 3 是一个 K 近邻下标。
- 对下标 4 ，|4 - 5| <= k 且 nums[5] == key ，所以 4 是一个 K 近邻下标。
- 对下标 5 ，|5 - 5| <= k 且 nums[5] == key ，所以 5 是一个 K 近邻下标。
- 对下标 6 ，|6 - 5| <= k 且 nums[5] == key ，所以 6 是一个 K 近邻下标。
因此，按递增顺序返回 [1,2,3,4,5,6] 。 
示例 2：
输入：nums = [2,2,2,2,2], key = 2, k = 2
输出：[0,1,2,3,4]
解释：对 nums 的所有下标 i ，总存在某个下标 j 使得 |i - j| <= k 且 nums[j] == key ，所以每个下标都是一个 K 近邻下标。 
因此，返回 [0,1,2,3,4] 。
  提示：
1 <= nums.length <= 1000
1 <= nums[i] <= 1000
key 是数组 nums 中的一个整数
1 <= k <= nums.length",8,,9976,['https://leetcode.cn/tag/array/'],[],19229
评论 (88),count-artifacts-that-can-be-extracted,中等,"存在一个 n x n 大小、下标从 0 开始的网格，网格中埋着一些工件。给你一个整数 n 和一个下标从 0 开始的二维整数数组 artifacts ，artifacts 描述了矩形工件的位置，其中 artifacts[i] = [r1i, c1i, r2i, c2i] 表示第 i 个工件在子网格中的填埋情况：
(r1i, c1i) 是第 i 个工件 左上 单元格的坐标，且
(r2i, c2i) 是第 i 个工件 右下 单元格的坐标。
你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。
给你一个下标从 0 开始的二维整数数组 dig ，其中 dig[i] = [ri, ci] 表示你将会挖掘单元格 (ri, ci) ，返回你可以提取的工件数目。
生成的测试用例满足：
不存在重叠的两个工件。
每个工件最多只覆盖 4 个单元格。
dig 中的元素互不相同。
  示例 1：
输入：n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]
输出：1
解释： 
不同颜色表示不同的工件。挖掘的单元格用 'D' 在网格中进行标记。
有 1 个工件可以提取，即红色工件。
蓝色工件在单元格 (1,1) 的部分尚未裸露出来，所以无法提取该工件。
因此，返回 1 。
示例 2：
输入：n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]
输出：2
解释：红色工件和蓝色工件的所有部分都裸露出来（用 'D' 标记），都可以提取。因此，返回 2 。 
  提示：
1 <= n <= 1000
1 <= artifacts.length, dig.length <= min(n2, 105)
artifacts[i].length == 4
dig[i].length == 2
0 <= r1i, c1i, r2i, c2i, ri, ci <= n - 1
r1i <= r2i
c1i <= c2i
不存在重叠的两个工件
每个工件 最多 只覆盖 4 个单元格
dig 中的元素互不相同",12,https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram.jpg,7496,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/simulation/']",[],15542
评论 (127),maximize-the-topmost-element-after-k-moves,中等,"给你一个下标从 0 开始的整数数组 nums ，它表示一个 栈 ，其中 nums[0] 是栈顶的元素。
每一次操作中，你可以执行以下操作 之一 ：
如果栈非空，那么 删除 栈顶端的元素。
如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，添加 回栈顶，这个元素成为新的栈顶元素。
同时给你一个整数 k ，它表示你总共需要执行操作的次数。
请你返回 恰好 执行 k 次操作以后，栈顶元素的 最大值 。如果执行完 k 次操作以后，栈一定为空，请你返回 -1 。
  示例 1：
输入：nums = [5,2,2,4,0,6], k = 4
输出：5
解释：
4 次操作后，栈顶元素为 5 的方法之一为：
- 第 1 次操作：删除栈顶元素 5 ，栈变为 [2,2,4,0,6] 。
- 第 2 次操作：删除栈顶元素 2 ，栈变为 [2,4,0,6] 。
- 第 3 次操作：删除栈顶元素 2 ，栈变为 [4,0,6] 。
- 第 4 次操作：将 5 添加回栈顶，栈变为 [5,4,0,6] 。
注意，这不是最后栈顶元素为 5 的唯一方式。但可以证明，4 次操作以后 5 是能得到的最大栈顶元素。
示例 2：
输入：nums = [2], k = 1
输出：-1
解释：
第 1 次操作中，我们唯一的选择是将栈顶元素弹出栈。
由于 1 次操作后无法得到一个非空的栈，所以我们返回 -1 。
  提示：
1 <= nums.length <= 105
0 <= nums[i], k <= 109",16,,7583,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],37053
评论 (69),minimum-weighted-subgraph-with-the-required-paths,困难,"给你一个整数 n ，它表示一个 带权有向 图的节点数，节点编号为 0 到 n - 1 。
同时给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi, weighti] ，表示从 fromi 到 toi 有一条边权为 weighti 的 有向 边。
最后，给你三个 互不相同 的整数 src1 ，src2 和 dest ，表示图中三个不同的点。
请你从图中选出一个 边权和最小 的子图，使得从 src1 和 src2 出发，在这个子图中，都 可以 到达 dest 。如果这样的子图不存在，请返回 -1 。
子图 中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。
  示例 1：
输入：n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5
输出：9
解释：
上图为输入的图。
蓝色边为最优子图之一。
注意，子图 [[1,0,3],[0,5,6]] 也能得到最优解，但无法在满足所有限制的前提下，得到更优解。
示例 2：
输入：n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2
输出：-1
解释：
上图为输入的图。
可以看到，不存在从节点 1 到节点 2 的路径，所以不存在任何子图满足所有限制。
  提示：
3 <= n <= 105
0 <= edges.length <= 105
edges[i].length == 3
0 <= fromi, toi, src1, src2, dest <= n - 1
fromi != toi
src1 ，src2 和 dest 两两不同。
1 <= weight[i] <= 105",38,,3390,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/shortest-path/']",[],9308
评论 (4),distance-to-a-cycle-in-undirected-graph,Unknown,,-1,,-1,[],[],-1
评论 (13),the-number-of-users-that-are-eligible-for-discount,Unknown,,-1,,-1,[],[],-1
评论 (52),divide-array-into-equal-pairs,简单,"给你一个整数数组 nums ，它包含 2 * n 个整数。
你需要将 nums 划分成 n 个数对，满足：
每个元素 只属于一个 数对。
同一数对中的元素 相等 。
如果可以将 nums 划分成 n 个数对，请你返回 true ，否则返回 false 。
  示例 1：
输入：nums = [3,2,3,2,2,2]
输出：true
解释：
nums 中总共有 6 个元素，所以它们应该被划分成 6 / 2 = 3 个数对。
nums 可以划分成 (2, 2) ，(3, 3) 和 (2, 2) ，满足所有要求。
示例 2：
输入：nums = [1,2,3,4]
输出：false
解释：
无法将 nums 划分成 4 / 2 = 2 个数对且满足所有要求。
  提示：
nums.length == 2 * n
1 <= n <= 500
1 <= nums[i] <= 500",5,,7623,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],9985
评论 (61),maximize-number-of-subsequences-in-a-string,中等,"给你一个下标从 0 开始的字符串 text 和另一个下标从 0 开始且长度为 2 的字符串 pattern ，两者都只包含小写英文字母。
你可以在 text 中任意位置插入 一个 字符，这个插入的字符必须是 pattern[0] 或者 pattern[1] 。注意，这个字符可以插入在 text 开头或者结尾的位置。
请你返回插入一个字符后，text 中最多包含多少个等于 pattern 的 子序列 。
子序列 指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。
  示例 1：
输入：text = ""abdcdbc"", pattern = ""ac""
输出：4
解释：
如果我们在 text[1] 和 text[2] 之间添加 pattern[0] = 'a' ，那么我们得到 ""abadcdbc"" 。那么 ""ac"" 作为子序列出现 4 次。
其他得到 4 个 ""ac"" 子序列的方案还有 ""aabdcdbc"" 和 ""abdacdbc"" 。
但是，""abdcadbc"" ，""abdccdbc"" 和 ""abdcdbcc"" 这些字符串虽然是可行的插入方案，但是只出现了 3 次 ""ac"" 子序列，所以不是最优解。
可以证明插入一个字符后，无法得到超过 4 个 ""ac"" 子序列。
示例 2：
输入：text = ""aabb"", pattern = ""ab""
输出：6
解释：
可以得到 6 个 ""ab"" 子序列的部分方案为 ""aaabb"" ，""aaabb"" 和 ""aabbb"" 。
  提示：
1 <= text.length <= 105
pattern.length == 2
text 和 pattern 都只包含小写英文字母。",12,,5438,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/prefix-sum/']",[],18293
评论 (54),minimum-operations-to-halve-array-sum,中等,"给你一个正整数数组 nums 。每一次操作中，你可以从 nums 中选择 任意 一个数并将它减小到 恰好 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）
请你返回将 nums 数组和 至少 减少一半的 最少 操作数。
  示例 1：
输入：nums = [5,19,8,1]
输出：3
解释：初始 nums 的和为 5 + 19 + 8 + 1 = 33 。
以下是将数组和减少至少一半的一种方法：
选择数字 19 并减小为 9.5 。
选择数字 9.5 并减小为 4.75 。
选择数字 8 并减小为 4 。
最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。
nums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 >= 33/2 = 16.5 。
我们需要 3 个操作实现题目要求，所以返回 3 。
可以证明，无法通过少于 3 个操作使数组和减少至少一半。
示例 2：
输入：nums = [3,8,20]
输出：3
解释：初始 nums 的和为 3 + 8 + 20 = 31 。
以下是将数组和减少至少一半的一种方法：
选择数字 20 并减小为 10 。
选择数字 10 并减小为 5 。
选择数字 3 并减小为 1.5 。
最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。
nums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 >= 31/2 = 16.5 。
我们需要 3 个操作实现题目要求，所以返回 3 。
可以证明，无法通过少于 3 个操作使数组和减少至少一半。
  提示：
1 <= nums.length <= 105
1 <= nums[i] <= 107",6,,5035,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],12918
评论 (70),minimum-white-tiles-after-covering-with-carpets,困难,"给你一个下标从 0 开始的 二进制 字符串 floor ，它表示地板上砖块的颜色。
floor[i] = '0' 表示地板上第 i 块砖块的颜色是 黑色 。
floor[i] = '1' 表示地板上第 i 块砖块的颜色是 白色 。
同时给你 numCarpets 和 carpetLen 。你有 numCarpets 条 黑色 的地毯，每一条 黑色 的地毯长度都为 carpetLen 块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 白色 砖块的数目 最小 。地毯相互之间可以覆盖。
请你返回没被覆盖的白色砖块的 最少 数目。
  示例 1：
输入：floor = ""10110101"", numCarpets = 2, carpetLen = 2
输出：2
解释：
上图展示了剩余 2 块白色砖块的方案。
没有其他方案可以使未被覆盖的白色砖块少于 2 块。
示例 2：
输入：floor = ""11111"", numCarpets = 2, carpetLen = 3
输出：0
解释：
上图展示了所有白色砖块都被覆盖的一种方案。
注意，地毯相互之间可以覆盖。
  提示：
1 <= carpetLen <= floor.length <= 1000
floor[i] 要么是 '0' ，要么是 '1' 。
1 <= numCarpets <= 1000",22,,3411,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/prefix-sum/']",[],9488
评论 (69),count-hills-and-valleys-in-an-array,简单,"给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。对于相邻下标 i 和 j ，如果 nums[i] == nums[j] ， 则认为这两下标属于 同一个 峰或谷。
注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。
返回 nums 中峰和谷的数量。
  示例 1：
输入：nums = [2,4,1,1,6,5]
输出：3
解释：
在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。
在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 > 2 且 4 > 1 ，下标 1 是一个峰。
在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 < 4 且 1 < 6 ，下标 2 是一个谷。
在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 < 4 且 1 < 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。
在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 > 1 且 6 > 5 ，下标 4 是一个峰。
在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。
共有 3 个峰和谷，所以返回 3 。
示例 2：
输入：nums = [6,6,5,5,4,1]
输出：0
解释：
在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。
在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。
在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 < 6 且 5 > 4 ，下标 2 既不是峰也不是谷。
在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 < 6 且 5 > 4 ，下标 3 既不是峰也不是谷。
在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 < 5 且 4 > 1 ，下标 4 既不是峰也不是谷。
在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。
共有 0 个峰和谷，所以返回 0 。
  提示：
3 <= nums.length <= 100
1 <= nums[i] <= 100",7,,9633,['https://leetcode.cn/tag/array/'],[],16662
评论 (86),count-collisions-on-a-road,中等,"在一条无限长的公路上有 n 辆汽车正在行驶。汽车按从左到右的顺序按从 0 到 n - 1 编号，每辆车都在一个 独特的 位置。
给你一个下标从 0 开始的字符串 directions ，长度为 n 。directions[i] 可以是 'L'、'R' 或 'S' 分别表示第 i 辆车是向 左 、向 右 或者 停留 在当前位置。每辆车移动时 速度相同 。
碰撞次数可以按下述方式计算：
当两辆移动方向 相反 的车相撞时，碰撞次数加 2 。
当一辆移动的车和一辆静止的车相撞时，碰撞次数加 1 。
碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。
返回在这条道路上发生的 碰撞总次数 。
  示例 1：
输入：directions = ""RLRSLL""
输出：5
解释：
将会在道路上发生的碰撞列出如下：
- 车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。
- 车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。
- 车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。
- 车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。
因此，将会在道路上发生的碰撞总次数是 5 。
示例 2：
输入：directions = ""LLRR""
输出：0
解释：
不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。
  提示：
1 <= directions.length <= 105
directions[i] 的值为 'L'、'R' 或 'S'",19,,7983,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/string/']",[],20577
评论 (111),maximum-points-in-an-archery-competition,中等,"Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：
Alice 先射 numArrows 支箭，然后 Bob 也射 numArrows 支箭。
分数按下述规则计算：
箭靶有若干整数计分区域，范围从 0 到 11 （含 0 和 11）。
箭靶上每个区域都对应一个得分 k（范围是 0 到 11），Alice 和 Bob 分别在得分 k 区域射中 ak 和 bk 支箭。如果 ak >= bk ，那么 Alice 得 k 分。如果 ak < bk ，则 Bob 得 k 分
如果 ak == bk == 0 ，那么无人得到 k 分。
例如，Alice 和 Bob 都向计分为 11 的区域射 2 支箭，那么 Alice 得 11 分。如果 Alice 向计分为 11 的区域射 0 支箭，但 Bob 向同一个区域射 2 支箭，那么 Bob 得 11 分。
给你整数 numArrows 和一个长度为 12 的整数数组 aliceArrows ，该数组表示 Alice 射中 0 到 11 每个计分区域的箭数量。现在，Bob 想要尽可能 最大化 他所能获得的总分。
返回数组 bobArrows ，该数组表示 Bob 射中 0 到 11 每个 计分区域的箭数量。且 bobArrows 的总和应当等于 numArrows 。
如果存在多种方法都可以使 Bob 获得最大总分，返回其中 任意一种 即可。
  示例 1：
输入：numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]
输出：[0,0,0,0,1,1,0,0,1,2,3,1]
解释：上表显示了比赛得分情况。
Bob 获得总分 4 + 5 + 8 + 9 + 10 + 11 = 47 。
可以证明 Bob 无法获得比 47 更高的分数。
示例 2：
输入：numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]
输出：[0,0,0,0,0,0,0,0,1,1,1,0]
解释：上表显示了比赛得分情况。
Bob 获得总分 8 + 9 + 10 = 27 。
可以证明 Bob 无法获得比 27 更高的分数。
  提示：
1 <= numArrows <= 105
aliceArrows.length == bobArrows.length == 12
0 <= aliceArrows[i], bobArrows[i] <= numArrows
sum(aliceArrows[i]) == numArrows",31,,6075,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/enumeration/']",[],12973
评论 (34),longest-substring-of-one-repeating-character,困难,"给你一个下标从 0 开始的字符串 s 。另给你一个下标从 0 开始、长度为 k 的字符串 queryCharacters ，一个下标从 0 开始、长度也是 k 的整数 下标 数组 queryIndices ，这两个都用来描述 k 个查询。
第 i 个查询会将 s 中位于下标 queryIndices[i] 的字符更新为 queryCharacters[i] 。
返回一个长度为 k 的数组 lengths ，其中 lengths[i] 是在执行第 i 个查询 之后 s 中仅由 单个字符重复 组成的 最长子字符串 的 长度 。
  示例 1：
输入：s = ""babacc"", queryCharacters = ""bcb"", queryIndices = [1,3,3]
输出：[3,3,4]
解释：
- 第 1 次查询更新后 s = ""bbbacc"" 。由单个字符重复组成的最长子字符串是 ""bbb"" ，长度为 3 。
- 第 2 次查询更新后 s = ""bbbccc"" 。由单个字符重复组成的最长子字符串是 ""bbb"" 或 ""ccc""，长度为 3 。
- 第 3 次查询更新后 s = ""bbbbcc"" 。由单个字符重复组成的最长子字符串是 ""bbbb"" ，长度为 4 。
因此，返回 [3,3,4] 。
示例 2：
输入：s = ""abyzz"", queryCharacters = ""aa"", queryIndices = [2,1]
输出：[2,3]
解释：
- 第 1 次查询更新后 s = ""abazz"" 。由单个字符重复组成的最长子字符串是 ""zz"" ，长度为 2 。
- 第 2 次查询更新后 s = ""aaazz"" 。由单个字符重复组成的最长子字符串是 ""aaa"" ，长度为 3 。
因此，返回 [2,3] 。
  提示：
1 <= s.length <= 105
s 由小写英文字母组成
k == queryCharacters.length == queryIndices.length
1 <= k <= 105
queryCharacters 由小写英文字母组成
0 <= queryIndices[i] < s.length",22,,2097,"['https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/ordered-set/']",[],5739
评论 (5),minimum-health-to-beat-game,Unknown,,-1,,-1,[],[],-1
评论 (37),find-the-difference-of-two-arrays,简单,"给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中：
answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。
answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。
注意：列表中的整数可以按 任意 顺序返回。
  示例 1：
输入：nums1 = [1,2,3], nums2 = [2,4,6]
输出：[[1,3],[4,6]]
解释：
对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。
对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。
示例 2：
输入：nums1 = [1,2,3,3], nums2 = [1,1,2,2]
输出：[[3],[]]
解释：
对于 nums1 ，nums1[2] 和 nums1[3] 没有出现在 nums2 中。由于 nums1[2] == nums1[3] ，二者的值只需要在 answer[0] 中出现一次，故 answer[0] = [3]。
nums2 中的每个整数都在 nums1 中出现，因此，answer[1] = [] 。 
  提示：
1 <= nums1.length, nums2.length <= 1000
-1000 <= nums1[i], nums2[i] <= 1000",6,,10053,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/']",[],14988
评论 (71),minimum-deletions-to-make-array-beautiful,中等,"给你一个下标从 0 开始的整数数组 nums ，如果满足下述条件，则认为数组 nums 是一个 美丽数组 ：
nums.length 为偶数
对所有满足 i % 2 == 0 的下标 i ，nums[i] != nums[i + 1] 均成立
注意，空数组同样认为是美丽数组。
你可以从 nums 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 不变 。
返回使 nums 变为美丽数组所需删除的 最少 元素数目。
  示例 1：
输入：nums = [1,1,2,3,5]
输出：1
解释：可以删除 nums[0] 或 nums[1] ，这样得到的 nums = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。
示例 2：
输入：nums = [1,1,2,2,3,3]
输出：2
解释：可以删除 nums[0] 和 nums[5] ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 105",21,,7951,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/']",[],16909
评论 (75),find-palindrome-with-fixed-length,中等,"给你一个整数数组 queries 和一个 正 整数 intLength ，请你返回一个数组 answer ，其中 answer[i] 是长度为 intLength 的 正回文数 中第 queries[i] 小的数字，如果不存在这样的回文数，则为 -1 。
回文数 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。
  示例 1：
输入：queries = [1,2,3,4,5,90], intLength = 3
输出：[101,111,121,131,141,999]
解释：
长度为 3 的最小回文数依次是：
101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...
第 90 个长度为 3 的回文数是 999 。
示例 2：
输入：queries = [2,4,6], intLength = 4
输出：[1111,1331,1551]
解释：
长度为 4 的前 6 个回文数是：
1001, 1111, 1221, 1331, 1441 和 1551 。
  提示：
1 <= queries.length <= 5 * 104
1 <= queries[i] <= 109
1 <= intLength <= 15",22,,6154,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],19056
评论 (60),maximum-value-of-k-coins-from-piles,困难,"一张桌子上总共有 n 个硬币 栈 。每个栈有 正整数 个带面值的硬币。
每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里。
给你一个列表 piles ，其中 piles[i] 是一个整数数组，分别表示第 i 个栈里 从顶到底 的硬币面值。同时给你一个正整数 k ，请你返回在 恰好 进行 k 次操作的前提下，你钱包里硬币面值之和 最大为多少 。
  示例 1：
输入：piles = [[1,100,3],[7,8,9]], k = 2
输出：101
解释：
上图展示了几种选择 k 个硬币的不同方法。
我们可以得到的最大面值为 101 。
示例 2：
输入：piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7
输出：706
解释：
如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。
  提示：
n == piles.length
1 <= n <= 1000
1 <= piles[i][j] <= 105
1 <= k <= sum(piles[i].length) <= 2000",37,,4654,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/prefix-sum/']",[],8754
评论 (9),maximum-sum-score-of-array,Unknown,,-1,,-1,[],[],-1
评论 (63),minimum-bit-flips-to-convert-number,简单,"一次 位翻转 定义为将数字 x 二进制中的一个位进行 翻转 操作，即将 0 变成 1 ，或者将 1 变成 0 。
比方说，x = 7 ，二进制表示为 111 ，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到 110 ，或者翻转右边起第二位得到 101 ，或者翻转右边起第五位（这一位是前导 0 ）得到 10111 等等。
给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的 最少位翻转 次数。
  示例 1：
输入：start = 10, goal = 7
输出：3
解释：10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：
- 翻转右边起第一位得到：1010 -> 1011 。
- 翻转右边起第三位：1011 -> 1111 。
- 翻转右边起第四位：1111 -> 0111 。
我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。
示例 2：
输入：start = 3, goal = 4
输出：3
解释：3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：
- 翻转右边起第一位：011 -> 010 。
- 翻转右边起第二位：010 -> 000 。
- 翻转右边起第三位：000 -> 100 。
我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。
  提示：
0 <= start, goal <= 109",4,,6001,['https://leetcode.cn/tag/bit-manipulation/'],[],7254
评论 (39),find-triangular-sum-of-an-array,中等,"给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 0 到 9 之间（两者都包含）的一个数字。
nums 的 三角和 是执行以下操作以后最后剩下元素的值：
nums 初始包含 n 个元素。如果 n == 1 ，终止 操作。否则，创建 一个新的下标从 0 开始的长度为 n - 1 的整数数组 newNums 。
对于满足 0 <= i < n - 1 的下标 i ，newNums[i] 赋值 为 (nums[i] + nums[i+1]) % 10 ，% 表示取余运算。
将 newNums 替换 数组 nums 。
从步骤 1 开始 重复 整个过程。
请你返回 nums 的三角和。
  示例 1：
输入：nums = [1,2,3,4,5]
输出：8
解释：
上图展示了得到数组三角和的过程。
示例 2：
输入：nums = [5]
输出：5
解释：
由于 nums 中只有一个元素，数组的三角和为这个元素自己。
  提示：
1 <= nums.length <= 1000
0 <= nums[i] <= 9",1,,5750,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/combinatorics/', 'https://leetcode.cn/tag/simulation/']",[],7185
评论 (57),number-of-ways-to-select-buildings,中等,"给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：
s[i] = '0' 表示第 i 栋建筑是一栋办公楼，
s[i] = '1' 表示第 i 栋建筑是一间餐厅。
作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。
比方说，给你 s = ""001101"" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 ""011"" ，有相邻两栋建筑是同一类型，所以 不合 题意。
请你返回可以选择 3 栋建筑的 有效方案数 。
  示例 1：
输入：s = ""001101""
输出：6
解释：
以下下标集合是合法的：
- [0,2,4] ，从 ""001101"" 得到 ""010""
- [0,3,4] ，从 ""001101"" 得到 ""010""
- [1,2,4] ，从 ""001101"" 得到 ""010""
- [1,3,4] ，从 ""001101"" 得到 ""010""
- [2,4,5] ，从 ""001101"" 得到 ""101""
- [3,4,5] ，从 ""001101"" 得到 ""101""
没有别的合法选择，所以总共有 6 种方法。
示例 2：
输入：s = ""11100""
输出：0
解释：没有任何符合题意的选择。
  提示：
3 <= s.length <= 105
s[i] 要么是 '0' ，要么是 '1' 。",23,,4669,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/prefix-sum/']",[],9906
评论 (27),sum-of-scores-of-built-strings,困难,"你需要从空字符串开始 构造 一个长度为 n 的字符串 s ，构造的过程为每次给当前字符串 前面 添加 一个 字符。构造过程中得到的所有字符串编号为 1 到 n ，其中长度为 i 的字符串编号为 si 。
比方说，s = ""abaca"" ，s1 == ""a"" ，s2 == ""ca"" ，s3 == ""aca"" 依次类推。
si 的 得分 为 si 和 sn 的 最长公共前缀 的长度（注意 s == sn ）。
给你最终的字符串 s ，请你返回每一个 si 的 得分之和 。
  示例 1：
输入：s = ""babab""
输出：9
解释：
s1 == ""b"" ，最长公共前缀是 ""b"" ，得分为 1 。
s2 == ""ab"" ，没有公共前缀，得分为 0 。
s3 == ""bab"" ，最长公共前缀为 ""bab"" ，得分为 3 。
s4 == ""abab"" ，没有公共前缀，得分为 0 。
s5 == ""babab"" ，最长公共前缀为 ""babab"" ，得分为 5 。
得分和为 1 + 0 + 3 + 0 + 5 = 9 ，所以我们返回 9 。
示例 2 ：
输入：s = ""azbazbzaz""
输出：14
解释：
s2 == ""az"" ，最长公共前缀为 ""az"" ，得分为 2 。
s6 == ""azbzaz"" ，最长公共前缀为 ""azb"" ，得分为 3 。
s9 == ""azbazbzaz"" ，最长公共前缀为 ""azbazbzaz"" ，得分为 9 。
其他 si 得分均为 0 。
得分和为 2 + 3 + 9 = 14 ，所以我们返回 14 。
  提示：
1 <= s.length <= 105
s 只包含小写英文字母。",24,,2555,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/string-matching/', 'https://leetcode.cn/tag/suffix-array/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],7581
评论 (64),minimum-number-of-operations-to-convert-time,简单,"给你两个字符串 current 和 correct ，表示两个 24 小时制时间 。
24 小时制时间 按 ""HH:MM"" 进行格式化，其中 HH 在 00 和 23 之间，而 MM 在 00 和 59 之间。最早的 24 小时制时间为 00:00 ，最晚的是 23:59 。
在一步操作中，你可以将 current 这个时间增加 1、5、15 或 60 分钟。你可以执行这一操作 任意 次数。
返回将 current 转化为 correct 需要的 最少操作数 。
  示例 1：
输入：current = ""02:30"", correct = ""04:35""
输出：3
解释：
可以按下述 3 步操作将 current 转换为 correct ：
- 为 current 加 60 分钟，current 变为 ""03:30"" 。
- 为 current 加 60 分钟，current 变为 ""04:30"" 。 
- 为 current 加 5 分钟，current 变为 ""04:35"" 。
可以证明，无法用少于 3 步操作将 current 转化为 correct 。
示例 2：
输入：current = ""11:00"", correct = ""11:01""
输出：1
解释：只需要为 current 加一分钟，所以最小操作数是 1 。
  提示：
current 和 correct 都符合 ""HH:MM"" 格式
current <= correct",7,,9222,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/']",[],13344
评论 (49),find-players-with-zero-or-one-losses,中等,"给你一个整数数组 matches 其中 matches[i] = [winneri, loseri] 表示在一场比赛中 winneri 击败了 loseri 。
返回一个长度为 2 的列表 answer ：
answer[0] 是所有 没有 输掉任何比赛的玩家列表。
answer[1] 是所有恰好输掉 一场 比赛的玩家列表。
两个列表中的值都应该按 递增 顺序返回。
注意：
只考虑那些参与 至少一场 比赛的玩家。
生成的测试用例保证 不存在 两场比赛结果 相同 。
  示例 1：
输入：matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
输出：[[1,2,10],[4,5,7,8]]
解释：
玩家 1、2 和 10 都没有输掉任何比赛。
玩家 4、5、7 和 8 每个都输掉一场比赛。
玩家 3、6 和 9 每个都输掉两场比赛。
因此，answer[0] = [1,2,10] 和 answer[1] = [4,5,7,8] 。
示例 2：
输入：matches = [[2,3],[1,3],[5,4],[6,4]]
输出：[[1,2,5,6],[]]
解释：
玩家 1、2、5 和 6 都没有输掉任何比赛。
玩家 3 和 4 每个都输掉两场比赛。
因此，answer[0] = [1,2,5,6] 和 answer[1] = [] 。
  提示：
1 <= matches.length <= 105
matches[i].length == 2
1 <= winneri, loseri <= 105
winneri != loseri
所有 matches[i] 互不相同",5,,8459,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],13541
评论 (78),maximum-candies-allocated-to-k-children,中等,"给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。
另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。
返回每个小孩可以拿走的 最大糖果数目 。
  示例 1：
输入：candies = [5,8,6], k = 3
输出：5
解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。
示例 2：
输入：candies = [2,5], k = 11
输出：0
解释：总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。
  提示：
1 <= candies.length <= 105
1 <= candies[i] <= 107
1 <= k <= 1012",28,,8203,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],25364
评论 (81),encrypt-and-decrypt-strings,困难,"给你一个字符数组 keys ，由若干 互不相同 的字符组成。还有一个字符串数组 values ，内含若干长度为 2 的字符串。另给你一个字符串数组 dictionary ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 0 开始字符串的数据结构。
字符串 加密 按下述步骤进行：
对字符串中的每个字符 c ，先从 keys 中找出满足 keys[i] == c 的下标 i 。
在字符串中，用 values[i] 替换字符 c 。
字符串 解密 按下述步骤进行：
将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 s ，找出满足 values[i] == s 的一个下标 i 。如果存在多个有效的 i ，从中选择 任意 一个。这意味着一个字符串解密可能得到多个解密字符串。
在字符串中，用 keys[i] 替换 s 。
实现 Encrypter 类：
Encrypter(char[] keys, String[] values, String[] dictionary) 用 keys、values 和 dictionary 初始化 Encrypter 类。
String encrypt(String word1) 按上述加密过程完成对 word1 的加密，并返回加密后的字符串。
int decrypt(String word2) 统计并返回可以由 word2 解密得到且出现在 dictionary 中的字符串数目。
  示例：
输入：
[""Encrypter"", ""encrypt"", ""decrypt""]
[[['a', 'b', 'c', 'd'], [""ei"", ""zf"", ""ei"", ""am""], [""abcd"", ""acbd"", ""adbc"", ""badc"", ""dacb"", ""cadb"", ""cbda"", ""abad""]], [""abcd""], [""eizfeiam""]]
输出：
[null, ""eizfeiam"", 2]

解释：
Encrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [""ei"", ""zf"", ""ei"", ""am""], [""abcd"", ""acbd"", ""adbc"", ""badc"", ""dacb"", ""cadb"", ""cbda"", ""abad""]);
encrypter.encrypt(""abcd""); // 返回 ""eizfeiam""。 
                           // 'a' 映射为 ""ei""，'b' 映射为 ""zf""，'c' 映射为 ""ei""，'d' 映射为 ""am""。
encrypter.decrypt(""eizfeiam""); // return 2. 
                              // ""ei"" 可以映射为 'a' 或 'c'，""zf"" 映射为 'b'，""am"" 映射为 'd'。 
                              // 因此，解密后可以得到的字符串是 ""abad""，""cbad""，""abcd"" 和 ""cbcd""。 
                              // 其中 2 个字符串，""abad"" 和 ""abcd""，在 dictionary 中出现，所以答案是 2 。
  提示：
1 <= keys.length == values.length <= 26
values[i].length == 2
1 <= dictionary.length <= 100
1 <= dictionary[i].length <= 100
所有 keys[i] 和 dictionary[i] 互不相同
1 <= word1.length <= 2000
1 <= word2.length <= 200
所有 word1[i] 都出现在 keys 中
word2.length 是偶数
keys、values[i]、dictionary[i]、word1 和 word2 只含小写英文字母
至多调用 encrypt 和 decrypt 总计 200 次",15,,4574,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],11861
评论 (14),users-with-two-purchases-within-seven-days,Unknown,,-1,,-1,[],[],-1
评论 (8),check-if-an-array-is-consecutive,Unknown,,-1,,-1,[],[],-1
评论 (5),the-users-that-are-eligible-for-discount,Unknown,,-1,,-1,[],[],-1
评论 (64),largest-number-after-digit-swaps-by-parity,简单,"给你一个正整数 num 。你可以交换 num 中 奇偶性 相同的任意两位数字（即，都是奇数或者偶数）。
返回交换 任意 次之后 num 的 最大 可能值。
  示例 1：
输入：num = 1234
输出：3412
解释：交换数字 3 和数字 1 ，结果得到 3214 。
交换数字 2 和数字 4 ，结果得到 3412 。
注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。
注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。
示例 2：
输入：num = 65875
输出：87655
解释：交换数字 8 和数字 6 ，结果得到 85675 。
交换数字 5 和数字 7 ，结果得到 87655 。
注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。
  提示：
1 <= num <= 109",12,,8515,"['https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],13492
评论 (74),minimize-result-by-adding-parentheses-to-expression,中等,"给你一个下标从 0 开始的字符串 expression ，格式为 ""<num1>+<num2>"" ，其中 <num1> 和 <num2> 表示正整数。
请你向 expression 中添加一对括号，使得在添加之后， expression 仍然是一个有效的数学表达式，并且计算后可以得到 最小 可能值。左括号 必须 添加在 '+' 的左侧，而右括号必须添加在 '+' 的右侧。
返回添加一对括号后形成的表达式 expression ，且满足 expression 计算得到 最小 可能值。如果存在多个答案都能产生相同结果，返回任意一个答案。
生成的输入满足：expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围。
  示例 1：
输入：expression = ""247+38""
输出：""2(47+38)""
解释：表达式计算得到 2 * (47 + 38) = 2 * 85 = 170 。
注意 ""2(4)7+38"" 不是有效的结果，因为右括号必须添加在 '+' 的右侧。
可以证明 170 是最小可能值。
示例 2：
输入：expression = ""12+34""
输出：""1(2+3)4""
解释：表达式计算得到 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20 。
示例 3：
输入：expression = ""999+999""
输出：""(999+999)""
解释：表达式计算得到 999 + 999 = 1998 。
  提示：
3 <= expression.length <= 10
expression 仅由数字 '1' 到 '9' 和 '+' 组成
expression 由数字开始和结束
expression 恰好仅含有一个 '+'.
expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围",8,,6254,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/enumeration/']",[],10275
评论 (91),maximum-product-after-k-increments,中等,"给你一个非负整数数组 nums 和一个整数 k 。每次操作，你可以选择 nums 中 任一 元素并将它 增加 1 。
请你返回 至多 k 次操作后，能得到的 nums的 最大乘积 。由于答案可能很大，请你将答案对 109 + 7 取余后返回。
  示例 1：
输入：nums = [0,4], k = 5
输出：20
解释：将第一个数增加 5 次。
得到 nums = [5, 4] ，乘积为 5 * 4 = 20 。
可以证明 20 是能得到的最大乘积，所以我们返回 20 。
存在其他增加 nums 的方法，也能得到最大乘积。
示例 2：
输入：nums = [6,3,3,2], k = 2
输出：216
解释：将第二个数增加 1 次，将第四个数增加 1 次。
得到 nums = [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 = 216 。
可以证明 216 是能得到的最大乘积，所以我们返回 216 。
存在其他增加 nums 的方法，也能得到最大乘积。
  提示：
1 <= nums.length, k <= 105
0 <= nums[i] <= 106",15,,6829,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],19195
评论 (41),maximum-total-beauty-of-the-gardens,困难,"Alice 是 n 个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。
给你一个下标从 0 开始大小为 n 的整数数组 flowers ，其中 flowers[i] 是第 i 个花园里已经种的花的数目。已经种了的花 不能 移走。同时给你 newFlowers ，表示 Alice 额外可以种花的 最大数目 。同时给你的还有整数 target ，full 和 partial 。
如果一个花园有 至少 target 朵花，那么这个花园称为 完善的 ，花园的 总美丽值 为以下分数之 和 ：
完善 花园数目乘以 full.
剩余 不完善 花园里，花的 最少数目 乘以 partial 。如果没有不完善花园，那么这一部分的值为 0 。
请你返回 Alice 种最多 newFlowers 朵花以后，能得到的 最大 总美丽值。
  示例 1：
输入：flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
输出：14
解释：Alice 可以按以下方案种花
- 在第 0 个花园种 2 朵花
- 在第 1 个花园种 3 朵花
- 在第 2 个花园种 1 朵花
- 在第 3 个花园种 1 朵花
花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 = 7 朵花。
只有 1 个花园是完善的。
不完善花园里花的最少数目是 2 。
所以总美丽值为 1 * 12 + 2 * 1 = 12 + 2 = 14 。
没有其他方案可以让花园总美丽值超过 14 。
示例 2：
输入：flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
输出：30
解释：Alice 可以按以下方案种花
- 在第 0 个花园种 3 朵花
- 在第 1 个花园种 0 朵花
- 在第 2 个花园种 0 朵花
- 在第 3 个花园种 2 朵花
花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 = 5 朵花。
有 3 个花园是完善的。
不完善花园里花的最少数目为 4 。
所以总美丽值为 3 * 2 + 4 * 6 = 6 + 24 = 30 。
没有其他方案可以让花园总美丽值超过 30 。
注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。
  提示：
1 <= flowers.length <= 105
1 <= flowers[i], target <= 105
1 <= newFlowers <= 1010
1 <= full, partial <= 105",21,,2504,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],9178
评论 (77),add-two-integers,简单,"给你两个整数 num1 和 num2，返回这两个整数的和。
  示例 1：
输入：num1 = 12, num2 = 5
输出：17
解释：num1 是 12，num2 是 5 ，它们的和是 12 + 5 = 17 ，因此返回 17 。
示例 2：
输入：num1 = -10, num2 = 4
输出：-6
解释：num1 + num2 = -6 ，因此返回 -6 。
  提示：
-100 <= num1, num2 <= 100",27,,5282,['https://leetcode.cn/tag/math/'],[],5914
评论 (32),root-equals-sum-of-children,简单,"给你一个 二叉树 的根结点 root，该二叉树由恰好 3 个结点组成：根结点、左子结点和右子结点。
如果根结点值等于两个子结点值之和，返回 true ，否则返回 false 。
  示例 1：
输入：root = [10,4,6]
输出：true
解释：根结点、左子结点和右子结点的值分别是 10 、4 和 6 。
由于 10 等于 4 + 6 ，因此返回 true 。
示例 2：
输入：root = [5,3,1]
输出：false
解释：根结点、左子结点和右子结点的值分别是 5 、3 和 1 。
由于 5 不等于 3 + 1 ，因此返回 false 。
  提示：
树只包含根结点、左子结点和右子结点
-100 <= Node.val <= 100",6,https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png,2438,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-tree/']",[],2796
评论 (7),count-positions-on-street-with-required-brightness,Unknown,,-1,,-1,[],[],-1
评论 (12),number-of-times-a-driver-was-a-passenger,Unknown,,-1,,-1,[],[],-1
评论 (26),find-closest-number-to-zero,简单,"给你一个长度为 n 的整数数组 nums ，请你返回 nums 中最 接近 0 的数字。如果有多个答案，请你返回它们中的 最大值 。
  示例 1：
输入：nums = [-4,-2,1,4,8]
输出：1
解释：
-4 到 0 的距离为 |-4| = 4 。
-2 到 0 的距离为 |-2| = 2 。
1 到 0 的距离为 |1| = 1 。
4 到 0 的距离为 |4| = 4 。
8 到 0 的距离为 |8| = 8 。
所以，数组中距离 0 最近的数字为 1 。
示例 2：
输入：nums = [2,-1,1]
输出：1
解释：1 和 -1 都是距离 0 最近的数字，所以返回较大值 1 。
  提示：
1 <= n <= 1000
-105 <= nums[i] <= 105",4,,6166,['https://leetcode.cn/tag/array/'],[],11024
评论 (25),number-of-ways-to-buy-pens-and-pencils,中等,"给你一个整数 total ，表示你拥有的总钱数。同时给你两个整数 cost1 和 cost2 ，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。
请你返回购买钢笔和铅笔的 不同方案数目 。
  示例 1：
输入：total = 20, cost1 = 10, cost2 = 5
输出：9
解释：一支钢笔的价格为 10 ，一支铅笔的价格为 5 。
- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。
- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。
- 如果你买 2 支钢笔，那么你没法买任何铅笔。
所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。
示例 2：
输入：total = 5, cost1 = 10, cost2 = 10
输出：1
解释：钢笔和铅笔的价格都为 10 ，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0 支钢笔和 0 支铅笔。
  提示：
1 <= total, cost1, cost2 <= 106",3,,4877,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/']",[],8543
评论 (29),design-an-atm-machine,中等,"一个 ATM 机器，存有 5 种面值的钞票：20 ，50 ，100 ，200 和 500 美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。
取款时，机器会优先取 较大 数额的钱。
比方说，你想取 $300 ，并且机器里有 2 张 $50 的钞票，1 张 $100 的钞票和1 张 $200 的钞票，那么机器会取出 $100 和 $200 的钞票。
但是，如果你想取 $600 ，机器里有 3 张 $200 的钞票和1 张 $500 的钞票，那么取款请求会被拒绝，因为机器会先取出 $500 的钞票，然后无法取出剩余的 $100 。注意，因为有 $500 钞票的存在，机器 不能 取 $200 的钞票。
请你实现 ATM 类：
ATM() 初始化 ATM 对象。
void deposit(int[] banknotesCount) 分别存入 $20 ，$50，$100，$200 和 $500 钞票的数目。
int[] withdraw(int amount) 返回一个长度为 5 的数组，分别表示 $20 ，$50，$100 ，$200 和 $500 钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回 [-1] （这种情况下 不 取出任何钞票）。
  示例 1：
输入：
[""ATM"", ""deposit"", ""withdraw"", ""deposit"", ""withdraw"", ""withdraw""]
[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]
输出：
[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]

解释：
ATM atm = new ATM();
atm.deposit([0,0,1,2,1]); // 存入 1 张 $100 ，2 张 $200 和 1 张 $500 的钞票。
atm.withdraw(600);        // 返回 [0,0,1,0,1] 。机器返回 1 张 $100 和 1 张 $500 的钞票。机器里剩余钞票的数量为 [0,0,0,2,0] 。
atm.deposit([0,1,0,1,1]); // 存入 1 张 $50 ，1 张 $200 和 1 张 $500 的钞票。
                          // 机器中剩余钞票数量为 [0,1,0,3,1] 。
atm.withdraw(600);        // 返回 [-1] 。机器会尝试取出 $500 的钞票，然后无法得到剩余的 $100 ，所以取款请求会被拒绝。
                          // 由于请求被拒绝，机器中钞票的数量不会发生改变。
atm.withdraw(550);        // 返回 [0,1,0,0,1] ，机器会返回 1 张 $50 的钞票和 1 张 $500 的钞票。
  提示：
banknotesCount.length == 5
0 <= banknotesCount[i] <= 109
1 <= amount <= 109
总共 最多有 5000 次 withdraw 和 deposit 的调用。
函数 withdraw 和 deposit 至少各有 一次 调用。",4,,4312,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/']",[],12457
评论 (21),maximum-score-of-a-node-sequence,困难,"给你一个 n 个节点的 无向图 ，节点编号为 0 到 n - 1 。
给你一个下标从 0 开始的整数数组 scores ，其中 scores[i] 是第 i 个节点的分数。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] ，表示节点 ai 和 bi 之间有一条 无向 边。
一个合法的节点序列如果满足以下条件，我们称它是 合法的 ：
序列中每 相邻 节点之间有边相连。
序列中没有节点出现超过一次。
节点序列的分数定义为序列中节点分数之 和 。
请你返回一个长度为 4 的合法节点序列的最大分数。如果不存在这样的序列，请你返回 -1 。
  示例 1：
输入：scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
输出：24
解释：上图为输入的图，节点序列为 [0,1,2,3] 。
节点序列的分数为 5 + 2 + 9 + 8 = 24 。
观察可知，没有其他节点序列得分和超过 24 。
注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。
序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。
示例 2：
输入：scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]
输出：-1
解释：上图为输入的图。
没有长度为 4 的合法序列，所以我们返回 -1 。
  提示：
n == scores.length
4 <= n <= 5 * 104
1 <= scores[i] <= 108
0 <= edges.length <= 5 * 104
edges[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
不会有重边。",17,,2254,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/enumeration/', 'https://leetcode.cn/tag/sorting/']",[],7492
评论 (51),calculate-digit-sum-of-a-string,简单,"给你一个由若干数字（0 - 9）组成的字符串 s ，和一个整数。
如果 s 的长度大于 k ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：
将 s 拆分 成长度为 k 的若干 连续数字组 ，使得前 k 个字符都分在第一组，接下来的 k 个字符都分在第二组，依此类推。注意，最后一个数字组的长度可以小于 k 。
用表示每个数字组中所有数字之和的字符串来 替换 对应的数字组。例如，""346"" 会替换为 ""13"" ，因为 3 + 4 + 6 = 13 。
合并 所有组以形成一个新字符串。如果新字符串的长度大于 k 则重复第一步。
返回在完成所有轮操作后的 s 。
  示例 1：
输入：s = ""11111222223"", k = 3
输出：""135""
解释：
- 第一轮，将 s 分成：""111""、""112""、""222"" 和 ""23"" 。
  接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 
  这样，s 在第一轮之后变成 ""3"" + ""4"" + ""6"" + ""5"" = ""3465"" 。
- 第二轮，将 s 分成：""346"" 和 ""5"" 。
  接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。
  这样，s 在第二轮之后变成 ""13"" + ""5"" = ""135"" 。 
现在，s.length <= k ，所以返回 ""135"" 作为答案。
示例 2：
输入：s = ""00000000"", k = 3
输出：""000""
解释：
将 ""000"", ""000"", and ""00"".
接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 
s 变为 ""0"" + ""0"" + ""0"" = ""000"" ，其长度等于 k ，所以返回 ""000"" 。
  提示：
1 <= s.length <= 100
2 <= k <= 100
s 仅由数字（0 - 9）组成。",8,,8990,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],14222
评论 (64),minimum-rounds-to-complete-all-tasks,中等,"给你一个下标从 0 开始的整数数组 tasks ，其中 tasks[i] 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 相同难度级别 的任务。
返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 。
  示例 1：
输入：tasks = [2,2,3,3,2,4,4,4,4,4]
输出：4
解释：要想完成所有任务，一个可能的计划是：
- 第一轮，完成难度级别为 2 的 3 个任务。 
- 第二轮，完成难度级别为 3 的 2 个任务。 
- 第三轮，完成难度级别为 4 的 3 个任务。 
- 第四轮，完成难度级别为 4 的 2 个任务。 
可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。
示例 2：
输入：tasks = [2,3,3]
输出：-1
解释：难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。
  提示：
1 <= tasks.length <= 105
1 <= tasks[i] <= 109",12,,8446,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],15339
评论 (73),maximum-trailing-zeros-in-a-cornered-path,中等,"给你一个二维整数数组 grid ，大小为 m x n，其中每个单元格都含一个正整数。
转角路径 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 向水平方向 或者 向竖直方向 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 另一个 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。
一条路径的 乘积 定义为：路径上所有值的乘积。
请你从 grid 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。
注意：
水平 移动是指向左或右移动。
竖直 移动是指向上或下移动。
  示例 1：
输入：grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]
输出：3
解释：左侧的图展示了一条有效的转角路径。
其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。
可以证明在这条转角路径的乘积中尾随零数目最多。

中间的图不是一条有效的转角路径，因为它有不止一个弯。
右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。
示例 2：
输入：grid = [[4,3,2],[7,6,1],[8,8,8]]
输出：0
解释：网格如上图所示。
不存在乘积含尾随零的转角路径。
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 105
1 <= m * n <= 105
1 <= grid[i][j] <= 1000",30,,3890,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/prefix-sum/']",[],11481
评论 (57),longest-path-with-different-adjacent-characters,困难,"给你一棵 树（即一个连通、无向、无环图），根节点是节点 0 ，这棵树由编号从 0 到 n - 1 的 n 个节点组成。用下标从 0 开始、长度为 n 的数组 parent 来表示这棵树，其中 parent[i] 是节点 i 的父节点，由于节点 0 是根节点，所以 parent[0] == -1 。
另给你一个字符串 s ，长度也是 n ，其中 s[i] 表示分配给节点 i 的字符。
请你找出路径上任意一对相邻节点都没有分配到相同字符的 最长路径 ，并返回该路径的长度。
  示例 1：
输入：parent = [-1,0,0,1,1,2], s = ""abacbe""
输出：3
解释：任意一对相邻节点字符都不同的最长路径是：0 -> 1 -> 3 。该路径的长度是 3 ，所以返回 3 。
可以证明不存在满足上述条件且比 3 更长的路径。 
示例 2：
输入：parent = [-1,0,0,0], s = ""aabc""
输出：3
解释：任意一对相邻节点字符都不同的最长路径是：2 -> 0 -> 3 。该路径的长度为 3 ，所以返回 3 。
  提示：
n == parent.length == s.length
1 <= n <= 105
对所有 i >= 1 ，0 <= parent[i] <= n - 1 均成立
parent[0] == -1
parent 表示一棵有效的树
s 仅由小写英文字母组成",30,,3350,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],7831
评论 (12),maximum-cost-of-trip-with-k-highways,Unknown,,-1,,-1,[],[],-1
评论 (60),intersection-of-multiple-arrays,简单,"给你一个二维整数数组 nums ，其中 nums[i] 是由 不同 正整数组成的一个非空数组，按 升序排列 返回一个数组，数组中的每个元素在 nums 所有数组 中都出现过。
  示例 1：
输入：nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
输出：[3,4]
解释：
nums[0] = [3,1,2,4,5]，nums[1] = [1,2,3,4]，nums[2] = [3,4,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。
示例 2：
输入：nums = [[1,2,3],[4,5,6]]
输出：[]
解释：
不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。
  提示：
1 <= nums.length <= 1000
1 <= sum(nums[i].length) <= 1000
1 <= nums[i][j] <= 1000
nums[i] 中的所有值 互不相同",15,,9706,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],14367
评论 (86),count-lattice-points-inside-a-circle,中等,"给你一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。
注意：
格点 是指整数坐标对应的点。
圆周上的点 也被视为出现在圆内的点。
  示例 1：
输入：circles = [[2,2,1]]
输出：5
解释：
给定的圆如上图所示。
出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。
像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。
因此，出现在至少一个圆内的格点数目是 5 。
示例 2：
输入：circles = [[2,2,2],[3,4,1]]
输出：16
解释：
给定的圆如上图所示。
共有 16 个格点出现在至少一个圆内。
其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。
  提示：
1 <= circles.length <= 200
circles[i].length == 3
1 <= xi, yi <= 100
1 <= ri <= min(xi, yi)",11,,7390,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/']",[],14337
评论 (67),number-of-flowers-in-full-bloom,困难,"给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [starti, endi] 表示第 i 朵花的 花期 从 starti 到 endi （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数数组 persons ，persons[i] 是第 i 个人来看花的时间。
请你返回一个大小为 n 的整数数组 answer ，其中 answer[i]是第 i 个人到达时在花期内花的 数目 。
  示例 1：
输入：flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11]
输出：[1,2,2,2]
解释：上图展示了每朵花的花期时间，和每个人的到达时间。
对每个人，我们返回他们到达时在花期内花的数目。
示例 2：
输入：flowers = [[1,10],[3,3]], persons = [3,3,2]
输出：[2,2,1]
解释：上图展示了每朵花的花期时间，和每个人的到达时间。
对每个人，我们返回他们到达时在花期内花的数目。
  提示：
1 <= flowers.length <= 5 * 104
flowers[i].length == 2
1 <= starti <= endi <= 109
1 <= persons.length <= 5 * 104
1 <= persons[i] <= 109",24,,4469,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sorting/']",[],9243
评论 (2),dynamic-pivoting-of-a-table,Unknown,,-1,,-1,[],[],-1
评论,dynamic-unpivoting-of-a-table,Unknown,,-1,,-1,[],[],-1
评论 (5),design-video-sharing-platform,Unknown,,-1,,-1,[],[],-1
评论 (36),count-prefixes-of-a-given-string,简单,"给你一个字符串数组 words 和一个字符串 s ，其中 words[i] 和 s 只包含 小写英文字母 。
请你返回 words 中是字符串 s 前缀 的 字符串数目 。
一个字符串的 前缀 是出现在字符串开头的子字符串。子字符串 是一个字符串中的连续一段字符序列。
  示例 1：
输入：words = [""a"",""b"",""c"",""ab"",""bc"",""abc""], s = ""abc""
输出：3
解释：
words 中是 s = ""abc"" 前缀的字符串为：
""a"" ，""ab"" 和 ""abc"" 。
所以 words 中是字符串 s 前缀的字符串数目为 3 。
示例 2：
输入：words = [""a"",""a""], s = ""aa""
输出：2
解释：
两个字符串都是 s 的前缀。
注意，相同的字符串可能在 words 中出现多次，它们应该被计数多次。
  提示：
1 <= words.length <= 1000
1 <= words[i].length, s.length <= 10
words[i] 和 s 只 包含小写英文字母。",2,,5176,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],6329
评论 (41),minimum-average-difference,中等,"给你一个下标从 0 开始长度为 n 的整数数组 nums 。
下标 i 处的 平均差 指的是 nums 中 前 i + 1 个元素平均值和 后 n - i - 1 个元素平均值的 绝对差 。两个平均值都需要 向下取整 到最近的整数。
请你返回产生 最小平均差 的下标。如果有多个下标最小平均差相等，请你返回 最小 的一个下标。
注意：
两个数的 绝对差 是两者差的绝对值。
 n 个元素的平均值是 n 个元素之 和 除以（整数除法） n 。
0 个元素的平均值视为 0 。
  示例 1：
输入：nums = [2,5,3,9,5,3]
输出：3
解释：
- 下标 0 处的平均差为：|2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3 。
- 下标 1 处的平均差为：|(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2 。
- 下标 2 处的平均差为：|(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2 。
- 下标 3 处的平均差为：|(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0 。 
- 下标 4 处的平均差为：|(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1 。
- 下标 5 处的平均差为：|(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4 。
下标 3 处的平均差为最小平均差，所以返回 3 。
示例 2：
输入：nums = [0]
输出：0
解释：
唯一的下标是 0 ，所以我们返回 0 。
下标 0 处的平均差为：|0 / 1 - 0| = |0 - 0| = 0 。
  提示：
1 <= nums.length <= 105
0 <= nums[i] <= 105",6,,4523,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],12818
评论 (58),count-unguarded-cells-in-the-grid,中等,"给你两个整数 m 和 n 表示一个下标从 0 开始的 m x n 网格图。同时给你两个二维整数数组 guards 和 walls ，其中 guards[i] = [rowi, coli] 且 walls[j] = [rowj, colj] ，分别表示第 i 个警卫和第 j 座墙所在的位置。
一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 所有 格子，除非他们被一座墙或者另外一个警卫 挡住 了视线。如果一个格子能被 至少 一个警卫看到，那么我们说这个格子被 保卫 了。
请你返回空格子中，有多少个格子是 没被保卫 的。
  示例 1：
输入：m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]
输出：7
解释：上图中，被保卫和没有被保卫的格子分别用红色和绿色表示。
总共有 7 个没有被保卫的格子，所以我们返回 7 。
示例 2：
输入：m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]
输出：4
解释：上图中，没有被保卫的格子用绿色表示。
总共有 4 个没有被保卫的格子，所以我们返回 4 。
  提示：
1 <= m, n <= 105
2 <= m * n <= 105
1 <= guards.length, walls.length <= 5 * 104
2 <= guards.length + walls.length <= m * n
guards[i].length == walls[j].length == 2
0 <= rowi, rowj < m
0 <= coli, colj < n
guards 和 walls 中所有位置 互不相同 。",9,,3780,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],7457
评论 (41),escape-the-spreading-fire,困难,"给你一个下标从 0 开始大小为 m x n 的二维整数数组 grid ，它表示一个网格图。每个格子为下面 3 个值之一：
0 表示草地。
1 表示着火的格子。
2 表示一座墙，你跟火都不能通过这个格子。
一开始你在最左上角的格子 (0, 0) ，你想要到达最右下角的安全屋格子 (m - 1, n - 1) 。每一分钟，你可以移动到 相邻 的草地格子。每次你移动 之后 ，着火的格子会扩散到所有不是墙的 相邻 格子。
请你返回你在初始位置可以停留的 最多 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 -1 。如果不管你在初始位置停留多久，你 总是 能到达安全屋，请你返回 109 。
注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。
如果两个格子有共同边，那么它们为 相邻 格子。
  示例 1：
输入：grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
输出：3
解释：上图展示了你在初始位置停留 3 分钟后的情形。
你仍然可以安全到达安全屋。
停留超过 3 分钟会让你无法安全到达安全屋。
示例 2：
输入：grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
输出：-1
解释：上图展示了你马上开始朝安全屋移动的情形。
火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。
所以返回 -1 。
示例 3：
输入：grid = [[0,0,0],[2,2,0],[1,2,0]]
输出：1000000000
解释：上图展示了初始网格图。
注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。
所以返回 109 。
  提示：
m == grid.length
n == grid[i].length
2 <= m, n <= 300
4 <= m * n <= 2 * 104
grid[i][j] 是 0 ，1 或者 2 。
grid[0][0] == grid[m - 1][n - 1] == 0",13,,2078,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/matrix/']",[],6138
评论 (62),remove-digit-from-number-to-maximize-result,简单,"给你一个表示某个正整数的字符串 number 和一个字符 digit 。
从 number 中 恰好 移除 一个 等于 digit 的字符后，找出并返回按 十进制 表示 最大 的结果字符串。生成的测试用例满足 digit 在 number 中出现至少一次。
  示例 1：
输入：number = ""123"", digit = ""3""
输出：""12""
解释：""123"" 中只有一个 '3' ，在移除 '3' 之后，结果为 ""12"" 。
示例 2：
输入：number = ""1231"", digit = ""1""
输出：""231""
解释：可以移除第一个 '1' 得到 ""231"" 或者移除第二个 '1' 得到 ""123"" 。
由于 231 > 123 ，返回 ""231"" 。
示例 3：
输入：number = ""551"", digit = ""5""
输出：""51""
解释：可以从 ""551"" 中移除第一个或者第二个 '5' 。
两种方案的结果都是 ""51"" 。
  提示：
2 <= number.length <= 100
number 由数字 '1' 到 '9' 组成
digit 是 '1' 到 '9' 中的一个数字
digit 在 number 中出现至少一次",10,,8517,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/enumeration/']",[],17364
评论 (72),minimum-consecutive-cards-to-pick-up,中等,"给你一个整数数组 cards ，其中 cards[i] 表示第 i 张卡牌的 值 。如果两张卡牌的值相同，则认为这一对卡牌 匹配 。
返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 -1 。
  示例 1：
输入：cards = [3,4,2,3,4,7]
输出：4
解释：拿起卡牌 [3,4,2,3] 将会包含一对值为 3 的匹配卡牌。注意，拿起 [4,2,3,4] 也是最优方案。
示例 2：
输入：cards = [1,0,5,3]
输出：-1
解释：无法找出含一对匹配卡牌的一组连续卡牌。
  提示：
1 <= cards.length <= 105
0 <= cards[i] <= 106",7,,7972,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sliding-window/']",[],15965
评论 (83),k-divisible-elements-subarrays,中等,"给你一个整数数组 nums 和两个整数 k 和 p ，找出并返回满足要求的不同的子数组数，要求子数组中最多 k 个可被 p 整除的元素。
如果满足下述条件之一，则认为数组 nums1 和 nums2 是 不同 数组：
两数组长度 不同 ，或者
存在 至少 一个下标 i 满足 nums1[i] != nums2[i] 。
子数组 定义为：数组中的连续元素组成的一个 非空 序列。
  示例 1：
输入：nums = [2,3,3,2,2], k = 2, p = 2
输出：11
解释：
位于下标 0、3 和 4 的元素都可以被 p = 2 整除。
共计 11 个不同子数组都满足最多含 k = 2 个可以被 2 整除的元素：
[2]、[2,3]、[2,3,3]、[2,3,3,2]、[3]、[3,3]、[3,3,2]、[3,3,2,2]、[3,2]、[3,2,2] 和 [2,2] 。
注意，尽管子数组 [2] 和 [3] 在 nums 中出现不止一次，但统计时只计数一次。
子数组 [2,3,3,2,2] 不满足条件，因为其中有 3 个元素可以被 2 整除。
示例 2：
输入：nums = [1,2,3,4], k = 4, p = 1
输出：10
解释：
nums 中的所有元素都可以被 p = 1 整除。
此外，nums 中的每个子数组都满足最多 4 个元素可以被 1 整除。
因为所有子数组互不相同，因此满足所有限制条件的子数组总数为 10 。
  提示：
1 <= nums.length <= 200
1 <= nums[i], p <= 200
1 <= k <= nums.length",20,,6877,"['https://leetcode.cn/tag/trie/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/enumeration/', 'https://leetcode.cn/tag/hash-function/', 'https://leetcode.cn/tag/rolling-hash/']",[],13274
评论 (64),total-appeal-of-a-string,困难,"字符串的 引力 定义为：字符串中 不同 字符的数量。
例如，""abbca"" 的引力为 3 ，因为其中有 3 个不同字符 'a'、'b' 和 'c' 。
给你一个字符串 s ，返回 其所有子字符串的总引力 。
子字符串 定义为：字符串中的一个连续字符序列。
  示例 1：
输入：s = ""abbca""
输出：28
解释：""abbca"" 的子字符串有：
- 长度为 1 的子字符串：""a""、""b""、""b""、""c""、""a"" 的引力分别为 1、1、1、1、1，总和为 5 。
- 长度为 2 的子字符串：""ab""、""bb""、""bc""、""ca"" 的引力分别为 2、1、2、2 ，总和为 7 。
- 长度为 3 的子字符串：""abb""、""bbc""、""bca"" 的引力分别为 2、2、3 ，总和为 7 。
- 长度为 4 的子字符串：""abbc""、""bbca"" 的引力分别为 3、3 ，总和为 6 。
- 长度为 5 的子字符串：""abbca"" 的引力为 3 ，总和为 3 。
引力总和为 5 + 7 + 7 + 6 + 3 = 28 。
示例 2：
输入：s = ""code""
输出：20
解释：""code"" 的子字符串有：
- 长度为 1 的子字符串：""c""、""o""、""d""、""e"" 的引力分别为 1、1、1、1 ，总和为 4 。
- 长度为 2 的子字符串：""co""、""od""、""de"" 的引力分别为 2、2、2 ，总和为 6 。
- 长度为 3 的子字符串：""cod""、""ode"" 的引力分别为 3、3 ，总和为 6 。
- 长度为 4 的子字符串：""code"" 的引力为 4 ，总和为 4 。
引力总和为 4 + 6 + 6 + 4 = 20 。
  提示：
1 <= s.length <= 105
s 由小写英文字母组成",51,,4983,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],9153
评论 (5),make-array-non-decreasing-or-non-increasing,Unknown,,-1,,-1,[],[],-1
评论 (61),largest-3-same-digit-number-in-string,简单,"给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：
该整数是 num 的一个长度为 3 的 子字符串 。
该整数由唯一一个数字重复 3 次组成。
以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 """" 。
注意：
子字符串 是字符串中的一个连续字符序列。
num 或优质整数中可能存在 前导零 。
  示例 1：
输入：num = ""6777133339""
输出：""777""
解释：num 中存在两个优质整数：""777"" 和 ""333"" 。
""777"" 是最大的那个，所以返回 ""777"" 。
示例 2：
输入：num = ""2300019""
输出：""000""
解释：""000"" 是唯一一个优质整数。
示例 3：
输入：num = ""42352338""
输出：""""
解释：不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。
  提示：
3 <= num.length <= 1000
num 仅由数字（0 - 9）组成",4,,9481,['https://leetcode.cn/tag/string/'],[],15197
评论 (68),count-nodes-equal-to-average-of-subtree,中等,"给你一棵二叉树的根节点 root ，找出并返回满足要求的节点数，要求节点的值等于其 子树 中值的 平均值 。
注意：
n 个元素的平均值可以由 n 个元素 求和 然后再除以 n ，并 向下舍入 到最近的整数。
root 的 子树 由 root 和它的所有后代组成。
  示例 1：
输入：root = [4,8,5,0,1,null,6]
输出：5
解释：
对值为 4 的节点：子树的平均值 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 。
对值为 5 的节点：子树的平均值 (5 + 6) / 2 = 11 / 2 = 5 。
对值为 0 的节点：子树的平均值 0 / 1 = 0 。
对值为 1 的节点：子树的平均值 1 / 1 = 1 。
对值为 6 的节点：子树的平均值 6 / 1 = 6 。
示例 2：
输入：root = [1]
输出：1
解释：对值为 1 的节点：子树的平均值 1 / 1 = 1。
  提示：
树中节点数目在范围 [1, 1000] 内
0 <= Node.val <= 1000",12,https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png,7985,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],9564
评论 (108),count-number-of-texts,中等,"Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。
为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。
比方说，为了按出字母 's' ，Alice 需要按 '7' 四次。类似的， Alice 需要按 '5' 两次得到字母  'k' 。
注意，数字 '0' 和 '1' 不映射到任何字母，所以 Alice 不 使用它们。
但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。
比方说，Alice 发出的信息为 ""bob"" ，Bob 将收到字符串 ""2266622"" 。
给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。
由于答案可能很大，将它对 109 + 7 取余 后返回。
  示例 1：
输入：pressedKeys = ""22233""
输出：8
解释：
Alice 可能发出的文字信息包括：
""aaadd"", ""abdd"", ""badd"", ""cdd"", ""aaae"", ""abe"", ""bae"" 和 ""ce"" 。
由于总共有 8 种可能的信息，所以我们返回 8 。
示例 2：
输入：pressedKeys = ""222222222222222222222222222222222222""
输出：82876089
解释：
总共有 2082876103 种 Alice 可能发出的文字信息。
由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。
  提示：
1 <= pressedKeys.length <= 105
pressedKeys 只包含数字 '2' 到 '9' 。",22,,6260,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],14724
评论 (58),check-if-there-is-a-valid-parentheses-string-path,困难,"一个括号字符串是一个 非空 且只包含 '(' 和 ')' 的字符串。如果下面 任意 条件为 真 ，那么这个括号字符串就是 合法的 。
字符串是 () 。
字符串可以表示为 AB（A 连接 B），A 和 B 都是合法括号序列。
字符串可以表示为 (A) ，其中 A 是合法括号序列。
给你一个 m x n 的括号网格图矩阵 grid 。网格图中一个 合法括号路径 是满足以下所有条件的一条路径：
路径开始于左上角格子 (0, 0) 。
路径结束于右下角格子 (m - 1, n - 1) 。
路径每次只会向 下 或者向 右 移动。
路径经过的格子组成的括号字符串是 合法 的。
如果网格图中存在一条 合法括号路径 ，请返回 true ，否则返回 false 。
  示例 1：
输入：grid = [[""("",""("",""(""],["")"",""("","")""],[""("",""("","")""],[""("",""("","")""]]
输出：true
解释：上图展示了两条路径，它们都是合法括号字符串路径。
第一条路径得到的合法字符串是 ""()(())"" 。
第二条路径得到的合法字符串是 ""((()))"" 。
注意可能有其他的合法括号字符串路径。
示例 2：
输入：grid = [["")"","")""],[""("",""(""]]
输出：false
解释：两条可行路径分别得到 ""))("" 和 "")(("" 。由于它们都不是合法括号字符串，我们返回 false 。
  提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] 要么是 '(' ，要么是 ')' 。",23,,6440,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],17761
评论 (4),minimum-number-of-keypresses,Unknown,,-1,,-1,[],[],-1
评论 (38),find-the-k-beauty-of-a-number,简单,"一个整数 num 的 k 美丽值定义为 num 中符合以下条件的 子字符串 数目：
子字符串长度为 k 。
子字符串能整除 num 。
给你整数 num 和 k ，请你返回 num 的 k 美丽值。
注意：
允许有 前缀 0 。
0 不能整除任何值。
一个 子字符串 是一个字符串里的连续一段字符序列。
  示例 1：
输入：num = 240, k = 2
输出：2
解释：以下是 num 里长度为 k 的子字符串：
- ""240"" 中的 ""24"" ：24 能整除 240 。
- ""240"" 中的 ""40"" ：40 能整除 240 。
所以，k 美丽值为 2 。
示例 2：
输入：num = 430043, k = 2
输出：2
解释：以下是 num 里长度为 k 的子字符串：
- ""430043"" 中的 ""43"" ：43 能整除 430043 。
- ""430043"" 中的 ""30"" ：30 不能整除 430043 。
- ""430043"" 中的 ""00"" ：0 不能整除 430043 。
- ""430043"" 中的 ""04"" ：4 不能整除 430043 。
- ""430043"" 中的 ""43"" ：43 能整除 430043 。
所以，k 美丽值为 2 。
  提示：
1 <= num <= 109
1 <= k <= num.length （将 num 视为字符串）",4,,4906,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],7482
评论 (54),number-of-ways-to-split-array,中等,"给你一个下标从 0 开始长度为 n 的整数数组 nums 。
如果以下描述为真，那么 nums 在下标 i 处有一个 合法的分割 ：
前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。
下标 i 的右边 至少有一个 元素，也就是说下标 i 满足 0 <= i < n - 1 。
请你返回 nums 中的 合法分割 方案数。
  示例 1：
输入：nums = [10,4,-8,7]
输出：2
解释：
总共有 3 种不同的方案可以将 nums 分割成两个非空的部分：
- 在下标 0 处分割 nums 。那么第一部分为 [10] ，和为 10 。第二部分为 [4,-8,7] ，和为 3 。因为 10 >= 3 ，所以 i = 0 是一个合法的分割。
- 在下标 1 处分割 nums 。那么第一部分为 [10,4] ，和为 14 。第二部分为 [-8,7] ，和为 -1 。因为 14 >= -1 ，所以 i = 1 是一个合法的分割。
- 在下标 2 处分割 nums 。那么第一部分为 [10,4,-8] ，和为 6 。第二部分为 [7] ，和为 7 。因为 6 < 7 ，所以 i = 2 不是一个合法的分割。
所以 nums 中总共合法分割方案受为 2 。
示例 2：
输入：nums = [2,3,1,0]
输出：2
解释：
总共有 2 种 nums 的合法分割：
- 在下标 1 处分割 nums 。那么第一部分为 [2,3] ，和为 5 。第二部分为 [1,0] ，和为 1 。因为 5 >= 1 ，所以 i = 1 是一个合法的分割。
- 在下标 2 处分割 nums 。那么第一部分为 [2,3,1] ，和为 6 。第二部分为 [0] ，和为 0 。因为 6 >= 0 ，所以 i = 2 是一个合法的分割。
  提示：
2 <= nums.length <= 105
-105 <= nums[i] <= 105",3,,4742,[],[],10184
评论 (78),maximum-white-tiles-covered-by-a-carpet,中等,"给你一个二维整数数组 tiles ，其中 tiles[i] = [li, ri] ，表示所有在 li <= j <= ri 之间的每个瓷砖位置 j 都被涂成了白色。
同时给你一个整数 carpetLen ，表示可以放在 任何位置 的一块毯子。
请你返回使用这块毯子，最多 可以盖住多少块瓷砖。
  示例 1：
输入：tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10
输出：9
解释：将毯子从瓷砖 10 开始放置。
总共覆盖 9 块瓷砖，所以返回 9 。
注意可能有其他方案也可以覆盖 9 块瓷砖。
可以看出，瓷砖无法覆盖超过 9 块瓷砖。
示例 2：
输入：tiles = [[10,11],[1,1]], carpetLen = 2
输出：2
解释：将毯子从瓷砖 10 开始放置。
总共覆盖 2 块瓷砖，所以我们返回 2 。
  提示：
1 <= tiles.length <= 5 * 104
tiles[i].length == 2
1 <= li <= ri <= 109
1 <= carpetLen <= 109
tiles 互相 不会重叠 。",28,,3860,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sorting/']",[],12962
评论 (22),substring-with-largest-variance,困难,"字符串的 波动 定义为子字符串中出现次数 最多 的字符次数与出现次数 最少 的字符次数之差。
给你一个字符串 s ，它只包含小写英文字母。请你返回 s 里所有 子字符串的 最大波动 值。
子字符串 是一个字符串的一段连续字符序列。
  示例 1：
输入：s = ""aababbb""
输出：3
解释：
所有可能的波动值和它们对应的子字符串如以下所示：
- 波动值为 0 的子字符串：""a"" ，""aa"" ，""ab"" ，""abab"" ，""aababb"" ，""ba"" ，""b"" ，""bb"" 和 ""bbb"" 。
- 波动值为 1 的子字符串：""aab"" ，""aba"" ，""abb"" ，""aabab"" ，""ababb"" ，""aababbb"" 和 ""bab"" 。
- 波动值为 2 的子字符串：""aaba"" ，""ababbb"" ，""abbb"" 和 ""babb"" 。
- 波动值为 3 的子字符串 ""babbb"" 。
所以，最大可能波动值为 3 。
示例 2：
输入：s = ""abcde""
输出：0
解释：
s 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。
  提示：
1 <= s.length <= 104
s  只包含小写英文字母。",31,,1947,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],5722
评论 (52),find-resultant-array-after-removing-anagrams,简单,"给你一个下标从 0 开始的字符串 words ，其中 words[i] 由小写英文字符组成。
在一步操作中，需要选出任一下标 i ，从 words 中 删除 words[i] 。其中下标 i 需要同时满足下述两个条件：
0 < i < words.length
words[i - 1] 和 words[i] 是 字母异位词 。
只要可以选出满足条件的下标，就一直执行这个操作。
在执行所有操作后，返回 words 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。
字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，""dacb"" 是 ""abdc"" 的一个字母异位词。
  示例 1：
输入：words = [""abba"",""baba"",""bbaa"",""cd"",""cd""]
输出：[""abba"",""cd""]
解释：
获取结果数组的方法之一是执行下述步骤：
- 由于 words[2] = ""bbaa"" 和 words[1] = ""baba"" 是字母异位词，选择下标 2 并删除 words[2] 。
  现在 words = [""abba"",""baba"",""cd"",""cd""] 。
- 由于 words[1] = ""baba"" 和 words[0] = ""abba"" 是字母异位词，选择下标 1 并删除 words[1] 。
  现在 words = [""abba"",""cd"",""cd""] 。
- 由于 words[2] = ""cd"" 和 words[1] = ""cd"" 是字母异位词，选择下标 2 并删除 words[2] 。
  现在 words = [""abba"",""cd""] 。
无法再执行任何操作，所以 [""abba"",""cd""] 是最终答案。
示例 2：
输入：words = [""a"",""b"",""c"",""d"",""e""]
输出：[""a"",""b"",""c"",""d"",""e""]
解释：
words 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。
  提示：
1 <= words.length <= 100
1 <= words[i].length <= 10
words[i] 由小写英文字母组成",10,,8383,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],14477
评论 (60),maximum-consecutive-floors-without-special-floors,中等,"Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 特殊楼层 ，仅用于放松。
给你两个整数 bottom 和 top ，表示 Alice 租用了从 bottom 到 top（含 bottom 和 top 在内）的所有楼层。另给你一个整数数组 special ，其中 special[i] 表示  Alice 指定用于放松的特殊楼层。
返回不含特殊楼层的 最大 连续楼层数。
  示例 1：
输入：bottom = 2, top = 9, special = [4,6]
输出：3
解释：下面列出的是不含特殊楼层的连续楼层范围：
- (2, 3) ，楼层数为 2 。
- (5, 5) ，楼层数为 1 。
- (7, 9) ，楼层数为 3 。
因此，返回最大连续楼层数 3 。
示例 2：
输入：bottom = 6, top = 8, special = [7,6,8]
输出：0
解释：每层楼都被规划为特殊楼层，所以返回 0 。
  提示
1 <= special.length <= 105
1 <= bottom <= special[i] <= top <= 109
special 中的所有值 互不相同",6,,7969,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],14919
评论 (66),largest-combination-with-bitwise-and-greater-than-zero,中等,"对数组 nums 执行 按位与 相当于对数组 nums 中的所有整数执行 按位与 。
例如，对 nums = [1, 5, 3] 来说，按位与等于 1 & 5 & 3 = 1 。
同样，对 nums = [7] 而言，按位与等于 7 。
给你一个正整数数组 candidates 。计算 candidates 中的数字每种组合下 按位与 的结果。 candidates 中的每个数字在每种组合中只能使用 一次 。
返回按位与结果大于 0 的 最长 组合的长度。
  示例 1：
输入：candidates = [16,17,71,62,12,24,14]
输出：4
解释：组合 [16,17,62,24] 的按位与结果是 16 & 17 & 62 & 24 = 16 > 0 。
组合长度是 4 。
可以证明不存在按位与结果大于 0 且长度大于 4 的组合。
注意，符合长度最大的组合可能不止一种。
例如，组合 [62,12,24,14] 的按位与结果是 62 & 12 & 24 & 14 = 8 > 0 。
示例 2：
输入：candidates = [8,8]
输出：2
解释：最长组合是 [8,8] ，按位与结果 8 & 8 = 8 > 0 。
组合长度是 2 ，所以返回 2 。
  提示：
1 <= candidates.length <= 105
1 <= candidates[i] <= 107",24,,6307,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/']",[],11145
评论 (42),count-integers-in-intervals,困难,"给你区间的 空 集，请你设计并实现满足要求的数据结构：
新增：添加一个区间到这个区间集合中。
统计：计算出现在 至少一个 区间中的整数个数。
实现 CountIntervals 类：
CountIntervals() 使用区间的空集初始化对象
void add(int left, int right) 添加区间 [left, right] 到区间集合之中。
int count() 返回出现在 至少一个 区间中的整数个数。
注意：区间 [left, right] 表示满足 left <= x <= right 的所有整数 x 。
  示例 1：
输入
[""CountIntervals"", ""add"", ""add"", ""count"", ""add"", ""count""]
[[], [2, 3], [7, 10], [], [5, 8], []]
输出
[null, null, null, 6, null, 8]

解释
CountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象
countIntervals.add(2, 3);  // 将 [2, 3] 添加到区间集合中
countIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中
countIntervals.count();    // 返回 6
                           // 整数 2 和 3 出现在区间 [2, 3] 中
                           // 整数 7、8、9、10 出现在区间 [7, 10] 中
countIntervals.add(5, 8);  // 将 [5, 8] 添加到区间集合中
countIntervals.count();    // 返回 8
                           // 整数 2 和 3 出现在区间 [2, 3] 中
                           // 整数 5 和 6 出现在区间 [5, 8] 中
                           // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中
                           // 整数 9 和 10 出现在区间 [7, 10] 中
  提示：
1 <= left <= right <= 109
最多调用  add 和 count 方法 总计 105 次
调用 count 方法至少一次",27,,4363,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/ordered-set/']",[],13469
评论 (1),closest-node-to-path-in-tree,Unknown,,-1,,-1,[],[],-1
评论 (49),count-number-of-rectangles-containing-each-point,中等,"给你一个二维整数数组 rectangles ，其中 rectangles[i] = [li, hi] 表示第 i 个矩形长为 li 高为 hi 。给你一个二维整数数组 points ，其中 points[j] = [xj, yj] 是坐标为 (xj, yj) 的一个点。
第 i 个矩形的 左下角 在 (0, 0) 处，右上角 在 (li, hi) 。
请你返回一个整数数组 count ，长度为 points.length，其中 count[j]是 包含 第 j 个点的矩形数目。
如果 0 <= xj <= li 且 0 <= yj <= hi ，那么我们说第 i 个矩形包含第 j 个点。如果一个点刚好在矩形的 边上 ，这个点也被视为被矩形包含。
  示例 1：
输入：rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]
输出：[2,1]
解释：
第一个矩形不包含任何点。
第二个矩形只包含一个点 (2, 1) 。
第三个矩形包含点 (2, 1) 和 (1, 4) 。
包含点 (2, 1) 的矩形数目为 2 。
包含点 (1, 4) 的矩形数目为 1 。
所以，我们返回 [2, 1] 。
示例 2：
输入：rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]
输出：[1,3]
解释：
第一个矩形只包含点 (1, 1) 。
第二个矩形只包含点 (1, 1) 。
第三个矩形包含点 (1, 3) 和 (1, 1) 。
包含点 (1, 3) 的矩形数目为 1 。
包含点 (1, 1) 的矩形数目为 3 。
所以，我们返回 [1, 3] 。
  提示：
1 <= rectangles.length, points.length <= 5 * 104
rectangles[i].length == points[j].length == 2
1 <= li, xj <= 109
1 <= hi, yj <= 100
所有 rectangles 互不相同 。
所有 points 互不相同 。",26,,5005,[],[],15229
评论 (543),guess-numbers,简单,"小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？
输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。
  示例 1：
输入：guess = [1,2,3], answer = [1,2,3]
输出：3
解释：小A 每次都猜对了。
示例 2：
输入：guess = [2,2,3], answer = [3,2,1]
输出：1
解释：小A 只猜对了第二次。
  限制：
guess 的长度 = 3
answer 的长度 = 3
guess 的元素取值为 {1, 2, 3} 之一。
answer 的元素取值为 {1, 2, 3} 之一。",141,,88870,['https://leetcode.cn/tag/array/'],[],105176
评论 (171),deep-dark-fraction,简单,"有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？
连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。
  输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。
  示例 1：
输入：cont = [3, 2, 0, 2]
输出：[13, 4]
解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。
示例 2：
输入：cont = [0, 0, 3]
输出：[3, 1]
解释：如果答案是整数，令分母为1即可。
  限制：
cont[i] >= 0
1 <= cont的长度 <= 10
cont最后一个元素不等于0
答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。",97,,16260,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/number-theory/', 'https://leetcode.cn/tag/simulation/']",[],23362
评论 (157),programmable-robot,中等,"力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：
U: 向y轴正方向移动一格
R: 向x轴正方向移动一格。
不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。
给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。
  示例 1：
输入：command = ""URR"", obstacles = [], x = 3, y = 2
输出：true
解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。
示例 2：
输入：command = ""URR"", obstacles = [[2, 2]], x = 3, y = 2
输出：false
解释：机器人在到达终点前会碰到(2, 2)的障碍物。
示例 3：
输入：command = ""URR"", obstacles = [[4, 2]], x = 3, y = 2
输出：true
解释：到达终点后，再碰到障碍物也不影响返回结果。
  限制：
2 <= command的长度 <= 1000
command由U，R构成，且至少有一个U，至少有一个R
0 <= x <= 1e9, 0 <= y <= 1e9
0 <= obstacles的长度 <= 1000
obstacles[i]不为原点或者终点",108,,13121,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/simulation/']",[],57806
评论 (40),broken-board-dominoes,困难,"你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为1 * 2的多米诺骨牌，你想把这些骨牌不重叠地覆盖在完好的格子上，请找出你最多能在棋盘上放多少块骨牌？这些骨牌可以横着或者竖着放。
  输入：n, m代表棋盘的大小；broken是一个b * 2的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。
输出：一个整数，代表最多能在棋盘上放的骨牌数。
  示例 1：
输入：n = 2, m = 3, broken = [[1, 0], [1, 1]]
输出：2
解释：我们最多可以放两块骨牌：[[0, 0], [0, 1]]以及[[0, 2], [1, 2]]。（见下图）
  示例 2：
输入：n = 3, m = 3, broken = []
输出：4
解释：下图是其中一种可行的摆放方式
  限制：
1 <= n <= 8
1 <= m <= 8
0 <= b <= n * m",56,,3344,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],8333
评论 (97),coin-bonus,困难,"力扣决定给一个刷题团队发LeetCoin作为奖励。同时，为了监控给大家发了多少LeetCoin，力扣有时候也会进行查询。
  该刷题团队的管理模式可以用一棵树表示：
团队只有一个负责人，编号为1。除了该负责人外，每个人有且仅有一个领导（负责人没有领导）；
不存在循环管理的情况，如A管理B，B管理C，C管理A。
  力扣想进行的操作有以下三种：
给团队的一个成员（也可以是负责人）发一定数量的LeetCoin；
给团队的一个成员（也可以是负责人），以及他/她管理的所有人（即他/她的下属、他/她下属的下属，……），发一定数量的LeetCoin；
查询某一个成员（也可以是负责人），以及他/她管理的所有人被发到的LeetCoin之和。
  输入：
N表示团队成员的个数（编号为1～N，负责人为1）；
leadership是大小为(N - 1) * 2的二维数组，其中每个元素[a, b]代表b是a的下属；
operations是一个长度为Q的二维数组，代表以时间排序的操作，格式如下：
operations[i][0] = 1: 代表第一种操作，operations[i][1]代表成员的编号，operations[i][2]代表LeetCoin的数量；
operations[i][0] = 2: 代表第二种操作，operations[i][1]代表成员的编号，operations[i][2]代表LeetCoin的数量；
operations[i][0] = 3: 代表第三种操作，operations[i][1]代表成员的编号；
输出：
返回一个数组，数组里是每次查询的返回值（发LeetCoin的操作不需要任何返回值）。由于发的LeetCoin很多，请把每次查询的结果模1e9+7 (1000000007)。
  示例 1：
输入：N = 6, leadership = [[1, 2], [1, 6], [2, 3], [2, 5], [1, 4]], operations = [[1, 1, 500], [2, 2, 50], [3, 1], [2, 6, 15], [3, 1]]
输出：[650, 665]
解释：团队的管理关系见下图。
第一次查询时，每个成员得到的LeetCoin的数量分别为（按编号顺序）：500, 50, 50, 0, 50, 0;
第二次查询时，每个成员得到的LeetCoin的数量分别为（按编号顺序）：500, 50, 50, 0, 50, 15.
  限制：
1 <= N <= 50000
1 <= Q <= 50000
operations[i][0] != 3 时，1 <= operations[i][2] <= 5000",57,,2457,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/']",[],11638
评论 (328),na-ying-bi,简单,"桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。
示例 1：
输入：[4,2,1]
输出：4
解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。
示例 2：
输入：[2,3,10]
输出：8
限制：
1 <= n <= 4
1 <= coins[i] <= 10",45,,49968,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],59462
评论 (406),chuan-di-xin-xi,简单,"小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
示例 1：
输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
输出：3
解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。
示例 2：
输入：n = 3, relation = [[0,2],[2,1]], k = 2
输出：0
解释：信息不能从小 A 处经过 2 轮传递到编号 2
限制：
2 <= n <= 10
1 <= k <= 5
1 <= relation.length <= 90, 且 relation[i].length == 2
0 <= relation[i][0],relation[i][1] < n 且 relation[i][0] != relation[i][1]",211,,45675,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/dynamic-programming/']",[],59767
评论 (102),ju-qing-hong-fa-shi-jian,中等,"在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。
随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。
所有剧情的触发条件也用一个二维数组 requirements 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]，如果当前 C >= c[i] 且 R >= r[i] 且 H >= h[i] ，则剧情会被触发。
根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。
示例 1：
输入： increase = [[2,8,4],[2,5,0],[10,9,8]] requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]]
输出: [2,-1,3,-1]
解释：
初始时，C = 0，R = 0，H = 0
第 1 天，C = 2，R = 8，H = 4
第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0
第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2
剧情 1 和 3 无法触发。
示例 2：
输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]
输出: [-1,4,3,3,3]
示例 3：
输入： increase = [[1,1,1]] requirements = [[0,0,0]]
输出: [0]
限制：
1 <= increase.length <= 10000
1 <= requirements.length <= 100000
0 <= increase[i] <= 10
0 <= requirements[i] <= 100000",39,,6057,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],19641
评论 (158),zui-xiao-tiao-yue-ci-shu,困难,"为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]>=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。
为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。
示例 1：
输入：jump = [2, 5, 1, 1, 1, 1]
输出：3
解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -> 2 -> 1 -> 6，最终小球弹出了机器。
限制：
1 <= jump.length <= 10^6
1 <= jump[i] <= 10000",69,,8420,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],28064
评论 (40),er-cha-shu-ren-wu-diao-du,困难,"任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。
通常任务之间是存在依赖关系的，即对于某个任务，你需要先完成他的前导任务（如果非空），才能开始执行该任务。我们保证任务的依赖关系是一棵二叉树，其中 root 为根任务，root.left 和 root.right 为他的两个前导任务（可能为空），root.val 为其自身的执行时间。
在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。
现在，系统有两个 CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。
示例 1：
输入：root = [47, 74, 31]
输出：121
解释：根节点的左右节点可以并行执行31分钟，剩下的43+47分钟只能串行执行，因此总体执行时间是121分钟。
示例 2：
输入：root = [15, 21, null, 24, null, 27, 26]
输出：87
示例 3：
输入：root = [1,3,2,null,null,4,4]
输出：7.5
限制：
1 <= 节点数量 <= 1000
1 <= 单节点执行时间 <= 1000",56,,2350,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",[],3896
评论 (112),qi-wang-ge-shu-tong-ji,简单,"某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。
小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 scores，设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。
提示：离散的非负随机变量的期望计算公式为 。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是 。
示例 1：
输入：scores = [1,2,3]
输出：3
解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 3 。
示例 2：
输入：scores = [1,1]
输出：1
解释：设两位面试者的编号为 0, 1。由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 [[0,1],[1,0]] 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 [0,1] 或者 [1,0] ，那么出现在同一位置的简历数为 2 ，否则是 0 。所以 X 的期望是 (2+0+2+0) * 1/4 = 1
示例 3：
输入：scores = [1,1,2]
输出：2
限制：
1 <= scores.length <= 10^5
0 <= scores[i] <= 10^6",31,,8266,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/probability-and-statistics/']",[],11717
评论 (142),xiao-zhang-shua-ti-ji-hua,中等,"为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。
在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。
我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。
示例 1：
输入：time = [1,2,3,3], m = 2
输出：3
解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。
示例 2：
输入：time = [999,999,999], m = 4
输出：0
解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。
  限制：
1 <= time.length <= 10^5
1 <= time[i] <= 10000
1 <= m <= 1000",78,,8352,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],19631
评论 (355),xun-bao,困难,"我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。
迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 'S' 表示），和唯一的宝藏地点（用 'T' 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 'M' 表示），只有所有机关均被触发，才可以拿到宝藏。
要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 'O' 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。
迷宫中同样有一些墙壁（用 '#' 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 '.' 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。
我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。
示例 1：
输入： [""S#O"", ""M.."", ""M.T""]
输出：16
解释：最优路线为： S->O, cost = 4, 去搬石头 O->第二行的M, cost = 3, M机关触发 第二行的M->O, cost = 3, 我们需要继续回去 O 搬石头。 O->第三行的M, cost = 4, 此时所有机关均触发 第三行的M->T, cost = 2，去T点拿宝藏。 总步数为16。
示例 2：
输入： [""S#O"", ""M.#"", ""M.T""]
输出：-1
解释：我们无法搬到石头触发机关
示例 3：
输入： [""S#O"", ""M.T"", ""M..""]
输出：17
解释：注意终点也是可以通行的。
限制：
1 <= maze.length <= 100
1 <= maze[i].length <= 100
maze[i].length == maze[j].length
S 和 T 有且只有一个
0 <= M的数量 <= 16
0 <= O的数量 <= 40，题目保证当迷宫中存在 M 时，一定存在至少一个 O 。",171,,9784,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/', 'https://leetcode.cn/tag/matrix/']",[],16092
评论 (57),qie-fen-shu-zu,困难,"给定一个整数数组 nums ，小李想将 nums 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。为了减少他的工作量，请求出最少可以切成多少个子数组。
示例 1：
输入：nums = [2,3,3,2,3,3]
输出：2
解释：最优切割为 [2,3,3,2] 和 [3,3] 。第一个子数组头尾数字的最大公约数为 2 ，第二个子数组头尾数字的最大公约数为 3 。
示例 2：
输入：nums = [2,3,5,7]
输出：4
解释：只有一种可行的切割：[2], [3], [5], [7]
限制：
1 <= nums.length <= 10^5
2 <= nums[i] <= 10^6",49,,3244,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/number-theory/']",[],14406
评论 (15),you-le-yuan-de-mi-gong,困难,"小王来到了游乐园，她玩的第一个项目是模拟推销员。有一个二维平面地图，其中散布着 N 个推销点，编号 0 到 N-1，不存在三点共线的情况。每两点之间有一条直线相连。游戏没有规定起点和终点，但限定了每次转角的方向。首先，小王需要先选择两个点分别作为起点和终点，然后从起点开始访问剩余 N-2 个点恰好一次并回到终点。访问的顺序需要满足一串给定的长度为 N-2 由 L 和 R 组成的字符串 direction，表示从起点出发之后在每个顶点上转角的方向。根据这个提示，小王希望你能够帮她找到一个可行的遍历顺序，输出顺序下标（若有多个方案，输出任意一种）。可以证明这样的遍历顺序一定是存在的。
（上图：A->B->C 右转； 下图：D->E->F 左转）
示例 1：
输入：points = [[1,1],[1,4],[3,2],[2,1]], direction = ""LL""
输入：[0,2,1,3]
解释：[0,2,1,3] 是符合""LL""的方案之一。在 [0,2,1,3] 方案中，0->2->1 是左转方向， 2->1->3 也是左转方向
示例 2：
输入：points = [[1,3],[2,4],[3,3],[2,1]], direction = ""LR""
输入：[0,3,1,2]
解释：[0,3,1,2] 是符合""LR""的方案之一。在 [0,3,1,2] 方案中，0->3->1 是左转方向， 3->1->2 是右转方向
限制：
3 <= points.length <= 1000 且 points[i].length == 2
1 <= points[i][0],points[i][1] <= 10000
direction.length == points.length - 2
direction 只包含 ""L"",""R""",16,,1096,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],1855
评论 (12),you-le-yuan-de-you-lan-ji-hua,困难,"又到了一年一度的春游时间，小吴计划去游乐场游玩 1 天，游乐场总共有 N 个游乐项目，编号从 0 到 N-1。小吴给每个游乐项目定义了一个非负整数值 value[i] 表示自己的喜爱值。两个游乐项目之间会有双向路径相连，整个游乐场总共有 M 条双向路径，保存在二维数组 edges中。 小吴计划选择一个游乐项目 A 作为这一天游玩的重点项目。上午小吴准备游玩重点项目 A 以及与项目 A 相邻的两个项目 B、C （项目A、B与C要求是不同的项目，且项目B与项目C要求相邻），并返回 A ，即存在一条 A-B-C-A 的路径。 下午，小吴决定再游玩重点项目 A以及与A相邻的两个项目 B'、C'，（项目A、B'与C'要求是不同的项目，且项目B'与项目C'要求相邻），并返回 A ，即存在一条 A-B'-C'-A 的路径。下午游玩项目 B'、C' 可与上午游玩项目B、C存在重复项目。 小吴希望提前安排好游玩路径，使得喜爱值之和最大。请你返回满足游玩路径选取条件的最大喜爱值之和，如果没有这样的路径，返回 0。 注意：一天中重复游玩同一个项目并不能重复增加喜爱值了。例如：上下午游玩路径分别是 A-B-C-A与A-C-D-A 那么只能获得 value[A] + value[B] + value[C] + value[D] 的总和。
示例 1：
输入：edges = [[0,1],[1,2],[0,2]], value = [1,2,3]
输出：6
解释：喜爱值之和最高的方案之一是 0->1->2->0 与 0->2->1->0 。重复游玩同一点不重复计入喜爱值，返回1+2+3=6
示例 2：
输入：edges = [[0,2],[2,1]], value = [1,2,5]
输出：0
解释：无满足要求的游玩路径，返回 0
示例 3：
输入：edges = [[0,1],[0,2],[0,3],[0,4],[0,5],[1,3],[2,4],[2,5],[3,4],[3,5],[4,5]], value = [7,8,6,8,9,7]
输出：39
解释：喜爱值之和最高的方案之一是 3->0->1->3 与 3->4->5->3 。喜爱值最高为 7+8+8+9+7=39
限制：
3 <= value.length <= 10000
1 <= edges.length <= 10000
0 <= edges[i][0],edges[i][1] < value.length
0 <= value[i] <= 10000
edges中没有重复的边
edges[i][0] != edges[i][1]",22,,795,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/math/']",[],2407
评论 (139),nGK0Fy,简单,"小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 x 和 y），请小扣说出计算指令：
""A"" 运算：使 x = 2 * x + y；
""B"" 运算：使 y = 2 * y + x。
在本次游戏中，店家说出的数字为 x = 1 和 y = 0，小扣说出的计算指令记作仅由大写字母 A、B 组成的字符串 s，字符串中字符的顺序表示计算顺序，请返回最终 x 与 y 的和为多少。
示例 1：
输入：s = ""AB""
输出：4
解释：
经过一次 A 运算后，x = 2, y = 0。
再经过一次 B 运算，x = 2, y = 2。
最终 x 与 y 之和为 4。
提示：
0 <= s.length <= 10
s 由 'A' 和 'B' 组成",28,,27279,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],34077
评论 (201),2vYnGI,简单,"小扣在秋日市集选择了一家早餐摊位，一维整型数组 staple 中记录了每种主食的价格，一维整型数组 drinks 中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 x 元。请返回小扣共有多少种购买方案。
注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1
示例 1：
输入：staple = [10,20,5], drinks = [5,5,2], x = 15
输出：6
解释：小扣有 6 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：
第 1 种方案：staple[0] + drinks[0] = 10 + 5 = 15；
第 2 种方案：staple[0] + drinks[1] = 10 + 5 = 15；
第 3 种方案：staple[0] + drinks[2] = 10 + 2 = 12；
第 4 种方案：staple[2] + drinks[0] = 5 + 5 = 10；
第 5 种方案：staple[2] + drinks[1] = 5 + 5 = 10；
第 6 种方案：staple[2] + drinks[2] = 5 + 2 = 7。
示例 2：
输入：staple = [2,1,1], drinks = [8,9,5,1], x = 9
输出：8
解释：小扣有 8 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：
第 1 种方案：staple[0] + drinks[2] = 2 + 5 = 7；
第 2 种方案：staple[0] + drinks[3] = 2 + 1 = 3；
第 3 种方案：staple[1] + drinks[0] = 1 + 8 = 9；
第 4 种方案：staple[1] + drinks[2] = 1 + 5 = 6；
第 5 种方案：staple[1] + drinks[3] = 1 + 1 = 2；
第 6 种方案：staple[2] + drinks[0] = 1 + 8 = 9；
第 7 种方案：staple[2] + drinks[2] = 1 + 5 = 6；
第 8 种方案：staple[2] + drinks[3] = 1 + 1 = 2；
提示：
1 <= staple.length <= 10^5
1 <= drinks.length <= 10^5
1 <= staple[i],drinks[i] <= 10^5
1 <= x <= 2*10^5",65,,21003,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],70902
评论 (221),UlBDOe,中等,"小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。
出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。
示例 1：
输入：leaves = ""rrryyyrryyyrr""
输出：2
解释：调整两次，将中间的两片红叶替换成黄叶，得到 ""rrryyyyyyyyrr""
示例 2：
输入：leaves = ""ryr""
输出：0
解释：已符合要求，不需要额外操作
提示：
3 <= leaves.length <= 10^5
leaves 中只包含字符 'r' 和字符 'y'",216,,20738,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],40002
评论 (37),meChtZ,困难,"小扣打算去秋日市集，由于游客较多，小扣的移动速度受到了人流影响：
小扣从 x 号站点移动至 x + 1 号站点需要花费的时间为 inc；
小扣从 x 号站点移动至 x - 1 号站点需要花费的时间为 dec。
现有 m 辆公交车，编号为 0 到 m-1。小扣也可以通过搭乘编号为 i 的公交车，从 x 号站点移动至 jump[i]*x 号站点，耗时仅为 cost[i]。小扣可以搭乘任意编号的公交车且搭乘公交次数不限。
假定小扣起始站点记作 0，秋日市集站点记作 target，请返回小扣抵达秋日市集最少需要花费多少时间。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。
注意：小扣可在移动过程中到达编号大于 target 的站点。
示例 1：
输入：target = 31, inc = 5, dec = 3, jump = [6], cost = [10]
输出：33
解释：
小扣步行至 1 号站点，花费时间为 5；
小扣从 1 号站台搭乘 0 号公交至 6 * 1 = 6 站台，花费时间为 10；
小扣从 6 号站台步行至 5 号站台，花费时间为 3；
小扣从 5 号站台搭乘 0 号公交至 6 * 5 = 30 站台，花费时间为 10；
小扣从 30 号站台步行至 31 号站台，花费时间为 5；
最终小扣花费总时间为 33。
示例 2：
输入：target = 612, inc = 4, dec = 5, jump = [3,6,8,11,5,10,4], cost = [4,7,6,3,7,6,4]
输出：26
解释：
小扣步行至 1 号站点，花费时间为 4；
小扣从 1 号站台搭乘 0 号公交至 3 * 1 = 3 站台，花费时间为 4；
小扣从 3 号站台搭乘 3 号公交至 11 * 3 = 33 站台，花费时间为 3；
小扣从 33 号站台步行至 34 站台，花费时间为 4；
小扣从 34 号站台搭乘 0 号公交至 3 * 34 = 102 站台，花费时间为 4；
小扣从 102 号站台搭乘 1 号公交至 6 * 102 = 612 站台，花费时间为 7；
最终小扣花费总时间为 26。
提示：
1 <= target <= 10^9
1 <= jump.length, cost.length <= 10
2 <= jump[i] <= 10^6
1 <= inc, dec, cost[i] <= 10^6",36,,2131,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],6341
评论 (21),Za25hA,困难,"秋游中的小力和小扣设计了一个追逐游戏。他们选了秋日市集景区中的 N 个景点，景点编号为 1~N。此外，他们还选择了 N 条小路，满足任意两个景点之间都可以通过小路互相到达，且不存在两条连接景点相同的小路。整个游戏场景可视作一个无向连通图，记作二维数组 edges，数组中以 [a,b] 形式表示景点 a 与景点 b 之间有一条小路连通。
小力和小扣只能沿景点间的小路移动。小力的目标是在最快时间内追到小扣，小扣的目标是尽可能延后被小力追到的时间。游戏开始前，两人分别站在两个不同的景点 startA 和 startB。每一回合，小力先行动，小扣观察到小力的行动后再行动。小力和小扣在每回合可选择以下行动之一：
移动至相邻景点
留在原地
如果小力追到小扣（即两人于某一时刻出现在同一位置），则游戏结束。若小力可以追到小扣，请返回最少需要多少回合；若小力无法追到小扣，请返回 -1。
注意：小力和小扣一定会采取最优移动策略。
示例 1：
输入：edges = [[1,2],[2,3],[3,4],[4,1],[2,5],[5,6]], startA = 3, startB = 5
输出：3
解释：
第一回合，小力移动至 2 号点，小扣观察到小力的行动后移动至 6 号点；
第二回合，小力移动至 5 号点，小扣无法移动，留在原地；
第三回合，小力移动至 6 号点，小力追到小扣。返回 3。
示例 2：
输入：edges = [[1,2],[2,3],[3,4],[4,1]], startA = 1, startB = 3
输出：-1
解释：
小力如果不动，则小扣也不动；否则小扣移动到小力的对角线位置。这样小力无法追到小扣。
提示：
edges 的长度等于图中节点个数
3 <= edges.length <= 10^5
1 <= edges[i][0], edges[i][1] <= edges.length 且 edges[i][0] != edges[i][1]
1 <= startA, startB <= edges.length 且 startA != startB",23,,1195,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/topological-sort/']",[],3281
评论 (128),ccw6C7,简单,"小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有 n * n 的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色（选择的整行、整列均需涂成黑色），所选行数、列数均可为 0。
小扣希望最终的成品上需要有 k 个黑色格子，请返回小扣共有多少种涂色方案。
注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。
示例 1：
输入：n = 2, k = 2
输出：4
解释：一共有四种不同的方案：
第一种方案：涂第一列；
第二种方案：涂第二列；
第三种方案：涂第一行；
第四种方案：涂第二行。
示例 2：
输入：n = 2, k = 1
输出：0
解释：不可行，因为第一次涂色至少会涂两个黑格。
示例 3：
输入：n = 2, k = 4
输出：1
解释：共有 2*2=4 个格子，仅有一种涂色方案。
限制：
1 <= n <= 6
0 <= k <= n * n",64,,9946,['https://leetcode.cn/tag/math/'],[],29132
评论 (56),er94lq,中等,"秋日市集上，魔术师邀请小扣与他互动。魔术师的道具为分别写有数字 1~N 的 N 张卡牌，然后请小扣思考一个 N 张卡牌的排列 target。
魔术师的目标是找到一个数字 k（k >= 1），使得初始排列顺序为 1~N 的卡牌经过特殊的洗牌方式最终变成小扣所想的排列 target，特殊的洗牌方式为：
第一步，魔术师将当前位于 偶数位置 的卡牌（下标自 1 开始），保持 当前排列顺序 放在位于 奇数位置 的卡牌之前。例如：将当前排列 [1,2,3,4,5] 位于偶数位置的 [2,4] 置于奇数位置的 [1,3,5] 前，排列变为 [2,4,1,3,5]；
第二步，若当前卡牌数量小于等于 k，则魔术师按排列顺序取走全部卡牌；若当前卡牌数量大于 k，则取走前 k 张卡牌，剩余卡牌继续重复这两个步骤，直至所有卡牌全部被取走；
卡牌按照魔术师取走顺序构成的新排列为「魔术取数排列」，请返回是否存在这个数字 k 使得「魔术取数排列」恰好就是 target，从而让小扣感到大吃一惊。
示例 1：
输入：target = [2,4,3,1,5]
输出：true
解释：排列 target 长度为 5，初始排列为：1,2,3,4,5。我们选择 k = 2：
第一次：将当前排列 [1,2,3,4,5] 位于偶数位置的 [2,4] 置于奇数位置的 [1,3,5] 前，排列变为 [2,4,1,3,5]。取走前 2 张卡牌 2,4，剩余 [1,3,5]；
第二次：将当前排列 [1,3,5] 位于偶数位置的 [3] 置于奇数位置的 [1,5] 前，排列变为 [3,1,5]。取走前 2 张 3,1，剩余 [5]；
第三次：当前排列为 [5]，全部取出。
最后，数字按照取出顺序构成的「魔术取数排列」2,4,3,1,5 恰好为 target。
示例 2：
输入：target = [5,4,3,2,1]
输出：false
解释：无法找到一个数字 k 可以使「魔术取数排列」恰好为 target。
提示：
1 <= target.length = N <= 5000
题目保证 target 是 1~N 的一个排列。",19,,3118,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],8895
评论 (20),5TxKeK,困难,"小扣在秋日市集入口处发现了一个数字游戏。主办方共有 N 个计数器，计数器编号为 0 ~ N-1。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组 nums。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。
主办方请小扣回答出一个长度为 N 的数组，第 i 个元素(0 <= i < N)表示将 0~i 号计数器 初始 所示数字操作成满足所有条件 nums[a]+1 == nums[a+1],(0 <= a < i) 的最小操作数。回答正确方可进入秋日市集。
由于答案可能很大，请将每个最小操作数对 1,000,000,007 取余。
示例 1：
输入：nums = [3,4,5,1,6,7]
输出：[0,0,0,5,6,7]
解释：
i = 0，[3] 无需操作
i = 1，[3,4] 无需操作；
i = 2，[3,4,5] 无需操作；
i = 3，将 [3,4,5,1] 操作成 [3,4,5,6], 最少 5 次操作；
i = 4，将 [3,4,5,1,6] 操作成 [3,4,5,6,7], 最少 6 次操作；
i = 5，将 [3,4,5,1,6,7] 操作成 [3,4,5,6,7,8]，最少 7 次操作；
返回 [0,0,0,5,6,7]。
示例 2：
输入：nums = [1,2,3,4,5]
输出：[0,0,0,0,0]
解释：对于任意计数器编号 i 都无需操作。
示例 3：
输入：nums = [1,1,1,2,3,4]
输出：[0,1,2,3,3,3]
解释：
i = 0，无需操作；
i = 1，将 [1,1] 操作成 [1,2] 或 [0,1] 最少 1 次操作；
i = 2，将 [1,1,1] 操作成 [1,2,3] 或 [0,1,2]，最少 2 次操作；
i = 3，将 [1,1,1,2] 操作成 [1,2,3,4] 或 [0,1,2,3]，最少 3 次操作；
i = 4，将 [1,1,1,2,3] 操作成 [-1,0,1,2,3]，最少 3 次操作；
i = 5，将 [1,1,1,2,3,4] 操作成 [-1,0,1,2,3,4]，最少 3 次操作；
返回 [0,1,2,3,3,3]。
提示：
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^3",24,,1139,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],3748
评论 (15),Uh984O,困难,"小扣在秋日市集购买了一个古董键盘。由于古董键盘年久失修，键盘上只有 26 个字母 a~z 可以按下，且每个字母最多仅能被按 k 次。
小扣随机按了 n 次按键，请返回小扣总共有可能按出多少种内容。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。
示例 1：
输入：k = 1, n = 1
输出：26
解释：由于只能按一次按键，所有可能的字符串为 ""a"", ""b"", ... ""z""
示例 2：
输入：k = 1, n = 2
输出：650
解释：由于只能按两次按键，且每个键最多只能按一次，所有可能的字符串（按字典序排序）为 ""ab"", ""ac"", ... ""zy""
提示：
1 <= k <= 5
1 <= n <= 26*k",30,,1493,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/combinatorics/']",[],4119
评论 (8),hSRGyL,困难,"小扣参加的秋日市集景区共有
N
N 个景点，景点编号为
1
1~
N
N。景点内设有
N-1
N−1 条双向道路，使所有景点形成了一个二叉树结构，根结点记为 root，景点编号即为节点值。
由于秋日市集景区的结构特殊，游客很容易迷路，主办方决定在景区的若干个景点设置导航装置，按照所在景点编号升序排列后定义装置编号为 1 ~ M。导航装置向游客发送数据，数据内容为列表 [游客与装置 1 的相对距离,游客与装置 2 的相对距离,...,游客与装置 M 的相对距离]。由于游客根据导航装置发送的信息来确认位置，因此主办方需保证游客在每个景点接收的数据信息皆不相同。请返回主办方最少需要设置多少个导航装置。
示例 1：
输入：root = [1,2,null,3,4]
输出：2
解释：在景点 1、3 或景点 1、4 或景点 3、4 设置导航装置。
示例 2：
输入：root = [1,2,3,4]
输出：1
解释：在景点 3、4 设置导航装置皆可。
提示：
2 <= N <= 50000
二叉树的非空节点值为 1~N 的一个排列。",12,,738,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",[],2047
评论 (31),IQvJ9i,困难,"秋日市集上有个奇怪的黑盒，黑盒的主视图为 n*m 的矩形。从黑盒的主视图来看，黑盒的上面和下面各均匀分布有 m 个小孔，黑盒的左面和右面各均匀分布有 n 个小孔。黑盒左上角小孔序号为 0，按顺时针编号，总共有 2*(m+n) 个小孔。每个小孔均可以打开或者关闭，初始时，所有小孔均处于关闭状态。每个小孔上的盖子均为镜面材质。例如一个 2*3 的黑盒主视图与其小孔分布如图所示:
店长告诉小扣，这里是「几何学的快问快答」，店长可能有两种操作：
open(int index, int direction) - 若小孔处于关闭状态，则打开小孔，照入光线；否则直接照入光线；
close(int index) - 关闭处于打开状态小孔，店长保证不会关闭已处于关闭状态的小孔；
其中：
index： 表示小孔序号
direction：1 表示光线沿
y=x 方向，-1 表示光线沿
y=−x 方向。
当光线照至边界时：若边界上的小孔为开启状态，则光线会射出；否则，光线会在小孔之间进行反射。特别地：
若光线射向未打开的拐角（黑盒顶点），则光线会原路反射回去；
光线自拐角处的小孔照入时，只有一种入射方向（如自序号为 0 的小孔照入方向只能为 -1）
请帮助小扣判断并返回店长每次照入的光线从几号小孔射出。
示例 1：
输入：
[""BlackBox"",""open"",""open"",""open"",""close"",""open""]
[[2,3],[6,-1],[4,-1],[0,-1],[6],[0,-1]]
输出：[null,6,4,6,null,4]
解释：
BlackBox b = BlackBox(2,3); // 新建一个 2x3 的黑盒
b.open(6,-1) // 打开 6 号小孔，并沿 y=-x 方向照入光线，光线至 0 号小孔反射，从 6 号小孔射出
b.open(4,-1) // 打开 4 号小孔，并沿 y=-x 方向照入光线，光线轨迹为 4-2-8-2-4，从 4 号小孔射出
b.open(0,-1) // 打开 0 号小孔，并沿 y=-x 方向照入光线，由于 6 号小孔为开启状态，光线从 6 号小孔射出
b.close(6) // 关闭 6 号小孔
b.shoot(0,-1) // 从 0 号小孔沿 y=-x 方向照入光线，由于 6 号小孔为关闭状态，4 号小孔为开启状态，光线轨迹为 0-6-4，从 4 号小孔射出
示例 2：
输入：
[""BlackBox"",""open"",""open"",""open"",""open"",""close"",""open"",""close"",""open""]
[[3,3],[1,-1],[5,1],[11,-1],[11,1],[1],[11,1],[5],[11,-1]]
输出：[null,1,1,5,1,null,5,null,11]
解释：
BlackBox b = BlackBox(3,3); // 新建一个 3x3 的黑盒
b.open(1,-1) // 打开 1 号小孔，并沿 y=-x 方向照入光线，光线轨迹为 1-5-7-11-1，从 1 号小孔射出
b.open(5,1) // 打开 5 号小孔，并沿 y=x 方向照入光线，光线轨迹为 5-7-11-1，从 1 号小孔射出
b.open(11,-1) // 打开 11 号小孔，并沿逆 y=-x 方向照入光线，光线轨迹为 11-7-5，从 5 号小孔射出
b.open(11,1) // 从 11 号小孔沿 y=x 方向照入光线，光线轨迹为 11-1，从 1 号小孔射出
b.close(1) // 关闭 1 号小孔
b.open(11,1) // 从 11 号小孔沿 y=x 方向照入光线，光线轨迹为 11-1-5，从 5 号小孔射出
b.close(5) // 关闭 5 号小孔
b.open(11,-1) // 从 11 号小孔沿 y=-x 方向照入光线，光线轨迹为 11-1-5-7-11，从 11 号小孔射出
提示：
1 <= n, m <= 10000
1 <= 操作次数 <= 10000
direction 仅为 1 或 -1
0 <= index < 2*(m+n)",16,,1435,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/ordered-set/']",[],4242
评论 (137),4xy4Wx,简单,"小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。
注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1
示例 1：
输入：nums = [2,5,3,5], target = 6
输出：1
解释：预算内仅能购买 nums[0] 与 nums[2]。
示例 2：
输入：nums = [2,2,1,9], target = 10
输出：4
解释：符合预算的采购方案如下：
nums[0] + nums[1] = 4
nums[0] + nums[2] = 3
nums[1] + nums[2] = 3
nums[2] + nums[3] = 10
提示：
2 <= nums.length <= 10^5
1 <= nums[i], target <= 10^5",47,,15025,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],49042
评论 (171),SNJvJP,中等,"某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。
为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，...，9 循环重复排列。例如当 num = 5 时，站位如图所示
请返回位于场地坐标 [Xpos,Ypos] 的成员所持乐器编号。
示例 1：
输入：num = 3, Xpos = 0, Ypos = 2
输出：3
解释：
示例 2：
输入：num = 4, Xpos = 1, Ypos = 2
输出：5
解释：
提示：
1 <= num <= 10^9
0 <= Xpos, Ypos < num",63,,7210,['https://leetcode.cn/tag/math/'],[],34548
评论 (126),p0NxJO,中等,"小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。
小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。
示例 1：
输入：nums = [100,100,100,-250,-60,-140,-50,-50,100,150]
输出：1
解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求。
示例 2：
输入：nums = [-200,-300,400,0]
输出：-1
解释：调整访问顺序也无法完成全部房间的访问。
提示：
1 <= nums.length <= 10^5
-10^5 <= nums[i] <= 10^5",44,,7632,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],20563
评论 (33),Db3wC1,困难,"某解密游戏中，有一个 N*M 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 (n-1,m-1) 位置。迷宫变化规律记录于 maze 中，maze[i] 表示 i 时刻迷宫的地形状态，""."" 表示可通行空地，""#"" 表示陷阱。
地形图初始状态记作 maze[0]，此时小力位于起点 (0,0)。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。
小力背包有以下两个魔法卷轴（卷轴使用一次后消失）：
临时消除术：将指定位置在下一个时刻变为空地；
永久消除术：将指定位置永久变为空地。
请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？
注意： 输入数据保证起点和终点在所有时刻均为空地。
示例 1：
输入：maze = [["".#."",""#..""],[""..."","".#.""],["".##"","".#.""],[""..#"","".#.""]]
输出：true
解释：
示例 2：
输入：maze = [["".#."",""...""],[""..."",""...""]]
输出：false
解释：由于时间不够，小力无法到达终点逃出迷宫。
示例 3：
输入：maze = [[""..."",""..."",""...""],["".##"",""###"",""##.""],["".##"",""###"",""##.""],["".##"",""###"",""##.""],["".##"",""###"",""##.""],["".##"",""###"",""##.""],["".##"",""###"",""##.""]]
输出：false
解释：由于道路不通，小力无法到达终点逃出迷宫。
提示：
1 <= maze.length <= 100
1 <= maze[i].length, maze[i][j].length <= 50
maze[i][j] 仅包含 "".""、""#""",30,,2391,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],8418
评论 (22),t3fKg1,困难,"某实验室计算机待处理任务以 [start,end,period] 格式记于二维数组 tasks，表示完成该任务的时间范围为起始时间 start 至结束时间 end 之间，需要计算机投入 period 的时长，注意：
period 可为不连续时间
首尾时间均包含在内
处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。
示例 1：
输入：tasks = [[1,3,2],[2,5,3],[5,6,2]]
输出：4
解释：
tasks[0] 选择时间点 2、3；
tasks[1] 选择时间点 2、3、5；
tasks[2] 选择时间点 5、6；
因此计算机仅需在时间点 2、3、5、6 四个时刻保持开机即可完成任务。
示例 2：
输入：tasks = [[2,3,1],[5,5,1],[5,6,2]]
输出：3
解释：
tasks[0] 选择时间点 2 或 3；
tasks[1] 选择时间点 5；
tasks[2] 选择时间点 5、6；
因此计算机仅需在时间点 2、5、6 或 3、5、6 三个时刻保持开机即可完成任务。
提示：
2 <= tasks.length <= 10^5
tasks[i].length == 3
0 <= tasks[i][0] <= tasks[i][1] <= 10^9
1 <= tasks[i][2] <= tasks[i][1]-tasks[i][0] + 1",24,,1545,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],3478
评论 (121),o8SXZn,简单,"给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 bucket[i]。小扣有以下两种操作：
升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1
蓄水：将全部水桶接满水，倒入各自对应的水缸
每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。
注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。
示例 1：
输入：bucket = [1,3], vat = [6,8]
输出：4
解释：
第 1 次操作升级 bucket[0]；
第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。
示例 2：
输入：bucket = [9,0,1], vat = [0,2,2]
输出：3
解释：
第 1 次操作均选择升级 bucket[1]
第 2~3 次操作选择蓄水，即可完成蓄水要求。
提示：
1 <= bucket.length == vat.length <= 100
0 <= bucket[i], vat[i] <= 10^4",59,,6846,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],27357
评论 (46),er-cha-shu-ran-se-UGC,中等,"小扣有一个根结点为 root 的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色，模型的每个结点有一个 val 价值。小扣出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过 k 个，求所有染成蓝色的结点价值总和最大是多少？
示例 1：
输入：root = [5,2,3,4], k = 2
输出：12
解释：结点 5、3、4 染成蓝色，获得最大的价值 5+3+4=12
示例 2：
输入：root = [4,1,3,9,null,null,2], k = 2
输出：16
解释：结点 4、3、9 染成蓝色，获得最大的价值 4+3+9=16
提示：
1 <= k <= 10
1 <= val <= 10000
1 <= 结点数量 <= 10000",54,,3705,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",[],6938
评论 (27),DFPeFJ,困难,"小明的电动车电量充满时可行驶距离为 cnt，每行驶 1 单位距离消耗 1 单位电量，且花费 1 单位时间。小明想选择电动车作为代步工具。地图上共有 N 个景点，景点编号为 0 ~ N-1。他将地图信息以 [城市 A 编号,城市 B 编号,两城市间距离] 格式整理在在二维数组 paths，表示城市 A、B 间存在双向通路。初始状态，电动车电量为 0。每个城市都设有充电桩，charge[i] 表示第 i 个城市每充 1 单位电量需要花费的单位时间。请返回小明最少需要花费多少单位时间从起点城市 start 抵达终点城市 end。
示例 1：
输入：paths = [[1,3,3],[3,2,1],[2,1,3],[0,1,4],[3,0,5]], cnt = 6, start = 1, end = 0, charge = [2,10,4,1]
输出：43
解释：最佳路线为：1->3->0。
在城市 1 仅充 3 单位电至城市 3，然后在城市 3 充 5 单位电，行驶至城市 5。
充电用时共 3*10 + 5*1= 35
行驶用时 3 + 5 = 8，此时总用时最短 43。
示例 2：
输入：paths = [[0,4,2],[4,3,5],[3,0,5],[0,1,5],[3,2,4],[1,2,8]], cnt = 8, start = 0, end = 2, charge = [4,1,1,3,2]
输出：38
解释：最佳路线为：0->4->3->2。
城市 0 充电 2 单位，行驶至城市 4 充电 8 单位，行驶至城市 3 充电 1 单位，最终行驶至城市 2。
充电用时 4*2+2*8+3*1 = 27
行驶用时 2+5+4 = 11，总用时最短 38。
提示：
1 <= paths.length <= 200
paths[i].length == 3
2 <= charge.length == n <= 100
0 <= path[i][0],path[i][1],start,end < n
1 <= cnt <= 100
1 <= path[i][2] <= cnt
1 <= charge[i] <= 100
题目保证所有城市相互可以到达",27,,1790,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/shortest-path/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],3836
评论 (27),Up5XYM,困难,"麻将的游戏规则中，共有两种方式凑成「一组牌」：
顺子：三张牌面数字连续的麻将，例如 [4,5,6]
刻子：三张牌面数字相同的麻将，例如 [10,10,10]
给定若干数字作为麻将牌的数值（记作一维数组 tiles），请返回所给 tiles 最多可组成的牌组数。
注意：凑成牌组时，每张牌仅能使用一次。
示例 1：
输入：tiles = [2,2,2,3,4]
输出：1
解释：最多可以组合出 [2,2,2] 或者 [2,3,4] 其中一组牌。
示例 2：
输入：tiles = [2,2,2,3,4,1,3]
输出：2
解释：最多可以组合出 [1,2,3] 与 [2,3,4] 两组牌。
提示：
1 <= tiles.length <= 10^5
1 <= tiles[i] <= 10^9",24,,1280,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/sorting/']",[],3902
评论 (21),zui-xiao-ju-xing-mian-ji,困难,"二维平面上有
N
N 条直线，形式为 y = kx + b，其中 k、b为整数 且 k > 0。所有直线以 [k,b] 的形式存于二维数组 lines 中，不存在重合的两条直线。两两直线之间可能存在一个交点，最多会有
C_N^2
C
N
2
个交点。我们用一个平行于坐标轴的矩形覆盖所有的交点，请问这个矩形最小面积是多少。若直线之间无交点、仅有一个交点或所有交点均在同一条平行坐标轴的直线上，则返回0。
注意：返回结果是浮点数，与标准答案 绝对误差或相对误差 在 10^-4 以内的结果都被视为正确结果
示例 1：
输入：lines = [[2,3],[3,0],[4,1]]
输出：48.00000
解释：三条直线的三个交点为 (3, 9) (1, 5) 和 (-1, -3)。最小覆盖矩形左下角为 (-1, -3) 右上角为 (3,9)，面积为 48
示例 2：
输入：lines = [[1,1],[2,3]]
输出：0.00000
解释：仅有一个交点 (-2，-1）
限制：
1 <= lines.length <= 10^5 且 lines[i].length == 2
1 <= lines[0] <= 10000
-10000 <= lines[1] <= 10000
与标准答案绝对误差或相对误差在 10^-4 以内的结果都被视为正确结果",18,,1223,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/combinatorics/', 'https://leetcode.cn/tag/sorting/']",[],5166
评论 (10),7rLGCR,困难,"城堡守卫游戏的胜利条件为使恶魔无法从出生点到达城堡。游戏地图可视作 2*N 的方格图，记作字符串数组 grid，其中：
""."" 表示恶魔可随意通行的平地；
""#"" 表示恶魔不可通过的障碍物，玩家可通过在 平地 上设置障碍物，即将 ""."" 变为 ""#"" 以阻挡恶魔前进；
""S"" 表示恶魔出生点，将有大量的恶魔该点生成，恶魔可向上/向下/向左/向右移动，且无法移动至地图外；
""P"" 表示瞬移点，移动到 ""P"" 点的恶魔可被传送至任意一个 ""P"" 点，也可选择不传送；
""C"" 表示城堡。
然而在游戏中用于建造障碍物的金钱是有限的，请返回玩家最少需要放置几个障碍物才能获得胜利。若无论怎样放置障碍物均无法获胜，请返回 -1。
注意：
地图上可能有一个或多个出生点
地图上有且只有一个城堡
示例 1
输入：grid = [""S.C.P#P."", "".....#.S""]
输出：3
解释：至少需要放置三个障碍物
示例 2：
输入：grid = [""SP#P..P#PC#.S"", ""..#P..P####.#""]
输出：-1
解释：无论怎样修筑障碍物，均无法阻挡最左侧出生的恶魔到达城堡位置
示例 3：
输入：grid = [""SP#.C.#PS"", ""P.#...#.P""]
输出：0
解释：无需放置障碍物即可获得胜利
示例 4：
输入：grid = [""CP.#.P."", ""...S..S""]
输出：4
解释：至少需要放置 4 个障碍物，示意图为放置方法之一
提示：
grid.length == 2
2 <= grid[0].length == grid[1].length <= 10^4
grid[i][j] 仅包含字符 "".""、""#""、""C""、""P""、""S""",9,,774,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],1221
评论 (44),0jQkd0,简单,"在 「力扣挑战赛」 开幕式的压轴节目 「无人机方阵」中，每一架无人机展示一种灯光颜色。 无人机方阵通过两种操作进行颜色图案变换：
调整无人机的位置布局
切换无人机展示的灯光颜色
给定两个大小均为 N*M 的二维数组 source 和 target 表示无人机方阵表演的两种颜色图案，由于无人机切换灯光颜色的耗能很大，请返回从 source 到 target 最少需要多少架无人机切换灯光颜色。
注意： 调整无人机的位置布局时无人机的位置可以随意变动。
示例 1：
输入：source = [[1,3],[5,4]], target = [[3,1],[6,5]]
输出：1
解释：
最佳方案为
将 [0,1] 处的无人机移动至 [0,0] 处；
将 [0,0] 处的无人机移动至 [0,1] 处；
将 [1,0] 处的无人机移动至 [1,1] 处；
将 [1,1] 处的无人机移动至 [1,0] 处，其灯光颜色切换为颜色编号为 6 的灯光；
因此从source 到 target 所需要的最少灯光切换次数为 1。
示例 2：
输入：source = [[1,2,3],[3,4,5]], target = [[1,3,5],[2,3,4]]
输出：0
解释：
仅需调整无人机的位置布局，便可完成图案切换。因此不需要无人机切换颜色
提示：
n == source.length == target.length
m == source[i].length == target[i].length
1 <= n, m <=100
1 <= source[i][j], target[i][j] <=10^4",5,,5642,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/matrix/']",[],10636
评论 (86),uOAnQW,简单,"「力扣挑战赛」心算项目的挑战比赛中，要求选手从 N 张卡牌中选出 cnt 张卡牌，若这 cnt 张卡牌数字总和为偶数，则选手成绩「有效」且得分为 cnt 张卡牌数字总和。
给定数组 cards 和 cnt，其中 cards[i] 表示第 i 张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。
示例 1：
输入：cards = [1,2,8,9], cnt = 3
输出：18
解释：选择数字为 1、8、9 的这三张卡牌，此时可获得最大的有效得分 1+8+9=18。
示例 2：
输入：cards = [3,3,1], cnt = 1
输出：0
解释：不存在获取有效得分的卡牌方案。
提示：
1 <= cnt <= cards.length <= 10^5
1 <= cards[i] <= 1000",31,,5138,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],18366
评论 (32),fHi6rV,中等,"在 n*m 大小的棋盘中，有黑白两种棋子，黑棋记作字母 ""X"", 白棋记作字母 ""O""，空余位置记作 "".""。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。
「力扣挑战赛」黑白翻转棋项目中，将提供给选手一个未形成可翻转棋子的棋盘残局，其状态记作 chessboard。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。
注意：
若翻转白棋成黑棋后，棋盘上仍存在可以翻转的白棋，将可以 继续 翻转白棋
输入数据保证初始棋盘状态无可以翻转的棋子且存在空余位置
示例 1：
输入：chessboard = [""....X."",""....X."",""XOOO.."",""......"",""......""]
输出：3
解释：
可以选择下在 [2,4] 处，能够翻转白方三枚棋子。
示例 2：
输入：chessboard = ["".X."","".O."",""XO.""]
输出：2
解释：
可以选择下在 [2,2] 处，能够翻转白方两枚棋子。
示例 3：
输入：chessboard = [""......."",""......."",""......."",""X......"","".O....."",""..O...."",""....OOX""]
输出：4
解释：
可以选择下在 [6,3] 处，能够翻转白方四枚棋子。
提示：
1 <= chessboard.length, chessboard[i].length <= 8
chessboard[i] 仅包含 "".""、""O"" 和 ""X""",5,,1825,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],3942
评论 (45),vFjcfV,困难,"「力扣挑战赛」场地外，小力组织了一个套玩具的游戏。所有的玩具摆在平地上，toys[i] 以 [xi,yi,ri] 的形式记录了第 i 个玩具的坐标 (xi,yi) 和半径 ri。小扣试玩了一下，他扔了若干个半径均为 r 的圈，circles[j] 记录了第 j 个圈的坐标 (xj,yj)。套圈的规则如下：
若一个玩具被某个圈完整覆盖了（即玩具的任意部分均在圈内或者圈上），则该玩具被套中。
若一个玩具被多个圈同时套中，最终仅计算为套中一个玩具
请帮助小扣计算，他成功套中了多少玩具。
注意：
输入数据保证任意两个玩具的圆心不会重合，但玩具之间可能存在重叠。
示例 1：
输入：toys = [[3,3,1],[3,2,1]], circles = [[4,3]], r = 2
输出：1
解释： 如图所示，仅套中一个玩具
示例 2：
输入：toys = [[1,3,2],[4,3,1],[7,1,2]], circles = [[1,0],[3,3]], r = 4
输出：2
解释： 如图所示，套中两个玩具
提示：
1 <= toys.length <= 10^4
0 <= toys[i][0], toys[i][1] <= 10^9
1 <= circles.length <= 10^4
0 <= circles[i][0], circles[i][1] <= 10^9
1 <= toys[i][2], r <= 10",11,,1641,"['https://leetcode.cn/tag/geometry/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/sorting/']",[],6668
评论 (7),Y1VbOX,困难,"前往「力扣挑战赛」场馆的道路上，有一个拥堵的十字路口，该十字路口由两条双向两车道的路交叉构成。由于信号灯故障，交警需要手动指挥拥堵车辆。假定路口没有新的来车且一辆车从一个车道驶入另一个车道所需的时间恰好为一秒钟，长度为 4 的一维字符串数组 directions 中按照 东、南、西、北 顺序记录了四个方向从最靠近路口到最远离路口的车辆计划开往的方向。其中：
""E"" 表示向东行驶；
""S"" 表示向南行驶；
""W"" 表示向西行驶；
""N"" 表示向北行驶。
交警每秒钟只能指挥各个车道距离路口最近的一辆车，且每次指挥需要满足如下规则：
同一秒钟内，一个方向的车道只允许驶出一辆车；
同一秒钟内，一个方向的车道只允许驶入一辆车；
同一秒钟内，车辆的行驶路线不可相交。
请返回最少需要几秒钟，该十字路口等候的车辆才能全部走完。
各个车道驶出的车辆可能的行驶路线如图所示：
注意：
测试数据保证不会出现掉头行驶指令，即某一方向的行驶车辆计划开往的方向不会是当前车辆所在的车道的方向;
表示堵塞车辆行驶方向的字符串仅用大写字母 ""E""，""N""，""W""，""S"" 表示。
示例 1：
输入：directions = [""W"",""N"",""ES"",""W""]
输出：2
解释：
第 1 秒：东西方向排在最前的车先行，剩余车辆状态 ["""",""N"",""S"",""W""]；
第 2 秒：南、西、北方向的车行驶，路口无等待车辆；
因此最少需要 2 秒，返回 2。
示例 2：
输入：directions = [""NS"",""WE"",""SE"",""EW""]
输出：3
解释：
第 1 秒：四个方向排在最前的车均可驶出；
第 2 秒：东南方向的车驶出，剩余车辆状态 ["""","""",""E"",""W""]；
第 3 秒：西北方向的车驶出。
提示：
directions.length = 4
0 <= directions[i].length <= 20",9,,653,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],1374
评论 (62),sZ59z6,简单,"「力扣挑战赛」开幕式开始了，空中绽放了一颗二叉树形的巨型焰火。
给定一棵二叉树 root 代表焰火，节点值表示巨型焰火这一位置的颜色种类。请帮小扣计算巨型焰火有多少种不同的颜色。
示例 1：
输入：root = [1,3,2,1,null,2]
输出：3
解释：焰火中有 3 个不同的颜色，值分别为 1、2、3
示例 2：
输入：root = [3,3,3]
输出：1
解释：焰火中仅出现 1 个颜色，值为 3
提示：
1 <= 节点个数 <= 1000
1 <= Node.val <= 1000",18,,8244,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/binary-tree/']",[],10354
评论 (39),kplEvH,中等,"「力扣挑战赛」中 N*M 大小的自行车炫技赛场的场地由一片连绵起伏的上下坡组成，场地的高度值记录于二维数组 terrain 中，场地的减速值记录于二维数组 obstacle 中。
若选手骑着自行车从高度为 h1 且减速值为 o1 的位置到高度为 h2 且减速值为 o2 的相邻位置（上下左右四个方向），速度变化值为 h1-h2-o2（负值减速，正值增速）。
选手初始位于坐标 position 处且初始速度为 1，请问选手可以刚好到其他哪些位置时速度依旧为 1。请以二维数组形式返回这些位置。若有多个位置则按行坐标升序排列，若有多个位置行坐标相同则按列坐标升序排列。
注意： 骑行过程中速度不能为零或负值
示例 1：
输入：position = [0,0], terrain = [[0,0],[0,0]], obstacle = [[0,0],[0,0]]
输出：[[0,1],[1,0],[1,1]]
解释：
由于当前场地属于平地，根据上面的规则，选手从[0,0]的位置出发都能刚好在其他处的位置速度为 1。
示例 2：
输入：position = [1,1], terrain = [[5,0],[0,6]], obstacle = [[0,6],[7,0]]
输出：[[0,1]]
解释：
选手从 [1,1] 处的位置出发，到 [0,1] 处的位置时恰好速度为 1。
提示：
n == terrain.length == obstacle.length
m == terrain[i].length == obstacle[i].length
1 <= n <= 100
1 <= m <= 100
0 <= terrain[i][j], obstacle[i][j] <= 100
position.length == 2
0 <= position[0] < n
0 <= position[1] < m",8,,1653,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],6932
评论 (25),05ZEDJ,中等,"「力扣挑战赛」有 n 个比赛场馆（场馆编号从 0 开始），场馆之间的通道分布情况记录于二维数组 edges 中，edges[i]= [x, y] 表示第 i 条通道连接场馆 x 和场馆 y(即两个场馆相邻)。初始每个场馆中都有一定人数的志愿者（不同场馆人数可能不同），后续 m 天每天均会根据赛事热度进行志愿者人数调配。调配方案分为如下三种：
将编号为 idx 的场馆内的志愿者人数减半；
将编号为 idx 的场馆相邻的场馆的志愿者人数都加上编号为 idx 的场馆的志愿者人数；
将编号为 idx 的场馆相邻的场馆的志愿者人数都减去编号为 idx 的场馆的志愿者人数。
所有的调配信息记录于数组 plans 中，plans[i] = [num,idx] 表示第 i 天对编号 idx 的场馆执行了第 num 种调配方案。
在比赛结束后对调配方案进行复盘时，不慎将第 0 个场馆的最终志愿者人数丢失，只保留了初始所有场馆的志愿者总人数 totalNum ，以及记录了第 1 ~ n-1 个场馆的最终志愿者人数的一维数组 finalCnt。请你根据现有的信息求出初始每个场馆的志愿者人数，并按场馆编号顺序返回志愿者人数列表。
注意：
测试数据保证当某场馆进行第一种调配时，该场馆的志愿者人数一定为偶数；
测试数据保证当某场馆进行第三种调配时，该场馆的相邻场馆志愿者人数不为负数；
测试数据保证比赛开始时每个场馆的志愿者人数都不超过 10^9；
测试数据保证给定的场馆间的道路分布情况中不会出现自环、重边的情况。
示例 1：

输入：
finalCnt = [1,16], totalNum = 21, edges = [[0,1],[1,2]], plans = [[2,1],[1,0],[3,0]]
输出：[5,7,9]
解释：
示例 2 ：
输入：
finalCnt = [4,13,4,3,8], totalNum = 54, edges = [[0,3],[1,3],[4,3],[2,3],[2,5]], plans = [[1,1],[3,3],[2,5],[1,0]]
输出：[10,16,9,4,7,8]
提示：
2 <= n <= 5*10^4
1 <= edges.length <= min((n * (n - 1)) / 2, 5*10^4)
0 <= edges[i][0], edges[i][1] < n
1 <= plans.length <= 10
1 <= plans[i][0] <=3
0 <= plans[i][1] < n
finalCnt.length = n-1
0 <= finalCnt[i] < 10^9
0 <= totalNum < 5*10^13",5,,1300,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],2988
评论 (13),oPs9Bm,困难,"「力扣挑战赛」 的入场仪式马上就要开始了，由于安保工作的需要，设置了可容纳人数总和为 M 的 N 个安检室，capacities[i] 记录第 i 个安检室可容纳人数。安检室拥有两种类型：
先进先出：在安检室中的所有观众中，最早进入安检室的观众最先离开
后进先出：在安检室中的所有观众中，最晚进入安检室的观众最先离开
恰好 M+1 位入场的观众（编号从 0 开始）需要排队依次入场安检， 入场安检的规则如下：
观众需要先进入编号 0 的安检室
当观众将进入编号 i 的安检室时（0 <= i < N)，
若安检室未到达可容纳人数上限，该观众可直接进入；
若安检室已到达可容纳人数上限，在该观众进入安检室之前需根据当前安检室类型选择一位观众离开后才能进入；
当观众离开编号 i 的安检室时 （0 <= i < N-1)，将进入编号 i+1 的安检室接受安检。
若可以任意设定每个安检室的类型，请问有多少种设定安检室类型的方案可以使得编号 k 的观众第一个通过最后一个安检室入场。
注意：
观众不可主动离开安检室，只有当安检室容纳人数达到上限，且又有新观众需要进入时，才可根据安检室的类型选择一位观众离开；
由于方案数可能过大，请将答案对 1000000007 取模后返回。
示例 1：
输入：capacities = [2,2,3], k = 2
输出：2
解释：
存在两种设定的 2 种方案：
方案 1：将编号为 0 、1 的实验室设置为 后进先出 的类型，编号为 2 的实验室设置为 先进先出 的类型；
方案 2：将编号为 0 、1 的实验室设置为 先进先出 的类型，编号为 2 的实验室设置为 后进先出 的类型。
以下是方案 1 的示意图：
示例 2：
输入：capacities = [3,3], k = 3
输出：0
示例 3：
输入：capacities = [4,3,2,2], k = 6
输出：2
提示:
1 <= capacities.length <= 200
1 <= capacities[i] <= 200
0 <= k <= sum(capacities)",10,,1192,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],2946
评论 (5),fsa7oZ,困难,"小力正在通过残局练习来备战「力扣挑战赛」中的「五子棋」项目，他想请你能帮他预测当前残局的输赢情况。棋盘中的棋子分布信息记录于二维数组 pieces 中，其中 pieces[i] = [x,y,color] 表示第 i 枚棋子的横坐标为 x，纵坐标为 y，棋子颜色为 color(0 表示黑棋，1 表示白棋)。假如黑棋先行，并且黑棋和白棋都按最优策略落子，请你求出当前棋局在三步（按 黑、白、黑 的落子顺序）之内的输赢情况（三步之内先构成同行、列或对角线连续同颜色的至少 5 颗即为获胜）：
黑棋胜, 请返回 ""Black""
白棋胜, 请返回 ""White""
仍无胜者, 请返回 ""None""
注意：
和传统的五子棋项目不同，「力扣挑战赛」中的「五子棋」项目 不存在边界限制，即可在 任意位置 落子；
黑棋和白棋均按 3 步内的输赢情况进行最优策略的选择
测试数据保证所给棋局目前无胜者；
测试数据保证不会存在坐标一样的棋子。
示例 1：
输入：
pieces = [[0,0,1],[1,1,1],[2,2,0]]
输出：""None""
解释：无论黑、白棋以何种方式落子，三步以内都不会产生胜者。
示例 2：
输入：
pieces = [[1,2,1],[1,4,1],[1,5,1],[2,1,0],[2,3,0],[2,4,0],[3,2,1],[3,4,0],[4,2,1],[5,2,1]]
输出：""Black""
解释：三步之内黑棋必胜，以下是一种可能的落子情况：
提示：
0 <= pieces.length <= 1000
pieces[i].length = 3
-10^9 <= pieces[i][0], pieces[i][1] <=10^9
0 <= pieces[i][2] <=1",9,,584,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/enumeration/', 'https://leetcode.cn/tag/game-theory/']",[],2607
评论 (6),K8GULz,困难,"「力扣挑战赛」中有一个由 N 个关卡组成的环形闯关游戏，关卡编号为 0~N-1，编号 0 的关卡和编号 N-1 的关卡相邻。每个关卡均有积分要求，challenge[i] 表示挑战编号 i 的关卡最少需要拥有的积分。
小扣想要挑战关卡，闯关的具体规则如下：
初始小扣可以指定其中一个关卡为「开启」状态，其余关卡将处于「未开启」状态。
小扣可以挑战处于「开启」状态且满足最少积分要求的关卡，若小扣挑战该关卡前积分为 score，挑战结束后，积分将增长为 score|challenge[i]（即位运算中的 ""OR"" 运算）
在挑战某个关卡后，该关卡两侧相邻的关卡将会开启（若之前未开启）
请帮助小扣进行计算，初始最少需要多少积分，可以挑战 环形闯关游戏 的所有关卡。
示例1：
输入：challenge = [5,4,6,2,7]
输出：4
解释： 初始选择编号 3 的关卡开启，积分为 4
挑战编号 3 的关卡，积分变为
4∣2=6，开启 2、4 处的关卡
挑战编号 2 的关卡，积分变为
6∣6=6，开启 1 处的关卡
挑战编号 1 的关卡，积分变为
6∣4=6，开启 0 处的关卡
挑战编号 0 的关卡，积分变为
6∣5=7
挑战编号 4 的关卡，顺利完成全部的关卡
示例2：
输入：challenge = [12,7,11,3,9]
输出：8
解释： 初始选择编号 3 的关卡开启，积分为 8
挑战编号 3 的关卡，积分变为
8∣3=11，开启 2、4 处的关卡
挑战编号 2 的关卡，积分变为
11∣11=11，开启 1 处的关卡
挑战编号 4 的关卡，积分变为
11∣9=11，开启 0 处的关卡
挑战编号 1 的关卡，积分变为
11∣7=15
挑战编号 0 的关卡，顺利完成全部的关卡
示例3：
输入：challenge = [1,1,1]
输出：1
提示：
1 <= challenge.length <= 5*10^4
1 <= challenge[i] <= 10^18",8,,589,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],1995
评论 (22),WHnhjV,简单,"欢迎各位勇者来到力扣新手村，在开始试炼之前，请各位勇者先进行「宝石补给」。
每位勇者初始都拥有一些能量宝石， gem[i] 表示第 i 位勇者的宝石数量。现在这些勇者们进行了一系列的赠送，operations[j] = [x, y] 表示在第 j 次的赠送中 第 x 位勇者将自己一半的宝石（需向下取整）赠送给第 y 位勇者。
在完成所有的赠送后，请找到拥有最多宝石的勇者和拥有最少宝石的勇者，并返回他们二者的宝石数量之差。
注意：
赠送将按顺序逐步进行。
示例 1：
输入：gem = [3,1,2], operations = [[0,2],[2,1],[2,0]]
输出：2
解释：
第 1 次操作，勇者 0 将一半的宝石赠送给勇者 2， gem = [2,1,3]
第 2 次操作，勇者 2 将一半的宝石赠送给勇者 1， gem = [2,2,2]
第 3 次操作，勇者 2 将一半的宝石赠送给勇者 0， gem = [3,2,1]
返回 3 - 1 = 2
示例 2：
输入：gem = [100,0,50,100], operations = [[0,2],[0,1],[3,0],[3,0]]
输出：75
解释：
第 1 次操作，勇者 0 将一半的宝石赠送给勇者 2， gem = [50,0,100,100]
第 2 次操作，勇者 0 将一半的宝石赠送给勇者 1， gem = [25,25,100,100]
第 3 次操作，勇者 3 将一半的宝石赠送给勇者 0， gem = [75,25,100,50]
第 4 次操作，勇者 3 将一半的宝石赠送给勇者 0， gem = [100,25,100,25]
返回 100 - 25 = 75
示例 3：
输入：gem = [0,0,0,0], operations = [[1,2],[3,1],[1,2]]
输出：0
提示：
2 <= gem.length <= 10^3
0 <= gem[i] <= 10^3
0 <= operations.length <= 10^4
operations[i].length == 2
0 <= operations[i][0], operations[i][1] < gem.length",2,,5158,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],7743
评论 (43),UEcfPD,简单,"欢迎各位勇者来到力扣城，城内设有烹饪锅供勇者制作料理，为自己恢复状态。
勇者背包内共有编号为 0 ~ 4 的五种食材，其中 materials[j] 表示第 j 种食材的数量。通过这些食材可以制作若干料理，cookbooks[i][j] 表示制作第 i 种料理需要第 j 种食材的数量，而 attribute[i] = [x,y] 表示第 i 道料理的美味度 x 和饱腹感 y。
在饱腹感不小于 limit 的情况下，请返回勇者可获得的最大美味度。如果无法满足饱腹感要求，则返回 -1。
注意：
每种料理只能制作一次。
示例 1：
输入：materials = [3,2,4,1,2]
cookbooks = [[1,1,0,1,2],[2,1,4,0,0],[3,2,4,1,0]]
attribute = [[3,2],[2,4],[7,6]]
limit = 5
输出：7
解释：
食材数量可以满足以下两种方案：
方案一：制作料理 0 和料理 1，可获得饱腹感 2+4、美味度 3+2
方案二：仅制作料理 2， 可饱腹感为 6、美味度为 7
因此在满足饱腹感的要求下，可获得最高美味度 7
示例 2：
输入：materials = [10,10,10,10,10]
cookbooks = [[1,1,1,1,1],[3,3,3,3,3],[10,10,10,10,10]]
attribute = [[5,5],[6,6],[10,10]]
limit = 1
输出：11
解释：通过制作料理 0 和 1，可满足饱腹感，并获得最高美味度 11
提示：
materials.length == 5
1 <= cookbooks.length == attribute.length <= 8
cookbooks[i].length == 5
attribute[i].length == 2
0 <= materials[i], cookbooks[i][j], attribute[i][j] <= 20
1 <= limit <= 100",7,,3594,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/enumeration/']",[],7925
评论 (44),QO5KpG,中等,"欢迎各位勇者来到力扣城，本次试炼主题为「二叉搜索树染色」。
每位勇士面前设有一个二叉搜索树的模型，模型的根节点为 root，树上的各个节点值均不重复。初始时，所有节点均为蓝色。现在按顺序对这棵二叉树进行若干次操作， ops[i] = [type, x, y] 表示第 i 次操作为：
type 等于 0 时，将节点值范围在 [x, y] 的节点均染蓝
type 等于 1 时，将节点值范围在 [x, y] 的节点均染红
请返回完成所有染色后，该二叉树中红色节点的数量。
注意：
题目保证对于每个操作的 x、y 值定出现在二叉搜索树节点中
示例 1：
输入：root = [1,null,2,null,3,null,4,null,5], ops = [[1,2,4],[1,1,3],[0,3,5]]
输出：2
解释：
第 0 次操作，将值为 2、3、4 的节点染红；
第 1 次操作，将值为 1、2、3 的节点染红；
第 2 次操作，将值为 3、4、5 的节点染蓝；
因此，最终值为 1、2 的节点为红色节点，返回数量 2
示例 2：
输入：root = [4,2,7,1,null,5,null,null,null,null,6]
ops = [[0,2,2],[1,1,5],[0,4,5],[1,5,7]]
输出：5
解释：
第 0 次操作，将值为 2 的节点染蓝；
第 1 次操作，将值为 1、2、4、5 的节点染红；
第 2 次操作，将值为 4、5 的节点染蓝；
第 3 次操作，将值为 5、6、7 的节点染红；
因此，最终值为 1、2、5、6、7 的节点为红色节点，返回数量 5
提示：
1 <= 二叉树节点数量 <= 10^5
1 <= ops.length <= 10^5
ops[i].length == 3
ops[i][0] 仅为 0 or 1
0 <= ops[i][1] <= ops[i][2] <= 10^9
0 <= 节点值 <= 10^9",16,,2512,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/ordered-set/']",[],10738
评论 (18),EJvmW4,困难,"各位勇者请注意，力扣太空城发布陨石雨红色预警。
太空城中的一些舱室将要受到陨石雨的冲击，这些舱室按照编号 0 ~ N 的顺序依次排列。为了阻挡陨石损毁舱室，太空城可以使用能量展开防护屏障，具体消耗如下：
选择一个舱室开启屏障，能量消耗为 2
选择相邻两个舱室开启联合屏障，能量消耗为 3
对于已开启的一个屏障，多维持一时刻，能量消耗为 1
已知陨石雨的影响范围和到达时刻，time[i] 和 position[i] 分别表示该陨石的到达时刻和冲击位置。请返回太空舱能够守护所有舱室所需要的最少能量。
注意：
同一时间，一个舱室不能被多个屏障覆盖
陨石雨仅在到达时刻对冲击位置处的舱室有影响
示例 1：
输入：time = [1,2,1], position = [6,3,3]
输出：5
解释：
时刻 1，分别开启编号 3、6 舱室的屏障，能量消耗 2*2 = 4
时刻 2，维持编号 3 舱室的屏障，能量消耗 1
因此，最少需要能量 5
示例 2：
输入：time = [1,1,1,2,2,3,5], position = [1,2,3,1,2,1,3]
输出：9
解释：
时刻 1，开启编号 1、2 舱室的联合屏障，能量消耗 3
时刻 1，开启编号 3 舱室的屏障，能量消耗 2
时刻 2，维持编号 1、2 舱室的联合屏障，能量消耗 1
时刻 3，维持编号 1、2 舱室的联合屏障，能量消耗 1
时刻 5，重新开启编号 3 舱室的联合屏障，能量消耗 2
因此，最少需要能量 9
提示：
1 <= time.length == position.length <= 500
1 <= time[i] <= 5
0 <= position[i] <= 100",7,,684,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/bitmask/']",[],1754
评论 (5),s5kipK,困难,"欢迎各位勇者来到力扣城，本次试炼主题为「夺回据点」。
魔物了占领若干据点，这些据点被若干条道路相连接，roads[i] = [x, y] 表示编号 x、y 的两个据点通过一条道路连接。
现在勇者要将按照以下原则将这些据点逐一夺回：
在开始的时候，勇者可以花费资源先夺回一些据点，初始夺回第 j 个据点所需消耗的资源数量为 cost[j]
接下来，勇者在不消耗资源情况下，每次可以夺回一个和「已夺回据点」相连接的魔物据点，并对其进行夺回
注：为了防止魔物暴动，勇者在每一次夺回据点后（包括花费资源夺回据点后），需要保证剩余的所有魔物据点之间是相连通的（不经过「已夺回据点」）。
请返回勇者夺回所有据点需要消耗的最少资源数量。
注意：
输入保证初始所有据点都是连通的，且不存在重边和自环
示例 1：
输入：
cost = [1,2,3,4,5,6]
roads = [[0,1],[0,2],[1,3],[2,3],[1,2],[2,4],[2,5]]
输出：6
解释：
勇者消耗资源 6 夺回据点 0 和 4，魔物据点 1、2、3、5 相连通；
第一次夺回据点 1，魔物据点 2、3、5 相连通；
第二次夺回据点 3，魔物据点 2、5 相连通；
第三次夺回据点 2，剩余魔物据点 5；
第四次夺回据点 5，无剩余魔物据点；
因此最少需要消耗资源为 6，可占领所有据点。
示例 2：
输入：
cost = [3,2,1,4]
roads = [[0,2],[2,3],[3,1]]
输出：2
解释：
勇者消耗资源 2 夺回据点 1，魔物据点 0、2、3 相连通；
第一次夺回据点 3，魔物据点 2、0 相连通；
第二次夺回据点 2，剩余魔物据点 0；
第三次夺回据点 0，无剩余魔物据点；
因此最少需要消耗资源为 2，可占领所有据点。
提示：
1 <= roads.length, cost.length <= 10^5
0 <= roads[i][0], roads[i][1] < cost.length
1 <= cost[i] <= 10^9",4,,260,"['https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/biconnected-component/']",[],812
评论 (23),PTXy4P,简单,"欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。
在新手村中，各位勇者需要采集一些果实来制作药剂。time[i] 表示勇者每次采集 1～limit 颗第 i 种类型的果实需要的时间（即每次最多可以采集 limit 颗果实）。
当前勇者需要完成「采集若干批果实」的任务， fruits[j] = [type, num] 表示第 j 批需要采集 num 颗 type 类型的果实。采集规则如下：
按 fruits 给定的顺序依次采集每一批次
采集完当前批次的果实才能开始采集下一批次
勇者完成当前批次的采集后将清空背包（即多余的果实将清空）
请计算并返回勇者完成采集任务最少需要的时间。
示例 1：
输入：time = [2,3,2], fruits = [[0,2],[1,4],[2,1]], limit = 3
输出：10
解释：
由于单次最多采集 3 颗
第 0 批需要采集 2 颗第 0 类型果实，需要采集 1 次，耗时为 2*1=2
第 1 批需要采集 4 颗第 1 类型果实，需要采集 2 次，耗时为 3*2=6
第 2 批需要采集 1 颗第 2 类型果实，需要采集 1 次，耗时为 2*1=2
返回总耗时 2+6+2=10
示例 2：
输入：time = [1], fruits = [[0,3],[0,5]], limit = 2
输出：5
解释：
由于单次最多采集 2 颗
第 0 批需要采集 3 颗第 0 类型果实，需要采集 2 次，耗时为 1*2=2
第 1 批需要采集 5 颗第 0 类型果实，需要采集 3 次，耗时为 1*3=3
需按照顺序依次采集，返回 2+3=5
提示：
1 <= time.length <= 100
1 <= time[i] <= 100
1 <= fruits.length <= 10^3
0 <= fruits[i][0] < time.length
1 <= fruits[i][1] < 10^3
1 <= limit <= 100",1,,2596,['https://leetcode.cn/tag/array/'],[],3513
评论 (30),6UEx57,中等,"欢迎各位勇者来到力扣城，本次试炼主题为「信物传送」。
本次试炼场地设有若干传送带，matrix[i][j] 表示第 i 行 j 列的传送带运作方向，""^"",""v"",""<"","">"" 这四种符号分别表示 上、下、左、右 四个方向。信物会随传送带的方向移动。勇者每一次施法操作，可临时变更一处传送带的方向，在物品经过后传送带恢复原方向。
通关信物初始位于坐标 start处，勇者需要将其移动到坐标 end 处，请返回勇者施法操作的最少次数。
注意：
start 和 end 的格式均为 [i,j]
示例 1:
输入：matrix = ["">>v"",""v^<"",""<><""], start = [0,1], end = [2,0]
输出：1
解释：
如上图所示
当信物移动到 [1,1] 时，勇者施法一次将 [1,1] 的传送方向 ^ 从变更为 <
从而信物移动到 [1,0]，后续到达 end 位置
因此勇者最少需要施法操作 1 次
示例 2:
输入：matrix = ["">>v"","">>v"",""^<<""], start = [0,0], end = [1,1]
输出：0
解释：勇者无需施法，信物将自动传送至 end 位置
示例 3:
输入：matrix = ["">^^>"",""<^v>"",""^v^<""], start = [0,0], end = [1,3]
输出：3
提示：
matrix 中仅包含 '^'、'v'、'<'、'>'
0 < matrix.length <= 100
0 < matrix[i].length <= 100
0 <= start[0],end[0] < matrix.length
0 <= start[1],end[1] < matrix[i].length",5,,1480,"['https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/graph/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/shortest-path/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],4219
评论 (17),ZbAuEH,困难,"欢迎各位勇者来到力扣城，本次试炼主题为「打地鼠」。

勇者面前有一个大小为 3*3 的打地鼠游戏机，地鼠将随机出现在各个位置，moles[i] = [t,x,y] 表示在第 t 秒会有地鼠出现在 (x,y) 位置上，并于第 t+1 秒该地鼠消失。
勇者有一把可敲打地鼠的锤子，初始时刻（即第 0 秒）锤子位于正中间的格子 (1,1)，锤子的使用规则如下：
锤子每经过 1 秒可以往上、下、左、右中的一个方向移动一格，也可以不移动
锤子只可敲击所在格子的地鼠，敲击不耗时
请返回勇者最多能够敲击多少只地鼠。
注意：
输入用例保证在相同时间相同位置最多仅有一只地鼠
示例 1：
输入： moles = [[1,1,0],[2,0,1],[4,2,2]]
输出： 2
解释：
第 0 秒，锤子位于 (1,1)
第 1 秒，锤子移动至 (1,0) 并敲击地鼠
第 2 秒，锤子移动至 (2,0)
第 3 秒，锤子移动至 (2,1)
第 4 秒，锤子移动至 (2,2) 并敲击地鼠
因此勇者最多可敲击 2 只地鼠
示例 2：
输入：moles = [[2,0,2],[5,2,0],[4,1,0],[1,2,1],[3,0,2]]
输出：3
解释：
第 0 秒，锤子位于 (1,1)
第 1 秒，锤子移动至 (2,1) 并敲击地鼠
第 2 秒，锤子移动至 (1,1)
第 3 秒，锤子移动至 (1,0)
第 4 秒，锤子在 (1,0) 不移动并敲击地鼠
第 5 秒，锤子移动至 (2,0) 并敲击地鼠
因此勇者最多可敲击 3 只地鼠
示例 3：
输入：moles = [[0,1,0],[0,0,1]]
输出：0
解释：
第 0 秒，锤子初始位于 (1,1)，此时并不能敲击 (1,0)、(0,1) 位置处的地鼠
提示：
1 <= moles.length <= 10^5
moles[i].length == 3
0 <= moles[i][0] <= 10^9
0 <= moles[i][1], moles[i][2] < 3",7,,1275,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/sorting/']",[],5291
评论 (6),De4qBB,困难,"欢迎各位勇者来到力扣城，本次试炼主题为「积木拼接」。
勇者面前有 6 片积木（厚度均为 1），每片积木的形状记录于二维字符串数组 shapes 中，shapes[i] 表示第 i 片积木，其中 1 表示积木对应位置无空缺，0 表示积木对应位置有空缺。
例如 [""010"",""111"",""010""] 对应积木形状为
拼接积木的规则如下：
积木片可以旋转、翻面
积木片边缘必须完全吻合才能拼接在一起
每片积木片 shapes[i] 的中心点在拼接时必须处于正方体对应面的中心点
例如 3*3、4*4 的积木片的中心点如图所示（红色点）：
请返回这 6 片积木能否拼接成一个严丝合缝的正方体且每片积木正好对应正方体的一个面。
注意：
输入确保每片积木均无空心情况（即输入数据保证对于大小 N*N 的 shapes[i]，内部的 (N-2)*(N-2) 的区域必然均为 1）
输入确保每片积木的所有 1 位置均连通
示例 1：
输入：shapes = [[""000"",""110"",""000""],[""110"",""011"",""000""],[""110"",""011"",""110""],[""000"",""010"",""111""],[""011"",""111"",""011""],[""011"",""010"",""000""]]
输出：true
解释：
示例 2：
输入：shapes = [[""101"",""111"",""000""],[""000"",""010"",""111""],[""010"",""011"",""000""],[""010"",""111"",""010""],[""101"",""111"",""010""],[""000"",""010"",""011""]]
输出：false
解释：
由于每片积木片的中心点在拼接时必须处于正方体对应面的中心点，积木片 [""010"",""011"",""000""] 不能作为 [""100"",""110"",""000""] 使用，因此无法构成正方体
提示：
shapes.length == 6
shapes[i].length == shapes[j].length
shapes[i].length == shapes[i][j].length
3 <= shapes[i].length <= 10",1,,214,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/matrix/']",[],843
评论 (6),NfY1m5,困难,"欢迎各位勇者来到力扣城，本次试炼主题为「搭桥过河」。
勇者面前有一段长度为 num 的河流，河流可以划分为若干河道。每条河道上恰有一块浮木，wood[i] 记录了第 i 条河道上的浮木初始的覆盖范围。
当且仅当浮木与相邻河道的浮木覆盖范围有重叠时，勇者才可以在两条浮木间移动
勇者 仅能在岸上 通过花费一点「自然之力」，使任意一条浮木沿着河流移动一个单位距离
请问勇者跨越这条河流，最少需要花费多少「自然之力」。
示例 1：
输入： num = 10, wood = [[1,2],[4,7],[8,9]]
输出： 3
解释：如下图所示，
将 [1,2] 浮木移动至 [3,4]，花费 2「自然之力」，
将 [8,9] 浮木移动至 [7,8]，花费 1「自然之力」，
此时勇者可以顺着 [3,4]->[4,7]->[7,8] 跨越河流，
因此，勇者最少需要花费 3 点「自然之力」跨越这条河流
示例 2：
输入： num = 10, wood = [[1,5],[1,1],[10,10],[6,7],[7,8]]
输出： 10
解释：
将 [1,5] 浮木移动至 [2,6]，花费 1「自然之力」，
将 [1,1] 浮木移动至 [6,6]，花费 5「自然之力」，
将 [10,10] 浮木移动至 [6,6]，花费 4「自然之力」，
此时勇者可以顺着 [2,6]->[6,6]->[6,6]->[6,7]->[7,8] 跨越河流，
因此，勇者最少需要花费 10 点「自然之力」跨越这条河流
示例 3：
输入： num = 5, wood = [[1,2],[2,4]]
输出： 0
解释：勇者不需要移动浮木，仍可以跨越这条河流
提示:
1 <= num <= 10^9
1 <= wood.length <= 10^5
wood[i].length == 2
1 <= wood[i][0] <= wood[i][1] <= num",1,,89,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],356
评论 (7),WInSav,困难,"欢迎各位勇者来到力扣城，本次试炼主题为「力扣泡泡龙」。
游戏初始状态的泡泡形如二叉树 root，每个节点值对应了该泡泡的分值。勇者最多可以击破一个节点泡泡，要求满足：
被击破的节点泡泡 至多 只有一个子节点泡泡
当被击破的节点泡泡有子节点泡泡时，则子节点泡泡将取代被击破泡泡的位置
注：即整棵子树泡泡上移
请问在击破一个节点泡泡操作或无击破操作后，二叉泡泡树的最大「层和」是多少。
注意：
「层和」为同一高度的所有节点的分值之和
示例 1：
输入：root = [6,0,3,null,8]
输出：11
解释：勇者的最佳方案如图所示
示例 2：
输入：root = [5,6,2,4,null,null,1,3,5]
输出：9
解释：勇者击破 6 节点，此时「层和」最大为 3+5+1 = 9
示例 3：
输入：root = [-5,1,7]
输出：8
解释：勇者不击破节点，「层和」最大为 1+7 = 8
提示：
2 <= 树中节点个数 <= 10^5
-10000 <= 树中节点的值 <= 10000",4,,295,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/binary-tree/']",[],1896
评论 (118),Ju9Xwi,简单,"小扣打算给自己的 VS code 安装使用插件，初始状态下带宽每分钟可以完成 1 个插件的下载。假定每分钟选择以下两种策略之一:
使用当前带宽下载插件
将带宽加倍（下载插件数量随之加倍）
请返回小扣完成下载 n 个插件最少需要多少分钟。
注意：实际的下载的插件数量可以超过 n 个
示例 1：
输入：n = 2
输出：2
解释：
以下两个方案，都能实现 2 分钟内下载 2 个插件
方案一：第一分钟带宽加倍，带宽可每分钟下载 2 个插件；第二分钟下载 2 个插件
方案二：第一分钟下载 1 个插件，第二分钟下载 1 个插件
示例 2：
输入：n = 4
输出：3
解释：
最少需要 3 分钟可完成 4 个插件的下载，以下是其中一种方案:
第一分钟带宽加倍，带宽可每分钟下载 2 个插件;
第二分钟下载 2 个插件;
第三分钟下载 2 个插件。
提示：
1 <= n <= 10^5",24,,8376,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],15313
评论 (78),WqXACV,简单,"有 N 位扣友参加了微软与力扣举办了「以扣会友」线下活动。主办方提供了 2*N 道题目，整型数组 questions 中每个数字对应了每道题目所涉及的知识点类型。
若每位扣友选择不同的一题，请返回被选的 N 道题目至少包含多少种知识点类型。
示例 1：
输入：questions = [2,1,6,2]
输出：1
解释：有 2 位扣友在 4 道题目中选择 2 题。
可选择完成知识点类型为 2 的题目时，此时仅一种知识点类型
因此至少包含 1 种知识点类型。
示例 2：
输入：questions = [1,5,1,3,4,5,2,5,3,3,8,6]
输出：2
解释：有 6 位扣友在 12 道题目中选择题目，需要选择 6 题。
选择完成知识点类型为 3、5 的题目，因此至少包含 2 种知识点类型。
提示：
questions.length == 2*n
2 <= questions.length <= 10^5
1 <= questions[i] <= 1000",8,,5998,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],9117
评论 (47),YesdPw,中等,"「以扣会友」线下活动所在场地由若干主题空间与走廊组成，场地的地图记作由一维字符串型数组 grid，字符串中仅包含 ""0""～""5"" 这 6 个字符。地图上每一个字符代表面积为 1 的区域，其中 ""0"" 表示走廊，其他字符表示主题空间。相同且连续（连续指上、下、左、右四个方向连接）的字符组成同一个主题空间。
假如整个 grid 区域的外侧均为走廊。请问，不与走廊直接相邻的主题空间的最大面积是多少？如果不存在这样的空间请返回 0。
示例 1:
输入：grid = [""110"",""231"",""221""]
输出：1
解释：4 个主题空间中，只有 1 个不与走廊相邻，面积为 1。
示例 2:
输入：grid = [""11111100000"",""21243101111"",""21224101221"",""11111101111""]
输出：3
解释：8 个主题空间中，有 5 个不与走廊相邻，面积分别为 3、1、1、1、2，最大面积为 3。
提示：
1 <= grid.length <= 500
1 <= grid[i].length <= 500
grid[i][j] 仅可能是 ""0""～""5""",12,,2586,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/union-find/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/']",[],6293
评论 (1.3k),shu-zu-zhong-zhong-fu-de-shu-zi-lcof,简单,"找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
  限制：
2 <= n <= 100000",844,,564640,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/sorting/']",[],831239
评论 (1.2k),er-wei-shu-zu-zhong-de-cha-zhao-lcof,中等,"在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
  示例:
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
  限制：
0 <= n <= 1000
0 <= m <= 1000
  注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/",675,,378565,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/matrix/']",[],944092
评论 (1.0k),ti-huan-kong-ge-lcof,简单,"请实现一个函数，把字符串 s 中的每个空格替换成""%20""。
  示例 1：
输入：s = ""We are happy.""
输出：""We%20are%20happy.""
  限制：
0 <= s 的长度 <= 10000",291,,452242,['https://leetcode.cn/tag/string/'],[],596241
评论 (1.0k),cong-wei-dao-tou-da-yin-lian-biao-lcof,简单,"输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
  示例 1：
输入：head = [1,3,2]
输出：[2,3,1]
  限制：
0 <= 链表长度 <= 10000",297,,454815,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],606919
评论 (796),zhong-jian-er-cha-shu-lcof,中等,"输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
  示例 1:
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
示例 2:
Input: preorder = [-1], inorder = [-1]
Output: [-1]
  限制：
0 <= 节点个数 <= 5000
  注意：本题与主站 105 题重复：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",795,https://assets.leetcode.com/uploads/2021/02/19/tree.jpg,257158,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/binary-tree/']",[],366055
评论 (1.2k),yong-liang-ge-zhan-shi-xian-dui-lie-lcof,简单,"用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
  示例 1：
输入：
[""CQueue"",""appendTail"",""deleteHead"",""deleteHead""]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：
输入：
[""CQueue"",""deleteHead"",""appendTail"",""appendTail"",""deleteHead"",""deleteHead""]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
提示：
1 <= values <= 10000
最多会对 appendTail、deleteHead 进行 10000 次调用",535,,419662,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/']",[],592317
评论 (1.3k),fei-bo-na-qi-shu-lie-lcof,简单,"写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
  示例 1：
输入：n = 2
输出：1
示例 2：
输入：n = 5
输出：5
  提示：
0 <= n <= 100",363,,372973,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],1031221
评论 (825),qing-wa-tiao-tai-jie-wen-ti-lcof,简单,"一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2
输出：2
示例 2：
输入：n = 7
输出：21
示例 3：
输入：n = 0
输出：1
提示：
0 <= n <= 100
注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/
 ",292,,282976,"['https://leetcode.cn/tag/memoization/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],622208
评论 (1.4k),xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof,简单,"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
  示例 1：
输入：numbers = [3,4,5,1,2]
输出：1
示例 2：
输入：numbers = [2,2,2,0,1]
输出：0
  提示：
n == numbers.length
1 <= n <= 5000
-5000 <= numbers[i] <= 5000
numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转
注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/",626,,373864,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],759881
评论 (730),ju-zhen-zhong-de-lu-jing-lcof,中等,"给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
  例如，在下面的 3×4 的矩阵中包含单词 ""ABCCED""（单词中的字母已标出）。
  示例 1：
输入：board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCCED""
输出：true
示例 2：
输入：board = [[""a"",""b""],[""c"",""d""]], word = ""abcd""
输出：false
  提示：
1 <= board.length <= 200
1 <= board[i].length <= 200
board 和 word 仅由大小写英文字母组成
  注意：本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/",602,,248061,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/matrix/']",[],548406
评论 (1.3k),ji-qi-ren-de-yun-dong-fan-wei-lcof,中等,"地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
  示例 1：
输入：m = 2, n = 3, k = 1
输出：3
示例 2：
输入：m = 3, n = 1, k = 0
输出：1
提示：
1 <= n,m <= 100
0 <= k <= 20",507,,252941,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/dynamic-programming/']",[],474161
评论 (861),jian-sheng-zi-lcof,中等,"给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
提示：
2 <= n <= 58
注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/",436,,217001,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],378609
评论 (458),jian-sheng-zi-ii-lcof,中等,"给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
  示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
  提示：
2 <= n <= 1000
注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/",189,,114096,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],359761
评论 (975),er-jin-zhi-zhong-1de-ge-shu-lcof,简单,"编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。
  提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
  示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000)
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
  提示：
输入必须是长度为 32 的 二进制串 。
  注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/",251,,261594,['https://leetcode.cn/tag/bit-manipulation/'],[],348175
评论 (735),shu-zhi-de-zheng-shu-ci-fang-lcof,中等,"实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
  示例 1：
输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：
输入：x = 2.10000, n = 3
输出：9.26100
示例 3：
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
  提示：
-100.0 < x < 100.0
-231 <= n <= 231-1
-104 <= xn <= 104
  注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/",306,,175701,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']",[],508594
评论 (531),da-yin-cong-1dao-zui-da-de-nwei-shu-lcof,简单,"输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
示例 1:
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
  说明：
用返回一个整数列表来代替打印
n 为正整数",227,,200184,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/']",[],257082
评论 (771),shan-chu-lian-biao-de-jie-dian-lcof,简单,"给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意：此题对比原题有改动
示例 1:
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
  说明：
题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点",227,,268419,['https://leetcode.cn/tag/linked-list/'],[],446532
评论 (548),zheng-ze-biao-da-shi-pi-pei-lcof,困难,"请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串""aaa""与模式""a.a""和""ab*ac*a""匹配，但与""aa.a""和""ab*a""均不匹配。
示例 1:
输入:
s = ""aa""
p = ""a""
输出: false
解释: ""a"" 无法匹配 ""aa"" 整个字符串。
示例 2:
输入:
s = ""aa""
p = ""a*""
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 ""aa"" 可被视为 'a' 重复了一次。
示例 3:
输入:
s = ""ab""
p = "".*""
输出: true
解释: "".*"" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4:
输入:
s = ""aab""
p = ""c*a*b""
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 ""aab""。
示例 5:
输入:
s = ""mississippi""
p = ""mis*is*p*.""
输出: false
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。
注意：本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/",394,,90423,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],233662
评论 (1.4k),biao-shi-shu-zhi-de-zi-fu-chuan-lcof,中等,"请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
数值（按顺序）可以分成以下几个部分：
若干空格
一个 小数 或者 整数
（可选）一个 'e' 或 'E' ，后面跟着一个 整数
若干空格
小数（按顺序）可以分成以下几个部分：
（可选）一个符号字符（'+' 或 '-'）
下述格式之一：
至少一位数字，后面跟着一个点 '.'
至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
一个点 '.' ，后面跟着至少一位数字
整数（按顺序）可以分成以下几个部分：
（可选）一个符号字符（'+' 或 '-'）
至少一位数字
部分数值列举如下：
[""+100"", ""5e2"", ""-123"", ""3.1416"", ""-1E-16"", ""0123""]
部分非数值列举如下：
[""12e"", ""1a3.14"", ""1.2.3"", ""+-5"", ""12e+5.4""]
  示例 1：
输入：s = ""0""
输出：true
示例 2：
输入：s = ""e""
输出：false
示例 3：
输入：s = "".""
输出：false
示例 4：
输入：s = ""    .1  ""
输出：true
  提示：
1 <= s.length <= 20
s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，空格 ' ' 或者点 '.' 。",342,,106287,['https://leetcode.cn/tag/string/'],[],422545
评论 (1.1k),diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof,简单,"输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。
  示例：
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
  提示：
0 <= nums.length <= 50000
0 <= nums[i] <= 10000",227,,280228,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],432839
评论 (1.2k),lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof,简单,"输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
  示例：
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.",362,,354974,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],442645
评论 (762),fan-zhuan-lian-biao-lcof,简单,"定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
  示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
  限制：
0 <= 节点个数 <= 5000
  注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/",440,,425522,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/']",[],572416
评论 (593),he-bing-liang-ge-pai-xu-de-lian-biao-lcof,简单,"输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
示例1：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
限制：
0 <= 链表长度 <= 1000
注意：本题与主站 21 题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/",247,,266203,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/']",[],366512
评论 (880),shu-de-zi-jie-gou-lcof,中等,"输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如:
给定的树 A:
     3
    / \
   4   5
  / \
 1   2
给定的树 B：
   4 
  /
 1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
示例 1：
输入：A = [1,2,3], B = [3,1]
输出：false
示例 2：
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
限制：
0 <= 节点个数 <= 10000",557,,224876,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],481197
评论 (755),er-cha-shu-de-jing-xiang-lcof,简单,"请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入：
     4
   /   \
  2     7
 / \   / \
1   3 6   9
镜像输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1
  示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
  限制：
0 <= 节点个数 <= 1000
注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/",261,,274920,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],345927
评论 (787),dui-cheng-de-er-cha-shu-lcof,简单,"请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
    1
   / \
  2   2
   \   \
   3    3
  示例 1：
输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：
输入：root = [1,2,2,null,3,null,3]
输出：false
  限制：
0 <= 节点个数 <= 1000
注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/",344,,221115,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],383516
评论 (1.1k),shun-shi-zhen-da-yin-ju-zhen-lcof,简单,"输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
  示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
示例 2：
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
  限制：
0 <= matrix.length <= 100
0 <= matrix[i].length <= 100
注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/",414,,197098,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/simulation/']",[],450793
评论 (645),bao-han-minhan-shu-de-zhan-lcof,简单,"定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
  示例:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
  提示：
各函数的调用总次数不超过 20000 次
  注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/",345,,249272,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/design/']",[],450633
评论 (646),zhan-de-ya-ru-dan-chu-xu-lie-lcof,中等,"输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
  示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
  提示：
0 <= pushed.length == popped.length <= 1000
0 <= pushed[i], popped[i] < 1000
pushed 是 popped 的排列。
注意：本题与主站 946 题相同：https://leetcode-cn.com/problems/validate-stack-sequences/",335,,161891,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/simulation/']",[],261184
评论 (541),cong-shang-dao-xia-da-yin-er-cha-shu-lcof,中等,"从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
  例如:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回：
[3,9,20,15,7]
  提示：
节点总数 <= 1000",201,,207594,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],325333
评论 (665),cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof,简单,"从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
  例如:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
  提示：
节点总数 <= 1000
注意：本题与主站 102 题相同：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/",228,,207771,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],301645
评论 (722),cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof,中等,"请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
  例如:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：
[
  [3],
  [20,9],
  [15,7]
]
  提示：
节点总数 <= 1000",228,,189276,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],322434
评论 (759),er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof,中等,"输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
  参考以下这颗二叉搜索树：
     5
    / \
   2   6
  / \
 1   3
示例 1：
输入: [1,6,3,2,5]
输出: false
示例 2：
输入: [1,3,2,6,5]
输出: true
  提示：
数组长度 <= 1000",517,,165086,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/monotonic-stack/']",[],294232
评论 (803),er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof,中等,"给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
  示例 1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
示例 2：
输入：root = [1,2,3], targetSum = 5
输出：[]
示例 3：
输入：root = [1,2], targetSum = 0
输出：[]
  提示：
树中节点总数在范围 [0, 5000] 内
-1000 <= Node.val <= 1000
-1000 <= targetSum <= 1000
注意：本题与主站 113 题相同：https://leetcode-cn.com/problems/path-sum-ii/",340,,196554,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/backtracking/', 'https://leetcode.cn/tag/binary-tree/']",[],335386
评论 (966),fu-za-lian-biao-de-fu-zhi-lcof,中等,"请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
  示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
示例 3：
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
示例 4：
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
  提示：
-10000 <= Node.val <= 10000
Node.random 为空（null）或指向链表中的节点。
节点数目不超过 1000 。
  注意：本题与主站 138 题相同：https://leetcode-cn.com/problems/copy-list-with-random-pointer/
 ",529,,203368,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/']",[],283975
评论 (915),er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof,中等,"输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
  为了让您更好地理解问题，以下面的二叉搜索树为例：
    我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。
    特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
  注意：本题与主站 426 题相同：https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/
注意：此题对比原题有改动。",505,,157600,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/binary-tree/', 'https://leetcode.cn/tag/doubly-linked-list/']",[],241417
评论 (655),xu-lie-hua-er-cha-shu-lcof,困难,"请实现两个函数，分别用来序列化和反序列化二叉树。
你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
  示例：
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
  注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/",306,https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg,105390,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/binary-tree/']",[],184866
评论 (854),zi-fu-chuan-de-pai-lie-lcof,中等,"输入一个字符串，打印出该字符串中字符的所有排列。
  你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
  示例:
输入：s = ""abc""
输出：[""abc"",""acb"",""bac"",""bca"",""cab"",""cba""]
  限制：
1 <= s 的长度 <= 8",563,,211649,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/backtracking/']",[],365403
评论 (538),shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof,简单,"数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
  你可以假设数组是非空的，并且给定的数组总是存在多数元素。
  示例 1:
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
  限制：
1 <= 数组长度 <= 50000
  注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/
 ",286,,233693,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/counting/', 'https://leetcode.cn/tag/sorting/']",[],334018
评论 (1.1k),zui-xiao-de-kge-shu-lcof,简单,"输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
  示例 1：
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
示例 2：
输入：arr = [0,1,2,1], k = 1
输出：[0]
  限制：
0 <= k <= arr.length <= 10000
0 <= arr[i] <= 10000",437,,342953,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/quickselect/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],598132
评论 (398),shu-ju-liu-zhong-de-zhong-wei-shu-lcof,困难,"如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
例如，
[2,3,4] 的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
示例 1：
输入：
[""MedianFinder"",""addNum"",""addNum"",""findMedian"",""addNum"",""findMedian""]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
示例 2：
输入：
[""MedianFinder"",""addNum"",""findMedian"",""addNum"",""findMedian""]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]
  限制：
最多会对 addNum、findMedian 进行 50000 次调用。
注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/",318,,98383,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/data-stream/', 'https://leetcode.cn/tag/sorting/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],168378
评论 (985),lian-xu-zi-shu-zu-de-zui-da-he-lcof,简单,"输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。
  示例1:
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
  提示：
1 <= arr.length <= 10^5
-100 <= arr[i] <= 100
注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/
 ",536,,308154,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/dynamic-programming/']",[],507482
评论 (449),1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof,困难,"输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
  示例 1：
输入：n = 12
输出：5
示例 2：
输入：n = 13
输出：6
  限制：
1 <= n < 2^31
注意：本题与主站 233 题相同：https://leetcode-cn.com/problems/number-of-digit-one/",335,,67986,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/']",[],136019
评论 (498),shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof,中等,"数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。
  示例 1：
输入：n = 3
输出：3
示例 2：
输入：n = 11
输出：0
  限制：
0 <= n < 2^31
注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/",254,,79538,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],186728
评论 (684),ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof,中等,"输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
  示例 1:
输入: [10,2]
输出: ""102""
示例 2:
输入: [3,30,34,5,9]
输出: ""3033459""
  提示:
0 < nums.length <= 100
说明:
输出结果可能非常大，所以你需要返回一个字符串而不是整数
拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0",460,,166695,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],299784
评论 (1.2k),ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof,中等,"给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
  示例 1:
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是""bccfi"", ""bwfi"", ""bczi"", ""mcfi""和""mzi""
  提示：
0 <= num < 231",438,,183997,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],351908
评论 (867),li-wu-de-zui-da-jie-zhi-lcof,中等,"在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
  示例 1:
输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
  提示：
0 < grid.length <= 200
0 < grid[0].length <= 200",292,,182407,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/matrix/']",[],264166
评论 (768),zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof,中等,"请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
  示例 1:
输入: ""abcabcbb""
输出: 3 
解释: 因为无重复字符的最长子串是 ""abc""，所以其长度为 3。
示例 2:
输入: ""bbbbb""
输出: 1
解释: 因为无重复字符的最长子串是 ""b""，所以其长度为 1。
示例 3:
输入: ""pwwkew""
输出: 3
解释: 因为无重复字符的最长子串是 ""wke""，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，""pwke"" 是一个子序列，不是子串。
  提示：
s.length <= 40000
注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/",431,,226290,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],487952
评论 (357),chou-shu-lcof,中等,"我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
  示例:
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
说明:  
1 是丑数。
n 不超过1690。
注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/",348,,124145,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],190304
评论 (700),di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof,简单,"在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
示例 1:
输入：s = ""abaccdeff""
输出：'b'
示例 2:
输入：s = """" 
输出：' '
  限制：
0 <= s 的长度 <= 50000",232,,238148,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/counting/']",[],383111
评论 (877),shu-zu-zhong-de-ni-xu-dui-lcof,困难,"在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
  示例 1:
输入: [7,5,6,4]
输出: 5
  限制：
0 <= 数组长度 <= 50000",747,,146162,"['https://leetcode.cn/tag/binary-indexed-tree/', 'https://leetcode.cn/tag/segment-tree/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/divide-and-conquer/', 'https://leetcode.cn/tag/ordered-set/', 'https://leetcode.cn/tag/merge-sort/']",[],297005
评论 (928),liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof,简单,"输入两个链表，找出它们的第一个公共节点。
如下面的两个链表：
在节点 c1 开始相交。
  示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
  示例 2：
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
  示例 3：
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
  注意：
如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/",506,,242048,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],369195
评论 (1.1k),zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof,简单,"统计一个数字在排序数组中出现的次数。
  示例 1:
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
示例 2:
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
  提示：
0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums 是一个非递减数组
-109 <= target <= 109
  注意：本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/",317,,287283,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/']",[],540604
评论 (1.1k),que-shi-de-shu-zi-lcof,简单,"一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
  示例 1:
输入: [0,1,3]
输出: 2
示例 2:
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
  限制：
1 <= 数组长度 <= 10000",272,,260218,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/binary-search/']",[],581913
评论 (761),er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof,简单,"给定一棵二叉搜索树，请找出其中第 k 大的节点的值。
  示例 1:
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
示例 2:
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
  限制：
1 ≤ k ≤ 二叉搜索树元素个数",305,,233289,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",[],305779
评论 (594),er-cha-shu-de-shen-du-lcof,简单,"输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
  提示：
节点总数 <= 10000
注意：本题与主站 104 题相同：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/",189,,240353,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/breadth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],303494
评论 (638),ping-heng-er-cha-shu-lcof,简单,"输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
  示例 1:
给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
返回 true 。

示例 2:
给定二叉树 [1,2,2,3,3,null,null,4,4]
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
  限制：
0 <= 树的结点个数 <= 10000
注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/
 ",279,,193674,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],325574
评论 (692),shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof,中等,"一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
  示例 1：
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
示例 2：
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
  限制：
2 <= nums.length <= 10000
 ",643,,157249,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/']",[],227038
评论 (479),shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof,中等,"在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
  示例 1：
输入：nums = [3,4,3,3]
输出：4
示例 2：
输入：nums = [9,1,7,9,7,9,7]
输出：1
  限制：
1 <= nums.length <= 10000
1 <= nums[i] < 2^31
 ",342,,128503,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/']",[],159496
评论 (513),he-wei-sde-liang-ge-shu-zi-lcof,简单,"输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
  示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
示例 2：
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
  限制：
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^6",189,,198567,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/']",[],292975
评论 (1.0k),he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof,简单,"输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
  示例 1：
输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
  限制：
1 <= target <= 10^5
 ",443,,187984,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/enumeration/']",[],264321
评论 (736),fan-zhuan-dan-ci-shun-xu-lcof,简单,"输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串""I am a student. ""，则输出""student. a am I""。
  示例 1：
输入: ""the sky is blue""
输出: ""blue is sky the""
示例 2：
输入: ""  hello world!  ""
输出: ""world! hello""
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
示例 3：
输入: ""a good   example""
输出: ""example good a""
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
  说明：
无空格字符构成一个单词。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
注意：本题与主站 151 题相同：https://leetcode-cn.com/problems/reverse-words-in-a-string/
注意：此题对比原题有改动",212,,191287,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],429515
评论 (976),zuo-xuan-zhuan-zi-fu-chuan-lcof,简单,"字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串""abcdefg""和数字2，该函数将返回左旋转两位得到的结果""cdefgab""。
  示例 1：
输入: s = ""abcdefg"", k = 2
输出: ""cdefgab""
示例 2：
输入: s = ""lrloseumgh"", k = 6
输出: ""umghlrlose""
  限制：
1 <= k < s.length <= 10000",253,,328625,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],381736
评论 (835),hua-dong-chuang-kou-de-zui-da-zhi-lcof,困难,"给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
  提示：
你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。
注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/",442,,176598,"['https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/sliding-window/', 'https://leetcode.cn/tag/monotonic-queue/', 'https://leetcode.cn/tag/heap-priority-queue/']",[],395284
评论 (653),dui-lie-de-zui-da-zhi-lcof,中等,"请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value 需要返回 -1
示例 1：
输入: 
[""MaxQueue"",""push_back"",""push_back"",""max_value"",""pop_front"",""max_value""]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：
输入: 
[""MaxQueue"",""pop_front"",""max_value""]
[[],[],[]]
输出: [null,-1,-1]
  限制：
1 <= push_back,pop_front,max_value的总操作数 <= 10000
1 <= value <= 10^5",369,,128908,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/queue/', 'https://leetcode.cn/tag/monotonic-queue/']",[],269607
评论 (660),nge-tou-zi-de-dian-shu-lcof,中等,"把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
  你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
  示例 1:
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
示例 2:
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
  限制：
1 <= n <= 11",426,,93466,"['https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/dynamic-programming/', 'https://leetcode.cn/tag/probability-and-statistics/']",[],163057
评论 (1.0k),bu-ke-pai-zhong-de-shun-zi-lcof,简单,"从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
  示例 1:
输入: [1,2,3,4,5]
输出: True
  示例 2:
输入: [0,0,1,2,5]
输出: True
  限制：
数组长度为 5 
数组的数取值为 [0, 13] .",243,,157893,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sorting/']",[],342846
评论 (700),yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof,简单,"0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
  示例 1：
输入: n = 5, m = 3
输出: 3
示例 2：
输入: n = 10, m = 17
输出: 2
  限制：
1 <= n <= 10^5
1 <= m <= 10^6",613,,149558,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/math/']",[],227272
评论 (680),gu-piao-de-zui-da-li-run-lcof,中等,"假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
  示例 1:
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
  限制：
0 <= 数组长度 <= 10^5
  注意：本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/",252,,200760,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/dynamic-programming/']",[],316003
评论 (1.2k),qiu-12n-lcof,中等,"求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
  示例 1：
输入: n = 3
输出: 6
示例 2：
输入: n = 9
输出: 45
  限制：
1 <= n <= 10000",500,,186961,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/brainteaser/']",[],217576
评论 (463),bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof,简单,"写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
  示例:
输入: a = 1, b = 1
输出: 2
  提示：
a, b 均可能是负数或 0
结果不会溢出 32 位整数",319,,106910,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/']",[],180257
评论 (502),gou-jian-cheng-ji-shu-zu-lcof,中等,"给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。
  示例:
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
  提示：
所有元素乘积之和不会溢出 32 位整数
a.length <= 100000",233,,108665,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],181466
评论 (548),ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof,中等,"写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
  首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。
示例 1:
输入: ""42""
输出: 42
示例 2:
输入: ""   -42""
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:
输入: ""4193 with words""
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
示例 4:
输入: ""words and 987""
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
示例 5:
输入: ""-91283472332""
输出: -2147483648
解释: 数字 ""-91283472332"" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
  注意：本题与主站 8 题相同：https://leetcode-cn.com/problems/string-to-integer-atoi/",166,,99225,['https://leetcode.cn/tag/string/'],[],341308
评论 (360),er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof,简单,"给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
  示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
  说明:
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。
注意：本题与主站 235 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",231,,170001,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-search-tree/', 'https://leetcode.cn/tag/binary-tree/']",[],244615
评论 (510),er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof,简单,"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
  示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
  说明:
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。
注意：本题与主站 236 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/",443,,165180,"['https://leetcode.cn/tag/tree/', 'https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/binary-tree/']",[],234658
评论 (309),xoh6Oh,简单,"给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。
  注意：
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1
  示例 1：
输入：a = 15, b = 2
输出：7
解释：15/2 = truncate(7.5) = 7
示例 2：
输入：a = 7, b = -3
输出：-2
解释：7/-3 = truncate(-2.33333..) = -2
示例 3：
输入：a = 0, b = 1
输出：0
示例 4：
输入：a = 1, b = 1
输出：1
  提示:
-231 <= a, b <= 231 - 1
b != 0
  注意：本题与主站 29 题相同：https://leetcode-cn.com/problems/divide-two-integers/
 ",148,,35886,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/']",[],170396
评论 (189),JFETK5,简单,"给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。
输入为 非空 字符串且只包含数字 1 和 0。
  示例 1:
输入: a = ""11"", b = ""10""
输出: ""101""
示例 2:
输入: a = ""1010"", b = ""1011""
输出: ""10101""
  提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 ""0"" ，就都不含前导零。
  注意：本题与主站 67 题相同：https://leetcode-cn.com/problems/add-binary/",37,,31663,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/simulation/']",[],57705
评论 (192),w3tCBm,简单,"给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。
  示例 1:
输入: n = 2
输出: [0,1,1]
解释: 
0 --> 0
1 --> 1
2 --> 10
示例 2:
输入: n = 5
输出: [0,1,1,2,1,2]
解释:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
  说明 :
0 <= n <= 105
  进阶:
给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？
要求算法的空间复杂度为 O(n) 。
你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。
  注意：本题与主站 338 题相同：https://leetcode-cn.com/problems/counting-bits/",69,,40491,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/dynamic-programming/']",[],51537
评论 (166),WGki4K,中等,"给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
  示例 1：
输入：nums = [2,2,3,2]
输出：3
示例 2：
输入：nums = [0,1,0,1,0,1,100]
输出：100
  提示：
1 <= nums.length <= 3 * 104
-231 <= nums[i] <= 231 - 1
nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
  进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
  注意：本题与主站 137 题相同：https://leetcode-cn.com/problems/single-number-ii/",77,,34462,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/']",[],48525
评论 (138),aseY1I,中等,"给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。
  示例 1:
输入: words = [""abcw"",""baz"",""foo"",""bar"",""fxyz"",""abcdef""]
输出: 16 
解释: 这两个单词为 ""abcw"", ""fxyz""。它们不包含相同字符，且长度的乘积最大。
示例 2:
输入: words = [""a"",""ab"",""abc"",""d"",""cd"",""bcd"",""abcd""]
输出: 4 
解释: 这两个单词为 ""ab"", ""cd""。
示例 3:
输入: words = [""a"",""aa"",""aaa"",""aaaa""]
输出: 0 
解释: 不存在这样的两个单词。
  提示：
2 <= words.length <= 1000
1 <= words[i].length <= 1000
words[i] 仅包含小写字母
  注意：本题与主站 318 题相同：https://leetcode-cn.com/problems/maximum-product-of-word-lengths/",79,,27481,"['https://leetcode.cn/tag/bit-manipulation/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/string/']",[],38768
评论 (139),kLl5u1,简单,"给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0 开始计数 ，所以答案数组应当满足 0 <= answer[0] < answer[1] < numbers.length 。
假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。
  示例 1：
输入：numbers = [1,2,4,6,10], target = 8
输出：[1,3]
解释：2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。
示例 2：
输入：numbers = [2,3,4], target = 6
输出：[0,2]
示例 3：
输入：numbers = [-1,0], target = -1
输出：[0,1]
  提示：
2 <= numbers.length <= 3 * 104
-1000 <= numbers[i] <= 1000
numbers 按 递增顺序 排列
-1000 <= target <= 1000
仅存在一个有效答案
  注意：本题与主站 167 题相似（下标起点不同）：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/",35,,32162,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/binary-search/']",[],49799
评论 (105),1fGaJU,中等,"给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。
  示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：
输入：nums = []
输出：[]
示例 3：
输入：nums = [0]
输出：[]
  提示：
0 <= nums.length <= 3000
-105 <= nums[i] <= 105
  注意：本题与主站 15 题相同：https://leetcode-cn.com/problems/3sum/",62,,28729,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/sorting/']",[],65069
评论 (160),2VG8Kg,中等,"给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
  示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：
输入：target = 4, nums = [1,4,4]
输出：1
示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
  提示：
1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 105
  进阶：
如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。
  注意：本题与主站 209 题相同：https://leetcode-cn.com/problems/minimum-size-subarray-sum/",67,,29507,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/binary-search/', 'https://leetcode.cn/tag/prefix-sum/', 'https://leetcode.cn/tag/sliding-window/']",[],60246
评论 (127),ZVAVXX,中等,"给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。
  示例 1:
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
示例 2:
输入: nums = [1,2,3], k = 0
输出: 0
  提示: 
1 <= nums.length <= 3 * 104
1 <= nums[i] <= 1000
0 <= k <= 106
  注意：本题与主站 713 题相同：https://leetcode-cn.com/problems/subarray-product-less-than-k/ ",81,,24669,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/sliding-window/']",[],45847
评论 (138),QTMn0o,中等,"给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。
  示例 1：
输入:nums = [1,1,1], k = 2
输出: 2
解释: 此题 [1,1] 与 [1,1] 为两种不同的情况
示例 2：
输入:nums = [1,2,3], k = 3
输出: 2
  提示:
1 <= nums.length <= 2 * 104
-1000 <= nums[i] <= 1000
-107 <= k <= 107
  注意：本题与主站 560 题相同： https://leetcode-cn.com/problems/subarray-sum-equals-k/",72,,26077,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']",[],60281
评论 (110),A1NYOS,中等,"给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。
  示例 1：
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
示例 2：
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。
  提示：
1 <= nums.length <= 105
nums[i] 不是 0 就是 1
  注意：本题与主站 525 题相同： https://leetcode-cn.com/problems/contiguous-array/",69,,20437,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/prefix-sum/']",[],36878
评论 (152),tvdfij,简单,"给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
  示例 1：
输入：nums = [1,7,3,6,5,6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
示例 2：
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
示例 3：
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
  提示：
1 <= nums.length <= 104
-1000 <= nums[i] <= 1000
  注意：本题与主站 724 题相同： https://leetcode-cn.com/problems/find-pivot-index/",35,,23654,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/prefix-sum/']",[],35298
评论 (103),O4NDxx,中等,"给定一个二维矩阵 matrix，以下类型的多个请求：
计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。
实现 NumMatrix 类：
NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。
  示例 1：
输入: 
[""NumMatrix"",""sumRegion"",""sumRegion"",""sumRegion""]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
输出: 
[null, 8, 11, 12]

解释:
NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)
  提示：
m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
-105 <= matrix[i][j] <= 105
0 <= row1 <= row2 < m
0 <= col1 <= col2 < n
最多调用 104 次 sumRegion 方法
  注意：本题与主站 304 题相同： https://leetcode-cn.com/problems/range-sum-query-2d-immutable/",41,,16788,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/matrix/', 'https://leetcode.cn/tag/prefix-sum/']",[],25332
评论 (129),MPnaiL,中等,"给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的某个变位词。
换句话说，第一个字符串的排列之一是第二个字符串的 子串 。
  示例 1：
输入: s1 = ""ab"" s2 = ""eidbaooo""
输出: True
解释: s2 包含 s1 的排列之一 (""ba"").
示例 2：
输入: s1= ""ab"" s2 = ""eidboaoo""
输出: False
  提示：
1 <= s1.length, s2.length <= 104
s1 和 s2 仅包含小写字母
  注意：本题与主站 567 题相同： https://leetcode-cn.com/problems/permutation-in-string/",46,,21310,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],41436
评论 (114),VabMRr,中等,"给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
变位词 指字母相同，但排列不同的字符串。
  示例 1：
输入: s = ""cbaebabacd"", p = ""abc""
输出: [0,6]
解释:
起始索引等于 0 的子串是 ""cba"", 它是 ""abc"" 的变位词。
起始索引等于 6 的子串是 ""bac"", 它是 ""abc"" 的变位词。
 示例 2：
输入: s = ""abab"", p = ""ab""
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 ""ab"", 它是 ""ab"" 的变位词。
起始索引等于 1 的子串是 ""ba"", 它是 ""ab"" 的变位词。
起始索引等于 2 的子串是 ""ab"", 它是 ""ab"" 的变位词。
  提示:
1 <= s.length, p.length <= 3 * 104
s 和 p 仅包含小写字母
  注意：本题与主站 438 题相同： https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/",28,,16823,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],27164
评论 (157),wtcaE1,中等,"给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。
  示例 1:
输入: s = ""abcabcbb""
输出: 3 
解释: 因为无重复字符的最长子字符串是 ""abc""，所以其长度为 3。
示例 2:
输入: s = ""bbbbb""
输出: 1
解释: 因为无重复字符的最长子字符串是 ""b""，所以其长度为 1。
示例 3:
输入: s = ""pwwkew""
输出: 3
解释: 因为无重复字符的最长子串是 ""wke""，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，""pwke"" 是一个子序列，不是子串。
示例 4:
输入: s = """"
输出: 0
  提示：
0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
  注意：本题与主站 3 题相同： https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/",39,,23183,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],48734
评论 (108),M1oyTv,困难,"给定两个字符串 s 和 t 。返回 s 中包含 t 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 """" 。
如果 s 中存在多个符合条件的子字符串，返回任意一个。
  注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
  示例 1：
输入：s = ""ADOBECODEBANC"", t = ""ABC""
输出：""BANC"" 
解释：最短子字符串 ""BANC"" 包含了字符串 t 的所有字符 'A'、'B'、'C'
示例 2：
输入：s = ""a"", t = ""a""
输出：""a""
示例 3：
输入：s = ""a"", t = ""aa""
输出：""""
解释：t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。
  提示：
1 <= s.length, t.length <= 105
s 和 t 由英文字母组成
  进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？
  注意：本题与主站 76 题相似（本题答案不唯一）：https://leetcode-cn.com/problems/minimum-window-substring/",46,,14830,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sliding-window/']",[],29482
评论 (148),XltzEq,简单,"给定一个字符串 s ，验证 s 是否是 回文串 ，只考虑字母和数字字符，可以忽略字母的大小写。
本题中，将空字符串定义为有效的 回文串 。
  示例 1:
输入: s = ""A man, a plan, a canal: Panama""
输出: true
解释：""amanaplanacanalpanama"" 是回文串
示例 2:
输入: s = ""race a car""
输出: false
解释：""raceacar"" 不是回文串
  提示：
1 <= s.length <= 2 * 105
字符串 s 由 ASCII 字符组成
  注意：本题与主站 125 题相同： https://leetcode-cn.com/problems/valid-palindrome/",24,,21680,"['https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],42034
评论 (113),RQku0D,简单,"给定一个非空字符串 s，请判断如果 最多 从字符串中删除一个字符能否得到一个回文字符串。
  示例 1:
输入: s = ""aba""
输出: true
示例 2:
输入: s = ""abca""
输出: true
解释: 可以删除 ""c"" 字符 或者 ""b"" 字符
示例 3:
输入: s = ""abc""
输出: false
  提示:
1 <= s.length <= 105
s 由小写英文字母组成
  注意：本题与主站 680 题相同： https://leetcode-cn.com/problems/valid-palindrome-ii/",36,,19109,"['https://leetcode.cn/tag/greedy/', 'https://leetcode.cn/tag/two-pointers/', 'https://leetcode.cn/tag/string/']",[],41643
评论 (120),a7VOhD,中等,"给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
  示例 1：
输入：s = ""abc""
输出：3
解释：三个回文子串: ""a"", ""b"", ""c""
示例 2：
输入：s = ""aaa""
输出：6
解释：6个回文子串: ""a"", ""a"", ""a"", ""aa"", ""aa"", ""aaa""
  提示：
1 <= s.length <= 1000
s 由小写英文字母组成
  注意：本题与主站 647 题相同：https://leetcode-cn.com/problems/palindromic-substrings/ ",50,,18677,"['https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/dynamic-programming/']",[],26018
评论 (137),SLwz0R,中等,"给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
  示例 1：
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
示例 2：
输入：head = [1], n = 1
输出：[]
示例 3：
输入：head = [1,2], n = 1
输出：[1]
  提示：
链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz
  进阶：能尝试使用一趟扫描实现吗？
  注意：本题与主站 19 题相同： https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/",42,,25095,"['https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],47477
评论 (102),c32eOV,中等,"给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
  示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
  提示：
链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引
  进阶：是否可以使用 O(1) 空间解决此题？
  注意：本题与主站 142 题相同： https://leetcode-cn.com/problems/linked-list-cycle-ii/",57,,28261,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],51078
评论 (84),3u1WK4,简单,"给定两个单链表的头节点 headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
  示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
示例 2：
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
示例 3：
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
  提示：
listA 中节点数目为 m
listB 中节点数目为 n
0 <= m, n <= 3 * 104
1 <= Node.val <= 105
0 <= skipA <= m
0 <= skipB <= n
如果 listA 和 listB 没有交点，intersectVal 为 0
如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]
  进阶：能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？
  注意：本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/",37,,22161,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],31677
评论 (149),UHnkqh,简单,"给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。
  示例 1：
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
示例 2：
输入：head = [1,2]
输出：[2,1]
示例 3：
输入：head = []
输出：[]
  提示：
链表中节点的数目范围是 [0, 5000]
-5000 <= Node.val <= 5000
  进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？
  注意：本题与主站 206 题相同： https://leetcode-cn.com/problems/reverse-linked-list/",67,,49041,"['https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/']",[],64943
评论 (179),lMSNwu,中等,"给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
可以假设除了数字 0 之外，这两个数字都不会以零开头。
  示例1：
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
示例2：
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[8,0,7]
示例3：
输入：l1 = [0], l2 = [0]
输出：[0]
  提示：
链表的长度范围为 [1, 100]
0 <= node.val <= 9
输入数据保证链表代表的数字无前导 0
  进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。
  注意：本题与主站 445 题相同：https://leetcode-cn.com/problems/add-two-numbers-ii/",53,,19579,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/math/']",[],32891
评论 (133),LGjMqU,中等,"给定一个单链表 L 的头节点 head ，单链表 L 表示为：
 L0 → L1 → … → Ln-1 → Ln 
请将其重新排列后变为：
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
  示例 1:
输入: head = [1,2,3,4]
输出: [1,4,2,3]
示例 2:
输入: head = [1,2,3,4,5]
输出: [1,5,2,4,3]
  提示：
链表的长度范围为 [1, 5 * 104]
1 <= node.val <= 1000
  注意：本题与主站 143 题相同：https://leetcode-cn.com/problems/reorder-list/ ",59,,20505,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],30833
评论 (181),aMhZSa,简单,"给定一个链表的 头节点 head ，请判断其是否为回文链表。
如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。
  示例 1：
输入: head = [1,2,3,3,2,1]
输出: true
示例 2：
输入: head = [1,2]
输出: false
  提示：
链表 L 的长度范围为 [1, 105]
0 <= node.val <= 9
  进阶：能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
  注意：本题与主站 234 题相同：https://leetcode-cn.com/problems/palindrome-linked-list/",58,,30972,"['https://leetcode.cn/tag/stack/', 'https://leetcode.cn/tag/recursion/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/two-pointers/']",[],50348
评论 (148),Qv1Da2,中等,"多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。
给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。
  示例 1：
输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
输出：[1,2,3,7,8,11,12,9,10,4,5,6]
解释：

输入的多级列表如下图所示：



扁平化后的链表如下图：
示例 2：
输入：head = [1,2,null,3]
输出：[1,3,2]
解释：

输入的多级列表如下图所示：

  1---2---NULL
  |
  3---NULL
示例 3：
输入：head = []
输出：[]
  如何表示测试用例中的多级链表？
以 示例 1 为例：
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL
序列化其中的每一级之后：
[1,2,3,4,5,6,null]
[7,8,9,10,null]
[11,12,null]
为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。
[1,2,3,4,5,6,null]
[null,null,7,8,9,10,null]
[null,11,12,null]
合并所有序列化结果，并去除末尾的 null 。
[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
  提示：
节点数目不超过 1000
1 <= Node.val <= 10^5
  注意：本题与主站 430 题相同： https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/",37,,12940,"['https://leetcode.cn/tag/depth-first-search/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/doubly-linked-list/']",[],21192
评论 (145),4ueAj6,中等,"给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。
给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。
如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。
如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。
  示例 1：

  输入：head = [3,4,1], insertVal = 2
输出：[3,4,1,2]
解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。
示例 2：
输入：head = [], insertVal = 1
输出：[1]
解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。
示例 3：
输入：head = [1], insertVal = 0
输出：[1,0]
  提示：
0 <= Number of Nodes <= 5 * 10^4
-10^6 <= Node.val <= 10^6
-10^6 <= insertVal <= 10^6
  注意：本题与主站 708 题相同： https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/",47,,13601,['https://leetcode.cn/tag/linked-list/'],[],44342
评论 (48),FortPu,中等,"设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构：
insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。
remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。
getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。
  示例 :
输入: inputs = [""RandomizedSet"", ""insert"", ""remove"", ""insert"", ""getRandom"", ""remove"", ""insert"", ""getRandom""]
[[], [1], [2], [2], [], [1], [2], []]
输出: [null, true, false, true, 2, true, false, 2]
解释:
RandomizedSet randomSet = new RandomizedSet();  // 初始化一个空的集合
randomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入

randomSet.remove(2); // 返回 false，表示集合中不存在 2 

randomSet.insert(2); // 向集合中插入 2 返回 true ，集合现在包含 [1,2] 

randomSet.getRandom(); // getRandom 应随机返回 1 或 2 
  
randomSet.remove(1); // 从集合中移除 1 返回 true 。集合现在包含 [2] 

randomSet.insert(2); // 2 已在集合中，所以返回 false 

randomSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 
  提示：
-231 <= val <= 231 - 1
最多进行 2 * 105 次 insert ， remove 和 getRandom 方法调用
当调用 getRandom 方法时，集合中至少有一个元素
  注意：本题与主站 380 题相同：https://leetcode-cn.com/problems/insert-delete-getrandom-o1/",37,,11852,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/randomized/']",[],21827
评论 (90),OrIXps,中等,"运用所掌握的数据结构，设计和实现一个  LRU (Least Recently Used，最近最少使用) 缓存机制 。
实现 LRUCache 类：
LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
  示例：
输入
[""LRUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""put"", ""get"", ""get"", ""get""]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
  提示：
1 <= capacity <= 3000
0 <= key <= 10000
0 <= value <= 105
最多调用 2 * 105 次 get 和 put
  进阶：是否可以在 O(1) 时间复杂度内完成这两种操作？
  注意：本题与主站 146 题相同：https://leetcode-cn.com/problems/lru-cache/ ",50,,12893,"['https://leetcode.cn/tag/design/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/linked-list/', 'https://leetcode.cn/tag/doubly-linked-list/']",[],23801
评论 (150),dKk3P7,简单,"给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。
注意：若 s 和 t 中每个字符出现的次数都相同且字符顺序不完全相同，则称 s 和 t 互为变位词（字母异位词）。
  示例 1:
输入: s = ""anagram"", t = ""nagaram""
输出: true
示例 2:
输入: s = ""rat"", t = ""car""
输出: false
示例 3:
输入: s = ""a"", t = ""a""
输出: false
  提示:
1 <= s.length, t.length <= 5 * 104
s and t 仅包含小写字母
  进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
  注意：本题与主站 242 题相似（字母异位词定义不同）：https://leetcode-cn.com/problems/valid-anagram/",19,,17398,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],28883
评论 (104),sfvd7V,中等,"给定一个字符串数组 strs ，将 变位词 组合在一起。 可以按任意顺序返回结果列表。
注意：若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。
  示例 1:
输入: strs = [""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""]
输出: [[""bat""],[""nat"",""tan""],[""ate"",""eat"",""tea""]]
示例 2:
输入: strs = [""""]
输出: [[""""]]
示例 3:
输入: strs = [""a""]
输出: [[""a""]]
  提示：
1 <= strs.length <= 104
0 <= strs[i].length <= 100
strs[i] 仅包含小写字母
  注意：本题与主站 49 题相同： https://leetcode-cn.com/problems/group-anagrams/",30,,14666,"['https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],19487
评论 (147),lwyVBB,简单,"某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。
给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。
  示例 1：
输入：words = [""hello"",""leetcode""], order = ""hlabcdefgijkmnopqrstuvwxyz""
输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。
示例 2：
输入：words = [""word"",""world"",""row""], order = ""worldabcefghijkmnpqstuvxyz""
输出：false
解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。
示例 3：
输入：words = [""apple"",""app""], order = ""abcdefghijklmnopqrstuvwxyz""
输出：false
解释：当前三个字符 ""app"" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 ""apple"" > ""app""，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。
  提示：
1 <= words.length <= 100
1 <= words[i].length <= 20
order.length == 26
在 words[i] 和 order 中的所有字符都是英文小写字母。
  注意：本题与主站 953 题相同： https://leetcode-cn.com/problems/verifying-an-alien-dictionary/",25,,12590,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/hash-table/', 'https://leetcode.cn/tag/string/']",[],22538
评论 (94),569nqc,中等,"给定一个 24 小时制（小时:分钟 ""HH:MM""）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
  示例 1：
输入：timePoints = [""23:59"",""00:00""]
输出：1
示例 2：
输入：timePoints = [""00:00"",""23:59"",""00:00""]
输出：0
  提示：
2 <= timePoints <= 2 * 104
timePoints[i] 格式为 ""HH:MM""
  注意：本题与主站 539 题相同： https://leetcode-cn.com/problems/minimum-time-difference/",18,,14316,"['https://leetcode.cn/tag/array/', 'https://leetcode.cn/tag/math/', 'https://leetcode.cn/tag/string/', 'https://leetcode.cn/tag/sorting/']",[],21367
